#? * LAPACK: Single Precision Complex Functions
;;.AUTHOR Fu Jie Huang, Yann LeCun
;; This provides a complete interface to the FORTRAN LAPACK
;; library of low-level linear algebra functions.

(libload "blas/blas-c")

(libload "lapack-config")
(libload "lapack-x")


;; Check if we can short-circuit by just mod-loading the object file
(let* ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags))
       (objfile (dhc-make-test ())) )
  (when objfile
    (mod-load objfile)
    (mapcar mod-load (append lapack-liblapack lapack-libfortran))
    (exit) ) )


(de lapack-c-dummy () (cheader "typedef int int_func();") ())


;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cbdsqr <uplo>  <n>  <ncvt>  <nru>  <ncc>  <d>  <e>  <vt>  <ldvt>  <u>  <ldu>  <c>  <ldc>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CBDSQR computes the singular value decomposition (SVD) of a real
;;*  N-by-N (upper or lower) bidiagonal matrix B:  B = Q * S * P' (P'
;;*  denotes the transpose of P), where S is a diagonal matrix with
;;*  non-negative diagonal elements (the singular values of B), and Q
;;*  and P are orthogonal matrices.
;;*
;;*  The routine computes S, and optionally computes U * Q, P' * VT,
;;*  or Q' * C, for given complex input matrices U, VT, and C.
;;*
;;*  See "Computing  Small Singular Values of Bidiagonal Matrices With
;;*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
;;*  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
;;*  no. 5, pp. 873-912, Sept 1990) and
;;*  "Accurate singular values and differential qd algorithms," by
;;*  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
;;*  Department, University of California at Berkeley, July 1992
;;*  for a detailed description of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  B is upper bidiagonal;
;;*          = 'L':  B is lower bidiagonal.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B.  N >= 0.
;;*
;;*  NCVT    (input) INTEGER
;;*          The number of columns of the matrix VT. NCVT >= 0.
;;*
;;*  NRU     (input) INTEGER
;;*          The number of rows of the matrix U. NRU >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C. NCC >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the bidiagonal matrix B.
;;*          On exit, if INFO=0, the singular values of B in decreasing
;;*          order.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the elements of E contain the
;;*          offdiagonal elements of of the bidiagonal matrix whose SVD
;;*          is desired. On normal exit (INFO = 0), E is destroyed.
;;*          If the algorithm does not converge (INFO > 0), D and E
;;*          will contain the diagonal and superdiagonal elements of a
;;*          bidiagonal matrix orthogonally equivalent to the one given
;;*          as input. E(N) is used for workspace.
;;*
;;*  VT      (input/output) COMPLEX array, dimension (LDVT, NCVT)
;;*          On entry, an N-by-NCVT matrix VT.
;;*          On exit, VT is overwritten by P' * VT.
;;*          VT is not referenced if NCVT = 0.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.
;;*          LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
;;*
;;*  U       (input/output) COMPLEX array, dimension (LDU, N)
;;*          On entry, an NRU-by-N matrix U.
;;*          On exit, U is overwritten by U * Q.
;;*          U is not referenced if NRU = 0.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= max(1,NRU).
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC, NCC)
;;*          On entry, an N-by-NCC matrix C.
;;*          On exit, C is overwritten by Q' * C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
;;*
;;*  RWORK   (workspace) REAL array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  If INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm did not converge; D and E contain the
;;*                elements of a bidiagonal matrix which is orthogonally
;;*                similar to the input matrix B;  if INFO = i, i
;;*                elements of E have not converged to zero.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLMUL  REAL, default = max(10,min(100,EPS**(-1/8)))
;;*          TOLMUL controls the convergence criterion of the QR loop.
;;*          If it is positive, TOLMUL*EPS is the desired relative
;;*             precision in the computed singular values.
;;*          If it is negative, abs(TOLMUL*EPS*sigma_max) is the
;;*             desired absolute accuracy in the computed singular
;;*             values (corresponds to relative accuracy
;;*             abs(TOLMUL*EPS) in the largest singular value.
;;*          abs(TOLMUL) should be between 1 and 1/EPS, and preferably
;;*             between 10 (for fast convergence) and .1/EPS
;;*             (for there to be some accuracy in the results).
;;*          Default is to lose at either one eighth or 2 of the
;;*             available decimal digits in each computed singular value
;;*             (whichever is smaller).
;;*
;;*  MAXITR  INTEGER, default = 6
;;*          MAXITR controls the maximum number of passes of the
;;*          algorithm through its inner loop. The algorithms stops
;;*          (and so fails to converge) if the number of passes
;;*          through the inner loop exceeds MAXITR*N**2.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cbdsqr (uplo  n  ncvt  nru  ncc  d  e  vt  ldvt  u  ldu  c  ldc  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncvt )
	((-idx0- (-int-)) nru )
	((-idx0- (-int-)) ncc )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx3- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cbdsqr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ncvt,int), IDX_PTR($nru,int), IDX_PTR($ncc,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbbrd <vect>  <m>  <n>  <ncc>  <kl>  <ku>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <pt>  <ldpt>  <c>  <ldc>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBBRD reduces a complex general m-by-n band matrix A to real upper
;;*  bidiagonal form B by a unitary transformation: Q' * A * P = B.
;;*
;;*  The routine computes B, and optionally forms Q or P', or computes
;;*  Q'*C for a given matrix C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether or not the matrices Q and P' are to be
;;*          formed.
;;*          = 'N': do not form Q or P';
;;*          = 'Q': form Q only;
;;*          = 'P': form P' only;
;;*          = 'B': form both.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C.  NCC >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals of the matrix A. KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals of the matrix A. KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the m-by-n band matrix A, stored in rows 1 to
;;*          KL+KU+1. The j-th column of A is stored in the j-th column of
;;*          the array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*          On exit, A is overwritten by values generated during the
;;*          reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A. LDAB >= KL+KU+1.
;;*
;;*  D       (output) REAL array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B.
;;*
;;*  E       (output) REAL array, dimension (min(M,N)-1)
;;*          The superdiagonal elements of the bidiagonal matrix B.
;;*
;;*  Q       (output) COMPLEX array, dimension (LDQ,M)
;;*          If VECT = 'Q' or 'B', the m-by-m unitary matrix Q.
;;*          If VECT = 'N' or 'P', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= max(1,M) if VECT = 'Q' or 'B'; LDQ >= 1 otherwise.
;;*
;;*  PT      (output) COMPLEX array, dimension (LDPT,N)
;;*          If VECT = 'P' or 'B', the n-by-n unitary matrix P'.
;;*          If VECT = 'N' or 'Q', the array PT is not referenced.
;;*
;;*  LDPT    (input) INTEGER
;;*          The leading dimension of the array PT.
;;*          LDPT >= max(1,N) if VECT = 'P' or 'B'; LDPT >= 1 otherwise.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,NCC)
;;*          On entry, an m-by-ncc matrix C.
;;*          On exit, C is overwritten by Q'*C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,M) if NCC > 0; LDC >= 1 if NCC = 0.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (max(M,N))
;;*
;;*  RWORK   (workspace) REAL array, dimension (max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbbrd (vect  m  n  ncc  kl  ku  ab  ldab  d  e  q  ldq  pt  ldpt  c  ldc  work  rwork  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncc )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) pt )
	((-idx0- (-int-)) ldpt )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgbbrd_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ncc,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($pt,float), IDX_PTR($ldpt,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbcon <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBCON estimates the reciprocal of the condition number of a complex
;;*  general band matrix A, in either the 1-norm or the infinity-norm,
;;*  using the LU factorization computed by CGBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by CGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  ANORM   (input) REAL
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbcon (norm  n  kl  ku  ab  ldab  ipiv  anorm  rcond  work  rwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgbcon_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbequ <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N band matrix A and reduce its condition number.  R returns the
;;*  row scale factors and C the column scale factors, chosen to try to
;;*  make the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  R       (output) REAL array, dimension (M)
;;*          If INFO = 0, or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) REAL array, dimension (N)
;;*          If INFO = 0, C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) REAL
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) REAL
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbequ (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ cgbequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbrfs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is banded, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The original band matrix A, stored in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input) COMPLEX array, dimension (LDAFB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by CGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from CGBTRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CGBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbrfs (trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgbrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbsv <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBSV computes the solution to a complex system of linear equations
;;*  A * X = B, where A is a band matrix of order N with KL subdiagonals
;;*  and KU superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as A = L * U, where L is a product of permutation
;;*  and unit lower triangular matrices with KL subdiagonals, and U is
;;*  upper triangular with KL+KU superdiagonals.  The factored form of A
;;*  is then used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de cgbsv (n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cgbsv_(IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbsvx <fact>  <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBSVX uses the LU factorization to compute the solution to a complex
;;*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
;;*  where A is a band matrix of order N with KL subdiagonals and KU
;;*  superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed by this subroutine:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = L * U,
;;*     where L is a product of permutation and unit lower triangular
;;*     matrices with KL subdiagonals, and U is upper triangular with
;;*     KL+KU superdiagonals.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB and IPIV contain the factored form of
;;*                  A.  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  AB, AFB, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)
;;*
;;*          If FACT = 'F' and EQUED is not 'N', then A must have been
;;*          equilibrated by the scaling factors in R and/or C.  AB is not
;;*          modified if FACT = 'F' or 'N', or if FACT = 'E' and
;;*          EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input or output) COMPLEX array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains details of the LU factorization of the band matrix
;;*          A, as computed by CGBTRF.  U is stored as an upper triangular
;;*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
;;*          and the multipliers used during the factorization are stored
;;*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. 'N', then AFB is
;;*          the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of A.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of the equilibrated
;;*          matrix A (see the description of AB for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = L*U
;;*          as computed by CGBTRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) REAL array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) REAL array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (N)
;;*          On exit, RWORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If RWORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          RWORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbsvx (fact  trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgbsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbtf2 <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBTF2 computes an LU factorization of a complex m-by-n band matrix
;;*  A using partial pivoting with row interchanges.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U, because of fill-in resulting from the row
;;*  interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbtf2 (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ cgbtf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbtrf <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBTRF computes an LU factorization of a complex m-by-n band matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbtrf (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ cgbtrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgbtrs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGBTRS solves a system of linear equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B
;;*  with a general band matrix A using the LU factorization computed
;;*  by CGBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by CGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbtrs (trans  n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cgbtrs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgebak <job>  <side>  <n>  <ilo>  <ihi>  <scale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEBAK forms the right or left eigenvectors of a complex general
;;*  matrix by backward transformation on the computed eigenvectors of the
;;*  balanced matrix output by CGEBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N', do nothing, return immediately;
;;*          = 'P', do backward transformation for permutation only;
;;*          = 'S', do backward transformation for scaling only;
;;*          = 'B', do backward transformations for both permutation and
;;*                 scaling.
;;*          JOB must be the same as the argument JOB supplied to CGEBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by CGEBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  SCALE   (input) REAL array, dimension (N)
;;*          Details of the permutation and scaling factors, as returned
;;*          by CGEBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) COMPLEX array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by CHSEIN or CTREVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgebak (job  side  n  ilo  ihi  scale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) scale )
	((-idx0- (-int-)) m )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ cgebak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,float), IDX_PTR($m,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgebal <job>  <n>  <a>  <lda>  <ilo>  <ihi>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEBAL balances a general complex matrix A.  This involves, first,
;;*  permuting A by a similarity transformation to isolate eigenvalues
;;*  in the first 1 to ILO-1 and last IHI+1 to N elements on the
;;*  diagonal; and second, applying a diagonal similarity transformation
;;*  to rows and columns ILO to IHI to make the rows and columns as
;;*  close in norm as possible.  Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrix, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
;;*                  for i = 1,...,N;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit,  A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  SCALE   (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied to
;;*          A.  If P(j) is the index of the row and column interchanged
;;*          with row and column j and D(j) is the scaling factor
;;*          applied to row and column j, then
;;*          SCALE(j) = P(j)    for j = 1,...,ILO-1
;;*                   = D(j)    for j = ILO,...,IHI
;;*                   = P(j)    for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The permutations consist of row and column interchanges which put
;;*  the matrix in the form
;;*
;;*             ( T1   X   Y  )
;;*     P A P = (  0   B   Z  )
;;*             (  0   0   T2 )
;;*
;;*  where T1 and T2 are upper triangular matrices whose eigenvalues lie
;;*  along the diagonal.  The column indices ILO and IHI mark the starting
;;*  and ending columns of the submatrix B. Balancing consists of applying
;;*  a diagonal similarity transformation inv(D) * B * D to make the
;;*  1-norms of each row of B and its corresponding column nearly equal.
;;*  The output matrix is
;;*
;;*     ( T1     X*D          Y    )
;;*     (  0  inv(D)*B*D  inv(D)*Z ).
;;*     (  0      0           T2   )
;;*
;;*  Information about the permutations P and the diagonal matrix D is
;;*  returned in the vector SCALE.
;;*
;;*  This subroutine is based on the EISPACK routine CBAL.
;;*
;;*  Modified by Tzu-Yi Chen, Computer Science Division, University of
;;*    California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgebal (job  n  a  lda  ilo  ihi  scale  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) scale )
	((-idx0- (-int-)) info )
	#{ cgebal_($job->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgebd2 <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEBD2 reduces a complex general m by n matrix A to upper or lower
;;*  real bidiagonal form B by a unitary transformation: Q' * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the unitary matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the unitary matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) REAL array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) COMPLEX array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q. See Further Details.
;;*
;;*  TAUP    (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix P. See Further Details.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit 
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
;;*  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, v and u are complex vectors;
;;*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
;;*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgebd2 (m  n  a  lda  d  e  tauq  taup  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tauq )
	((-idx2- (-float-)) taup )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgebd2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tauq,float), IDX_PTR($taup,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgebrd <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEBRD reduces a general complex M-by-N matrix A to upper or lower
;;*  bidiagonal form B by a unitary transformation: Q**H * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the unitary matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the unitary matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) REAL array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) COMPLEX array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q. See Further Details.
;;*
;;*  TAUP    (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix P. See Further Details.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,M,N).
;;*          For optimum performance LWORK >= (M+N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
;;*  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in
;;*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgebrd (m  n  a  lda  d  e  tauq  taup  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tauq )
	((-idx2- (-float-)) taup )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgebrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tauq,float), IDX_PTR($taup,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgecon <norm>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGECON estimates the reciprocal of the condition number of a general
;;*  complex matrix A, in either the 1-norm or the infinity-norm, using
;;*  the LU factorization computed by CGETRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by CGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) REAL
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgecon (norm  n  a  lda  anorm  rcond  work  rwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgecon_($norm->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeequ <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N matrix A and reduce its condition number.  R returns the row
;;*  scale factors and C the column scale factors, chosen to try to make
;;*  the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The M-by-N matrix whose equilibration factors are
;;*          to be computed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  R       (output) REAL array, dimension (M)
;;*          If INFO = 0 or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) REAL array, dimension (N)
;;*          If INFO = 0,  C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) REAL
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) REAL
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i,  and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeequ (m  n  a  lda  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ cgeequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgees <jobvs>  <sort>  <select>  <n>  <a>  <lda>  <sdim>  <w>  <vs>  <ldvs>  <work>  <lwork>  <rwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEES computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur
;;*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  Schur form so that selected eigenvalues are at the top left.
;;*  The leading columns of Z then form an orthonormal basis for the
;;*  invariant subspace corresponding to the selected eigenvalues.
;;*  A complex matrix is in Schur form if it is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered:
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of one COMPLEX argument
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to order
;;*          to the top left of the Schur form.
;;*          IF SORT = 'N', SELECT is not referenced.
;;*          The eigenvalue W(j) is selected if SELECT(W(j)) is true.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten by its Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues for which
;;*                         SELECT is true.
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          W contains the computed eigenvalues, in the same order that
;;*          they appear on the diagonal of the output Schur form T.
;;*
;;*  VS      (output) COMPLEX array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the unitary matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1; if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*               <= N:  the QR algorithm failed to compute all the
;;*                      eigenvalues; elements 1:ILO-1 and i+1:N of W
;;*                      contain those eigenvalues which have converged;
;;*                      if JOBVS = 'V', VS contains the matrix which
;;*                      reduces A to its partially converged Schur form.
;;*               = N+1: the eigenvalues could not be reordered because
;;*                      some eigenvalues were too close to separate (the
;;*                      problem is very ill-conditioned);
;;*               = N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Schur form no longer satisfy
;;*                      SELECT = .TRUE..  This could also be caused by
;;*                      underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgees (jobvs  sort  select  n  a  lda  sdim  w  vs  ldvs  work  lwork  rwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx2- (-float-)) w )
	((-idx3- (-float-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ cgees_($jobvs->data, $sort->data, $select, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($w,float), IDX_PTR($vs,float), IDX_PTR($ldvs,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeesx <jobvs>  <sort>  <select>  <sense>  <n>  <a>  <lda>  <sdim>  <w>  <vs>  <ldvs>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEESX computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur
;;*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  Schur form so that selected eigenvalues are at the top left;
;;*  computes a reciprocal condition number for the average of the
;;*  selected eigenvalues (RCONDE); and computes a reciprocal condition
;;*  number for the right invariant subspace corresponding to the
;;*  selected eigenvalues (RCONDV).  The leading columns of Z form an
;;*  orthonormal basis for this invariant subspace.
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
;;*  these quantities are called s and sep respectively).
;;*
;;*  A complex matrix is in Schur form if it is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered;
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of one COMPLEX argument
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to order
;;*          to the top left of the Schur form.
;;*          If SORT = 'N', SELECT is not referenced.
;;*          An eigenvalue W(j) is selected if SELECT(W(j)) is true.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for average of selected eigenvalues only;
;;*          = 'V': Computed for selected right invariant subspace only;
;;*          = 'B': Computed for both.
;;*          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A is overwritten by its Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues for which
;;*                         SELECT is true.
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          W contains the computed eigenvalues, in the same order
;;*          that they appear on the diagonal of the output Schur form T.
;;*
;;*  VS      (output) COMPLEX array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the unitary matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1, and if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  RCONDE  (output) REAL
;;*          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
;;*          condition number for the average of the selected eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) REAL
;;*          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
;;*          condition number for the selected right invariant subspace.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          Also, if SENSE = 'E' or 'V' or 'B', LWORK >= 2*SDIM*(N-SDIM),
;;*          where SDIM is the number of selected eigenvalues computed by
;;*          this routine.  Note that 2*SDIM*(N-SDIM) <= N*N/2.
;;*          For good performance, LWORK must generally be larger.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*             <= N: the QR algorithm failed to compute all the
;;*                   eigenvalues; elements 1:ILO-1 and i+1:N of W
;;*                   contain those eigenvalues which have converged; if
;;*                   JOBVS = 'V', VS contains the transformation which
;;*                   reduces A to its partially converged Schur form.
;;*             = N+1: the eigenvalues could not be reordered because some
;;*                   eigenvalues were too close to separate (the problem
;;*                   is very ill-conditioned);
;;*             = N+2: after reordering, roundoff changed values of some
;;*                   complex eigenvalues so that leading eigenvalues in
;;*                   the Schur form no longer satisfy SELECT=.TRUE.  This
;;*                   could also be caused by underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeesx (jobvs  sort  select  sense  n  a  lda  sdim  w  vs  ldvs  rconde  rcondv  work  lwork  rwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx2- (-float-)) w )
	((-idx3- (-float-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx0- (-float-)) rconde )
	((-idx0- (-float-)) rcondv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ cgeesx_($jobvs->data, $sort->data, $select, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($w,float), IDX_PTR($vs,float), IDX_PTR($ldvs,int), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeev <jobvl>  <jobvr>  <n>  <a>  <lda>  <w>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEEV computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of are computed.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          W contains the computed eigenvalues.
;;*
;;*  VL      (output) COMPLEX array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          u(j) = VL(:,j), the j-th column of VL.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          v(j) = VR(:,j), the j-th column of VR.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1; if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors have been computed;
;;*                elements and i+1:N of W contain eigenvalues which have
;;*                converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeev (jobvl  jobvr  n  a  lda  w  vl  ldvl  vr  ldvr  work  lwork  rwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) w )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgeev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($w,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <w>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <scale>  <abnrm>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  Optionally also, it computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
;;*  (RCONDE), and reciprocal condition numbers for the right
;;*  eigenvectors (RCONDV).
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Balancing a matrix means permuting the rows and columns to make it
;;*  more nearly upper triangular, and applying a diagonal similarity
;;*  transformation D * A * D**(-1), where D is a diagonal matrix, to
;;*  make its rows and columns closer in norm and the condition numbers
;;*  of its eigenvalues and eigenvectors smaller.  The computed
;;*  reciprocal condition numbers correspond to the balanced matrix.
;;*  Permuting rows and columns will not change the condition numbers
;;*  (in exact arithmetic) but diagonal scaling will.  For further
;;*  explanation of balancing, see section 4.10.2 of the LAPACK
;;*  Users' Guide.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Indicates how the input matrix should be diagonally scaled
;;*          and/or permuted to improve the conditioning of its
;;*          eigenvalues.
;;*          = 'N': Do not diagonally scale or permute;
;;*          = 'P': Perform permutations to make the matrix more nearly
;;*                 upper triangular. Do not diagonally scale;
;;*          = 'S': Diagonally scale the matrix, ie. replace A by
;;*                 D*A*D**(-1), where D is a diagonal matrix chosen
;;*                 to make the rows and columns of A more equal in
;;*                 norm. Do not permute;
;;*          = 'B': Both diagonally scale and permute A.
;;*
;;*          Computed reciprocal condition numbers will be for the matrix
;;*          after balancing and/or permuting. Permuting does not change
;;*          condition numbers (in exact arithmetic), but balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVL must = 'V'.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVR must = 'V'.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for eigenvalues only;
;;*          = 'V': Computed for right eigenvectors only;
;;*          = 'B': Computed for eigenvalues and right eigenvectors.
;;*
;;*          If SENSE = 'E' or 'B', both left and right eigenvectors
;;*          must also be computed (JOBVL = 'V' and JOBVR = 'V').
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.  If JOBVL = 'V' or
;;*          JOBVR = 'V', A contains the Schur form of the balanced 
;;*          version of the matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          W contains the computed eigenvalues.
;;*
;;*  VL      (output) COMPLEX array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          u(j) = VL(:,j), the j-th column of VL.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          v(j) = VR(:,j), the j-th column of VR.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1; if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values determined when A was
;;*          balanced.  The balanced A(i,j) = 0 if I > J and
;;*          J = 1,...,ILO-1 or I = IHI+1,...,N.
;;*
;;*  SCALE   (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          when balancing A.  If P(j) is the index of the row and column
;;*          interchanged with row and column j, and D(j) is the scaling
;;*          factor applied to row and column j, then
;;*          SCALE(J) = P(J),    for J = 1,...,ILO-1
;;*                   = D(J),    for J = ILO,...,IHI
;;*                   = P(J)     for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) REAL
;;*          The one-norm of the balanced matrix (the maximum
;;*          of the sum of absolute values of elements of any column).
;;*
;;*  RCONDE  (output) REAL array, dimension (N)
;;*          RCONDE(j) is the reciprocal condition number of the j-th
;;*          eigenvalue.
;;*
;;*  RCONDV  (output) REAL array, dimension (N)
;;*          RCONDV(j) is the reciprocal condition number of the j-th
;;*          right eigenvector.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  If SENSE = 'N' or 'E',
;;*          LWORK >= max(1,2*N), and if SENSE = 'V' or 'B',
;;*          LWORK >= N*N+2*N.
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors or condition numbers
;;*                have been computed; elements 1:ILO-1 and i+1:N of W
;;*                contain eigenvalues which have converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeevx (balanc  jobvl  jobvr  sense  n  a  lda  w  vl  ldvl  vr  ldvr  ilo  ihi  scale  abnrm  rconde  rcondv  work  lwork  rwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) w )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) scale )
	((-idx0- (-float-)) abnrm )
	((-idx1- (-float-)) rconde )
	((-idx1- (-float-)) rcondv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgeevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($w,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,float), IDX_PTR($abnrm,float), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgegs <jobvsl>  <jobvsr>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine CGGES.
;;*
;;*  CGEGS computes for a pair of N-by-N complex nonsymmetric matrices A,
;;*  B:  the generalized eigenvalues (alpha, beta), the complex Schur
;;*  form (A, B), and optionally left and/or right Schur vectors
;;*  (VSL and VSR).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver CGEGV
;;*  instead.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  The (generalized) Schur form of a pair of matrices is the result of
;;*  multiplying both matrices on the left by one unitary matrix and
;;*  both on the right by another unitary matrix, these two unitary
;;*  matrices being chosen so as to bring the pair of matrices into
;;*  upper triangular form with the diagonal elements of B being
;;*  non-negative real numbers (this is also called complex Schur form.)
;;*
;;*  The left and right Schur vectors are the columns of VSL and VSR,
;;*  respectively, where VSL and VSR are the unitary matrices
;;*  which reduce A and B to Schur form:
;;*
;;*  Schur form of (A,B) = ( (VSL)**H A (VSR), (VSL)**H B (VSR) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose generalized
;;*          eigenvalues and (optionally) Schur vectors are to be
;;*          computed.
;;*          On exit, the generalized Schur form of A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) Schur vectors are
;;*          to be computed.
;;*          On exit, the generalized Schur form of B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),
;;*          j=1,...,N  are the diagonals of the complex Schur form (A,B)
;;*          output by CGEGS.  The  BETA(j) will be non-negative real.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VSL     (output) COMPLEX array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >= 1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) COMPLEX array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for CGEQRF, CUNMQR, and CUNGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for CGEQRF, CUNMQR, and CUNGQR;
;;*          the optimal LWORK is N*(NB+1).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHA(j) and BETA(j) should be correct for
;;*                j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from CGGBAL
;;*                =N+2: error return from CGEQRF
;;*                =N+3: error return from CUNMQR
;;*                =N+4: error return from CUNGQR
;;*                =N+5: error return from CGGHRD
;;*                =N+6: error return from CHGEQZ (other than failed
;;*                                               iteration)
;;*                =N+7: error return from CGGBAK (computing VSL)
;;*                =N+8: error return from CGGBAK (computing VSR)
;;*                =N+9: error return from CLASCL (various places)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgegs (jobvsl  jobvsr  n  a  lda  b  ldb  alpha  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  rwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx3- (-float-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgegs_($jobvsl->data, $jobvsr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($vsl,float), IDX_PTR($ldvsl,int), IDX_PTR($vsr,float), IDX_PTR($ldvsr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgegv <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine CGGEV.
;;*
;;*  CGEGV computes for a pair of N-by-N complex nonsymmetric matrices A
;;*  and B, the generalized eigenvalues (alpha, beta), and optionally,
;;*  the left and/or right generalized eigenvectors (VL and VR).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  A right generalized eigenvector corresponding to a generalized
;;*  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
;;*  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
;;*  l such that l**H * (A - w B) = 0, where l**H is the
;;*  conjugate-transpose of l.
;;*
;;*  Note: this routine performs "full balancing" on A and B -- see
;;*  "Further Details", below.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of A on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of B on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VL      (output) COMPLEX array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors.  (See
;;*          "Purpose", above.)
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors.  (See
;;*          "Purpose", above.)
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for CGEQRF, CUNMQR, and CUNGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for CGEQRF, CUNMQR, and CUNGQR;
;;*          The optimal LWORK is  MAX( 2*N, N*(NB+1) ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (8*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHA(j) and BETA(j) should be
;;*                correct for j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from CGGBAL
;;*                =N+2: error return from CGEQRF
;;*                =N+3: error return from CUNMQR
;;*                =N+4: error return from CUNGQR
;;*                =N+5: error return from CGGHRD
;;*                =N+6: error return from CHGEQZ (other than failed
;;*                                               iteration)
;;*                =N+7: error return from CTGEVC
;;*                =N+8: error return from CGGBAK (computing VL)
;;*                =N+9: error return from CGGBAK (computing VR)
;;*                =N+10: error return from CLASCL (various calls)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing
;;*  ---------
;;*
;;*  This driver calls CGGBAL to both permute and scale rows and columns
;;*  of A and B.  The permutations PL and PR are chosen so that PL*A*PR
;;*  and PL*B*R will be upper triangular except for the diagonal blocks
;;*  A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
;;*  possible.  The diagonal scaling matrices DL and DR are chosen so
;;*  that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
;;*  one (except for the elements that start out zero.)
;;*
;;*  After the eigenvalues and eigenvectors of the balanced matrices
;;*  have been computed, CGGBAK transforms the eigenvectors back to what
;;*  they would have been (in perfect arithmetic) if they had not been
;;*  balanced.
;;*
;;*  Contents of A and B on Exit
;;*  -------- -- - --- - -- ----
;;*
;;*  If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
;;*  both), then on exit the arrays A and B will contain the complex Schur
;;*  form[*] of the "balanced" versions of A and B.  If no eigenvectors
;;*  are computed, then only the diagonal blocks will be correct.
;;*
;;*  [*] In other words, upper triangular form.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgegv (jobvl  jobvr  n  a  lda  b  ldb  alpha  beta  vl  ldvl  vr  ldvr  work  lwork  rwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgegv_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgehd2 <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEHD2 reduces a complex general matrix A to upper Hessenberg form H
;;*  by a unitary similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to CGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= max(1,N).
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the n by n general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the unitary matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) COMPLEX array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgehd2 (n  ilo  ihi  a  lda  tau  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgehd2_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgehrd <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEHRD reduces a complex general matrix A to upper Hessenberg form H
;;*  by a unitary similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to CGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the unitary matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) COMPLEX array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
;;*          zero.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgehrd (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgehrd_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgelq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGELQ2 computes an LQ factorization of a complex m by n matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m by min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
;;*  A(i,i+1:n), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgelq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgelq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgelqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGELQF computes an LQ factorization of a complex M-by-N matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
;;*  A(i,i+1:n), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cgelqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgelqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgelsd <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGELSD computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize 2-norm(| b - A*x |)
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The problem is solved in three steps:
;;*  (1) Reduce the coefficient matrix A to bidiagonal form with
;;*      Householder tranformations, reducing the original problem
;;*      into a "bidiagonal least squares problem" (BLS)
;;*  (2) Solve the BLS using a divide and conquer approach.
;;*  (3) Apply back all the Householder tranformations to solve
;;*      the original least squares problem.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M,N).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK must be at least 1.
;;*          The exact minimum amount of workspace needed depends on M,
;;*          N and NRHS. As long as LWORK is at least
;;*              2 * N + N * NRHS
;;*          if M is greater than or equal to N or
;;*              2 * M + M * NRHS
;;*          if M is less than N, the code will execute correctly.
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*
;;*  RWORK   (workspace) REAL array, dimension at least
;;*             10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
;;*             (SMLSIZ+1)**2
;;*          if M is greater than or equal to N or
;;*             10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +
;;*             (SMLSIZ+1)**2
;;*          if M is less than N, the code will execute correctly.
;;*          SMLSIZ is returned by ILAENV and is equal to the maximum
;;*          size of the subproblems at the bottom of the computation
;;*          tree (usually about 25), and
;;*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          LIWORK >= 3 * MINMN * NLVL + 11 * MINMN,
;;*          where MINMN = MIN( M,N ).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgelsd (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  rwork  iwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ cgelsd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($s,float), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgels <trans>  <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGELS solves overdetermined or underdetermined complex linear systems
;;*  involving an M-by-N matrix A, or its conjugate-transpose, using a QR
;;*  or LQ factorization of A.  It is assumed that A has full rank.
;;*
;;*  The following options are provided:
;;*
;;*  1. If TRANS = 'N' and m >= n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A*X ||.
;;*
;;*  2. If TRANS = 'N' and m < n:  find the minimum norm solution of
;;*     an underdetermined system A * X = B.
;;*
;;*  3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
;;*     an undetermined system A**H * X = B.
;;*
;;*  4. If TRANS = 'C' and m < n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A**H * X ||.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N': the linear system involves A;
;;*          = 'C': the linear system involves A**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*            if M >= N, A is overwritten by details of its QR
;;*                       factorization as returned by CGEQRF;
;;*            if M <  N, A is overwritten by details of its LQ
;;*                       factorization as returned by CGELQF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the matrix B of right hand side vectors, stored
;;*          columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
;;*          if TRANS = 'C'.
;;*          On exit, B is overwritten by the solution vectors, stored
;;*          columnwise:
;;*          if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
;;*          squares solution vectors; the residual sum of squares for the
;;*          solution in each column is given by the sum of squares of
;;*          elements N+1 to M in that column;
;;*          if TRANS = 'N' and m < n, rows 1 to N of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'C' and m >= n, rows 1 to M of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'C' and m < n, rows 1 to M of B contain the
;;*          least squares solution vectors; the residual sum of squares
;;*          for the solution in each column is given by the sum of
;;*          squares of elements M+1 to N in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= MAX(1,M,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          LWORK >= max( 1, MN + max( MN, NRHS ) ).
;;*          For optimal performance,
;;*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).
;;*          where MN = min(M,N) and NB is the optimum block size.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgels (trans  m  n  nrhs  a  lda  b  ldb  work  lwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgels_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgelss <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGELSS computes the minimum norm solution to a complex linear
;;*  least squares problem:
;;*
;;*  Minimize 2-norm(| b - A*x |).
;;*
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
;;*  X.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the first min(m,n) rows of A are overwritten with
;;*          its right singular vectors, stored rowwise.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M,N).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1, and also:
;;*          LWORK >=  2*min(M,N) + max(M,N,NRHS)
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (5*min(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgelss (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgelss_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($s,float), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgelsx <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine CGELSY.
;;*
;;*  CGELSX computes the minimum-norm solution to a complex linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by unitary transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements N+1:M in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is an
;;*          initial column, otherwise it is a free column.  Before
;;*          the QR factorization of A, all initial columns are
;;*          permuted to the leading positions; only the remaining
;;*          free columns are moved as a result of column pivoting
;;*          during the factorization.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                      (min(M,N) + max( N, 2*min(M,N)+NRHS )),
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgelsx (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgelsx_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgelsy <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGELSY computes the minimum-norm solution to a complex linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by unitary transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  This routine is basically identical to the original xGELSX except
;;*  three differences:
;;*    o The permutation of matrix B (the right hand side) is faster and
;;*      more simple.
;;*    o The call to the subroutine xGEQPF has been substituted by the
;;*      the call to the subroutine xGEQP3. This subroutine is a Blas-3
;;*      version of the QR factorization with column pivoting.
;;*    o Matrix B (the right hand side) is updated with Blas-3.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of AP, otherwise column i is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          The unblocked strategy requires that:
;;*            LWORK >= MN + MAX( 2*MN, N+1, MN+NRHS )
;;*          where MN = min(M,N).
;;*          The block algorithm requires that:
;;*            LWORK >= MN + MAX( 2*MN, NB*(N+1), MN+MN*NB, MN+NB*NRHS )
;;*          where NB is an upper bound on the blocksize returned
;;*          by ILAENV for the routines CGEQP3, CTZRZF, CTZRQF, CUNMQR,
;;*          and CUNMRZ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgelsy (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  lwork  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgelsy_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeql2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEQL2 computes a QL factorization of a complex m by n matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the m by n lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          unitary matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeql2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgeql2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeqlf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEQLF computes a QL factorization of a complex M-by-N matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the M-by-N lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          unitary matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cgeqlf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgeqlf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeqp3 <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEQP3 computes a QR factorization with column pivoting of a
;;*  matrix A:  A*P = Q*R  using Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper trapezoidal matrix R; the elements below
;;*          the diagonal, together with the array TAU, represent the
;;*          unitary matrix Q as a product of min(M,N) elementary
;;*          reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(J).ne.0, the J-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(J)=0,
;;*          the J-th column of A is a free column.
;;*          On exit, if JPVT(J)=K, then the J-th column of A*P was the
;;*          the K-th column of A.
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= N+1.
;;*          For optimal performance LWORK >= ( N+1 )*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real/complex scalar, and v is a real/complex vector
;;*  with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
;;*  A(i+1:m,i), and tau in TAU(i).
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeqp3 (m  n  a  lda  jpvt  tau  work  lwork  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgeqp3_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeqpf <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine CGEQP3.
;;*
;;*  CGEQPF computes a QR factorization with column pivoting of a
;;*  complex M-by-N matrix A: A*P = Q*R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper triangular matrix R; the elements
;;*          below the diagonal, together with the array TAU,
;;*          represent the unitary matrix Q as a product of
;;*          min(m,n) elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n)
;;*
;;*  Each H(i) has the form
;;*
;;*     H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
;;*
;;*  The matrix P is represented in jpvt as follows: If
;;*     jpvt(j) = i
;;*  then the jth column of P is the ith canonical unit vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeqpf (m  n  a  lda  jpvt  tau  work  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgeqpf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeqr2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEQR2 computes a QR factorization of a complex m by n matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(m,n) by n upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeqr2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgeqr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgeqrf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGEQRF computes a QR factorization of a complex M-by-N matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of min(m,n) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cgeqrf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgeqrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgerfs <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGERFS improves the computed solution to a system of linear
;;*  equations and provides error bounds and backward error estimates for
;;*  the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The original N-by-N matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX array, dimension (LDAF,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by CGETRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from CGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CGETRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgerfs (trans  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgerfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgerq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGERQ2 computes an RQ factorization of a complex m by n matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the m by n upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAU, represent the unitary matrix
;;*          Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
;;*  exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgerq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgerq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgerqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGERQF computes an RQ factorization of a complex M-by-N matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R;
;;*          the remaining elements, with the array TAU, represent the
;;*          unitary matrix Q as a product of min(m,n) elementary
;;*          reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
;;*  exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cgerqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgerqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgesc2 <n>  <a>  <lda>  <rhs>  <ipiv>  <jpiv>  <scale>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGESC2 solves a system of linear equations
;;*
;;*            A * X = scale* RHS
;;*
;;*  with a general N-by-N matrix A using the LU factorization with
;;*  complete pivoting computed by CGETC2.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA, N)
;;*          On entry, the  LU part of the factorization of the n-by-n
;;*          matrix A computed by CGETC2:  A = P * L * U * Q
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) COMPLEX array, dimension N.
;;*          On entry, the right hand side vector b.
;;*          On exit, the solution vector X.
;;*
;;*  IPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  SCALE    (output) REAL
;;*           On exit, SCALE contains the scale factor. SCALE is chosen
;;*           0 <= SCALE <= 1 to prevent owerflow in the solution.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgesc2 (n  a  lda  rhs  ipiv  jpiv  scale  )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) rhs )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-float-)) scale )
	#{ cgesc2_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($rhs,float), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($scale,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgesdd <jobz>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGESDD computes the singular value decomposition (SVD) of a complex
;;*  M-by-N matrix A, optionally computing the left and/or right singular
;;*  vectors, by using divide-and-conquer method. The SVD is written
;;*
;;*       A = U * SIGMA * conjugate-transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
;;*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns VT = V**H, not V.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U and all N rows of V**H are
;;*                  returned in the arrays U and VT;
;;*          = 'S':  the first min(M,N) columns of U and the first
;;*                  min(M,N) rows of V**H are returned in the arrays U
;;*                  and VT;
;;*          = 'O':  If M >= N, the first N columns of U are overwritten
;;*                  on the array A and all rows of V**H are returned in
;;*                  the array VT;
;;*                  otherwise, all columns of U are returned in the
;;*                  array U and the first M rows of V**H are overwritten
;;*                  in the array VT;
;;*          = 'N':  no columns of U or rows of V**H are computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBZ = 'O',  A is overwritten with the first N columns
;;*                          of U (the left singular vectors, stored
;;*                          columnwise) if M >= N;
;;*                          A is overwritten with the first M rows
;;*                          of V**H (the right singular vectors, stored
;;*                          rowwise) otherwise.
;;*          if JOBZ .ne. 'O', the contents of A are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) COMPLEX array, dimension (LDU,UCOL)
;;*          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
;;*          UCOL = min(M,N) if JOBZ = 'S'.
;;*          If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
;;*          unitary matrix U;
;;*          if JOBZ = 'S', U contains the first min(M,N) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
;;*
;;*  VT      (output) COMPLEX array, dimension (LDVT,N)
;;*          If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
;;*          N-by-N unitary matrix V**H;
;;*          if JOBZ = 'S', VT contains the first min(M,N) rows of
;;*          V**H (the right singular vectors, stored rowwise);
;;*          if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
;;*          if JOBZ = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
;;*          if JOBZ = 'O',
;;*                LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
;;*          if JOBZ = 'S' or 'A',
;;*                LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
;;*          For good performance, LWORK should generally be larger.
;;*          If LWORK < 0 but other input arguments are legal, WORK(1)
;;*          returns the optimal LWORK.
;;*
;;*  RWORK   (workspace) REAL array, dimension (LRWORK)
;;*          If JOBZ = 'N', LRWORK >= 7*min(M,N).
;;*          Otherwise, LRWORK >= 5*min(M,N)*min(M,N) + 5*min(M,N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The updating process of SBDSDC did not converge.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgesdd (jobz  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  rwork  iwork  info  )
	((-str-) jobz )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx3- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ cgesdd_($jobz->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgesvd <jobu>  <jobvt>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGESVD computes the singular value decomposition (SVD) of a complex
;;*  M-by-N matrix A, optionally computing the left and/or right singular
;;*  vectors. The SVD is written
;;*
;;*       A = U * SIGMA * conjugate-transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
;;*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns V**H, not V.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U are returned in array U:
;;*          = 'S':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are returned in the array U;
;;*          = 'O':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no columns of U (no left singular vectors) are
;;*                  computed.
;;*
;;*  JOBVT   (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix
;;*          V**H:
;;*          = 'A':  all N rows of V**H are returned in the array VT;
;;*          = 'S':  the first min(m,n) rows of V**H (the right singular
;;*                  vectors) are returned in the array VT;
;;*          = 'O':  the first min(m,n) rows of V**H (the right singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no rows of V**H (no right singular vectors) are
;;*                  computed.
;;*
;;*          JOBVT and JOBU cannot both be 'O'.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBU = 'O',  A is overwritten with the first min(m,n)
;;*                          columns of U (the left singular vectors,
;;*                          stored columnwise);
;;*          if JOBVT = 'O', A is overwritten with the first min(m,n)
;;*                          rows of V**H (the right singular vectors,
;;*                          stored rowwise);
;;*          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
;;*                          are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) COMPLEX array, dimension (LDU,UCOL)
;;*          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
;;*          If JOBU = 'A', U contains the M-by-M unitary matrix U;
;;*          if JOBU = 'S', U contains the first min(m,n) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBU = 'N' or 'O', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBU = 'S' or 'A', LDU >= M.
;;*
;;*  VT      (output) COMPLEX array, dimension (LDVT,N)
;;*          If JOBVT = 'A', VT contains the N-by-N unitary matrix
;;*          V**H;
;;*          if JOBVT = 'S', VT contains the first min(m,n) rows of
;;*          V**H (the right singular vectors, stored rowwise);
;;*          if JOBVT = 'N' or 'O', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          LWORK >=  2*MIN(M,N)+MAX(M,N).
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (5*min(M,N))
;;*          On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the
;;*          unconverged superdiagonal elements of an upper bidiagonal
;;*          matrix B whose diagonal is in S (not necessarily sorted).
;;*          B satisfies A = U * B * VT, so it has the same singular
;;*          values as A, and singular vectors related by U and VT.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if CBDSQR did not converge, INFO specifies how many
;;*                superdiagonals of an intermediate bidiagonal form B
;;*                did not converge to zero. See the description of RWORK
;;*                above for details.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgesvd (jobu  jobvt  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  rwork  info  )
	((-str-) jobu )
	((-str-) jobvt )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx3- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgesvd_($jobu->data, $jobvt->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgesv <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGESV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as
;;*     A = P * L * U,
;;*  where P is a permutation matrix, L is unit lower triangular, and U is
;;*  upper triangular.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the N-by-N coefficient matrix A.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS matrix of right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de cgesv (n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cgesv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgesvx <fact>  <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGESVX uses the LU factorization to compute the solution to a complex
;;*  system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = P * L * U,
;;*     where P is a permutation matrix, L is a unit lower triangular
;;*     matrix, and U is upper triangular.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF and IPIV contain the factored form of A.
;;*                  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  A, AF, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
;;*          not 'N', then A must have been equilibrated by the scaling
;;*          factors in R and/or C.  A is not modified if FACT = 'F' or
;;*          'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the factors L and U from the factorization
;;*          A = P*L*U as computed by CGETRF.  If EQUED .ne. 'N', then
;;*          AF is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the equilibrated matrix A (see the description of A for
;;*          the form of the equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          as computed by CGETRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) REAL array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) REAL array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (2*N)
;;*          On exit, RWORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If RWORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          RWORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization has
;;*                       been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgesvx (fact  trans  n  nrhs  a  lda  af  ldaf  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgesvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgetc2 <n>  <a>  <lda>  <ipiv>  <jpiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGETC2 computes an LU factorization, using complete pivoting, of the
;;*  n-by-n matrix A. The factorization has the form A = P * L * U * Q,
;;*  where P and Q are permutation matrices, L is lower triangular with
;;*  unit diagonal elements and U is upper triangular.
;;*
;;*  This is a level 1 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the n-by-n matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U*Q; the unit diagonal elements of L are not stored.
;;*          If U(k, k) appears to be less than SMIN, U(k, k) is given the
;;*          value of SMIN, giving a nonsingular perturbed system.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1, N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (output) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  INFO    (output) INTEGER
;;*           = 0: successful exit
;;*           > 0: if INFO = k, U(k, k) is likely to produce overflow if
;;*                one tries to solve for x in Ax = b. So U is perturbed
;;*                to avoid the overflow.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgetc2 (n  a  lda  ipiv  jpiv  info  )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-int-)) info )
	#{ cgetc2_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgetf2 <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGETF2 computes an LU factorization of a general m-by-n matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgetf2 (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ cgetf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgetrf <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGETRF computes an LU factorization of a general M-by-N matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgetrf (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ cgetrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgetri <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGETRI computes the inverse of a matrix using the LU factorization
;;*  computed by CGETRF.
;;*
;;*  This method inverts U and then computes inv(A) by solving the system
;;*  inv(A)*L = inv(U) for inv(A).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the factors L and U from the factorization
;;*          A = P*L*U as computed by CGETRF.
;;*          On exit, if INFO = 0, the inverse of the original matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from CGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimal performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
;;*                singular and its inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgetri (n  a  lda  ipiv  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgetri_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgetrs <trans>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGETRS solves a system of linear equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B
;;*  with a general N-by-N matrix A using the LU factorization computed
;;*  by CGETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by CGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from CGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgetrs (trans  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cgetrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggbak <job>  <side>  <n>  <ilo>  <ihi>  <lscale>  <rscale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGBAK forms the right or left eigenvectors of a complex generalized
;;*  eigenvalue problem A*x = lambda*B*x, by backward transformation on
;;*  the computed eigenvectors of the balanced pair of matrices output by
;;*  CGGBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N':  do nothing, return immediately;
;;*          = 'P':  do backward transformation for permutation only;
;;*          = 'S':  do backward transformation for scaling only;
;;*          = 'B':  do backward transformations for both permutation and
;;*                  scaling.
;;*          JOB must be the same as the argument JOB supplied to CGGBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by CGGBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  LSCALE  (input) REAL array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the left side of A and B, as returned by CGGBAL.
;;*
;;*  RSCALE  (input) REAL array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the right side of A and B, as returned by CGGBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) COMPLEX array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by CTGEVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the matrix V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. Ward, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cggbak (job  side  n  ilo  ihi  lscale  rscale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) lscale )
	((-idx1- (-float-)) rscale )
	((-idx0- (-int-)) m )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ cggbak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,float), IDX_PTR($rscale,float), IDX_PTR($m,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggbal <job>  <n>  <a>  <lda>  <b>  <ldb>  <ilo>  <ihi>  <lscale>  <rscale>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGBAL balances a pair of general complex matrices (A,B).  This
;;*  involves, first, permuting A and B by similarity transformations to
;;*  isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
;;*  elements on the diagonal; and second, applying a diagonal similarity
;;*  transformation to rows and columns ILO to IHI to make the rows
;;*  and columns as close in norm as possible. Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrices, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors in the
;;*  generalized eigenvalue problem A*x = lambda*B*x.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A and B:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
;;*                  and RSCALE(I) = 1.0 for i=1,...,N;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit, A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the input matrix B.
;;*          On exit, B is overwritten by the balanced matrix.
;;*          If JOB = 'N', B is not referenced.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If P(j) is the index of the
;;*          row interchanged with row j, and D(j) is the scaling factor
;;*          applied to row j, then
;;*            LSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If P(j) is the index of the
;;*          column interchanged with column j, and D(j) is the scaling
;;*          factor applied to column j, then
;;*            RSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  WORK    (workspace) REAL array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. WARD, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cggbal (job  n  a  lda  b  ldb  ilo  ihi  lscale  rscale  work  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) lscale )
	((-idx1- (-float-)) rscale )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cggbal_($job->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,float), IDX_PTR($rscale,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgges <jobvsl>  <jobvsr>  <sort>  <selctg>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alpha>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <rwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGES computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, the generalized complex Schur
;;*  form (S, T), and optionally left and/or right Schur vectors (VSL
;;*  and VSR). This gives the generalized Schur factorization
;;*
;;*          (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
;;*
;;*  where (VSR)**H is the conjugate-transpose of VSR.
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  triangular matrix S and the upper triangular matrix T. The leading
;;*  columns of VSL and VSR then form an unitary basis for the
;;*  corresponding left and right eigenspaces (deflating subspaces).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver
;;*  CGGEV instead, which is faster.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0, and even for both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized complex Schur form if S
;;*  and T are upper triangular and, in addition, the diagonal elements
;;*  of T are non-negative real numbers.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see SELCTG).
;;*
;;*  SELCTG  (input) LOGICAL FUNCTION of two COMPLEX arguments
;;*          SELCTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', SELCTG is not referenced.
;;*          If SORT = 'S', SELCTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          An eigenvalue ALPHA(j)/BETA(j) is selected if
;;*          SELCTG(ALPHA(j),BETA(j)) is true.
;;*
;;*          Note that a selected complex eigenvalue may no longer satisfy
;;*          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned), in this
;;*          case INFO is set to N+2 (See INFO below).
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which SELCTG is true.
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),
;;*          j=1,...,N  are the diagonals of the complex Schur form (A,B)
;;*          output by CGGES. The  BETA(j) will be non-negative real.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VSL     (output) COMPLEX array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >= 1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) COMPLEX array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (8*N)
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHA(j) and BETA(j) should be correct for
;;*                j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in CHGEQZ
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy SELCTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering falied in CTGSEN.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgges (jobvsl  jobvsr  sort  selctg  n  a  lda  b  ldb  sdim  alpha  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  rwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")selctg )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx3- (-float-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ cgges_($jobvsl->data, $jobvsr->data, $sort->data, $selctg, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($vsl,float), IDX_PTR($ldvsl,int), IDX_PTR($vsr,float), IDX_PTR($ldvsr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggesx <jobvsl>  <jobvsr>  <sort>  <selctg>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alpha>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <iwork>  <liwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGESX computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, the complex Schur form (S,T),
;;*  and, optionally, the left and/or right matrices of Schur vectors (VSL
;;*  and VSR).  This gives the generalized Schur factorization
;;*
;;*       (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
;;*
;;*  where (VSR)**H is the conjugate-transpose of VSR.
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  triangular matrix S and the upper triangular matrix T; computes
;;*  a reciprocal condition number for the average of the selected
;;*  eigenvalues (RCONDE); and computes a reciprocal condition number for
;;*  the right and left deflating subspaces corresponding to the selected
;;*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form
;;*  an orthonormal basis for the corresponding left and right eigenspaces
;;*  (deflating subspaces).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0 or for both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized complex Schur form if T is
;;*  upper triangular with non-negative diagonal and S is upper
;;*  triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see SELCTG).
;;*
;;*  SELCTG  (input) LOGICAL FUNCTION of two COMPLEX arguments
;;*          SELCTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', SELCTG is not referenced.
;;*          If SORT = 'S', SELCTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          Note that a selected complex eigenvalue may no longer satisfy
;;*          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned), in this
;;*          case INFO is set to N+3 see INFO below).
;;*
;;*  SENSE   (input) CHARACTER
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N' : None are computed;
;;*          = 'E' : Computed for average of selected eigenvalues only;
;;*          = 'V' : Computed for selected deflating subspaces only;
;;*          = 'B' : Computed for both.
;;*          If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which SELCTG is true.
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.  ALPHA(j) and BETA(j),j=1,...,N  are
;;*          the diagonals of the complex Schur form (S,T).  BETA(j) will
;;*          be non-negative real.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VSL     (output) COMPLEX array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) COMPLEX array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  RCONDE  (output) REAL array, dimension ( 2 )
;;*          If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
;;*          reciprocal condition numbers for the average of the selected
;;*          eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) REAL array, dimension ( 2 )
;;*          If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
;;*          reciprocal condition number for the selected deflating
;;*          subspaces.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 2*N.
;;*          If SENSE = 'E', 'V', or 'B',
;;*          LWORK >= MAX(2*N, 2*SDIM*(N-SDIM)).
;;*
;;*  RWORK   (workspace) REAL array, dimension ( 8*N )
;;*          Real workspace.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          Not referenced if SENSE = 'N'.
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array WORK. LIWORK >= N+2.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHA(j) and BETA(j) should be correct for
;;*                j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in CHGEQZ
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy SELCTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering failed in CTGSEN.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cggesx (jobvsl  jobvsr  sort  selctg  sense  n  a  lda  b  ldb  sdim  alpha  beta  vsl  ldvsl  vsr  ldvsr  rconde  rcondv  work  lwork  rwork  iwork  liwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")selctg )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx3- (-float-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-float-)) rconde )
	((-idx1- (-float-)) rcondv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ cggesx_($jobvsl->data, $jobvsr->data, $sort->data, $selctg, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($vsl,float), IDX_PTR($ldvsl,int), IDX_PTR($vsr,float), IDX_PTR($ldvsr,int), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggev <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGEV computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, and optionally, the left and/or
;;*  right generalized eigenvectors.
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right generalized eigenvector v(j) corresponding to the
;;*  generalized eigenvalue lambda(j) of (A,B) satisfies
;;*
;;*               A * v(j) = lambda(j) * B * v(j).
;;*
;;*  The left generalized eigenvector u(j) corresponding to the
;;*  generalized eigenvalues lambda(j) of (A,B) satisfies
;;*
;;*               u(j)**H * A = lambda(j) * u(j)**H * B
;;*
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VL      (output) COMPLEX array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors u(j) are
;;*          stored one after another in the columns of VL, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors v(j) are
;;*          stored one after another in the columns of VR, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (8*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHA(j) and BETA(j) should be
;;*                correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other then QZ iteration failed in SHGEQZ,
;;*                =N+2: error return from STGEVC.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cggev (jobvl  jobvr  n  a  lda  b  ldb  alpha  beta  vl  ldvl  vr  ldvr  work  lwork  rwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cggev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <lscale>  <rscale>  <abnrm>  <bbnrm>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <iwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B) the generalized eigenvalues, and optionally, the left and/or
;;*  right generalized eigenvectors.
;;*
;;*  Optionally, it also computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
;;*  the eigenvalues (RCONDE), and reciprocal condition numbers for the
;;*  right eigenvectors (RCONDV).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*                   A * v(j) = lambda(j) * B * v(j) .
;;*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*                   u(j)**H * A  = lambda(j) * u(j)**H * B.
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Specifies the balance option to be performed:
;;*          = 'N':  do not diagonally scale or permute;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*          Computed reciprocal condition numbers will be for the
;;*          matrices after permuting and/or balancing. Permuting does
;;*          not change condition numbers (in exact arithmetic), but
;;*          balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': none are computed;
;;*          = 'E': computed for eigenvalues only;
;;*          = 'V': computed for eigenvectors only;
;;*          = 'B': computed for eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then A contains the first part of the complex Schur
;;*          form of the "balanced" versions of the input A and B.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then B contains the second part of the complex
;;*          Schur form of the "balanced" versions of the input A and B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the generalized
;;*          eigenvalues.
;;*
;;*          Note: the quotient ALPHA(j)/BETA(j) ) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio ALPHA/BETA.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VL      (output) COMPLEX array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors u(j) are
;;*          stored one after another in the columns of VL, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors v(j) are
;;*          stored one after another in the columns of VR, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If BALANC = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If PL(j) is the index of the
;;*          row interchanged with row j, and DL(j) is the scaling
;;*          factor applied to row j, then
;;*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1
;;*                      = DL(j)  for j = ILO,...,IHI
;;*                      = PL(j)  for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If PR(j) is the index of the
;;*          column interchanged with column j, and DR(j) is the scaling
;;*          factor applied to column j, then
;;*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1
;;*                      = DR(j)  for j = ILO,...,IHI
;;*                      = PR(j)  for j = IHI+1,...,N
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) REAL
;;*          The one-norm of the balanced matrix A.
;;*
;;*  BBNRM   (output) REAL
;;*          The one-norm of the balanced matrix B.
;;*
;;*  RCONDE  (output) REAL array, dimension (N)
;;*          If SENSE = 'E' or 'B', the reciprocal condition numbers of
;;*          the selected eigenvalues, stored in consecutive elements of
;;*          the array.
;;*          If SENSE = 'V', RCONDE is not referenced.
;;*
;;*  RCONDV  (output) REAL array, dimension (N)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. If the eigenvalues cannot be reordered
;;*          to compute RCONDV(j), RCONDV(j) is set to 0; this can only
;;*          occur when the true value would be very small anyway.
;;*          If SENSE = 'E', RCONDV is not referenced.
;;*          Not referenced if JOB = 'E'.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,2*N).
;;*          If SENSE = 'N' or 'E', LWORK >= 2*N.
;;*          If SENSE = 'V' or 'B', LWORK >= 2*N*N+2*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (6*N)
;;*          Real workspace.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N+2)
;;*          If SENSE = 'E', IWORK is not referenced.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          If SENSE = 'N', BWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHA(j) and BETA(j) should be correct
;;*                for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in CHGEQZ.
;;*                =N+2: error return from CTGEVC.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing a matrix pair (A,B) includes, first, permuting rows and
;;*  columns to isolate eigenvalues, second, applying diagonal similarity
;;*  transformation to the rows and columns to make the rows and columns
;;*  as close in norm as possible. The computed reciprocal condition
;;*  numbers correspond to the balanced matrix. Permuting rows and columns
;;*  will not change the condition numbers (in exact arithmetic) but
;;*  diagonal scaling will.  For further explanation of balancing, see
;;*  section 4.11.1.2 of LAPACK Users' Guide.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)
;;*
;;*  An approximate error bound for the angle between the i-th computed
;;*  eigenvector VL(i) or VR(i) is given by
;;*
;;*       EPS * norm(ABNRM, BBNRM) / DIF(i).
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see section 4.11 of LAPACK User's Guide.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cggevx (balanc  jobvl  jobvr  sense  n  a  lda  b  ldb  alpha  beta  vl  ldvl  vr  ldvr  ilo  ihi  lscale  rscale  abnrm  bbnrm  rconde  rcondv  work  lwork  rwork  iwork  bwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) lscale )
	((-idx1- (-float-)) rscale )
	((-idx0- (-float-)) abnrm )
	((-idx0- (-float-)) bbnrm )
	((-idx1- (-float-)) rconde )
	((-idx1- (-float-)) rcondv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ cggevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,float), IDX_PTR($rscale,float), IDX_PTR($abnrm,float), IDX_PTR($bbnrm,float), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggglm <n>  <m>  <p>  <a>  <lda>  <b>  <ldb>  <d>  <x>  <y>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGGLM solves a general Gauss-Markov linear model (GLM) problem:
;;*
;;*          minimize || y ||_2   subject to   d = A*x + B*y
;;*              x
;;*
;;*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
;;*  given N-vector. It is assumed that M <= N <= M+P, and
;;*
;;*             rank(A) = M    and    rank( A B ) = N.
;;*
;;*  Under these assumptions, the constrained equation is always
;;*  consistent, and there is a unique solution x and a minimal 2-norm
;;*  solution y, which is obtained using a generalized QR factorization
;;*  of A and B.
;;*
;;*  In particular, if matrix B is square nonsingular, then the problem
;;*  GLM is equivalent to the following weighted linear least squares
;;*  problem
;;*
;;*               minimize || inv(B)*(d-A*x) ||_2
;;*                   x
;;*
;;*  where inv(B) denotes the inverse of B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B.  N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  0 <= M <= N.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= N-M.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  D       (input/output) COMPLEX array, dimension (N)
;;*          On entry, D is the left hand side of the GLM equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) COMPLEX array, dimension (M)
;;*  Y       (output) COMPLEX array, dimension (P)
;;*          On exit, X and Y are the solutions of the GLM problem.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N+M+P).
;;*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          CGEQRF, CGERQF, CUNMQR and CUNMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  ===================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cggglm (n  m  p  a  lda  b  ldb  d  x  y  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) x )
	((-idx2- (-float-)) y )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cggglm_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($d,float), IDX_PTR($x,float), IDX_PTR($y,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgghrd <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
;;*  Hessenberg form using unitary transformations, where A is a
;;*  general matrix and B is upper triangular:  Q' * A * Z = H and
;;*  Q' * B * Z = T, where H is upper Hessenberg, T is upper triangular,
;;*  and Q and Z are unitary, and ' means conjugate transpose.
;;*
;;*  The unitary matrices Q and Z are determined as products of Givens
;;*  rotations.  They may either be formed explicitly, or they may be
;;*  postmultiplied into input matrices Q1 and Z1, so that
;;*
;;*       Q1 * A * Z1' = (Q1*Q) * H * (Z1*Z)'
;;*       Q1 * B * Z1' = (Q1*Q) * T * (Z1*Z)'
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not compute Q;
;;*          = 'I': Q is initialized to the unit matrix, and the
;;*                 unitary matrix Q is returned;
;;*          = 'V': Q must contain a unitary matrix Q1 on entry,
;;*                 and the product Q1*Q is returned.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not compute Q;
;;*          = 'I': Q is initialized to the unit matrix, and the
;;*                 unitary matrix Q is returned;
;;*          = 'V': Q must contain a unitary matrix Q1 on entry,
;;*                 and the product Q1*Q is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.  ILO and IHI are normally set
;;*          by a previous call to CGGBAL; otherwise they should be set
;;*          to 1 and N respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          rest is set to zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.
;;*          On exit, the upper triangular matrix T = Q' B Z.  The
;;*          elements below the diagonal are set to zero.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ, N)
;;*          If COMPQ='N':  Q is not referenced.
;;*          If COMPQ='I':  on entry, Q need not be set, and on exit it
;;*                         contains the unitary matrix Q, where Q'
;;*                         is the product of the Givens transformations
;;*                         which are applied to A and B on the left.
;;*          If COMPQ='V':  on entry, Q must contain a unitary matrix
;;*                         Q1, and on exit this is overwritten by Q1*Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ, N)
;;*          If COMPZ='N':  Z is not referenced.
;;*          If COMPZ='I':  on entry, Z need not be set, and on exit it
;;*                         contains the unitary matrix Z, which is
;;*                         the product of the Givens transformations
;;*                         which are applied to A and B on the right.
;;*          If COMPZ='V':  on entry, Z must contain a unitary matrix
;;*                         Z1, and on exit this is overwritten by Z1*Z.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine reduces A to Hessenberg and B to triangular form by
;;*  an unblocked reduction, as described in _Matrix_Computations_,
;;*  by Golub and van Loan (Johns Hopkins Press).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgghrd (compq  compz  n  ilo  ihi  a  lda  b  ldb  q  ldq  z  ldz  info  )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ cgghrd_($compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgglse <m>  <n>  <p>  <a>  <lda>  <b>  <ldb>  <c>  <d>  <x>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGLSE solves the linear equality-constrained least squares (LSE)
;;*  problem:
;;*
;;*          minimize || c - A*x ||_2   subject to   B*x = d
;;*
;;*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
;;*  M-vector, and d is a given P-vector. It is assumed that
;;*  P <= N <= M+P, and
;;*
;;*           rank(B) = P and  rank( ( A ) ) = N.
;;*                                ( ( B ) )
;;*
;;*  These conditions ensure that the LSE problem has a unique solution,
;;*  which is obtained using a GRQ factorization of the matrices B and A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B. 0 <= P <= N <= M+P.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  C       (input/output) COMPLEX array, dimension (M)
;;*          On entry, C contains the right hand side vector for the
;;*          least squares part of the LSE problem.
;;*          On exit, the residual sum of squares for the solution
;;*          is given by the sum of squares of elements N-P+1 to M of
;;*          vector C.
;;*
;;*  D       (input/output) COMPLEX array, dimension (P)
;;*          On entry, D contains the right hand side vector for the
;;*          constrained equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) COMPLEX array, dimension (N)
;;*          On exit, X is the solution of the LSE problem.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M+N+P).
;;*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          CGEQRF, CGERQF, CUNMQR and CUNMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgglse (m  n  p  a  lda  b  ldb  c  d  x  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) c )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) x )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cgglse_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($d,float), IDX_PTR($x,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggqrf <n>  <m>  <p>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGQRF computes a generalized QR factorization of an N-by-M matrix A
;;*  and an N-by-P matrix B:
;;*
;;*              A = Q*R,        B = Q*T*Z,
;;*
;;*  where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
;;*  and R and T assume one of the forms:
;;*
;;*  if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
;;*                  (  0  ) N-M                         N   M-N
;;*                     M
;;*
;;*  where R11 is upper triangular, and
;;*
;;*  if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
;;*                   P-N  N                           ( T21 ) P
;;*                                                       P
;;*
;;*  where T12 or T21 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GQR factorization
;;*  of A and B implicitly gives the QR factorization of inv(B)*A:
;;*
;;*               inv(B)*A = Z'*(inv(T)*R)
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  conjugate transpose of matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B. N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(N,M)-by-M upper trapezoidal matrix R (R is
;;*          upper triangular if N >= M); the elements below the diagonal,
;;*          with the array TAUA, represent the unitary matrix Q as a
;;*          product of min(N,M) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAUA    (output) COMPLEX array, dimension (min(N,M))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q (see Further Details).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, if N <= P, the upper triangle of the subarray
;;*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
;;*          if N > P, the elements on and above the (N-P)-th subdiagonal
;;*          contain the N-by-P upper trapezoidal matrix T; the remaining
;;*          elements, with the array TAUB, represent the unitary
;;*          matrix Z as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  TAUB    (output) COMPLEX array, dimension (min(N,P))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the QR factorization
;;*          of an N-by-M matrix, NB2 is the optimal blocksize for the
;;*          RQ factorization of an N-by-P matrix, and NB3 is the optimal
;;*          blocksize for a call of CUNMQR.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*           = 0:  successful exit
;;*           < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(n,m).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine CUNGQR.
;;*  To use Q to update another matrix, use LAPACK subroutine CUNMQR.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(n,p).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a complex scalar, and v is a complex vector with
;;*  v(p-k+i+1:p) = 0 and v(p-k+i) = 1; v(1:p-k+i-1) is stored on exit in
;;*  B(n-k+i,1:p-k+i-1), and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine CUNGRQ.
;;*  To use Z to update another matrix, use LAPACK subroutine CUNMRQ.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cggqrf (n  m  p  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) taua )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) taub )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cggqrf_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($taua,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($taub,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggrqf <m>  <p>  <n>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGRQF computes a generalized RQ factorization of an M-by-N matrix A
;;*  and a P-by-N matrix B:
;;*
;;*              A = R*Q,        B = Z*T*Q,
;;*
;;*  where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
;;*  matrix, and R and T assume one of the forms:
;;*
;;*  if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
;;*                   N-M  M                           ( R21 ) N
;;*                                                       N
;;*
;;*  where R12 or R21 is upper triangular, and
;;*
;;*  if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
;;*                  (  0  ) P-N                         P   N-P
;;*                     N
;;*
;;*  where T11 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GRQ factorization
;;*  of A and B implicitly gives the RQ factorization of A*inv(B):
;;*
;;*               A*inv(B) = (R*inv(T))*Z'
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  conjugate transpose of the matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, if M <= N, the upper triangle of the subarray
;;*          A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
;;*          if M > N, the elements on and above the (M-N)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAUA, represent the unitary
;;*          matrix Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAUA    (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q (see Further Details).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(P,N)-by-N upper trapezoidal matrix T (T is
;;*          upper triangular if P >= N); the elements below the diagonal,
;;*          with the array TAUB, represent the unitary matrix Z as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TAUB    (output) COMPLEX array, dimension (min(P,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the RQ factorization
;;*          of an M-by-N matrix, NB2 is the optimal blocksize for the
;;*          QR factorization of a P-by-N matrix, and NB3 is the optimal
;;*          blocksize for a call of CUNMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO=-i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a complex scalar, and v is a complex vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine CUNGRQ.
;;*  To use Q to update another matrix, use LAPACK subroutine CUNMRQ.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(p,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i),
;;*  and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine CUNGQR.
;;*  To use Z to update another matrix, use LAPACK subroutine CUNMQR.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cggrqf (m  p  n  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) taua )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) taub )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cggrqf_(IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($taua,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($taub,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggsvd <jobu>  <jobv>  <jobq>  <m>  <n>  <p>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGSVD computes the generalized singular value decomposition (GSVD)
;;*  of an M-by-N complex matrix A and P-by-N complex matrix B:
;;*
;;*        U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
;;*
;;*  where U, V and Q are unitary matrices, and Z' means the conjugate
;;*  transpose of Z.  Let K+L = the effective numerical rank of the
;;*  matrix (A',B')', then R is a (K+L)-by-(K+L) nonsingular upper
;;*  triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
;;*  matrices and of the following structures, respectively:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                    K  L
;;*         D2 =   L ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                  N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 )
;;*              L (  0    0   R22 )
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                    K M-K K+L-M
;;*         D1 =   K ( I  0    0   )
;;*              M-K ( 0  C    0   )
;;*
;;*                      K M-K K+L-M
;;*         D2 =   M-K ( 0  S    0  )
;;*              K+L-M ( 0  0    I  )
;;*                P-L ( 0  0    0  )
;;*
;;*                     N-K-L  K   M-K  K+L-M
;;*    ( 0 R ) =     K ( 0    R11  R12  R13  )
;;*                M-K ( 0     0   R22  R23  )
;;*              K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*    S = diag( BETA(K+1),  ... , BETA(M) ),
;;*    C**2 + S**2 = I.
;;*
;;*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
;;*    ( 0  R22 R23 )
;;*    in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The routine computes C, S, R, and optionally the unitary
;;*  transformation matrices U, V and Q.
;;*
;;*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
;;*  A and B implicitly gives the SVD of A*inv(B):
;;*                       A*inv(B) = U*(D1*inv(D2))*V'.
;;*  If ( A',B')' has orthnormal columns, then the GSVD of A and B is also
;;*  equal to the CS decomposition of A and B. Furthermore, the GSVD can
;;*  be used to derive the solution of the eigenvalue problem:
;;*                       A'*A x = lambda* B'*B x.
;;*  In some literature, the GSVD of A and B is presented in the form
;;*                   U'*A*X = ( 0 D1 ),   V'*B*X = ( 0 D2 )
;;*  where U and V are orthogonal and X is nonsingular, and D1 and D2 are
;;*  ``diagonal''.  The former GSVD form can be converted to the latter
;;*  form by taking the nonsingular matrix X as
;;*
;;*                        X = Q*(  I   0    )
;;*                              (  0 inv(R) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Unitary matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Unitary matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Unitary matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in Purpose.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular matrix R, or part of R.
;;*          See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains part of the triangular matrix R if
;;*          M-K-L < 0.  See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  ALPHA   (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = C,
;;*            BETA(K+1:K+L)  = S,
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
;;*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1
;;*          and
;;*            ALPHA(K+L+1:N) = 0
;;*            BETA(K+L+1:N)  = 0
;;*
;;*  U       (output) COMPLEX array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the M-by-M unitary matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) COMPLEX array, dimension (LDV,P)
;;*          If JOBV = 'V', V contains the P-by-P unitary matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) COMPLEX array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (max(3*N,M,P)+N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (N)
;;*          On exit, IWORK stores the sorting information. More
;;*          precisely, the following loop will sort ALPHA
;;*             for I = K+1, min(M,K+L)
;;*                 swap ALPHA(I) and ALPHA(IWORK(I))
;;*             endfor
;;*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
;;*
;;*  INFO    (output)INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, the Jacobi-type procedure failed to
;;*                converge.  For further details, see subroutine CTGSJA.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLA    REAL
;;*  TOLB    REAL
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          rank of (A',B')'. Generally, they are set to
;;*                   TOLA = MAX(M,N)*norm(A)*MACHEPS,
;;*                   TOLB = MAX(P,N)*norm(B)*MACHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  2-96 Based on modifications by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cggsvd (jobu  jobv  jobq  m  n  p  k  l  a  lda  b  ldb  alpha  beta  u  ldu  v  ldv  q  ldq  work  rwork  iwork  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alpha )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ cggsvd_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cggsvp <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <k>  <l>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <iwork>  <rwork>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGGSVP computes unitary matrices U, V and Q such that
;;*
;;*                   N-K-L  K    L
;;*   U'*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
;;*                L ( 0     0   A23 )
;;*            M-K-L ( 0     0    0  )
;;*
;;*                   N-K-L  K    L
;;*          =     K ( 0    A12  A13 )  if M-K-L < 0;
;;*              M-K ( 0     0   A23 )
;;*
;;*                 N-K-L  K    L
;;*   V'*B*Q =   L ( 0     0   B13 )
;;*            P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
;;*  numerical rank of the (M+P)-by-N matrix (A',B')'.  Z' denotes the
;;*  conjugate transpose of Z.
;;*
;;*  This decomposition is the preprocessing step for computing the
;;*  Generalized Singular Value Decomposition (GSVD), see subroutine
;;*  CGGSVD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Unitary matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Unitary matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Unitary matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular (or trapezoidal) matrix
;;*          described in the Purpose section.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains the triangular matrix described in
;;*          the Purpose section.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) REAL
;;*  TOLB    (input) REAL
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          numerical rank of matrix B and a subblock of A. Generally,
;;*          they are set to
;;*             TOLA = MAX(M,N)*norm(A)*MACHEPS,
;;*             TOLB = MAX(P,N)*norm(B)*MACHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in Purpose section.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  U       (output) COMPLEX array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the unitary matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) COMPLEX array, dimension (LDV,M)
;;*          If JOBV = 'V', V contains the unitary matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) COMPLEX array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the unitary matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  TAU     (workspace) COMPLEX array, dimension (N)
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (max(3*N,M,P))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The subroutine uses LAPACK subroutine CGEQPF for the QR factorization
;;*  with column pivoting to detect the effective numerical rank of the
;;*  a matrix. It may be replaced by a better rank determination strategy.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cggsvp (jobu  jobv  jobq  m  p  n  a  lda  b  ldb  tola  tolb  k  l  u  ldu  v  ldv  q  ldq  iwork  rwork  tau  work  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) tola )
	((-idx0- (-float-)) tolb )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) iwork )
	((-idx1- (-float-)) rwork )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cggsvp_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($tola,float), IDX_PTR($tolb,float), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($iwork,int), IDX_PTR($rwork,float), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgtcon <norm>  <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTCON estimates the reciprocal of the condition number of a complex
;;*  tridiagonal matrix A using the LU factorization as computed by
;;*  CGTTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by CGTTRF.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) COMPLEX array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  ANORM   (input) REAL
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgtcon (norm  n  dl  d  du  du2  ipiv  anorm  rcond  work  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx2- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cgtcon_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgtrfs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is tridiagonal, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by CGTTRF.
;;*
;;*  DF      (input) COMPLEX array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DUF     (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) COMPLEX array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CGTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgtrfs (trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx2- (-float-)) dlf )
	((-idx2- (-float-)) df )
	((-idx2- (-float-)) duf )
	((-idx2- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgtrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($dlf,float), IDX_PTR($df,float), IDX_PTR($duf,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgtsv <n>  <nrhs>  <dl>  <d>  <du>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTSV  solves the equation
;;*
;;*     A*X = B,
;;*
;;*  where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
;;*  partial pivoting.
;;*
;;*  Note that the equation  A'*X = B  may be solved by interchanging the
;;*  order of the arguments DU and DL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input/output) COMPLEX array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) subdiagonal elements of
;;*          A.
;;*          On exit, DL is overwritten by the (n-2) elements of the
;;*          second superdiagonal of the upper triangular matrix U from
;;*          the LU factorization of A, in DL(1), ..., DL(n-2).
;;*
;;*  D       (input/output) COMPLEX array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*          On exit, D is overwritten by the n diagonal elements of U.
;;*
;;*  DU      (input/output) COMPLEX array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) superdiagonal elements
;;*          of A.
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          superdiagonal of U.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero, and the solution
;;*                has not been computed.  The factorization has not been
;;*                completed unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgtsv (n  nrhs  dl  d  du  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cgtsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgtsvx <fact>  <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTSVX uses the LU factorization to compute the solution to a complex
;;*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
;;*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the LU decomposition is used to factor the matrix A
;;*     as A = L * U, where L is a product of permutation and unit lower
;;*     bidiagonal matrices and U is upper triangular with nonzeros in
;;*     only the main diagonal and first two superdiagonals.
;;*
;;*  2. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  DLF, DF, DUF, DU2, and IPIV contain the factored form
;;*                  of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not
;;*                  be modified.
;;*          = 'N':  The matrix will be copied to DLF, DF, and DUF
;;*                  and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The n diagonal elements of A.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input or output) COMPLEX array, dimension (N-1)
;;*          If FACT = 'F', then DLF is an input argument and on entry
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A as computed by CGTTRF.
;;*
;;*          If FACT = 'N', then DLF is an output argument and on exit
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A.
;;*
;;*  DF      (input or output) COMPLEX array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*  DUF     (input or output) COMPLEX array, dimension (N-1)
;;*          If FACT = 'F', then DUF is an input argument and on entry
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*          If FACT = 'N', then DUF is an output argument and on exit
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input or output) COMPLEX array, dimension (N-2)
;;*          If FACT = 'F', then DU2 is an input argument and on entry
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*          If FACT = 'N', then DU2 is an output argument and on exit
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the LU factorization of A as
;;*          computed by CGTTRF.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the LU factorization of A;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates
;;*          a row interchange was not required.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has not been completed unless i = N, but the
;;*                       factor U is exactly singular, so the solution
;;*                       and error bounds could not be computed.
;;*                       RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgtsvx (fact  trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx2- (-float-)) dlf )
	((-idx2- (-float-)) df )
	((-idx2- (-float-)) duf )
	((-idx2- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cgtsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($dlf,float), IDX_PTR($df,float), IDX_PTR($duf,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgttrf <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTTRF computes an LU factorization of a complex tridiagonal matrix A
;;*  using elimination with partial pivoting and row interchanges.
;;*
;;*  The factorization has the form
;;*     A = L * U
;;*  where L is a product of permutation and unit lower bidiagonal
;;*  matrices and U is upper triangular with nonzeros in only the main
;;*  diagonal and first two superdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  DL      (input/output) COMPLEX array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) sub-diagonal elements of
;;*          A.
;;*
;;*          On exit, DL is overwritten by the (n-1) multipliers that
;;*          define the matrix L from the LU factorization of A.
;;*
;;*  D       (input/output) COMPLEX array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*
;;*          On exit, D is overwritten by the n diagonal elements of the
;;*          upper triangular matrix U from the LU factorization of A.
;;*
;;*  DU      (input/output) COMPLEX array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) super-diagonal elements
;;*          of A.
;;*
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          super-diagonal of U.
;;*
;;*  DU2     (output) COMPLEX array, dimension (N-2)
;;*          On exit, DU2 is overwritten by the (n-2) elements of the
;;*          second super-diagonal of U.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*          > 0:  if INFO = k, U(k,k) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgttrf (n  dl  d  du  du2  ipiv  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx2- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ cgttrf_(IDX_PTR($n,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgttrs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTTRS solves one of the systems of equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by CGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) COMPLEX array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cgttrs (trans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx2- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cgttrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cgtts2 <itrans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CGTTS2 solves one of the systems of equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by CGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITRANS  (input) INTEGER
;;*          Specifies the form of the system of equations.
;;*          = 0:  A * X = B     (No transpose)
;;*          = 1:  A**T * X = B  (Transpose)
;;*          = 2:  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) COMPLEX array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cgtts2 (itrans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  )
	((-idx0- (-int-)) itrans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx2- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ cgtts2_(IDX_PTR($itrans,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbevd <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBEVD computes all the eigenvalues and, optionally, eigenvectors of
;;*  a complex Hermitian band matrix A.  If eigenvectors are desired, it
;;*  uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LRWORK must be at least
;;*                        1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ = 'V' and N > 1, LIWORK must be at least 3 + 5*N .
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbevd (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ chbevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbev <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBEV computes all the eigenvalues and, optionally, eigenvectors of
;;*  a complex Hermitian band matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (max(1,3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbev (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chbev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbevx <jobz>  <range>  <uplo>  <n>  <kd>  <ab>  <ldab>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors
;;*  can be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  Q       (output) COMPLEX array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the N-by-N unitary matrix used in the
;;*                          reduction to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'V', then
;;*          LDQ >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AB to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbevx (jobz  range  uplo  n  kd  ab  ldab  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ chbevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbgst <vect>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <x>  <ldx>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBGST reduces a complex Hermitian-definite banded generalized
;;*  eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
;;*  such that C has the same bandwidth as A.
;;*
;;*  B must have been previously factorized as S**H*S by CPBSTF, using a
;;*  split Cholesky factorization. A is overwritten by C = X**H*A*X, where
;;*  X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
;;*  bandwidth of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form the transformation matrix X;
;;*          = 'V':  form X.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the transformed matrix X**H*A*X, stored in the same
;;*          format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input) COMPLEX array, dimension (LDBB,N)
;;*          The banded factor S from the split Cholesky factorization of
;;*          B, as returned by CPBSTF, stored in the first kb+1 rows of
;;*          the array.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,N)
;;*          If VECT = 'V', the n-by-n matrix X.
;;*          If VECT = 'N', the array X is not referenced.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.
;;*          LDX >= max(1,N) if VECT = 'V'; LDX >= 1 otherwise.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbgst (vect  uplo  n  ka  kb  ab  ldab  bb  ldbb  x  ldx  work  rwork  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chbgst_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbgvd <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
;;*  and banded, and B is also positive definite.  If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) COMPLEX array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**H*S, as returned by CPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**H*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (LRWORK)
;;*          On exit, if INFO=0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO=0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then CPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbgvd (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ chbgvd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbgv <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
;;*  and banded, and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) COMPLEX array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**H*S, as returned by CPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**H*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then CPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de chbgv (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chbgv_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbgvx <jobz>  <range>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBGVX computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
;;*  and banded, and B is also positive definite.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either all eigenvalues,
;;*  a range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) COMPLEX array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**H*S, as returned by CPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  Q       (output) COMPLEX array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the n-by-n matrix used in the reduction of
;;*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
;;*          and consequently C to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'N',
;;*          LDQ >= 1. If JOBZ = 'V', LDQ >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**H*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  then i eigenvectors failed to converge.  Their
;;*                    indices are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then CPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbgvx (jobz  range  uplo  n  ka  kb  ab  ldab  bb  ldbb  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ chbgvx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chbtrd <vect>  <uplo>  <n>  <kd>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHBTRD reduces a complex Hermitian band matrix A to real symmetric
;;*  tridiagonal form T by a unitary similarity transformation:
;;*  Q**H * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form Q;
;;*          = 'V':  form Q;
;;*          = 'U':  update a matrix X, by forming X*Q.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          On exit, the diagonal elements of AB are overwritten by the
;;*          diagonal elements of the tridiagonal matrix T; if KD > 0, the
;;*          elements on the first superdiagonal (if UPLO = 'U') or the
;;*          first subdiagonal (if UPLO = 'L') are overwritten by the
;;*          off-diagonal elements of T; the rest of AB is overwritten by
;;*          values generated during the reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ,N)
;;*          On entry, if VECT = 'U', then Q must contain an N-by-N
;;*          matrix X; if VECT = 'N' or 'V', then Q need not be set.
;;*
;;*          On exit:
;;*          if VECT = 'V', Q contains the N-by-N unitary matrix Q;
;;*          if VECT = 'U', Q contains the product X*Q;
;;*          if VECT = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1, and LDQ >= N if VECT = 'V' or 'U'.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by Linda Kaufman, Bell Labs.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbtrd (vect  uplo  n  kd  ab  ldab  d  e  q  ldq  work  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ chbtrd_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (checon <uplo>  <n>  <a>  <lda>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHECON estimates the reciprocal of the condition number of a complex
;;*  Hermitian matrix A using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by CHETRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CHETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHETRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de checon (uplo  n  a  lda  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ checon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cheevd <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEEVD computes all eigenvalues and, optionally, eigenvectors of a
;;*  complex Hermitian matrix A.  If eigenvectors are desired, it uses a
;;*  divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.
;;*          If N <= 1,                LWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
;;*          If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of the array RWORK.
;;*          If N <= 1,                LRWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LRWORK must be at least N.
;;*          If JOBZ  = 'V' and N > 1, LRWORK must be at least
;;*                         1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cheevd (jobz  uplo  n  a  lda  w  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ cheevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cheev <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEEV computes all eigenvalues and, optionally, eigenvectors of a
;;*  complex Hermitian matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the blocksize for CHETRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cheev (jobz  uplo  n  a  lda  w  work  lwork  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cheev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cheevr <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEEVR computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian matrix T.  Eigenvalues and eigenvectors can
;;*  be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Whenever possible, CHEEVR calls CSTEGR to compute the
;;*  eigenspectrum using Relatively Robust Representations.  CSTEGR
;;*  computes eigenvalues by the dqds algorithm, while orthogonal
;;*  eigenvectors are computed from various "good" L D L^T representations
;;*  (also known as Relatively Robust Representations). Gram-Schmidt
;;*  orthogonalization is avoided as far as possible. More specifically,
;;*  the various steps of the algorithm are as follows. For the i-th
;;*  unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*          is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB//CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*
;;*  Note 1 : CHEEVR calls CSTEGR when the full spectrum is requested
;;*  on machines which conform to the ieee-754 floating point standard.
;;*  CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
;;*  when partial spectrum requests are made.
;;*
;;*  Normal execution of CSTEGR may create NaNs and infinities and
;;*  hence may abort due to a floating point exception in environments
;;*  which do not handle NaNs and infinities in the ieee standard default
;;*  manner.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
;;********** CSTEIN are called
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*          If high relative accuracy is important, set ABSTOL to
;;*          SLAMCH( 'Safe minimum' ).  Doing so will guarantee that
;;*          eigenvalues are computed to high relative accuracy when
;;*          possible in future releases.  The current code does not
;;*          make any guarantees about high relative accuracy, but
;;*          furutre releases will. See J. Barlow and J. Demmel,
;;*          "Computing Accurate Eigensystems of Scaled Diagonally
;;*          Dominant Matrices", LAPACK Working Note #7, for a discussion
;;*          of which matrices define their eigenvalues to high relative
;;*          accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;********** Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the max of the blocksize for CHETRD and for
;;*          CUNMTR as returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal
;;*          (and minimal) LRWORK.
;;*
;;* LRWORK  (input) INTEGER
;;*         The length of the array RWORK.  LRWORK >= max(1,24*N).
;;*
;;*         If LRWORK = -1, then a workspace query is assumed; the routine
;;*         only calculates the optimal size of the RWORK array, returns
;;*         this value as the first entry of the RWORK array, and no error
;;*         message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal
;;*          (and minimal) LIWORK.
;;*
;;* LIWORK  (input) INTEGER
;;*         The dimension of the array IWORK.  LIWORK >= max(1,10*N).
;;*
;;*         If LIWORK = -1, then a workspace query is assumed; the
;;*         routine only calculates the optimal size of the IWORK array,
;;*         returns this value as the first entry of the IWORK array, and
;;*         no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  Internal error
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cheevr (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ cheevr_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cheevx <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
;;*  be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the max of the blocksize for CHETRD and for
;;*          CUNMTR as returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cheevx (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ cheevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chegs2 <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEGS2 reduces a complex Hermitian-definite generalized
;;*  eigenproblem to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U` or L'*A*L.
;;*
;;*  B must have been previously factorized as U'*U or L*L' by CPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U')*A*inv(U) or inv(L)*A*inv(L');
;;*          = 2 or 3: compute U*A*U' or L'*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored, and how B has been factorized.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by CPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chegs2 (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ chegs2_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chegst <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEGST reduces a complex Hermitian-definite generalized
;;*  eigenproblem to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
;;*
;;*  B must have been previously factorized as U**H*U or L*L**H by CPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
;;*          = 2 or 3: compute U*A*U**H or L**H*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**H*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by CPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chegst (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ chegst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chegvd <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian and B is also positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the Hermitian matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.
;;*          If N <= 1,                LWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LWORK >= N + 1.
;;*          If JOBZ  = 'V' and N > 1, LWORK >= 2*N + N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array, dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of the array RWORK.
;;*          If N <= 1,                LRWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LRWORK >= N.
;;*          If JOBZ  = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  CPOTRF or CHEEVD returned an error code:
;;*             <= N:  if INFO = i, CHEEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chegvd (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ chegvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chegv <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be Hermitian and B is also
;;*  positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the Hermitian positive definite matrix B.
;;*          If UPLO = 'U', the leading N-by-N upper triangular part of B
;;*          contains the upper triangular part of the matrix B.
;;*          If UPLO = 'L', the leading N-by-N lower triangular part of B
;;*          contains the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the blocksize for CHETRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  CPOTRF or CHEEV returned an error code:
;;*             <= N:  if INFO = i, CHEEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chegv (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  rwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chegv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chegvx <itype>  <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHEGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian and B is also positive definite.
;;*  Eigenvalues and eigenvectors can be selected by specifying either a
;;*  range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;**
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit,  the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the Hermitian matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the blocksize for CHETRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  CPOTRF or CHEEVX returned an error code:
;;*             <= N:  if INFO = i, CHEEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chegvx (itype  jobz  range  uplo  n  a  lda  b  ldb  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  rwork  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ chegvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cherfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHERFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian indefinite, and
;;*  provides error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX array, dimension (LDAF,N)
;;*          The factored form of the matrix A.  AF contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**H or
;;*          A = L*D*L**H as computed by CHETRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHETRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CHETRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cherfs (uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cherfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chesv <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHESV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**H,  if UPLO = 'U', or
;;*     A = L * D * L**H,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is Hermitian and block diagonal with 
;;*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
;;*  used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the block diagonal matrix D and the
;;*          multipliers used to obtain the factor U or L from the
;;*          factorization A = U*D*U**H or A = L*D*L**H as computed by
;;*          CHETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by CHETRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 1, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          CHETRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de chesv (uplo  n  nrhs  a  lda  ipiv  b  ldb  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ chesv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chesvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHESVX uses the diagonal pivoting factorization to compute the
;;*  solution to a complex system of linear equations A * X = B,
;;*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A.
;;*     The form of the factorization is
;;*        A = U * D * U**H,  if UPLO = 'U', or
;;*        A = L * D * L**H,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices, and D is Hermitian and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AF and IPIV contain the factored form
;;*                  of A.  A, AF and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by CHETRF.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CHETRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CHETRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 2*N, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          CHETRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chesvx (fact  uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  lwork  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chesvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chetd2 <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHETD2 reduces a complex Hermitian matrix A to real symmetric
;;*  tridiagonal form T by a unitary similarity transformation:
;;*  Q' * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the unitary
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the unitary matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) COMPLEX array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chetd2 (uplo  n  a  lda  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ chetd2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chetf2 <uplo>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHETF2 computes the factorization of a complex Hermitian matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U'  or  A = L*D*L'
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, U' is the conjugate transpose of U, and D is
;;*  Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  1-96 - Based on modifications by
;;*    J. Lewis, Boeing Computer Services Company
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chetf2 (uplo  n  a  lda  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ chetf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chetrd <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHETRD reduces a complex Hermitian matrix A to real symmetric
;;*  tridiagonal form T by a unitary similarity transformation:
;;*  Q**H * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the unitary
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the unitary matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) COMPLEX array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 1.
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chetrd (uplo  n  a  lda  d  e  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ chetrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chetrf <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHETRF computes the factorization of a complex Hermitian matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method.  The form of the
;;*  factorization is
;;*
;;*     A = U*D*U**H  or  A = L*D*L**H
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is Hermitian and block diagonal with 
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >=1.  For best performance
;;*          LWORK >= N*NB, where NB is the block size returned by ILAENV.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, and division by zero will occur if it
;;*                is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de chetrf (uplo  n  a  lda  ipiv  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ chetrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chetri <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHETRI computes the inverse of a complex Hermitian indefinite matrix
;;*  A using the factorization A = U*D*U**H or A = L*D*L**H computed by
;;*  CHETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by CHETRF.
;;*
;;*          On exit, if INFO = 0, the (Hermitian) inverse of the original
;;*          matrix.  If UPLO = 'U', the upper triangular part of the
;;*          inverse is formed and the part of A below the diagonal is not
;;*          referenced; if UPLO = 'L' the lower triangular part of the
;;*          inverse is formed and the part of A above the diagonal is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHETRF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chetri (uplo  n  a  lda  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ chetri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chetrs <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHETRS solves a system of linear equations A*X = B with a complex
;;*  Hermitian matrix A using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by CHETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CHETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHETRF.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chetrs (uplo  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ chetrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chgeqz <job>  <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <q>  <ldq>  <z>  <ldz>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHGEQZ implements a single-shift version of the QZ
;;*  method for finding the generalized eigenvalues w(i)=ALPHA(i)/BETA(i)
;;*  of the equation
;;*
;;*       det( A - w(i) B ) = 0
;;*
;;*  If JOB='S', then the pair (A,B) is simultaneously
;;*  reduced to Schur form (i.e., A and B are both upper triangular) by
;;*  applying one unitary tranformation (usually called Q) on the left and
;;*  another (usually called Z) on the right.  The diagonal elements of
;;*  A are then ALPHA(1),...,ALPHA(N), and of B are BETA(1),...,BETA(N).
;;*
;;*  If JOB='S' and COMPQ and COMPZ are 'V' or 'I', then the unitary
;;*  transformations used to reduce (A,B) are accumulated into the arrays
;;*  Q and Z s.t.:
;;*
;;*       Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
;;*       Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*
;;*
;;*  Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
;;*       Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
;;*       pp. 241--256.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E': compute only ALPHA and BETA.  A and B will not
;;*                 necessarily be put into generalized Schur form.
;;*          = 'S': put A and B into generalized Schur form, as well
;;*                 as computing ALPHA and BETA.
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not modify Q.
;;*          = 'V': multiply the array Q on the right by the conjugate
;;*                 transpose of the unitary tranformation that is
;;*                 applied to the left side of A and B to reduce them
;;*                 to Schur form.
;;*          = 'I': like COMPQ='V', except that Q will be initialized to
;;*                 the identity first.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not modify Z.
;;*          = 'V': multiply the array Z on the right by the unitary
;;*                 tranformation that is applied to the right side of
;;*                 A and B to reduce them to Schur form.
;;*          = 'I': like COMPZ='V', except that Z will be initialized to
;;*                 the identity first.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, Q, and Z.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA, N)
;;*          On entry, the N-by-N upper Hessenberg matrix A.  Elements
;;*          below the subdiagonal must be zero.
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to upper triangular form.
;;*          If JOB='E', then on exit A will have been destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max( 1, N ).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.  Elements
;;*          below the diagonal must be zero.
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to upper triangular form.
;;*          If JOB='E', then on exit B will have been destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max( 1, N ).
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*          The diagonal elements of A when the pair (A,B) has been
;;*          reduced to Schur form.  ALPHA(i)/BETA(i) i=1,...,N
;;*          are the generalized eigenvalues.
;;*
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          The diagonal elements of B when the pair (A,B) has been
;;*          reduced to Schur form.  ALPHA(i)/BETA(i) i=1,...,N
;;*          are the generalized eigenvalues.  A and B are normalized
;;*          so that BETA(1),...,BETA(N) are non-negative real numbers.
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ, N)
;;*          If COMPQ='N', then Q will not be referenced.
;;*          If COMPQ='V' or 'I', then the conjugate transpose of the
;;*             unitary transformations which are applied to A and B on
;;*             the left will be applied to the array Q on the right.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= 1.
;;*          If COMPQ='V' or 'I', then LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ, N)
;;*          If COMPZ='N', then Z will not be referenced.
;;*          If COMPZ='V' or 'I', then the unitary transformations which
;;*             are applied to A and B on the right will be applied to the
;;*             array Z on the right.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If COMPZ='V' or 'I', then LDZ >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1,...,N: the QZ iteration did not converge.  (A,B) is not
;;*                     in Schur form, but ALPHA(i) and BETA(i),
;;*                     i=INFO+1,...,N should be correct.
;;*          = N+1,...,2*N: the shift calculation failed.  (A,B) is not
;;*                     in Schur form, but ALPHA(i) and BETA(i),
;;*                     i=INFO-N+1,...,N should be correct.
;;*          > 2*N:     various "impossible" errors.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  We assume that complex ABS works as long as its value is less than
;;*  overflow.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chgeqz (job  compq  compz  n  ilo  ihi  a  lda  b  ldb  alpha  beta  q  ldq  z  ldz  work  lwork  rwork  info  )
	((-str-) job )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chgeqz_($job->data, $compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpcon <uplo>  <n>  <ap>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPCON estimates the reciprocal of the condition number of a complex
;;*  Hermitian packed matrix A using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by CHPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CHPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHPTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpcon (uplo  n  ap  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ chpcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpevd <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPEVD computes all the eigenvalues and, optionally, eigenvectors of
;;*  a complex Hermitian matrix A in packed storage.  If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least 2*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LRWORK must be at least
;;*                    1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpevd (jobz  uplo  n  ap  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ chpevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpev <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPEV computes all the eigenvalues and, optionally, eigenvectors of a
;;*  complex Hermitian matrix in packed storage.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (max(1, 2*N-1))
;;*
;;*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpev (jobz  uplo  n  ap  w  z  ldz  work  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chpev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpevx <jobz>  <range>  <uplo>  <n>  <ap>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian matrix A in packed storage.
;;*  Eigenvalues/vectors can be selected by specifying either a range of
;;*  values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the selected eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and
;;*          the index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpevx (jobz  range  uplo  n  ap  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ chpevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpgst <itype>  <uplo>  <n>  <ap>  <bp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPGST reduces a complex Hermitian-definite generalized
;;*  eigenproblem to standard form, using packed storage.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
;;*
;;*  B must have been previously factorized as U**H*U or L*L**H by CPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
;;*          = 2 or 3: compute U*A*U**H or L**H*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**H*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  BP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          stored in the same format as A, as returned by CPPTRF.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpgst (itype  uplo  n  ap  bp  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) bp )
	((-idx0- (-int-)) info )
	#{ chpgst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpgvd <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPGVD computes all the eigenvalues and, optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian, stored in packed format, and B is also
;;*  positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H, in the same storage
;;*          format as B.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 2*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  CPPTRF or CHPEVD returned an error code:
;;*             <= N:  if INFO = i, CHPEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not convergeto zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de chpgvd (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) bp )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ chpgvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpgv <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPGV computes all the eigenvalues and, optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be Hermitian, stored in packed format,
;;*  and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H, in the same storage
;;*          format as B.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (max(1, 2*N-1))
;;*
;;*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  CPPTRF or CHPEV returned an error code:
;;*             <= N:  if INFO = i, CHPEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not convergeto zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de chpgv (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  rwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) bp )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chpgv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpgvx <itype>  <jobz>  <range>  <uplo>  <n>  <ap>  <bp>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPGVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian, stored in packed format, and B is also
;;*  positive definite.  Eigenvalues and eigenvectors can be selected by
;;*  specifying either a range of values or a range of indices for the
;;*  desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H, in the same storage
;;*          format as B.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, N)
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  CPPTRF or CHPEVX returned an error code:
;;*             <= N:  if INFO = i, CHPEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de chpgvx (itype  jobz  range  uplo  n  ap  bp  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) bp )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ chpgvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian indefinite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The factored form of the matrix A.  AFP contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**H or
;;*          A = L*D*L**H as computed by CHPTRF, stored as a packed
;;*          triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHPTRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CHPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chprfs (uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpsv <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian matrix stored in packed format and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**H,  if UPLO = 'U', or
;;*     A = L * D * L**H,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, D is Hermitian and block diagonal with 1-by-1
;;*  and 2-by-2 diagonal blocks.  The factored form of A is then used to
;;*  solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by CHPTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, so the solution could not be
;;*                computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de chpsv (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ chpsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chpsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
;;*  A = L*D*L**H to compute the solution to a complex system of linear
;;*  equations A * X = B, where A is an N-by-N Hermitian matrix stored
;;*  in packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A as
;;*        A = U * D * U**H,  if UPLO = 'U', or
;;*        A = L * D * L**H,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices and D is Hermitian and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AFP and IPIV contain the factored form of
;;*                  A.  AFP and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CHPTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CHPTRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpsvx (fact  uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ chpsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chptrd <uplo>  <n>  <ap>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPTRD reduces a complex Hermitian matrix A stored in packed form to
;;*  real symmetric tridiagonal form T by a unitary similarity
;;*  transformation: Q**H * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the unitary
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the unitary matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) COMPLEX array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP,
;;*  overwriting A(1:i-1,i+1), and tau is stored in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP,
;;*  overwriting A(i+2:n,i), and tau is stored in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chptrd (uplo  n  ap  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ chptrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chptrf <uplo>  <n>  <ap>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPTRF computes the factorization of a complex Hermitian packed
;;*  matrix A using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U**H  or  A = L*D*L**H
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is Hermitian and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L, stored as a packed triangular
;;*          matrix overwriting A (see below for further details).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  5-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chptrf (uplo  n  ap  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ chptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chptri <uplo>  <n>  <ap>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPTRI computes the inverse of a complex Hermitian indefinite matrix
;;*  A in packed storage using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by CHPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by CHPTRF,
;;*          stored as a packed triangular matrix.
;;*
;;*          On exit, if INFO = 0, the (Hermitian) inverse of the original
;;*          matrix, stored as a packed triangular matrix. The j-th column
;;*          of inv(A) is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
;;*          if UPLO = 'L',
;;*             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHPTRF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chptri (uplo  n  ap  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ chptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chptrs <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHPTRS solves a system of linear equations A*X = B with a complex
;;*  Hermitian matrix A stored in packed format using the factorization
;;*  A = U*D*U**H or A = L*D*L**H computed by CHPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CHPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CHPTRF.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chptrs (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ chptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chsein <side>  <eigsrc>  <initv>  <select>  <n>  <h>  <ldh>  <w>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <rwork>  <ifaill>  <ifailr>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHSEIN uses inverse iteration to find specified right and/or left
;;*  eigenvectors of a complex upper Hessenberg matrix H.
;;*
;;*  The right eigenvector x and the left eigenvector y of the matrix H
;;*  corresponding to an eigenvalue w are defined by:
;;*
;;*               H * x = w * x,     y**h * H = w * y**h
;;*
;;*  where y**h denotes the conjugate transpose of the vector y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  EIGSRC  (input) CHARACTER*1
;;*          Specifies the source of eigenvalues supplied in W:
;;*          = 'Q': the eigenvalues were found using CHSEQR; thus, if
;;*                 H has zero subdiagonal elements, and so is
;;*                 block-triangular, then the j-th eigenvalue can be
;;*                 assumed to be an eigenvalue of the block containing
;;*                 the j-th row/column.  This property allows CHSEIN to
;;*                 perform inverse iteration on just one diagonal block.
;;*          = 'N': no assumptions are made on the correspondence
;;*                 between eigenvalues and diagonal blocks.  In this
;;*                 case, CHSEIN must always perform inverse iteration
;;*                 using the whole matrix H.
;;*
;;*  INITV   (input) CHARACTER*1
;;*          = 'N': no initial vectors are supplied;
;;*          = 'U': user-supplied initial vectors are stored in the arrays
;;*                 VL and/or VR.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          Specifies the eigenvectors to be computed. To select the
;;*          eigenvector corresponding to the eigenvalue W(j),
;;*          SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) COMPLEX array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  W       (input/output) COMPLEX array, dimension (N)
;;*          On entry, the eigenvalues of H.
;;*          On exit, the real parts of W may have been altered since
;;*          close eigenvalues are perturbed slightly in searching for
;;*          independent eigenvectors.
;;*
;;*  VL      (input/output) COMPLEX array, dimension (LDVL,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
;;*          contain starting vectors for the inverse iteration for the
;;*          left eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column in which the eigenvector will be
;;*          stored.
;;*          On exit, if SIDE = 'L' or 'B', the left eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VL, in the same order as their eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) COMPLEX array, dimension (LDVR,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
;;*          contain starting vectors for the inverse iteration for the
;;*          right eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column in which the eigenvector will be
;;*          stored.
;;*          On exit, if SIDE = 'R' or 'B', the right eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VR, in the same order as their eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR required to
;;*          store the eigenvectors (= the number of .TRUE. elements in
;;*          SELECT).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  IFAILL  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
;;*          eigenvector in the i-th column of VL (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
;;*          eigenvector converged satisfactorily.
;;*          If SIDE = 'R', IFAILL is not referenced.
;;*
;;*  IFAILR  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
;;*          eigenvector in the i-th column of VR (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
;;*          eigenvector converged satisfactorily.
;;*          If SIDE = 'L', IFAILR is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, i is the number of eigenvectors which
;;*                failed to converge; see IFAILL and IFAILR for further
;;*                details.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x|+|y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chsein (side  eigsrc  initv  select  n  h  ldh  w  vl  ldvl  vr  ldvr  mm  m  work  rwork  ifaill  ifailr  info  )
	((-str-) side )
	((-str-) eigsrc )
	((-str-) initv )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx2- (-float-)) w )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) ifaill )
	((-idx1- (-int-)) ifailr )
	((-idx0- (-int-)) info )
	#{ chsein_($side->data, $eigsrc->data, $initv->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($w,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($ifaill,int), IDX_PTR($ifailr,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (chseqr <job>  <compz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <w>  <z>  <ldz>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CHSEQR computes the eigenvalues of a complex upper Hessenberg
;;*  matrix H, and, optionally, the matrices T and Z from the Schur
;;*  decomposition H = Z T Z**H, where T is an upper triangular matrix
;;*  (the Schur form), and Z is the unitary matrix of Schur vectors.
;;*
;;*  Optionally Z may be postmultiplied into an input unitary matrix Q,
;;*  so that this routine can give the Schur factorization of a matrix A
;;*  which has been reduced to the Hessenberg form H by the unitary
;;*  matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E': compute eigenvalues only;
;;*          = 'S': compute eigenvalues and the Schur form T.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': no Schur vectors are computed;
;;*          = 'I': Z is initialized to the unit matrix and the matrix Z
;;*                 of Schur vectors of H is returned;
;;*          = 'V': Z must contain an unitary matrix Q on entry, and
;;*                 the product Q*Z is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to CGEBAL, and then passed to CGEHRD
;;*          when the matrix output by CGEBAL is reduced to Hessenberg
;;*          form. Otherwise ILO and IHI should be set to 1 and N
;;*          respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  H       (input/output) COMPLEX array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if JOB = 'S', H contains the upper triangular matrix
;;*          T from the Schur decomposition (the Schur form). If
;;*          JOB = 'E', the contents of H are unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          The computed eigenvalues. If JOB = 'S', the eigenvalues are
;;*          stored in the same order as on the diagonal of the Schur form
;;*          returned in H, with W(i) = H(i,i).
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          If COMPZ = 'N': Z is not referenced.
;;*          If COMPZ = 'I': on entry, Z need not be set, and on exit, Z
;;*          contains the unitary matrix Z of the Schur vectors of H.
;;*          If COMPZ = 'V': on entry Z must contain an N-by-N matrix Q,
;;*          which is assumed to be equal to the unit matrix except for
;;*          the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
;;*          Normally Q is the unitary matrix generated by CUNGHR after
;;*          the call to CGEHRD which formed the Hessenberg matrix H.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= max(1,N) if COMPZ = 'I' or 'V'; LDZ >= 1 otherwise.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, CHSEQR failed to compute all the
;;*                eigenvalues in a total of 30*(IHI-ILO+1) iterations;
;;*                elements 1:ilo-1 and i+1:n of W contain those
;;*                eigenvalues which have been successfully computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chseqr (job  compz  n  ilo  ihi  h  ldh  w  z  ldz  work  lwork  info  )
	((-str-) job )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx2- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ chseqr_($job->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clabrd <m>  <n>  <nb>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <x>  <ldx>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLABRD reduces the first NB rows and columns of a complex general
;;*  m by n matrix A to upper or lower real bidiagonal form by a unitary
;;*  transformation Q' * A * P, and returns the matrices X and Y which
;;*  are needed to apply the transformation to the unreduced part of A.
;;*
;;*  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
;;*  bidiagonal form.
;;*
;;*  This is an auxiliary routine called by CGEBRD
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of leading rows and columns of A to be reduced.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit, the first NB rows and columns of the matrix are
;;*          overwritten; the rest of the array is unchanged.
;;*          If m >= n, elements on and below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the unitary
;;*            matrix Q as a product of elementary reflectors; and
;;*            elements above the diagonal in the first NB rows, with the
;;*            array TAUP, represent the unitary matrix P as a product
;;*            of elementary reflectors.
;;*          If m < n, elements below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the unitary
;;*            matrix Q as a product of elementary reflectors, and
;;*            elements on and above the diagonal in the first NB rows,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) REAL array, dimension (NB)
;;*          The diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.  D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (NB)
;;*          The off-diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.
;;*
;;*  TAUQ    (output) COMPLEX array dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q. See Further Details.
;;*
;;*  TAUP    (output) COMPLEX array, dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix P. See Further Details.
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NB)
;;*          The m-by-nb matrix X required to update the unreduced part
;;*          of A.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X. LDX >= max(1,M).
;;*
;;*  Y       (output) COMPLEX array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y required to update the unreduced part
;;*          of A.
;;*
;;*  LDY     (output) INTEGER
;;*          The leading dimension of the array Y. LDY >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors.
;;*
;;*  If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
;;*  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The elements of the vectors v and u together form the m-by-nb matrix
;;*  V and the nb-by-n matrix U' which are needed, with X and Y, to apply
;;*  the transformation to the unreduced part of the matrix, using a block
;;*  update of the form:  A := A - V*Y' - X*U'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with nb = 2:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
;;*    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
;;*    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )
;;*
;;*  where a denotes an element of the original matrix which is unchanged,
;;*  vi denotes an element of the vector defining H(i), and ui an element
;;*  of the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clabrd (m  n  nb  a  lda  d  e  tauq  taup  x  ldx  y  ldy  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tauq )
	((-idx2- (-float-)) taup )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx3- (-float-)) y )
	((-idx0- (-int-)) ldy )
	#{ clabrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tauq,float), IDX_PTR($taup,float), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($y,float), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clacgv <n>  <x>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLACGV conjugates a complex vector of length N.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The length of the vector X.  N >= 0.
;;*
;;*  X       (input/output) COMPLEX array, dimension
;;*                         (1+(N-1)*abs(INCX))
;;*          On entry, the vector of length N to be conjugated.
;;*          On exit, X is overwritten with conjg(X).
;;*
;;*  INCX    (input) INTEGER
;;*          The spacing between successive elements of X.
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clacgv (n  x  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ clacgv_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clacon <n>  <v>  <x>  <est>  <kase>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLACON estimates the 1-norm of a square, complex matrix A.
;;*  Reverse communication is used for evaluating matrix-vector products.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The order of the matrix.  N >= 1.
;;*
;;*  V      (workspace) COMPLEX array, dimension (N)
;;*         On the final return, V = A*W,  where  EST = norm(V)/norm(W)
;;*         (W is not returned).
;;*
;;*  X      (input/output) COMPLEX array, dimension (N)
;;*         On an intermediate return, X should be overwritten by
;;*               A * X,   if KASE=1,
;;*               A' * X,  if KASE=2,
;;*         where A' is the conjugate transpose of A, and CLACON must be
;;*         re-called with all the other parameters unchanged.
;;*
;;*  EST    (output) REAL
;;*         An estimate (a lower bound) for norm(A).
;;*
;;*  KASE   (input/output) INTEGER
;;*         On the initial call to CLACON, KASE should be 0.
;;*         On an intermediate return, KASE will be 1 or 2, indicating
;;*         whether X should be overwritten by A * X  or A' * X.
;;*         On the final return from CLACON, KASE will again be 0.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  Contributed by Nick Higham, University of Manchester.
;;*  Originally named CONEST, dated March 16, 1988.
;;*
;;*  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of
;;*  a real or complex matrix, with applications to condition estimation",
;;*  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
;;*
;;*  Last modified:  April, 1999
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clacon (n  v  x  est  kase  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) v )
	((-idx2- (-float-)) x )
	((-idx0- (-float-)) est )
	((-idx0- (-int-)) kase )
	#{ clacon_(IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($x,float), IDX_PTR($est,float), IDX_PTR($kase,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clacp2 <uplo>  <m>  <n>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLACP2 copies all or part of a real two-dimensional matrix A to a
;;*  complex matrix B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be copied to B.
;;*          = 'U':      Upper triangular part
;;*          = 'L':      Lower triangular part
;;*          Otherwise:  All of the matrix A
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
;;*          is accessed; if UPLO = 'L', only the lower trapezium is
;;*          accessed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (output) COMPLEX array, dimension (LDB,N)
;;*          On exit, B = A in the locations specified by UPLO.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clacp2 (uplo  m  n  a  lda  b  ldb  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ clacp2_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clacpy <uplo>  <m>  <n>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLACPY copies all or part of a two-dimensional matrix A to another
;;*  matrix B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be copied to B.
;;*          = 'U':      Upper triangular part
;;*          = 'L':      Lower triangular part
;;*          Otherwise:  All of the matrix A
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
;;*          is accessed; if UPLO = 'L', only the lower trapezium is
;;*          accessed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (output) COMPLEX array, dimension (LDB,N)
;;*          On exit, B = A in the locations specified by UPLO.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clacpy (uplo  m  n  a  lda  b  ldb  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ clacpy_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clacrm <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <rwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLACRM performs a very simple matrix-matrix multiplication:
;;*           C := A * B,
;;*  where A is M by N and complex; B is N by N and real;
;;*  C is M by N and complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A and of the matrix C.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns and rows of the matrix B and
;;*          the number of columns of the matrix C.
;;*          N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA, N)
;;*          A contains the M by N matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >=max(1,M).
;;*
;;*  B       (input) REAL array, dimension (LDB, N)
;;*          B contains the N by N matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >=max(1,N).
;;*
;;*  C       (input) COMPLEX array, dimension (LDC, N)
;;*          C contains the M by N matrix C.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >=max(1,N).
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*M*N)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clacrm (m  n  a  lda  b  ldb  c  ldc  rwork  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) rwork )
	#{ clacrm_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($rwork,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clacrt <n>  <cx>  <incx>  <cy>  <incy>  <c>  <s>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLACRT performs the operation
;;*
;;*     (  c  s )( x )  ==> ( x )
;;*     ( -s  c )( y )      ( y )
;;*
;;*  where c and s are complex and the vectors x and y are complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements in the vectors CX and CY.
;;*
;;*  CX      (input/output) COMPLEX array, dimension (N)
;;*          On input, the vector x.
;;*          On output, CX is overwritten with c*x + s*y.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of CX.  INCX <> 0.
;;*
;;*  CY      (input/output) COMPLEX array, dimension (N)
;;*          On input, the vector y.
;;*          On output, CY is overwritten with -s*x + c*y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive values of CY.  INCY <> 0.
;;*
;;*  C       (input) COMPLEX
;;*  S       (input) COMPLEX
;;*          C and S define the matrix
;;*             [  C   S  ].
;;*             [ -S   C  ]
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clacrt (n  cx  incx  cy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	#{ clacrt_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($s,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cladiv <x>  <y>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLADIV := X / Y, where X and Y are complex.  The computation of X / Y
;;*  will not overflow on an intermediary step unless the results
;;*  overflows.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  X       (input) COMPLEX
;;*  Y       (input) COMPLEX
;;*          The complex scalars X and Y.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cladiv (x  y  )
	((-idx1- (-float-)) x )
	((-idx1- (-float-)) y )
	(let ((rval 0))
	#{ $rval=cladiv_(IDX_PTR($x,float), IDX_PTR($y,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claed0 <qsiz>  <n>  <d>  <e>  <q>  <ldq>  <qstore>  <ldqs>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Using the divide and conquer method, CLAED0 computes all eigenvalues
;;*  of a symmetric tridiagonal matrix which is one diagonal block of
;;*  those from reducing a dense or band Hermitian matrix and
;;*  corresponding eigenvectors of the dense or band matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the unitary matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, the diagonal elements of the tridiagonal matrix.
;;*         On exit, the eigenvalues in ascending order.
;;*
;;*  E      (input/output) REAL array, dimension (N-1)
;;*         On entry, the off-diagonal elements of the tridiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  Q      (input/output) COMPLEX array, dimension (LDQ,N)
;;*         On entry, Q must contain an QSIZ x N matrix whose columns
;;*         unitarily orthonormal. It is a part of the unitary matrix
;;*         that reduces the full dense Hermitian matrix to a
;;*         (reducible) symmetric tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  IWORK  (workspace) INTEGER array,
;;*         the dimension of IWORK must be at least
;;*                      6 + 6*N + 5*N*lg N
;;*                      ( lg( N ) = smallest integer k
;;*                                  such that 2^k >= N )
;;*
;;*  RWORK  (workspace) REAL array,
;;*                               dimension (1 + 3*N + 2*N*lg N + 3*N**2)
;;*                        ( lg( N ) = smallest integer k
;;*                                    such that 2^k >= N )
;;*
;;*  QSTORE (workspace) COMPLEX array, dimension (LDQS, N)
;;*         Used to store parts of
;;*         the eigenvector matrix when the updating matrix multiplies
;;*         take place.
;;*
;;*  LDQS   (input) INTEGER
;;*         The leading dimension of the array QSTORE.
;;*         LDQS >= max(1,N).
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  =====================================================================
;;*
;;*  Warning:      N could be as big as QSIZ!
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claed0 (qsiz  n  d  e  q  ldq  qstore  ldqs  rwork  iwork  info  )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) qstore )
	((-idx0- (-int-)) ldqs )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ claed0_(IDX_PTR($qsiz,int), IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($qstore,float), IDX_PTR($ldqs,int), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claed7 <n>  <cutpnt>  <qsiz>  <tlvls>  <curlvl>  <curpbm>  <d>  <q>  <ldq>  <rho>  <indxq>  <qstore>  <qptr>  <prmptr>  <perm>  <givptr>  <givcol>  <givnum>  <work>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAED7 computes the updated eigensystem of a diagonal
;;*  matrix after modification by a rank-one symmetric matrix. This
;;*  routine is used only for the eigenproblem which requires all
;;*  eigenvalues and optionally eigenvectors of a dense or banded
;;*  Hermitian matrix that has been reduced to tridiagonal form.
;;*
;;*    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
;;*
;;*    where Z = Q'u, u is a vector of length N with ones in the
;;*    CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
;;*
;;*     The eigenvectors of the original matrix are stored in Q, and the
;;*     eigenvalues are in D.  The algorithm consists of three stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple eigenvalues or if there is a zero in
;;*        the Z vector.  For each such occurence the dimension of the
;;*        secular equation problem is reduced by one.  This stage is
;;*        performed by the routine SLAED2.
;;*
;;*        The second stage consists of calculating the updated
;;*        eigenvalues. This is done by finding the roots of the secular
;;*        equation via the routine SLAED4 (as called by SLAED3).
;;*        This routine also calculates the eigenvectors of the current
;;*        problem.
;;*
;;*        The final stage consists of computing the updated eigenvectors
;;*        directly using the updated eigenvalues.  The eigenvectors for
;;*        the current problem are multiplied with the eigenvectors from
;;*        the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  CUTPNT (input) INTEGER
;;*         Contains the location of the last eigenvalue in the leading
;;*         sub-matrix.  min(1,N) <= CUTPNT <= N.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the unitary matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N.
;;*
;;*  TLVLS  (input) INTEGER
;;*         The total number of merging levels in the overall divide and
;;*         conquer tree.
;;*
;;*  CURLVL (input) INTEGER
;;*         The current level in the overall merge routine,
;;*         0 <= curlvl <= tlvls.
;;*
;;*  CURPBM (input) INTEGER
;;*         The current problem in the current level in the overall
;;*         merge routine (counting from upper left to lower right).
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, the eigenvalues of the rank-1-perturbed matrix.
;;*         On exit, the eigenvalues of the repaired matrix.
;;*
;;*  Q      (input/output) COMPLEX array, dimension (LDQ,N)
;;*         On entry, the eigenvectors of the rank-1-perturbed matrix.
;;*         On exit, the eigenvectors of the repaired tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  RHO    (input) REAL
;;*         Contains the subdiagonal element used to create the rank-1
;;*         modification.
;;*
;;*  INDXQ  (output) INTEGER array, dimension (N)
;;*         This contains the permutation which will reintegrate the
;;*         subproblem just solved back into sorted order,
;;*         ie. D( INDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  IWORK  (workspace) INTEGER array, dimension (4*N)
;;*
;;*  RWORK  (workspace) REAL array,
;;*                                 dimension (3*N+2*QSIZ*N)
;;*
;;*  WORK   (workspace) COMPLEX array, dimension (QSIZ*N)
;;*
;;*  QSTORE (input/output) REAL array, dimension (N**2+1)
;;*         Stores eigenvectors of submatrices encountered during
;;*         divide and conquer, packed together. QPTR points to
;;*         beginning of the submatrices.
;;*
;;*  QPTR   (input/output) INTEGER array, dimension (N+2)
;;*         List of indices pointing to beginning of submatrices stored
;;*         in QSTORE. The submatrices are numbered starting at the
;;*         bottom left of the divide and conquer tree, from left to
;;*         right and bottom to top.
;;*
;;*  PRMPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in PERM a
;;*         level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
;;*         indicates the size of the permutation and also the size of
;;*         the full, non-deflated problem.
;;*
;;*  PERM   (input) INTEGER array, dimension (N lg N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in GIVCOL a
;;*         level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
;;*         indicates the number of Givens rotations.
;;*
;;*  GIVCOL (input) INTEGER array, dimension (2, N lg N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (input) REAL array, dimension (2, N lg N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de claed7 (n  cutpnt  qsiz  tlvls  curlvl  curpbm  d  q  ldq  rho  indxq  qstore  qptr  prmptr  perm  givptr  givcol  givnum  work  rwork  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) cutpnt )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) tlvls )
	((-idx0- (-int-)) curlvl )
	((-idx0- (-int-)) curpbm )
	((-idx1- (-float-)) d )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) rho )
	((-idx1- (-int-)) indxq )
	((-idx1- (-float-)) qstore )
	((-idx1- (-int-)) qptr )
	((-idx1- (-int-)) prmptr )
	((-idx1- (-int-)) perm )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-float-)) givnum )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ claed7_(IDX_PTR($n,int), IDX_PTR($cutpnt,int), IDX_PTR($qsiz,int), IDX_PTR($tlvls,int), IDX_PTR($curlvl,int), IDX_PTR($curpbm,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($rho,float), IDX_PTR($indxq,int), IDX_PTR($qstore,float), IDX_PTR($qptr,int), IDX_PTR($prmptr,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claed8 <k>  <n>  <qsiz>  <q>  <ldq>  <d>  <rho>  <cutpnt>  <z>  <dlamda>  <q2>  <ldq2>  <w>  <indxp>  <indx>  <indxq>  <perm>  <givptr>  <givcol>  <givnum>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAED8 merges the two sets of eigenvalues together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  eigenvalues are close together or if there is a tiny element in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K      (output) INTEGER
;;*         Contains the number of non-deflated eigenvalues.
;;*         This is the order of the related secular equation.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the unitary matrix used to reduce
;;*         the dense or band matrix to tridiagonal form.
;;*         QSIZ >= N if ICOMPQ = 1.
;;*
;;*  Q      (input/output) COMPLEX array, dimension (LDQ,N)
;;*         On entry, Q contains the eigenvectors of the partially solved
;;*         system which has been previously updated in matrix
;;*         multiplies with other partially solved eigensystems.
;;*         On exit, Q contains the trailing (N-K) updated eigenvectors
;;*         (those which were deflated) in its last N-K columns.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max( 1, N ).
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, D contains the eigenvalues of the two submatrices to
;;*         be combined.  On exit, D contains the trailing (N-K) updated
;;*         eigenvalues (those which were deflated) sorted into increasing
;;*         order.
;;*
;;*  RHO    (input/output) REAL
;;*         Contains the off diagonal element associated with the rank-1
;;*         cut which originally split the two submatrices which are now
;;*         being recombined. RHO is modified during the computation to
;;*         the value required by SLAED3.
;;*
;;*  CUTPNT (input) INTEGER
;;*         Contains the location of the last eigenvalue in the leading
;;*         sub-matrix.  MIN(1,N) <= CUTPNT <= N.
;;*
;;*  Z      (input) REAL array, dimension (N)
;;*         On input this vector contains the updating vector (the last
;;*         row of the first sub-eigenvector matrix and the first row of
;;*         the second sub-eigenvector matrix).  The contents of Z are
;;*         destroyed during the updating process.
;;*
;;*  DLAMDA (output) REAL array, dimension (N)
;;*         Contains a copy of the first K eigenvalues which will be used
;;*         by SLAED3 to form the secular equation.
;;*
;;*  Q2     (output) COMPLEX array, dimension (LDQ2,N)
;;*         If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
;;*         Contains a copy of the first K eigenvectors which will be used
;;*         by SLAED7 in a matrix multiply (SGEMM) to update the new
;;*         eigenvectors.
;;*
;;*  LDQ2   (input) INTEGER
;;*         The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).
;;*
;;*  W      (output) REAL array, dimension (N)
;;*         This will hold the first k values of the final
;;*         deflation-altered z-vector and will be passed to SLAED3.
;;*
;;*  INDXP  (workspace) INTEGER array, dimension (N)
;;*         This will contain the permutation used to place deflated
;;*         values of D at the end of the array. On output INDXP(1:K)
;;*         points to the nondeflated D-values and INDXP(K+1:N)
;;*         points to the deflated eigenvalues.
;;*
;;*  INDX   (workspace) INTEGER array, dimension (N)
;;*         This will contain the permutation used to sort the contents of
;;*         D into ascending order.
;;*
;;*  INDXQ  (input) INTEGER array, dimension (N)
;;*         This contains the permutation which separately sorts the two
;;*         sub-problems in D into ascending order.  Note that elements in
;;*         the second half of this permutation must first have CUTPNT
;;*         added to their values in order to be accurate.
;;*
;;*  PERM   (output) INTEGER array, dimension (N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (output) INTEGER
;;*         Contains the number of Givens rotations which took place in
;;*         this subproblem.
;;*
;;*  GIVCOL (output) INTEGER array, dimension (2, N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (output) REAL array, dimension (2, N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claed8 (k  n  qsiz  q  ldq  d  rho  cutpnt  z  dlamda  q2  ldq2  w  indxp  indx  indxq  perm  givptr  givcol  givnum  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) qsiz )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) d )
	((-idx0- (-float-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) dlamda )
	((-idx3- (-float-)) q2 )
	((-idx0- (-int-)) ldq2 )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) indxp )
	((-idx1- (-int-)) indx )
	((-idx1- (-int-)) indxq )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-float-)) givnum )
	((-idx0- (-int-)) info )
	#{ claed8_(IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($qsiz,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($d,float), IDX_PTR($rho,float), IDX_PTR($cutpnt,int), IDX_PTR($z,float), IDX_PTR($dlamda,float), IDX_PTR($q2,float), IDX_PTR($ldq2,int), IDX_PTR($w,float), IDX_PTR($indxp,int), IDX_PTR($indx,int), IDX_PTR($indxq,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claein <rightv>  <noinit>  <n>  <h>  <ldh>  <w>  <v>  <b>  <ldb>  <rwork>  <eps3>  <smlnum>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAEIN uses inverse iteration to find a right or left eigenvector
;;*  corresponding to the eigenvalue W of a complex upper Hessenberg
;;*  matrix H.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  RIGHTV   (input) LOGICAL
;;*          = .TRUE. : compute right eigenvector;
;;*          = .FALSE.: compute left eigenvector.
;;*
;;*  NOINIT   (input) LOGICAL
;;*          = .TRUE. : no initial vector supplied in V
;;*          = .FALSE.: initial vector supplied in V.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) COMPLEX array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  W       (input) COMPLEX
;;*          The eigenvalue of H whose corresponding right or left
;;*          eigenvector is to be computed.
;;*
;;*  V       (input/output) COMPLEX array, dimension (N)
;;*          On entry, if NOINIT = .FALSE., V must contain a starting
;;*          vector for inverse iteration; otherwise V need not be set.
;;*          On exit, V contains the computed eigenvector, normalized so
;;*          that the component of largest magnitude has magnitude 1; here
;;*          the magnitude of a complex number (x,y) is taken to be
;;*          |x| + |y|.
;;*
;;*  B       (workspace) COMPLEX array, dimension (LDB,N)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  EPS3    (input) REAL
;;*          A small machine-dependent value which is used to perturb
;;*          close eigenvalues, and to replace zero pivots.
;;*
;;*  SMLNUM  (input) REAL
;;*          A machine-dependent value close to the underflow threshold.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          = 1:  inverse iteration did not converge; V is set to the
;;*                last iterate.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claein (rightv  noinit  n  h  ldh  w  v  b  ldb  rwork  eps3  smlnum  info  )
	((-idx0- (-int-)) rightv )
	((-idx0- (-int-)) noinit )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) v )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) rwork )
	((-idx0- (-float-)) eps3 )
	((-idx0- (-float-)) smlnum )
	((-idx0- (-int-)) info )
	#{ claein_(IDX_PTR($rightv,int), IDX_PTR($noinit,int), IDX_PTR($n,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($w,float), IDX_PTR($v,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($rwork,float), IDX_PTR($eps3,float), IDX_PTR($smlnum,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claesy <a>  <b>  <c>  <rt1>  <rt2>  <evscal>  <cs1>  <sn1>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
;;*     ( ( A, B );( B, C ) )
;;*  provided the norm of the matrix of eigenvectors is larger than
;;*  some threshold value.
;;*
;;*  RT1 is the eigenvalue of larger absolute value, and RT2 of
;;*  smaller absolute value.  If the eigenvectors are computed, then
;;*  on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
;;*
;;*  [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
;;*  [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) COMPLEX
;;*          The ( 1, 1 ) element of input matrix.
;;*
;;*  B       (input) COMPLEX
;;*          The ( 1, 2 ) element of input matrix.  The ( 2, 1 ) element
;;*          is also given by B, since the 2-by-2 matrix is symmetric.
;;*
;;*  C       (input) COMPLEX
;;*          The ( 2, 2 ) element of input matrix.
;;*
;;*  RT1     (output) COMPLEX
;;*          The eigenvalue of larger modulus.
;;*
;;*  RT2     (output) COMPLEX
;;*          The eigenvalue of smaller modulus.
;;*
;;*  EVSCAL  (output) COMPLEX
;;*          The complex value by which the eigenvector matrix was scaled
;;*          to make it orthonormal.  If EVSCAL is zero, the eigenvectors
;;*          were not computed.  This means one of two things:  the 2-by-2
;;*          matrix could not be diagonalized, or the norm of the matrix
;;*          of eigenvectors before scaling was larger than the threshold
;;*          value THRESH (set below).
;;*
;;*  CS1     (output) COMPLEX
;;*  SN1     (output) COMPLEX
;;*          If EVSCAL .NE. 0,  ( CS1, SN1 ) is the unit right eigenvector
;;*          for RT1.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claesy (a  b  c  rt1  rt2  evscal  cs1  sn1  )
	((-idx1- (-float-)) a )
	((-idx1- (-float-)) b )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) rt1 )
	((-idx1- (-float-)) rt2 )
	((-idx1- (-float-)) evscal )
	((-idx1- (-float-)) cs1 )
	((-idx1- (-float-)) sn1 )
	#{ claesy_(IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($rt1,float), IDX_PTR($rt2,float), IDX_PTR($evscal,float), IDX_PTR($cs1,float), IDX_PTR($sn1,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claev2 <a>  <b>  <c>  <rt1>  <rt2>  <cs1>  <sn1>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix
;;*     [  A         B  ]
;;*     [  CONJG(B)  C  ].
;;*  On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
;;*  eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
;;*  eigenvector for RT1, giving the decomposition
;;*
;;*  [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
;;*  [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A      (input) COMPLEX
;;*         The (1,1) element of the 2-by-2 matrix.
;;*
;;*  B      (input) COMPLEX
;;*         The (1,2) element and the conjugate of the (2,1) element of
;;*         the 2-by-2 matrix.
;;*
;;*  C      (input) COMPLEX
;;*         The (2,2) element of the 2-by-2 matrix.
;;*
;;*  RT1    (output) REAL
;;*         The eigenvalue of larger absolute value.
;;*
;;*  RT2    (output) REAL
;;*         The eigenvalue of smaller absolute value.
;;*
;;*  CS1    (output) REAL
;;*  SN1    (output) COMPLEX
;;*         The vector (CS1, SN1) is a unit right eigenvector for RT1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  RT1 is accurate to a few ulps barring over/underflow.
;;*
;;*  RT2 may be inaccurate if there is massive cancellation in the
;;*  determinant A*C-B*B; higher precision or correctly rounded or
;;*  correctly truncated arithmetic would be needed to compute RT2
;;*  accurately in all cases.
;;*
;;*  CS1 and SN1 are accurate to a few ulps barring over/underflow.
;;*
;;*  Overflow is possible only if RT1 is within a factor of 5 of overflow.
;;*  Underflow is harmless if the input data is 0 or exceeds
;;*     underflow_threshold / macheps.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claev2 (a  b  c  rt1  rt2  cs1  sn1  )
	((-idx1- (-float-)) a )
	((-idx1- (-float-)) b )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rt1 )
	((-idx0- (-float-)) rt2 )
	((-idx0- (-float-)) cs1 )
	((-idx1- (-float-)) sn1 )
	#{ claev2_(IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($rt1,float), IDX_PTR($rt2,float), IDX_PTR($cs1,float), IDX_PTR($sn1,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clags2 <upper>  <a1>  <a2>  <a3>  <b1>  <b2>  <b3>  <csu>  <snu>  <csv>  <snv>  <csq>  <snq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAGS2 computes 2-by-2 unitary matrices U, V and Q, such
;;*  that if ( UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 A2 )*Q = ( x  0  )
;;*                        ( 0  A3 )     ( x  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 B2 )*Q = ( x  0  )
;;*                        ( 0  B3 )     ( x  x  )
;;*
;;*  or if ( .NOT.UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 0  )*Q = ( x  x  )
;;*                        ( A2 A3 )     ( 0  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 0  )*Q = ( x  x  )
;;*                        ( B2 B3 )     ( 0  x  )
;;*  where
;;*
;;*    U = (     CSU      SNU ), V = (     CSV     SNV ),
;;*        ( -CONJG(SNU)  CSU )      ( -CONJG(SNV) CSV )
;;*
;;*    Q = (     CSQ      SNQ )
;;*        ( -CONJG(SNQ)  CSQ )
;;*
;;*  Z' denotes the conjugate transpose of Z.
;;*
;;*  The rows of the transformed A and B are parallel. Moreover, if the
;;*  input 2-by-2 matrix A is not zero, then the transformed (1,1) entry
;;*  of A is not zero. If the input matrices A and B are both not zero,
;;*  then the transformed (2,2) element of B is not zero, except when the
;;*  first rows of input A and B are parallel and the second rows are
;;*  zero.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPPER   (input) LOGICAL
;;*          = .TRUE.: the input matrices A and B are upper triangular.
;;*          = .FALSE.: the input matrices A and B are lower triangular.
;;*
;;*  A1      (input) REAL
;;*  A2      (input) COMPLEX
;;*  A3      (input) REAL
;;*          On entry, A1, A2 and A3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix A.
;;*
;;*  B1      (input) REAL
;;*  B2      (input) COMPLEX
;;*  B3      (input) REAL
;;*          On entry, B1, B2 and B3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix B.
;;*
;;*  CSU     (output) REAL
;;*  SNU     (output) COMPLEX
;;*          The desired unitary matrix U.
;;*
;;*  CSV     (output) REAL
;;*  SNV     (output) COMPLEX
;;*          The desired unitary matrix V.
;;*
;;*  CSQ     (output) REAL
;;*  SNQ     (output) COMPLEX
;;*          The desired unitary matrix Q.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clags2 (upper  a1  a2  a3  b1  b2  b3  csu  snu  csv  snv  csq  snq  )
	((-idx0- (-int-)) upper )
	((-idx0- (-float-)) a1 )
	((-idx1- (-float-)) a2 )
	((-idx0- (-float-)) a3 )
	((-idx0- (-float-)) b1 )
	((-idx1- (-float-)) b2 )
	((-idx0- (-float-)) b3 )
	((-idx0- (-float-)) csu )
	((-idx1- (-float-)) snu )
	((-idx0- (-float-)) csv )
	((-idx1- (-float-)) snv )
	((-idx0- (-float-)) csq )
	((-idx1- (-float-)) snq )
	#{ clags2_(IDX_PTR($upper,int), IDX_PTR($a1,float), IDX_PTR($a2,float), IDX_PTR($a3,float), IDX_PTR($b1,float), IDX_PTR($b2,float), IDX_PTR($b3,float), IDX_PTR($csu,float), IDX_PTR($snu,float), IDX_PTR($csv,float), IDX_PTR($snv,float), IDX_PTR($csq,float), IDX_PTR($snq,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clagtm <trans>  <n>  <nrhs>  <alpha>  <dl>  <d>  <du>  <x>  <ldx>  <beta>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAGTM performs a matrix-vector product of the form
;;*
;;*     B := alpha * A * X + beta * B
;;*
;;*  where A is a tridiagonal matrix of order N, B and X are N by NRHS
;;*  matrices, and alpha and beta are real scalars, each of which may be
;;*  0., 1., or -1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the operation applied to A.
;;*          = 'N':  No transpose, B := alpha * A * X + beta * B
;;*          = 'T':  Transpose,    B := alpha * A**T * X + beta * B
;;*          = 'C':  Conjugate transpose, B := alpha * A**H * X + beta * B
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices X and B.
;;*
;;*  ALPHA   (input) REAL
;;*          The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 0.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of T.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The diagonal elements of T.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of T.
;;*
;;*  X       (input) COMPLEX array, dimension (LDX,NRHS)
;;*          The N by NRHS matrix X.
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(N,1).
;;*
;;*  BETA    (input) REAL
;;*          The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 1.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N by NRHS matrix B.
;;*          On exit, B is overwritten by the matrix expression
;;*          B := alpha * A * X + beta * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(N,1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clagtm (trans  n  nrhs  alpha  dl  d  du  x  ldx  beta  b  ldb  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx0- (-float-)) alpha )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) beta )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ clagtm_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($alpha,float), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($beta,float), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clahef <uplo>  <n>  <nb>  <kb>  <a>  <lda>  <ipiv>  <w>  <ldw>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAHEF computes a partial factorization of a complex Hermitian
;;*  matrix A using the Bunch-Kaufman diagonal pivoting method. The
;;*  partial factorization has the form:
;;*
;;*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or:
;;*        ( 0  U22 ) (  0   D  ) ( U12' U22' )
;;*
;;*  A  =  ( L11  0 ) (  D   0  ) ( L11' L21' )  if UPLO = 'L'
;;*        ( L21  I ) (  0  A22 ) (  0    I   )
;;*
;;*  where the order of D is at most NB. The actual order is returned in
;;*  the argument KB, and is either NB or NB-1, or N if N <= NB.
;;*  Note that U' denotes the conjugate transpose of U.
;;*
;;*  CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code
;;*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
;;*  A22 (if UPLO = 'L').
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NB      (input) INTEGER
;;*          The maximum number of columns of the matrix A that should be
;;*          factored.  NB should be at least 2 to allow for 2-by-2 pivot
;;*          blocks.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns of A that were actually factored.
;;*          KB is either NB-1 or NB, or N if N <= NB.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, A contains details of the partial factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If UPLO = 'U', only the last KB elements of IPIV are set;
;;*          if UPLO = 'L', only the first KB elements are set.
;;*
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  W       (workspace) COMPLEX array, dimension (LDW,NB)
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W.  LDW >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clahef (uplo  n  nb  kb  a  lda  ipiv  w  ldw  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) w )
	((-idx0- (-int-)) ldw )
	((-idx0- (-int-)) info )
	#{ clahef_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($w,float), IDX_PTR($ldw,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clahqr <wantt>  <wantz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <w>  <iloz>  <ihiz>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAHQR is an auxiliary routine called by CHSEQR to update the
;;*  eigenvalues and Schur decomposition already computed by CHSEQR, by
;;*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTT   (input) LOGICAL
;;*          = .TRUE. : the full Schur form T is required;
;;*          = .FALSE.: only eigenvalues are required.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          = .TRUE. : the matrix of Schur vectors Z is required;
;;*          = .FALSE.: Schur vectors are not required.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper triangular in rows and
;;*          columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
;;*          CLAHQR works primarily with the Hessenberg submatrix in rows
;;*          and columns ILO to IHI, but applies transformations to all of
;;*          H if WANTT is .TRUE..
;;*          1 <= ILO <= max(1,IHI); IHI <= N.
;;*
;;*  H       (input/output) COMPLEX array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if WANTT is .TRUE., H is upper triangular in rows
;;*          and columns ILO:IHI, with any 2-by-2 diagonal blocks in
;;*          standard form. If WANTT is .FALSE., the contents of H are
;;*          unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          The computed eigenvalues ILO to IHI are stored in the
;;*          corresponding elements of W. If WANTT is .TRUE., the
;;*          eigenvalues are stored in the same order as on the diagonal
;;*          of the Schur form returned in H, with W(i) = H(i,i).
;;*
;;*  ILOZ    (input) INTEGER
;;*  IHIZ    (input) INTEGER
;;*          Specify the rows of Z to which transformations must be
;;*          applied if WANTZ is .TRUE..
;;*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          If WANTZ is .TRUE., on entry Z must contain the current
;;*          matrix Z of transformations accumulated by CHSEQR, and on
;;*          exit Z has been updated; transformations are applied only to
;;*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
;;*          If WANTZ is .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = i, CLAHQR failed to compute all the
;;*               eigenvalues ILO to IHI in a total of 30*(IHI-ILO+1)
;;*               iterations; elements i+1:ihi of W contain those
;;*               eigenvalues which have been successfully computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clahqr (wantt  wantz  n  ilo  ihi  h  ldh  w  iloz  ihiz  z  ldz  info  )
	((-idx0- (-int-)) wantt )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx2- (-float-)) w )
	((-idx0- (-int-)) iloz )
	((-idx0- (-int-)) ihiz )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ clahqr_(IDX_PTR($wantt,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($w,float), IDX_PTR($iloz,int), IDX_PTR($ihiz,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clahrd <n>  <k>  <nb>  <a>  <lda>  <tau>  <t_>  <ldt>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAHRD reduces the first NB columns of a complex general n-by-(n-k+1)
;;*  matrix A so that elements below the k-th subdiagonal are zero. The
;;*  reduction is performed by a unitary similarity transformation
;;*  Q' * A * Q. The routine returns the matrices V and T which determine
;;*  Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
;;*
;;*  This is an auxiliary routine called by CGEHRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  K       (input) INTEGER
;;*          The offset for the reduction. Elements below the k-th
;;*          subdiagonal in the first NB columns are reduced to zero.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to be reduced.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N-K+1)
;;*          On entry, the n-by-(n-k+1) general matrix A.
;;*          On exit, the elements on and above the k-th subdiagonal in
;;*          the first NB columns are overwritten with the corresponding
;;*          elements of the reduced matrix; the elements below the k-th
;;*          subdiagonal, with the array TAU, represent the matrix Q as a
;;*          product of elementary reflectors. The other columns of A are
;;*          unchanged. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) COMPLEX array, dimension (NB)
;;*          The scalar factors of the elementary reflectors. See Further
;;*          Details.
;;*
;;*  T       (output) COMPLEX array, dimension (LDT,NB)
;;*          The upper triangular matrix T.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T.  LDT >= NB.
;;*
;;*  Y       (output) COMPLEX array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y.
;;*
;;*  LDY     (input) INTEGER
;;*          The leading dimension of the array Y. LDY >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of nb elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
;;*  A(i+k+1:n,i), and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the (n-k+1)-by-nb matrix
;;*  V which is needed, with T and Y, to apply the transformation to the
;;*  unreduced part of the matrix, using an update of the form:
;;*  A := (I - V*T*V') * (A - Y*V').
;;*
;;*  The contents of A on exit are illustrated by the following example
;;*  with n = 7, k = 3 and nb = 2:
;;*
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( h   h   a   a   a )
;;*     ( v1  h   a   a   a )
;;*     ( v1  v2  a   a   a )
;;*     ( v1  v2  a   a   a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clahrd (n  k  nb  a  lda  tau  t_  ldt  y  ldy  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) nb )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) y )
	((-idx0- (-int-)) ldy )
	#{ clahrd_(IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($nb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($y,float), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claic1 <job>  <j>  <x>  <sest>  <w>  <gamma>  <sestpr>  <s>  <c>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAIC1 applies one step of incremental condition estimation in
;;*  its simplest version:
;;*
;;*  Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
;;*  lower triangular matrix L, such that
;;*           twonorm(L*x) = sest
;;*  Then CLAIC1 computes sestpr, s, c such that
;;*  the vector
;;*                  [ s*x ]
;;*           xhat = [  c  ]
;;*  is an approximate singular vector of
;;*                  [ L     0  ]
;;*           Lhat = [ w' gamma ]
;;*  in the sense that
;;*           twonorm(Lhat*xhat) = sestpr.
;;*
;;*  Depending on JOB, an estimate for the largest or smallest singular
;;*  value is computed.
;;*
;;*  Note that [s c]' and sestpr**2 is an eigenpair of the system
;;*
;;*      diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
;;*                                            [ conjg(gamma) ]
;;*
;;*  where  alpha =  conjg(x)'*w.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) INTEGER
;;*          = 1: an estimate for the largest singular value is computed.
;;*          = 2: an estimate for the smallest singular value is computed.
;;*
;;*  J       (input) INTEGER
;;*          Length of X and W
;;*
;;*  X       (input) COMPLEX array, dimension (J)
;;*          The j-vector x.
;;*
;;*  SEST    (input) REAL
;;*          Estimated singular value of j by j matrix L
;;*
;;*  W       (input) COMPLEX array, dimension (J)
;;*          The j-vector w.
;;*
;;*  GAMMA   (input) COMPLEX
;;*          The diagonal element gamma.
;;*
;;*  SESTPR  (output) REAL
;;*          Estimated singular value of (j+1) by (j+1) matrix Lhat.
;;*
;;*  S       (output) COMPLEX
;;*          Sine needed in forming xhat.
;;*
;;*  C       (output) COMPLEX
;;*          Cosine needed in forming xhat.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claic1 (job  j  x  sest  w  gamma  sestpr  s  c  )
	((-idx0- (-int-)) job )
	((-idx0- (-int-)) j )
	((-idx2- (-float-)) x )
	((-idx0- (-float-)) sest )
	((-idx2- (-float-)) w )
	((-idx1- (-float-)) gamma )
	((-idx0- (-float-)) sestpr )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) c )
	#{ claic1_(IDX_PTR($job,int), IDX_PTR($j,int), IDX_PTR($x,float), IDX_PTR($sest,float), IDX_PTR($w,float), IDX_PTR($gamma,float), IDX_PTR($sestpr,float), IDX_PTR($s,float), IDX_PTR($c,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clals0 <icompq>  <nl>  <nr>  <sqre>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <poles>  <difl>  <difr>  <z>  <k>  <c>  <s>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLALS0 applies back the multiplying factors of either the left or the
;;*  right singular vector matrix of a diagonal matrix appended by a row
;;*  to the right hand side matrix B in solving the least squares problem
;;*  using the divide-and-conquer SVD approach.
;;*
;;*  For the left singular vector matrix, three types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1L) Givens rotations: the number of such rotations is GIVPTR; the
;;*       pairs of columns/rows they were applied to are stored in GIVCOL;
;;*       and the C- and S-values of these rotations are stored in GIVNUM.
;;*
;;*  (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
;;*       row, and for J=2:N, PERM(J)-th row of B is to be moved to the
;;*       J-th row.
;;*
;;*  (3L) The left singular vector matrix of the remaining matrix.
;;*
;;*  For the right singular vector matrix, four types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1R) The right singular vector matrix of the remaining matrix.
;;*
;;*  (2R) If SQRE = 1, one extra Givens rotation to generate the right
;;*       null space.
;;*
;;*  (3R) The inverse transformation of (2L).
;;*
;;*  (4R) The inverse transformation of (1L).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed in
;;*         factored form:
;;*         = 0: Left singular vector matrix.
;;*         = 1: Right singular vector matrix.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block. NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block. NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input/output) COMPLEX array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B. LDB must be at least
;;*         max(1,MAX( M, N ) ).
;;*
;;*  BX     (workspace) COMPLEX array, dimension ( LDBX, NRHS )
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  PERM   (input) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) applied
;;*         to the two blocks.
;;*
;;*  GIVPTR (input) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of rows/columns
;;*         involved in a Givens rotation.
;;*
;;*  LDGCOL (input) INTEGER
;;*         The leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (input) REAL array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value used in the
;;*         corresponding Givens rotation.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of arrays DIFR, POLES and
;;*         GIVNUM, must be at least K.
;;*
;;*  POLES  (input) REAL array, dimension ( LDGNUM, 2 )
;;*         On entry, POLES(1:K, 1) contains the new singular
;;*         values obtained from solving the secular equation, and
;;*         POLES(1:K, 2) is an array containing the poles in the secular
;;*         equation.
;;*
;;*  DIFL   (input) REAL array, dimension ( K ).
;;*         On entry, DIFL(I) is the distance between I-th updated
;;*         (undeflated) singular value and the I-th (undeflated) old
;;*         singular value.
;;*
;;*  DIFR   (input) REAL array, dimension ( LDGNUM, 2 ).
;;*         On entry, DIFR(I, 1) contains the distances between I-th
;;*         updated (undeflated) singular value and the I+1-th
;;*         (undeflated) old singular value. And DIFR(I, 2) is the
;;*         normalizing factor for the I-th right singular vector.
;;*
;;*  Z      (input) REAL array, dimension ( K )
;;*         Contain the components of the deflation-adjusted updating row
;;*         vector.
;;*
;;*  K      (input) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  C      (input) REAL
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (input) REAL
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  RWORK  (workspace) REAL array, dimension
;;*         ( K*(1+NRHS) + 2*NRHS )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clals0 (icompq  nl  nr  sqre  nrhs  b  ldb  bx  ldbx  perm  givptr  givcol  ldgcol  givnum  ldgnum  poles  difl  difr  z  k  c  s  rwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-float-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx2- (-float-)) poles )
	((-idx1- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) k )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) s )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ clals0_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($nrhs,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($bx,float), IDX_PTR($ldbx,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,float), IDX_PTR($ldgnum,int), IDX_PTR($poles,float), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($z,float), IDX_PTR($k,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clalsa <icompq>  <smlsiz>  <n>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <u>  <ldu>  <vt>  <k>  <difl>  <difr>  <z>  <poles>  <givptr>  <givcol>  <ldgcol>  <perm>  <givnum>  <c>  <s>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLALSA is an itermediate step in solving the least squares problem
;;*  by computing the SVD of the coefficient matrix in compact form (The
;;*  singular vectors are computed as products of simple orthorgonal
;;*  matrices.).
;;*
;;*  If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
;;*  matrix of an upper bidiagonal matrix to the right hand side; and if
;;*  ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
;;*  right hand side. The singular vector matrices were generated in
;;*  compact form by CLALSA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether the left or the right singular vector
;;*         matrix is involved.
;;*         = 0: Left singular vector matrix
;;*         = 1: Right singular vector matrix
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The row and column dimensions of the upper bidiagonal matrix.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input) COMPLEX array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,MAX( M, N ) ).
;;*
;;*  BX     (output) COMPLEX array, dimension ( LDBX, NRHS )
;;*         On exit, the result of applying the left or right singular
;;*         vector matrix to B.
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  U      (input) REAL array, dimension ( LDU, SMLSIZ ).
;;*         On entry, U contains the left singular vector matrices of all
;;*         subproblems at the bottom level.
;;*
;;*  LDU    (input) INTEGER, LDU = > N.
;;*         The leading dimension of arrays U, VT, DIFL, DIFR,
;;*         POLES, GIVNUM, and Z.
;;*
;;*  VT     (input) REAL array, dimension ( LDU, SMLSIZ+1 ).
;;*         On entry, VT' contains the right singular vector matrices of
;;*         all subproblems at the bottom level.
;;*
;;*  K      (input) INTEGER array, dimension ( N ).
;;*
;;*  DIFL   (input) REAL array, dimension ( LDU, NLVL ).
;;*         where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.
;;*
;;*  DIFR   (input) REAL array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
;;*         distances between singular values on the I-th level and
;;*         singular values on the (I -1)-th level, and DIFR(*, 2 * I)
;;*         record the normalizing factors of the right singular vectors
;;*         matrices of subproblems on I-th level.
;;*
;;*  Z      (input) REAL array, dimension ( LDU, NLVL ).
;;*         On entry, Z(1, I) contains the components of the deflation-
;;*         adjusted updating row vector for subproblems on the I-th
;;*         level.
;;*
;;*  POLES  (input) REAL array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
;;*         singular values involved in the secular equations on the I-th
;;*         level.
;;*
;;*  GIVPTR (input) INTEGER array, dimension ( N ).
;;*         On entry, GIVPTR( I ) records the number of Givens
;;*         rotations performed on the I-th problem on the computation
;;*         tree.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
;;*         On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
;;*         locations of Givens rotations performed on the I-th level on
;;*         the computation tree.
;;*
;;*  LDGCOL (input) INTEGER, LDGCOL = > N.
;;*         The leading dimension of arrays GIVCOL and PERM.
;;*
;;*  PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
;;*         On entry, PERM(*, I) records permutations done on the I-th
;;*         level of the computation tree.
;;*
;;*  GIVNUM (input) REAL array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
;;*         values of Givens rotations performed on the I-th level on the
;;*         computation tree.
;;*
;;*  C      (input) REAL array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         C( I ) contains the C-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  S      (input) REAL array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         S( I ) contains the S-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  RWORK  (workspace) REAL array, dimension at least
;;*         max ( N, (SMLSZ+1)*NRHS*3 ).
;;*
;;*  IWORK  (workspace) INTEGER array.
;;*         The dimension must be at least 3 * N
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clalsa (icompq  smlsiz  n  nrhs  b  ldb  bx  ldbx  u  ldu  vt  k  difl  difr  z  poles  givptr  givcol  ldgcol  perm  givnum  c  s  rwork  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx1- (-int-)) k )
	((-idx2- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx2- (-float-)) z )
	((-idx2- (-float-)) poles )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-int-)) perm )
	((-idx2- (-float-)) givnum )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ clalsa_(IDX_PTR($icompq,int), IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($bx,float), IDX_PTR($ldbx,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($k,int), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($z,float), IDX_PTR($poles,float), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($perm,int), IDX_PTR($givnum,float), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clalsd <uplo>  <smlsiz>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <rcond>  <rank>  <work>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLALSD uses the singular value decomposition of A to solve the least
;;*  squares problem of finding X to minimize the Euclidean norm of each
;;*  column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
;;*  are N-by-NRHS. The solution X overwrites B.
;;*
;;*  The singular values of A smaller than RCOND times the largest
;;*  singular value are treated as zero in solving the least squares
;;*  problem; in this case a minimum norm solution is returned.
;;*  The actual singular values are returned in D in ascending order.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO   (input) CHARACTER*1
;;*         = 'U': D and E define an upper bidiagonal matrix.
;;*         = 'L': D and E define a  lower bidiagonal matrix.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the  bidiagonal matrix.  N >= 0.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B. NRHS must be at least 1.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix. On exit, if INFO = 0, D contains its singular values.
;;*
;;*  E      (input) REAL array, dimension (N-1)
;;*         Contains the super-diagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  B      (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*         On input, B contains the right hand sides of the least
;;*         squares problem. On output, B contains the solution X.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,N).
;;*
;;*  RCOND  (input) REAL
;;*         The singular values of A less than or equal to RCOND times
;;*         the largest singular value are treated as zero in solving
;;*         the least squares problem. If RCOND is negative,
;;*         machine precision is used instead.
;;*         For example, if diag(S)*X=B were the least squares problem,
;;*         where diag(S) is a diagonal matrix of singular values, the
;;*         solution would be X(i) = B(i) / S(i) if S(i) is greater than
;;*         RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
;;*         RCOND*max(S).
;;*
;;*  RANK   (output) INTEGER
;;*         The number of singular values of A greater than RCOND times
;;*         the largest singular value.
;;*
;;*  WORK   (workspace) COMPLEX array, dimension at least
;;*         (N * NRHS).
;;*
;;*  RWORK  (workspace) REAL array, dimension at least
;;*         (9*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS + (SMLSIZ+1)**2),
;;*         where
;;*         NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
;;*
;;*  IWORK  (workspace) INTEGER array, dimension at least
;;*         (3*N*NLVL + 11*N).
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*         > 0:  The algorithm failed to compute an singular value while
;;*               working on the submatrix lying in rows and columns
;;*               INFO/(N+1) through MOD(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clalsd (uplo  smlsiz  n  nrhs  d  e  b  ldb  rcond  rank  work  rwork  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ clalsd_($uplo->data, IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clangb <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANGB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANGB returns the value
;;*
;;*     CLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANGB as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANGB is
;;*          set to zero.
;;*
;;*  KL      (input) INTEGER
;;*          The number of sub-diagonals of the matrix A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of super-diagonals of the matrix A.  KU >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clangb (norm  n  kl  ku  ab  ldab  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clangb_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clange <norm>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANGE  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANGE returns the value
;;*
;;*     CLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANGE as described
;;*          above.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.  When M = 0,
;;*          CLANGE is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.  When N = 0,
;;*          CLANGE is set to zero.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The m by n matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clange (norm  m  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clange_($norm->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clangt <norm>  <n>  <dl>  <d>  <du>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANGT  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANGT returns the value
;;*
;;*     CLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANGT as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANGT is
;;*          set to zero.
;;*
;;*  DL      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of A.
;;*
;;*  D       (input) COMPLEX array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clangt (norm  n  dl  d  du  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) dl )
	((-idx2- (-float-)) d )
	((-idx2- (-float-)) du )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clangt_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clanhb <norm>  <uplo>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANHB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n hermitian band matrix A,  with k super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANHB returns the value
;;*
;;*     CLANHB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANHB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          band matrix A is supplied.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANHB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals or sub-diagonals of the
;;*          band matrix A.  K >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangle of the hermitian band matrix A,
;;*          stored in the first K+1 rows of AB.  The j-th column of A is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*          Note that the imaginary parts of the diagonal elements need
;;*          not be set and are assumed to be zero.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clanhb (norm  uplo  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clanhb_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clanhe <norm>  <uplo>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANHE  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex hermitian matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANHE returns the value
;;*
;;*     CLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANHE as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          hermitian matrix A is to be referenced.
;;*          = 'U':  Upper triangular part of A is referenced
;;*          = 'L':  Lower triangular part of A is referenced
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANHE is
;;*          set to zero.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The hermitian matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced. Note that the imaginary parts of the diagonal
;;*          elements need not be set and are assumed to be zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clanhe (norm  uplo  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clanhe_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clanhp <norm>  <uplo>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANHP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex hermitian matrix A,  supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANHP returns the value
;;*
;;*     CLANHP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANHP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          hermitian matrix A is supplied.
;;*          = 'U':  Upper triangular part of A is supplied
;;*          = 'L':  Lower triangular part of A is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANHP is
;;*          set to zero.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          Note that the  imaginary parts of the diagonal elements need
;;*          not be set and are assumed to be zero.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clanhp (norm  uplo  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clanhp_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clanhs <norm>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANHS  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  Hessenberg matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANHS returns the value
;;*
;;*     CLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANHS as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANHS is
;;*          set to zero.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The n by n upper Hessenberg matrix A; the part of A below the
;;*          first sub-diagonal is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clanhs (norm  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clanhs_($norm->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clanht <norm>  <n>  <d>  <e>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANHT  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex Hermitian tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANHT returns the value
;;*
;;*     CLANHT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANHT as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANHT is
;;*          set to zero.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  E       (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) sub-diagonal or super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clanht (norm  n  d  e  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clanht_($norm->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clansb <norm>  <uplo>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANSB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n symmetric band matrix A,  with k super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANSB returns the value
;;*
;;*     CLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANSB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          band matrix A is supplied.
;;*          = 'U':  Upper triangular part is supplied
;;*          = 'L':  Lower triangular part is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANSB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals or sub-diagonals of the
;;*          band matrix A.  K >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first K+1 rows of AB.  The j-th column of A is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clansb (norm  uplo  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clansb_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clansp <norm>  <uplo>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANSP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex symmetric matrix A,  supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANSP returns the value
;;*
;;*     CLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANSP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is supplied.
;;*          = 'U':  Upper triangular part of A is supplied
;;*          = 'L':  Lower triangular part of A is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANSP is
;;*          set to zero.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clansp (norm  uplo  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clansp_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clansy <norm>  <uplo>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANSY  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex symmetric matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANSY returns the value
;;*
;;*     CLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANSY as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is to be referenced.
;;*          = 'U':  Upper triangular part of A is referenced
;;*          = 'L':  Lower triangular part of A is referenced
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANSY is
;;*          set to zero.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clansy (norm  uplo  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clansy_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clantb <norm>  <uplo>  <diag>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANTB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n triangular band matrix A,  with ( k + 1 ) diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANTB returns the value
;;*
;;*     CLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANTB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANTB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals of the matrix A if UPLO = 'L'.
;;*          K >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first k+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*          Note that when DIAG = 'U', the elements of the array AB
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clantb (norm  uplo  diag  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clantb_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clantp <norm>  <uplo>  <diag>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANTP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  triangular matrix A, supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANTP returns the value
;;*
;;*     CLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANTP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, CLANTP is
;;*          set to zero.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          Note that when DIAG = 'U', the elements of the array AP
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clantp (norm  uplo  diag  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clantp_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clantr <norm>  <uplo>  <diag>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLANTR  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  trapezoidal or triangular matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  CLANTR returns the value
;;*
;;*     CLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in CLANTR as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower trapezoidal.
;;*          = 'U':  Upper trapezoidal
;;*          = 'L':  Lower trapezoidal
;;*          Note that A is triangular instead of trapezoidal if M = N.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A has unit diagonal.
;;*          = 'N':  Non-unit diagonal
;;*          = 'U':  Unit diagonal
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0, and if
;;*          UPLO = 'U', M <= N.  When M = 0, CLANTR is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0, and if
;;*          UPLO = 'L', N <= M.  When N = 0, CLANTR is set to zero.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The trapezoidal matrix A (A is triangular if M = N).
;;*          If UPLO = 'U', the leading m by n upper trapezoidal part of
;;*          the array A contains the upper trapezoidal matrix, and the
;;*          strictly lower triangular part of A is not referenced.
;;*          If UPLO = 'L', the leading m by n lower trapezoidal part of
;;*          the array A contains the lower trapezoidal matrix, and the
;;*          strictly upper triangular part of A is not referenced.  Note
;;*          that when DIAG = 'U', the diagonal elements of A are not
;;*          referenced and are assumed to be one.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clantr (norm  uplo  diag  m  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=clantr_($norm->data, $uplo->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clapll <n>  <x>  <incx>  <y>  <incy>  <ssmin>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given two column vectors X and Y, let
;;*
;;*                       A = ( X Y ).
;;*
;;*  The subroutine first computes the QR factorization of A = Q*R,
;;*  and then computes the SVD of the 2-by-2 upper triangular matrix R.
;;*  The smaller singular value of R is returned in SSMIN, which is used
;;*  as the measurement of the linear dependency of the vectors X and Y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The length of the vectors X and Y.
;;*
;;*  X       (input/output) COMPLEX array, dimension (1+(N-1)*INCX)
;;*          On entry, X contains the N-vector X.
;;*          On exit, X is overwritten.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive elements of X. INCX > 0.
;;*
;;*  Y       (input/output) COMPLEX array, dimension (1+(N-1)*INCY)
;;*          On entry, Y contains the N-vector Y.
;;*          On exit, Y is overwritten.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive elements of Y. INCY > 0.
;;*
;;*  SSMIN   (output) REAL
;;*          The smallest singular value of the N-by-2 matrix A = ( X Y ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clapll (n  x  incx  y  incy  ssmin  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx0- (-float-)) ssmin )
	#{ clapll_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($ssmin,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clapmt <forwrd>  <m>  <n>  <x>  <ldx>  <k>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAPMT rearranges the columns of the M by N matrix X as specified
;;*  by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
;;*  If FORWRD = .TRUE.,  forward permutation:
;;*
;;*       X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
;;*
;;*  If FORWRD = .FALSE., backward permutation:
;;*
;;*       X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FORWRD  (input) LOGICAL
;;*          = .TRUE., forward permutation
;;*          = .FALSE., backward permutation
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix X. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix X. N >= 0.
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,N)
;;*          On entry, the M by N matrix X.
;;*          On exit, X contains the permuted matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X, LDX >= MAX(1,M).
;;*
;;*  K       (input) INTEGER array, dimension (N)
;;*          On entry, K contains the permutation vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clapmt (forwrd  m  n  x  ldx  k  )
	((-idx0- (-int-)) forwrd )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-int-)) k )
	#{ clapmt_(IDX_PTR($forwrd,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($k,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqgb <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQGB equilibrates a general M by N band matrix A with KL
;;*  subdiagonals and KU superdiagonals using the row and scaling factors
;;*  in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, the equilibrated matrix, in the same storage format
;;*          as A.  See EQUED for the form of the equilibrated matrix.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDA >= KL+KU+1.
;;*
;;*  R       (output) REAL array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (output) REAL array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (output) REAL
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (output) REAL
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqgb (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqgb_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqge <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQGE equilibrates a general M by N matrix A using the row and
;;*  scaling factors in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M by N matrix A.
;;*          On exit, the equilibrated matrix.  See EQUED for the form of
;;*          the equilibrated matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  R       (input) REAL array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (input) REAL array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (input) REAL
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (input) REAL
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqge (m  n  a  lda  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqge_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqhb <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQHB equilibrates a symmetric band matrix A using the scaling
;;*  factors in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqhb (uplo  n  kd  ab  ldab  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqhb_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqhe <uplo>  <n>  <a>  <lda>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQHE equilibrates a Hermitian matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if EQUED = 'Y', the equilibrated matrix:
;;*          diag(S) * A * diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  S       (input) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqhe (uplo  n  a  lda  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqhe_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqhp <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQHP equilibrates a Hermitian matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
;;*          the same storage format as A.
;;*
;;*  S       (input) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqhp (uplo  n  ap  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqhp_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqp2 <m>  <n>  <offset>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQP2 computes a QR factorization with column pivoting of
;;*  the block A(OFFSET+1:M,1:N).
;;*  The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of the matrix A that must be pivoted
;;*          but no factorized. OFFSET >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of block A(OFFSET+1:M,1:N) is 
;;*          the triangular factor obtained; the elements in block 
;;*          A(OFFSET+1:M,1:N) below the diagonal, together with the 
;;*          array TAU, represent the orthogonal matrix Q as a product of
;;*          elementary reflectors. Block A(1:OFFSET,1:N) has been 
;;*          accordingly pivoted, but no factorized.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) COMPLEX array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) REAL array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) REAL array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqp2 (m  n  offset  a  lda  jpvt  tau  vn1  vn2  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-float-)) tau )
	((-idx1- (-float-)) vn1 )
	((-idx1- (-float-)) vn2 )
	((-idx2- (-float-)) work )
	#{ claqp2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($vn1,float), IDX_PTR($vn2,float), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqps <m>  <n>  <offset>  <nb>  <kb>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <auxv>  <f>  <ldf>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQPS computes a step of QR factorization with column pivoting
;;*  of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
;;*  NB columns from A starting from the row OFFSET+1, and updates all
;;*  of the matrix with Blas-3 xGEMM.
;;*
;;*  In some cases, due to catastrophic cancellations, it cannot
;;*  factorize NB columns.  Hence, the actual number of factorized
;;*  columns is returned in KB.
;;*
;;*  Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of A that have been factorized in
;;*          previous steps.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to factorize.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns actually factorized.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, block A(OFFSET+1:M,1:KB) is the triangular
;;*          factor obtained and block A(1:OFFSET,1:N) has been
;;*          accordingly pivoted, but no factorized.
;;*          The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
;;*          been updated.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          JPVT(I) = K <==> Column K of the full matrix A has been
;;*          permuted into position I in AP.
;;*
;;*  TAU     (output) COMPLEX array, dimension (KB)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) REAL array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) REAL array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  AUXV    (input/output) COMPLEX array, dimension (NB)
;;*          Auxiliar vector.
;;*
;;*  F       (input/output) COMPLEX array, dimension (LDF,NB)
;;*          Matrix F' = L*Y'*A.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqps (m  n  offset  nb  kb  a  lda  jpvt  tau  vn1  vn2  auxv  f  ldf  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-float-)) tau )
	((-idx1- (-float-)) vn1 )
	((-idx1- (-float-)) vn2 )
	((-idx2- (-float-)) auxv )
	((-idx3- (-float-)) f )
	((-idx0- (-int-)) ldf )
	#{ claqps_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($vn1,float), IDX_PTR($vn2,float), IDX_PTR($auxv,float), IDX_PTR($f,float), IDX_PTR($ldf,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqsb <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQSB equilibrates a symmetric band matrix A using the scaling
;;*  factors in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqsb (uplo  n  kd  ab  ldab  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqsb_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqsp <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQSP equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
;;*          the same storage format as A.
;;*
;;*  S       (input) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqsp (uplo  n  ap  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqsp_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claqsy <uplo>  <n>  <a>  <lda>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAQSY equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if EQUED = 'Y', the equilibrated matrix:
;;*          diag(S) * A * diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  S       (input) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de claqsy (uplo  n  a  lda  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ claqsy_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clar1v <n>  <b1>  <bn>  <sigma>  <d>  <l>  <ld>  <lld>  <gersch>  <z>  <ztz>  <mingma>  <r>  <isuppz>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAR1V computes the (scaled) r-th column of the inverse of
;;*  the sumbmatrix in rows B1 through BN of the tridiagonal matrix
;;*  L D L^T - sigma I. The following steps accomplish this computation :
;;*  (a) Stationary qd transform,  L D L^T - sigma I = L(+) D(+) L(+)^T,
;;*  (b) Progressive qd transform, L D L^T - sigma I = U(-) D(-) U(-)^T,
;;*  (c) Computation of the diagonal elements of the inverse of
;;*      L D L^T - sigma I by combining the above transforms, and choosing
;;*      r as the index where the diagonal of the inverse is (one of the)
;;*      largest in magnitude.
;;*  (d) Computation of the (scaled) r-th column of the inverse using the
;;*      twisted factorization obtained by combining the top part of the
;;*      the stationary and the bottom part of the progressive transform.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N        (input) INTEGER
;;*           The order of the matrix L D L^T.
;;*
;;*  B1       (input) INTEGER
;;*           First index of the submatrix of L D L^T.
;;*
;;*  BN       (input) INTEGER
;;*           Last index of the submatrix of L D L^T.
;;*
;;*  SIGMA    (input) REAL
;;*           The shift. Initially, when R = 0, SIGMA should be a good
;;*           approximation to an eigenvalue of L D L^T.
;;*
;;*  L        (input) REAL array, dimension (N-1)
;;*           The (n-1) subdiagonal elements of the unit bidiagonal matrix
;;*           L, in elements 1 to N-1.
;;*
;;*  D        (input) REAL array, dimension (N)
;;*           The n diagonal elements of the diagonal matrix D.
;;*
;;*  LD       (input) REAL array, dimension (N-1)
;;*           The n-1 elements L(i)*D(i).
;;*
;;*  LLD      (input) REAL array, dimension (N-1)
;;*           The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  GERSCH   (input) REAL array, dimension (2*N)
;;*           The n Gerschgorin intervals. These are used to restrict
;;*           the initial search for R, when R is input as 0.
;;*
;;*  Z        (output) COMPLEX array, dimension (N)
;;*           The (scaled) r-th column of the inverse. Z(R) is returned
;;*           to be 1.
;;*
;;*  ZTZ      (output) REAL
;;*           The square of the norm of Z.
;;*
;;*  MINGMA   (output) REAL
;;*           The reciprocal of the largest (in magnitude) diagonal
;;*           element of the inverse of L D L^T - sigma I.
;;*
;;*  R        (input/output) INTEGER
;;*           Initially, R should be input to be 0 and is then output as
;;*           the index where the diagonal element of the inverse is
;;*           largest in magnitude. In later iterations, this same value
;;*           of R should be input.
;;*
;;*  ISUPPZ   (output) INTEGER array, dimension (2)
;;*           The support of the vector in Z, i.e., the vector Z is
;;*           nonzero only in elements ISUPPZ(1) through ISUPPZ( 2 ).
;;*
;;*  WORK     (workspace) REAL array, dimension (4*N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clar1v (n  b1  bn  sigma  d  l  ld  lld  gersch  z  ztz  mingma  r  isuppz  work  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) b1 )
	((-idx0- (-int-)) bn )
	((-idx0- (-float-)) sigma )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) l )
	((-idx1- (-float-)) ld )
	((-idx1- (-float-)) lld )
	((-idx1- (-float-)) gersch )
	((-idx2- (-float-)) z )
	((-idx0- (-float-)) ztz )
	((-idx0- (-float-)) mingma )
	((-idx0- (-int-)) r )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	#{ clar1v_(IDX_PTR($n,int), IDX_PTR($b1,int), IDX_PTR($bn,int), IDX_PTR($sigma,float), IDX_PTR($d,float), IDX_PTR($l,float), IDX_PTR($ld,float), IDX_PTR($lld,float), IDX_PTR($gersch,float), IDX_PTR($z,float), IDX_PTR($ztz,float), IDX_PTR($mingma,float), IDX_PTR($r,int), IDX_PTR($isuppz,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clar2v <n>  <x>  <y>  <z>  <incx>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAR2V applies a vector of complex plane rotations with real cosines
;;*  from both sides to a sequence of 2-by-2 complex Hermitian matrices,
;;*  defined by the elements of the vectors x, y and z. For i = 1,2,...,n
;;*
;;*     (       x(i)  z(i) ) :=
;;*     ( conjg(z(i)) y(i) )
;;*
;;*       (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
;;*       ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) COMPLEX array, dimension (1+(N-1)*INCX)
;;*          The vector x; the elements of x are assumed to be real.
;;*
;;*  Y       (input/output) COMPLEX array, dimension (1+(N-1)*INCX)
;;*          The vector y; the elements of y are assumed to be real.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (1+(N-1)*INCX)
;;*          The vector z.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X, Y and Z. INCX > 0.
;;*
;;*  C       (input) REAL array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) COMPLEX array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clar2v (n  x  y  z  incx  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx2- (-float-)) y )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) c )
	((-idx2- (-float-)) s )
	((-idx0- (-int-)) incc )
	#{ clar2v_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($y,float), IDX_PTR($z,float), IDX_PTR($incx,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarcm <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <rwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARCM performs a very simple matrix-matrix multiplication:
;;*           C := A * B,
;;*  where A is M by M and real; B is M by N and complex;
;;*  C is M by N and complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A and of the matrix C.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns and rows of the matrix B and
;;*          the number of columns of the matrix C.
;;*          N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA, M)
;;*          A contains the M by M matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >=max(1,M).
;;*
;;*  B       (input) REAL array, dimension (LDB, N)
;;*          B contains the M by N matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >=max(1,M).
;;*
;;*  C       (input) COMPLEX array, dimension (LDC, N)
;;*          C contains the M by N matrix C.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >=max(1,M).
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*M*N)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarcm (m  n  a  lda  b  ldb  c  ldc  rwork  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) rwork )
	#{ clarcm_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($rwork,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarfb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARFB applies a complex block reflector H or its transpose H' to a
;;*  complex M-by-N matrix C, from either the left or the right.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'C': apply H' (Conjugate transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  V       (input) COMPLEX array, dimension
;;*                                (LDV,K) if STOREV = 'C'
;;*                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
;;*                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
;;*          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
;;*          if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) COMPLEX array, dimension (LDT,K)
;;*          The triangular K-by-K matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarfb (side  trans  direct  storev  m  n  k  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-float-)) work )
	((-idx0- (-int-)) ldwork )
	#{ clarfb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarfg <n>  <alpha>  <x>  <incx>  <tau>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARFG generates a complex elementary reflector H of order n, such
;;*  that
;;*
;;*        H' * ( alpha ) = ( beta ),   H' * H = I.
;;*             (   x   )   (   0  )
;;*
;;*  where alpha and beta are scalars, with beta real, and x is an
;;*  (n-1)-element complex vector. H is represented in the form
;;*
;;*        H = I - tau * ( 1 ) * ( 1 v' ) ,
;;*                      ( v )
;;*
;;*  where tau is a complex scalar and v is a complex (n-1)-element
;;*  vector. Note that H is not hermitian.
;;*
;;*  If the elements of x are all zero and alpha is real, then tau = 0
;;*  and H is taken to be the unit matrix.
;;*
;;*  Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the elementary reflector.
;;*
;;*  ALPHA   (input/output) COMPLEX
;;*          On entry, the value alpha.
;;*          On exit, it is overwritten with the value beta.
;;*
;;*  X       (input/output) COMPLEX array, dimension
;;*                         (1+(N-2)*abs(INCX))
;;*          On entry, the vector x.
;;*          On exit, it is overwritten with the vector v.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  TAU     (output) COMPLEX
;;*          The value tau.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarfg (n  alpha  x  incx  tau  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) tau )
	#{ clarfg_(IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($tau,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarf <side>  <m>  <n>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARF applies a complex elementary reflector H to a complex M-by-N
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar and v is a complex vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*  To apply H' (the conjugate transpose of H), supply conjg(tau) instead
;;*  tau.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) COMPLEX array, dimension
;;*                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of H. V is not used if
;;*          TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) COMPLEX
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarf (side  m  n  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) incv )
	((-idx1- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	#{ clarf_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($incv,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarft <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARFT forms the triangular factor T of a complex block reflector H
;;*  of order n, which is defined as a product of k elementary reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) COMPLEX array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) COMPLEX array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
;;*                   ( v1  1    )                     (     1 v2 v2 v2 )
;;*                   ( v1 v2  1 )                     (        1 v3 v3 )
;;*                   ( v1 v2 v3 )
;;*                   ( v1 v2 v3 )
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
;;*                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
;;*                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
;;*                   (     1 v3 )
;;*                   (        1 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarft (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ clarft_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($tau,float), IDX_PTR($t_,float), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarfx <side>  <m>  <n>  <v>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARFX applies a complex elementary reflector H to a complex m by n
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar and v is a complex vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix
;;*
;;*  This version uses inline code if H has order < 11.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) COMPLEX array, dimension (M) if SIDE = 'L'
;;*                                        or (N) if SIDE = 'R'
;;*          The vector v in the representation of H.
;;*
;;*  TAU     (input) COMPLEX
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDA >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N) if SIDE = 'L'
;;*                                            or (M) if SIDE = 'R'
;;*          WORK is not referenced if H has order < 11.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarfx (side  m  n  v  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) v )
	((-idx1- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	#{ clarfx_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clargv <n>  <x>  <incx>  <y>  <incy>  <c>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARGV generates a vector of complex plane rotations with real
;;*  cosines, determined by elements of the complex vectors x and y.
;;*  For i = 1,2,...,n
;;*
;;*     (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
;;*     ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )
;;*
;;*     where c(i)**2 + ABS(s(i))**2 = 1
;;*
;;*  The following conventions are used (these are the same as in CLARTG,
;;*  but differ from the BLAS1 routine CROTG):
;;*     If y(i)=0, then c(i)=1 and s(i)=0.
;;*     If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be generated.
;;*
;;*  X       (input/output) COMPLEX array, dimension (1+(N-1)*INCX)
;;*          On entry, the vector x.
;;*          On exit, x(i) is overwritten by r(i), for i = 1,...,n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) COMPLEX array, dimension (1+(N-1)*INCY)
;;*          On entry, the vector y.
;;*          On exit, the sines of the plane rotations.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (output) REAL array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C. INCC > 0.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  6-6-96 - Modified with a new algorithm by W. Kahan and J. Demmel
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clargv (n  x  incx  y  incy  c  incc  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-float-)) c )
	((-idx0- (-int-)) incc )
	#{ clargv_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarnv <idist>  <iseed>  <n>  <x>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARNV returns a vector of n random complex numbers from a uniform or
;;*  normal distribution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IDIST   (input) INTEGER
;;*          Specifies the distribution of the random numbers:
;;*          = 1:  real and imaginary parts each uniform (0,1)
;;*          = 2:  real and imaginary parts each uniform (-1,1)
;;*          = 3:  real and imaginary parts each normal (0,1)
;;*          = 4:  uniformly distributed on the disc abs(z) < 1
;;*          = 5:  uniformly distributed on the circle abs(z) = 1
;;*
;;*  ISEED   (input/output) INTEGER array, dimension (4)
;;*          On entry, the seed of the random number generator; the array
;;*          elements must be between 0 and 4095, and ISEED(4) must be
;;*          odd.
;;*          On exit, the seed is updated.
;;*
;;*  N       (input) INTEGER
;;*          The number of random numbers to be generated.
;;*
;;*  X       (output) COMPLEX array, dimension (N)
;;*          The generated random numbers.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine calls the auxiliary routine SLARUV to generate random
;;*  real numbers from a uniform (0,1) distribution, in batches of up to
;;*  128 using vectorisable code. The Box-Muller method is used to
;;*  transform numbers from a uniform to a normal distribution.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarnv (idist  iseed  n  x  )
	((-idx0- (-int-)) idist )
	((-idx1- (-int-)) iseed )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	#{ clarnv_(IDX_PTR($idist,int), IDX_PTR($iseed,int), IDX_PTR($n,int), IDX_PTR($x,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarrv <n>  <d>  <l>  <isplit>  <m>  <w>  <iblock>  <gersch>  <tol>  <z>  <ldz>  <isuppz>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARRV computes the eigenvectors of the tridiagonal matrix
;;*  T = L D L^T given L, D and the eigenvalues of L D L^T.
;;*  The input eigenvalues should have high relative accuracy with
;;*  respect to the entries of L and D. The desired accuracy of the
;;*  output can be specified by the input parameter TOL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the diagonal matrix D.
;;*          On exit, D may be overwritten.
;;*
;;*  L       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the unit
;;*          bidiagonal matrix L in elements 1 to N-1 of L. L(N) need
;;*          not be set. On exit, L is overwritten.
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*
;;*  TOL     (input) REAL
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors.
;;*          Errors in the input eigenvalues must be bounded by TOL.
;;*          The eigenvectors output have residual norms
;;*          bounded by TOL, and the dot products between different
;;*          eigenvectors are bounded by TOL. TOL must be at least
;;*          N*EPS*|T|, where EPS is the machine precision and |T| is
;;*          the 1-norm of the tridiagonal matrix.
;;*
;;*  M       (input) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (input) REAL array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block ( The output array
;;*          W from SLARRE is expected here ).
;;*          Errors in W must be bounded by TOL (see above).
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc. 
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace) REAL array, dimension (13*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in SLARRB
;;*                if INFO = 2, internal error in CSTEIN
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarrv (n  d  l  isplit  m  w  iblock  gersch  tol  z  ldz  isuppz  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) l )
	((-idx1- (-int-)) isplit )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-float-)) gersch )
	((-idx0- (-float-)) tol )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ clarrv_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($l,float), IDX_PTR($isplit,int), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($iblock,int), IDX_PTR($gersch,float), IDX_PTR($tol,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clartg <f>  <g>  <cs>  <sn>  <r>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARTG generates a plane rotation so that
;;*
;;*     [  CS  SN  ]     [ F ]     [ R ]
;;*     [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
;;*     [ -SN  CS  ]     [ G ]     [ 0 ]
;;*
;;*  This is a faster version of the BLAS1 routine CROTG, except for
;;*  the following differences:
;;*     F and G are unchanged on return.
;;*     If G=0, then CS=1 and SN=0.
;;*     If F=0, then CS=0 and SN is chosen so that R is real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) COMPLEX
;;*          The first component of vector to be rotated.
;;*
;;*  G       (input) COMPLEX
;;*          The second component of vector to be rotated.
;;*
;;*  CS      (output) REAL
;;*          The cosine of the rotation.
;;*
;;*  SN      (output) COMPLEX
;;*          The sine of the rotation.
;;*
;;*  R       (output) COMPLEX
;;*          The nonzero component of the rotated vector.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clartg (f  g  cs  sn  r  )
	((-idx1- (-float-)) f )
	((-idx1- (-float-)) g )
	((-idx0- (-float-)) cs )
	((-idx1- (-float-)) sn )
	((-idx1- (-float-)) r )
	#{ clartg_(IDX_PTR($f,float), IDX_PTR($g,float), IDX_PTR($cs,float), IDX_PTR($sn,float), IDX_PTR($r,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clartv <n>  <x>  <incx>  <y>  <incy>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARTV applies a vector of complex plane rotations with real cosines
;;*  to elements of the complex vectors x and y. For i = 1,2,...,n
;;*
;;*     ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
;;*     ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) COMPLEX array, dimension (1+(N-1)*INCX)
;;*          The vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) COMPLEX array, dimension (1+(N-1)*INCY)
;;*          The vector y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (input) REAL array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) COMPLEX array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de clartv (n  x  incx  y  incy  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-float-)) c )
	((-idx2- (-float-)) s )
	((-idx0- (-int-)) incc )
	#{ clartv_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarzb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <l>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARZB applies a complex block reflector H or its transpose H**H
;;*  to a complex distributed M-by-N  C from the left or the right.
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'C': apply H' (Conjugate transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise                        (not supported yet)
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix V containing the
;;*          meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) COMPLEX array, dimension (LDV,NV).
;;*          If STOREV = 'C', NV = K; if STOREV = 'R', NV = L.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= L; if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) COMPLEX array, dimension (LDT,K)
;;*          The triangular K-by-K matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarzb (side  trans  direct  storev  m  n  k  l  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-float-)) work )
	((-idx0- (-int-)) ldwork )
	#{ clarzb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarz <side>  <m>  <n>  <l>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARZ applies a complex elementary reflector H to a complex
;;*  M-by-N matrix C, from either the left or the right. H is represented
;;*  in the form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar and v is a complex vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*  To apply H' (the conjugate transpose of H), supply conjg(tau) instead
;;*  tau.
;;*
;;*  H is a product of k elementary reflectors as returned by CTZRZF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  L       (input) INTEGER
;;*          The number of entries of the vector V containing
;;*          the meaningful part of the Householder vectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) COMPLEX array, dimension (1+(L-1)*abs(INCV))
;;*          The vector v in the representation of H as returned by
;;*          CTZRZF. V is not used if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) COMPLEX
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarz (side  m  n  l  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) incv )
	((-idx1- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	#{ clarz_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($v,float), IDX_PTR($incv,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clarzt <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLARZT forms the triangular factor T of a complex block reflector
;;*  H of order > n, which is defined as a product of k elementary
;;*  reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise                        (not supported yet)
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) COMPLEX array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) COMPLEX array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*                                              ______V_____
;;*         ( v1 v2 v3 )                        /            \
;;*         ( v1 v2 v3 )                      ( v1 v1 v1 v1 v1 . . . . 1 )
;;*     V = ( v1 v2 v3 )                      ( v2 v2 v2 v2 v2 . . . 1   )
;;*         ( v1 v2 v3 )                      ( v3 v3 v3 v3 v3 . . 1     )
;;*         ( v1 v2 v3 )
;;*            .  .  .
;;*            .  .  .
;;*            1  .  .
;;*               1  .
;;*                  1
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*                                                        ______V_____
;;*            1                                          /            \
;;*            .  1                           ( 1 . . . . v1 v1 v1 v1 v1 )
;;*            .  .  1                        ( . 1 . . . v2 v2 v2 v2 v2 )
;;*            .  .  .                        ( . . 1 . . v3 v3 v3 v3 v3 )
;;*            .  .  .
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*     V = ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clarzt (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ clarzt_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($tau,float), IDX_PTR($t_,float), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clascl <type>  <kl>  <ku>  <cfrom>  <cto>  <m>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLASCL multiplies the M by N complex matrix A by the real scalar
;;*  CTO/CFROM.  This is done without over/underflow as long as the final
;;*  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
;;*  A may be full, upper triangular, lower triangular, upper Hessenberg,
;;*  or banded.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TYPE    (input) CHARACTER*1
;;*          TYPE indices the storage type of the input matrix.
;;*          = 'G':  A is a full matrix.
;;*          = 'L':  A is a lower triangular matrix.
;;*          = 'U':  A is an upper triangular matrix.
;;*          = 'H':  A is an upper Hessenberg matrix.
;;*          = 'B':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the lower
;;*                  half stored.
;;*          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the upper
;;*                  half stored.
;;*          = 'Z':  A is a band matrix with lower bandwidth KL and upper
;;*                  bandwidth KU.
;;*
;;*  KL      (input) INTEGER
;;*          The lower bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  KU      (input) INTEGER
;;*          The upper bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  CFROM   (input) REAL
;;*  CTO     (input) REAL
;;*          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
;;*          without over/underflow if the final result CTO*A(I,J)/CFROM
;;*          can be represented without over/underflow.  CFROM must be
;;*          nonzero.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,M)
;;*          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
;;*          storage type.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  INFO    (output) INTEGER
;;*          0  - successful exit
;;*          <0 - if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clascl (type  kl  ku  cfrom  cto  m  n  a  lda  info  )
	((-str-) type )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-float-)) cfrom )
	((-idx0- (-float-)) cto )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ clascl_($type->data, IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($cfrom,float), IDX_PTR($cto,float), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claset <uplo>  <m>  <n>  <alpha>  <beta>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLASET initializes a 2-D array A to BETA on the diagonal and
;;*  ALPHA on the offdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be set.
;;*          = 'U':      Upper triangular part is set. The lower triangle
;;*                      is unchanged.
;;*          = 'L':      Lower triangular part is set. The upper triangle
;;*                      is unchanged.
;;*          Otherwise:  All of the matrix A is set.
;;*
;;*  M       (input) INTEGER
;;*          On entry, M specifies the number of rows of A.
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the number of columns of A.
;;*
;;*  ALPHA   (input) COMPLEX
;;*          All the offdiagonal array elements are set to ALPHA.
;;*
;;*  BETA    (input) COMPLEX
;;*          All the diagonal array elements are set to BETA.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j;
;;*                   A(i,i) = BETA , 1 <= i <= min(m,n)
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de claset (uplo  m  n  alpha  beta  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ claset_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clasr <side>  <pivot>  <direct>  <m>  <n>  <c>  <s>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLASR   performs the transformation
;;*
;;*     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )
;;*
;;*     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )
;;*
;;*  where A is an m by n complex matrix and P is an orthogonal matrix,
;;*  consisting of a sequence of plane rotations determined by the
;;*  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
;;*  and z = n when SIDE = 'R' or 'r' ):
;;*
;;*  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then
;;*
;;*     P = P( z - 1 )*...*P( 2 )*P( 1 ),
;;*
;;*  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then
;;*
;;*     P = P( 1 )*P( 2 )*...*P( z - 1 ),
;;*
;;*  where  P( k ) is a plane rotation matrix for the following planes:
;;*
;;*     when  PIVOT = 'V' or 'v'  ( Variable pivot ),
;;*        the plane ( k, k + 1 )
;;*
;;*     when  PIVOT = 'T' or 't'  ( Top pivot ),
;;*        the plane ( 1, k + 1 )
;;*
;;*     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),
;;*        the plane ( k, z )
;;*
;;*  c( k ) and s( k )  must contain the  cosine and sine that define the
;;*  matrix  P( k ).  The two by two plane rotation part of the matrix
;;*  P( k ), R( k ), is assumed to be of the form
;;*
;;*     R( k ) = (  c( k )  s( k ) ).
;;*              ( -s( k )  c( k ) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          Specifies whether the plane rotation matrix P is applied to
;;*          A on the left or the right.
;;*          = 'L':  Left, compute A := P*A
;;*          = 'R':  Right, compute A:= A*P'
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies whether P is a forward or backward sequence of
;;*          plane rotations.
;;*          = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )
;;*          = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )
;;*
;;*  PIVOT   (input) CHARACTER*1
;;*          Specifies the plane for which P(k) is a plane rotation
;;*          matrix.
;;*          = 'V':  Variable pivot, the plane (k,k+1)
;;*          = 'T':  Top pivot, the plane (1,k+1)
;;*          = 'B':  Bottom pivot, the plane (k,z)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  If m <= 1, an immediate
;;*          return is effected.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  If n <= 1, an
;;*          immediate return is effected.
;;*
;;*  C, S    (input) REAL arrays, dimension
;;*                  (M-1) if SIDE = 'L'
;;*                  (N-1) if SIDE = 'R'
;;*          c(k) and s(k) contain the cosine and sine that define the
;;*          matrix P(k).  The two by two plane rotation part of the
;;*          matrix P(k), R(k), is assumed to be of the form
;;*          R( k ) = (  c( k )  s( k ) ).
;;*                   ( -s( k )  c( k ) )
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          The m by n matrix A.  On exit, A is overwritten by P*A if
;;*          SIDE = 'R' or by A*P' if SIDE = 'L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clasr (side  pivot  direct  m  n  c  s  a  lda  )
	((-str-) side )
	((-str-) pivot )
	((-str-) direct )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ clasr_($side->data, $pivot->data, $direct->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (classq <n>  <x>  <incx>  <scale>  <sumsq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLASSQ returns the values scl and ssq such that
;;*
;;*     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
;;*
;;*  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
;;*  assumed to be at least unity and the value of ssq will then satisfy
;;*
;;*     1.0 .le. ssq .le. ( sumsq + 2*n ).
;;*
;;*  scale is assumed to be non-negative and scl returns the value
;;*
;;*     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
;;*            i
;;*
;;*  scale and sumsq must be supplied in SCALE and SUMSQ respectively.
;;*  SCALE and SUMSQ are overwritten by scl and ssq respectively.
;;*
;;*  The routine makes only one pass through the vector X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements to be used from the vector X.
;;*
;;*  X       (input) COMPLEX array, dimension (N)
;;*          The vector x as described above.
;;*             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector X.
;;*          INCX > 0.
;;*
;;*  SCALE   (input/output) REAL
;;*          On entry, the value  scale  in the equation above.
;;*          On exit, SCALE is overwritten with the value  scl .
;;*
;;*  SUMSQ   (input/output) REAL
;;*          On entry, the value  sumsq  in the equation above.
;;*          On exit, SUMSQ is overwritten with the value  ssq .
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de classq (n  x  incx  scale  sumsq  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) sumsq )
	#{ classq_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($scale,float), IDX_PTR($sumsq,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (claswp <n>  <a>  <lda>  <k1>  <k2>  <ipiv>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLASWP performs a series of row interchanges on the matrix A.
;;*  One row interchange is initiated for each of rows K1 through K2 of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the matrix of column dimension N to which the row
;;*          interchanges will be applied.
;;*          On exit, the permuted matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*
;;*  K1      (input) INTEGER
;;*          The first element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  K2      (input) INTEGER
;;*          The last element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
;;*          The vector of pivot indices.  Only the elements in positions
;;*          K1 through K2 of IPIV are accessed.
;;*          IPIV(K) = L implies rows K and L are to be interchanged.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of IPIV.  If IPIV
;;*          is negative, the pivots are applied in reverse order.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by
;;*   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de claswp (n  a  lda  k1  k2  ipiv  incx  )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) k1 )
	((-idx0- (-int-)) k2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) incx )
	#{ claswp_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($k1,int), IDX_PTR($k2,int), IDX_PTR($ipiv,int), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clasyf <uplo>  <n>  <nb>  <kb>  <a>  <lda>  <ipiv>  <w>  <ldw>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLASYF computes a partial factorization of a complex symmetric matrix
;;*  A using the Bunch-Kaufman diagonal pivoting method. The partial
;;*  factorization has the form:
;;*
;;*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or:
;;*        ( 0  U22 ) (  0   D  ) ( U12' U22' )
;;*
;;*  A  =  ( L11  0 ) ( D    0  ) ( L11' L21' )  if UPLO = 'L'
;;*        ( L21  I ) ( 0   A22 ) (  0    I   )
;;*
;;*  where the order of D is at most NB. The actual order is returned in
;;*  the argument KB, and is either NB or NB-1, or N if N <= NB.
;;*  Note that U' denotes the transpose of U.
;;*
;;*  CLASYF is an auxiliary routine called by CSYTRF. It uses blocked code
;;*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
;;*  A22 (if UPLO = 'L').
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NB      (input) INTEGER
;;*          The maximum number of columns of the matrix A that should be
;;*          factored.  NB should be at least 2 to allow for 2-by-2 pivot
;;*          blocks.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns of A that were actually factored.
;;*          KB is either NB-1 or NB, or N if N <= NB.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, A contains details of the partial factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If UPLO = 'U', only the last KB elements of IPIV are set;
;;*          if UPLO = 'L', only the first KB elements are set.
;;*
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  W       (workspace) COMPLEX array, dimension (LDW,NB)
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W.  LDW >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clasyf (uplo  n  nb  kb  a  lda  ipiv  w  ldw  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) w )
	((-idx0- (-int-)) ldw )
	((-idx0- (-int-)) info )
	#{ clasyf_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($w,float), IDX_PTR($ldw,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatbs <uplo>  <trans>  <diag>  <normin>  <n>  <kd>  <ab>  <ldab>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLATBS solves one of the triangular systems
;;*
;;*     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular band matrix.  Here A' denotes the transpose of A, x and b
;;*  are n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b     (No transpose)
;;*          = 'T':  Solve A**T * x = s*b  (Transpose)
;;*          = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of subdiagonals or superdiagonals in the
;;*          triangular matrix A.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first KD+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  X       (input/output) COMPLEX array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) REAL
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) REAL array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, CTBSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine CTBSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A**T *x = b  or
;;*  A**H *x = b.  The basic algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call CTBSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatbs (uplo  trans  diag  normin  n  kd  ab  ldab  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) x )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) cnorm )
	((-idx0- (-int-)) info )
	#{ clatbs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($x,float), IDX_PTR($scale,float), IDX_PTR($cnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatdf <ijob>  <n>  <z>  <ldz>  <rhs>  <rdsum>  <rdscal>  <ipiv>  <jpiv>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLATDF computes the contribution to the reciprocal Dif-estimate
;;*  by solving for x in Z * x = b, where b is chosen such that the norm
;;*  of x is as large as possible. It is assumed that LU decomposition
;;*  of Z has been computed by CGETC2. On entry RHS = f holds the
;;*  contribution from earlier solved sub-systems, and on return RHS = x.
;;*
;;*  The factorization of Z returned by CGETC2 has the form
;;*  Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
;;*  triangular with unit diagonal elements and U is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          IJOB = 2: First compute an approximative null-vector e
;;*              of Z using CGECON, e is normalized and solve for
;;*              Zx = +-e - f with the sign giving the greater value of
;;*              2-norm(x).  About 5 times as expensive as Default.
;;*          IJOB .ne. 2: Local look ahead strategy where
;;*              all entries of the r.h.s. b is choosen as either +1 or
;;*              -1.  Default.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Z.
;;*
;;*  Z       (input) REAL array, dimension (LDZ, N)
;;*          On entry, the LU part of the factorization of the n-by-n
;;*          matrix Z computed by CGETC2:  Z = P * L * U * Q
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) REAL array, dimension (N).
;;*          On entry, RHS contains contributions from other subsystems.
;;*          On exit, RHS contains the solution of the subsystem with
;;*          entries according to the value of IJOB (see above).
;;*
;;*  RDSUM   (input/output) REAL
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by CTGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when CTGSY2 is called by CTGSYL.
;;*
;;*  RDSCAL  (input/output) REAL
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when CTGSY2 is called by
;;*          CTGSYL.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  This routine is a further developed implementation of algorithm
;;*  BSOLVE in [1] using complete pivoting in the LU factorization.
;;*
;;*   [1]   Bo Kagstrom and Lars Westin,
;;*         Generalized Schur Methods with Condition Estimators for
;;*         Solving the Generalized Sylvester Equation, IEEE Transactions
;;*         on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751.
;;*
;;*   [2]   Peter Poromaa,
;;*         On Efficient and Robust Estimators for the Separation
;;*         between two Regular Matrix Pairs with Applications in
;;*         Condition Estimation. Report UMINF-95.05, Department of
;;*         Computing Science, Umea University, S-901 87 Umea, Sweden,
;;*         1995.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatdf (ijob  n  z  ldz  rhs  rdsum  rdscal  ipiv  jpiv  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) rhs )
	((-idx0- (-float-)) rdsum )
	((-idx0- (-float-)) rdscal )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	#{ clatdf_(IDX_PTR($ijob,int), IDX_PTR($n,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($rhs,float), IDX_PTR($rdsum,float), IDX_PTR($rdscal,float), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatps <uplo>  <trans>  <diag>  <normin>  <n>  <ap>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLATPS solves one of the triangular systems
;;*
;;*     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular matrix stored in packed form.  Here A**T denotes the
;;*  transpose of A, A**H denotes the conjugate transpose of A, x and b
;;*  are n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b     (No transpose)
;;*          = 'T':  Solve A**T * x = s*b  (Transpose)
;;*          = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  X       (input/output) COMPLEX array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) REAL
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) REAL array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, CTPSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine CTPSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A**T *x = b  or
;;*  A**H *x = b.  The basic algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call CTPSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatps (uplo  trans  diag  normin  n  ap  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) x )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) cnorm )
	((-idx0- (-int-)) info )
	#{ clatps_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($x,float), IDX_PTR($scale,float), IDX_PTR($cnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatrd <uplo>  <n>  <nb>  <a>  <lda>  <e>  <tau>  <w>  <ldw>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLATRD reduces NB rows and columns of a complex Hermitian matrix A to
;;*  Hermitian tridiagonal form by a unitary similarity
;;*  transformation Q' * A * Q, and returns the matrices V and W which are
;;*  needed to apply the transformation to the unreduced part of A.
;;*
;;*  If UPLO = 'U', CLATRD reduces the last NB rows and columns of a
;;*  matrix, of which the upper triangle is supplied;
;;*  if UPLO = 'L', CLATRD reduces the first NB rows and columns of a
;;*  matrix, of which the lower triangle is supplied.
;;*
;;*  This is an auxiliary routine called by CHETRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U': Upper triangular
;;*          = 'L': Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of rows and columns to be reduced.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit:
;;*          if UPLO = 'U', the last NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements above the diagonal
;;*            with the array TAU, represent the unitary matrix Q as a
;;*            product of elementary reflectors;
;;*          if UPLO = 'L', the first NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements below the diagonal
;;*            with the array TAU, represent the  unitary matrix Q as a
;;*            product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
;;*          elements of the last NB columns of the reduced matrix;
;;*          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
;;*          the first NB columns of the reduced matrix.
;;*
;;*  TAU     (output) COMPLEX array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors, stored in
;;*          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
;;*          See Further Details.
;;*
;;*  W       (output) COMPLEX array, dimension (LDW,NB)
;;*          The n-by-nb matrix W required to update the unreduced part
;;*          of A.
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W. LDW >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n) H(n-1) . . . H(n-nb+1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
;;*  and tau in TAU(i-1).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the n-by-nb matrix V
;;*  which is needed, with W, to apply the transformation to the unreduced
;;*  part of the matrix, using a Hermitian rank-2k update of the form:
;;*  A := A - V*W' - W*V'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5 and nb = 2:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  a   a   a   v4  v5 )              (  d                  )
;;*    (      a   a   v4  v5 )              (  1   d              )
;;*    (          a   1   v5 )              (  v1  1   a          )
;;*    (              d   1  )              (  v1  v2  a   a      )
;;*    (                  d  )              (  v1  v2  a   a   a  )
;;*
;;*  where d denotes a diagonal element of the reduced matrix, a denotes
;;*  an element of the original matrix that is unchanged, and vi denotes
;;*  an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatrd (uplo  n  nb  a  lda  e  tau  w  ldw  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) w )
	((-idx0- (-int-)) ldw )
	#{ clatrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($w,float), IDX_PTR($ldw,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatrs <uplo>  <trans>  <diag>  <normin>  <n>  <a>  <lda>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLATRS solves one of the triangular systems
;;*
;;*     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
;;*
;;*  with scaling to prevent overflow.  Here A is an upper or lower
;;*  triangular matrix, A**T denotes the transpose of A, A**H denotes the
;;*  conjugate transpose of A, x and b are n-element vectors, and s is a
;;*  scaling factor, usually less than or equal to 1, chosen so that the
;;*  components of x will be less than the overflow threshold.  If the
;;*  unscaled problem will not cause overflow, the Level 2 BLAS routine
;;*  CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
;;*  then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b     (No transpose)
;;*          = 'T':  Solve A**T * x = s*b  (Transpose)
;;*          = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max (1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) REAL
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) REAL array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, CTRSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine CTRSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A**T *x = b  or
;;*  A**H *x = b.  The basic algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call CTRSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatrs (uplo  trans  diag  normin  n  a  lda  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) cnorm )
	((-idx0- (-int-)) info )
	#{ clatrs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($scale,float), IDX_PTR($cnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatrz <m>  <n>  <l>  <a>  <lda>  <tau>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLATRZ factors the M-by-(M+L) complex upper trapezoidal matrix
;;*  [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
;;*  of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
;;*  matrix and, R and A1 are M-by-M upper triangular matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing the
;;*          meaningful part of the Householder vectors. N-M >= L >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements N-L+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          unitary matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (M)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an l element vector. tau and z( k )
;;*  are chosen to annihilate the elements of the kth row of A2.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A2, such that the elements of z( k ) are
;;*  in  a( k, l + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A1.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatrz (m  n  l  a  lda  tau  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	#{ clatrz_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clatzm <side>  <m>  <n>  <v>  <incv>  <tau>  <c1>  <c2>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine CUNMRZ.
;;*
;;*  CLATZM applies a Householder matrix generated by CTZRQF to a matrix.
;;*
;;*  Let P = I - tau*u*u',   u = ( 1 ),
;;*                              ( v )
;;*  where v is an (m-1) vector if SIDE = 'L', or a (n-1) vector if
;;*  SIDE = 'R'.
;;*
;;*  If SIDE equals 'L', let
;;*         C = [ C1 ] 1
;;*             [ C2 ] m-1
;;*               n
;;*  Then C is overwritten by P*C.
;;*
;;*  If SIDE equals 'R', let
;;*         C = [ C1, C2 ] m
;;*                1  n-1
;;*  Then C is overwritten by C*P.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form P * C
;;*          = 'R': form C * P
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) COMPLEX array, dimension
;;*                  (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of P. V is not used
;;*          if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0
;;*
;;*  TAU     (input) COMPLEX
;;*          The value tau in the representation of P.
;;*
;;*  C1      (input/output) COMPLEX array, dimension
;;*                         (LDC,N) if SIDE = 'L'
;;*                         (M,1)   if SIDE = 'R'
;;*          On entry, the n-vector C1 if SIDE = 'L', or the m-vector C1
;;*          if SIDE = 'R'.
;;*
;;*          On exit, the first row of P*C if SIDE = 'L', or the first
;;*          column of C*P if SIDE = 'R'.
;;*
;;*  C2      (input/output) COMPLEX array, dimension
;;*                         (LDC, N)   if SIDE = 'L'
;;*                         (LDC, N-1) if SIDE = 'R'
;;*          On entry, the (m - 1) x n matrix C2 if SIDE = 'L', or the
;;*          m x (n - 1) matrix C2 if SIDE = 'R'.
;;*
;;*          On exit, rows 2:m of P*C if SIDE = 'L', or columns 2:m of C*P
;;*          if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the arrays C1 and C2.
;;*          LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                      (N) if SIDE = 'L'
;;*                      (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clatzm (side  m  n  v  incv  tau  c1  c2  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) incv )
	((-idx1- (-float-)) tau )
	((-idx3- (-float-)) c1 )
	((-idx3- (-float-)) c2 )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	#{ clatzm_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($incv,int), IDX_PTR($tau,float), IDX_PTR($c1,float), IDX_PTR($c2,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clauu2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAUU2 computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the unblocked form of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clauu2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ clauu2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (clauum <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CLAUUM computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the blocked form of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de clauum (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ clauum_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbcon <uplo>  <n>  <kd>  <ab>  <ldab>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite band matrix using
;;*  the Cholesky factorization A = U**H*U or A = L*L**H computed by
;;*  CPBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm (or infinity-norm) of the Hermitian band matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbcon (uplo  n  kd  ab  ldab  anorm  rcond  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cpbcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbequ <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBEQU computes row and column scalings intended to equilibrate a
;;*  Hermitian positive definite band matrix A and reduce its condition
;;*  number (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular of A is stored;
;;*          = 'L':  Lower triangular of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangle of the Hermitian band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB     (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) REAL
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbequ (uplo  n  kd  ab  ldab  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ cpbequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbrfs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite
;;*  and banded, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangle of the Hermitian band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  AFB     (input) COMPLEX array, dimension (LDAFB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H of the band matrix A as computed by
;;*          CPBTRF, in the same storage format as A (see AB).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CPBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbrfs (uplo  n  kd  nrhs  ab  ldab  afb  ldafb  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cpbrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbstf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBSTF computes a split Cholesky factorization of a complex
;;*  Hermitian positive definite band matrix A.
;;*
;;*  This routine is designed to be used in conjunction with CHBGST.
;;*
;;*  The factorization has the form  A = S**H*S  where S is a band matrix
;;*  of the same bandwidth as A and the following structure:
;;*
;;*    S = ( U    )
;;*        ( M  L )
;;*
;;*  where U is upper triangular of order m = (n+kd)/2, and L is lower
;;*  triangular of order n-m.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first kd+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the factor S from the split Cholesky
;;*          factorization A = S**H*S. See Further Details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the factorization could not be completed,
;;*               because the updated element a(i,i) was negative; the
;;*               matrix A is not positive definite.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 7, KD = 2:
;;*
;;*  S = ( s11  s12  s13                     )
;;*      (      s22  s23  s24                )
;;*      (           s33  s34                )
;;*      (                s44                )
;;*      (           s53  s54  s55           )
;;*      (                s64  s65  s66      )
;;*      (                     s75  s76  s77 )
;;*
;;*  If UPLO = 'U', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*   *    *   a13  a24  a35  a46  a57   *    *   s13  s24  s53' s64' s75'
;;*   *   a12  a23  a34  a45  a56  a67   *   s12  s23  s34  s54' s65' s76'
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*
;;*  If UPLO = 'L', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*  a21  a32  a43  a54  a65  a76   *   s12' s23' s34' s54  s65  s76   *
;;*  a31  a42  a53  a64  a64   *    *   s13' s24' s53  s64  s75   *    *
;;*
;;*  Array elements marked * are not used by the routine; s12' denotes
;;*  conjg(s12); the diagonal elements of S are real.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbstf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ cpbstf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbsv <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular band matrix, and L is a lower
;;*  triangular band matrix, with the same number of superdiagonals or
;;*  subdiagonals as A.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**H*U or A = L*L**H of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cpbsv (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cpbsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbsvx <fact>  <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
;;*  compute the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**H * U,  if UPLO = 'U', or
;;*        A = L * L**H,  if UPLO = 'L',
;;*     where U is an upper triangular band matrix, and L is a lower
;;*     triangular band matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AB and AFB will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right-hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array, except
;;*          if FACT = 'F' and EQUED = 'Y', then A must contain the
;;*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A
;;*          is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  AFB     (input or output) COMPLEX array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the band matrix
;;*          A, in the same storage format as A (see AB).  If EQUED = 'Y',
;;*          then AFB is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) REAL array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11  a12  a13
;;*          a22  a23  a24
;;*               a33  a34  a35
;;*                    a44  a45  a46
;;*                         a55  a56
;;*     (aij=conjg(aji))         a66
;;*
;;*  Band storage of the upper triangle of A:
;;*
;;*      *    *   a13  a24  a35  a46
;;*      *   a12  a23  a34  a45  a56
;;*     a11  a22  a33  a44  a55  a66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*     a11  a22  a33  a44  a55  a66
;;*     a21  a32  a43  a54  a65   *
;;*     a31  a42  a53  a64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbsvx (fact  uplo  n  kd  nrhs  ab  ldab  afb  ldafb  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-str-) equed )
	((-idx1- (-float-)) s )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cpbsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), $equed->data, IDX_PTR($s,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbtf2 <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBTF2 computes the Cholesky factorization of a complex Hermitian
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix, U' is the conjugate transpose
;;*  of U, and L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbtf2 (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ cpbtf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbtrf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBTRF computes the Cholesky factorization of a complex Hermitian
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L  * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**H*U or A = L*L**H of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  Contributed by
;;*  Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpbtrf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ cpbtrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpbtrs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPBTRS solves a system of linear equations A*X = B with a Hermitian
;;*  positive definite band matrix A using the Cholesky factorization
;;*  A = U**H*U or A = L*L**H computed by CPBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cpbtrs (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cpbtrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpocon <uplo>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite matrix using the
;;*  Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by CPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm (or infinity-norm) of the Hermitian matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpocon (uplo  n  a  lda  anorm  rcond  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cpocon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpoequ <n>  <a>  <lda>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOEQU computes row and column scalings intended to equilibrate a
;;*  Hermitian positive definite matrix A and reduce its condition number
;;*  (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The N-by-N Hermitian positive definite matrix whose scaling
;;*          factors are to be computed.  Only the diagonal elements of A
;;*          are referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) REAL
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpoequ (n  a  lda  s  scond  amax  info  )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ cpoequ_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cporfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPORFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite,
;;*  and provides error bounds and backward error estimates for the
;;*  solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX array, dimension (LDAF,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by CPOTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CPOTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cporfs (uplo  n  nrhs  a  lda  af  ldaf  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cporfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cposv <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**H* U,  if UPLO = 'U', or
;;*     A = L * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and  L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cposv (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cposv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cposvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
;;*  compute the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**H* U,  if UPLO = 'U', or
;;*        A = L * L**H,  if UPLO = 'L',
;;*     where U is an upper triangular matrix and L is a lower triangular
;;*     matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  A and AF will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A, except if FACT = 'F' and
;;*          EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AF is the factored form
;;*          of the equilibrated matrix diag(S)*A*diag(S).
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the original
;;*          matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) REAL array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS righthand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cposvx (fact  uplo  n  nrhs  a  lda  af  ldaf  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-str-) equed )
	((-idx1- (-float-)) s )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cposvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), $equed->data, IDX_PTR($s,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpotf2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOTF2 computes the Cholesky factorization of a complex Hermitian
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U'*U  or A = L*L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpotf2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ cpotf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpotrf <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOTRF computes the Cholesky factorization of a complex Hermitian
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L  * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the block version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpotrf (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ cpotrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpotri <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOTRI computes the inverse of a complex Hermitian positive definite
;;*  matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
;;*  computed by CPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, as computed by
;;*          CPOTRF.
;;*          On exit, the upper or lower triangle of the (Hermitian)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cpotri (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ cpotri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpotrs <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPOTRS solves a system of linear equations A*X = B with a Hermitian
;;*  positive definite matrix A using the Cholesky factorization 
;;*  A = U**H*U or A = L*L**H computed by CPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by CPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpotrs (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cpotrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cppcon <uplo>  <n>  <ap>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPCON estimates the reciprocal of the condition number (in the 
;;*  1-norm) of a complex Hermitian positive definite packed matrix using
;;*  the Cholesky factorization A = U**H*U or A = L*L**H computed by
;;*  CPPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm (or infinity-norm) of the Hermitian matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cppcon (uplo  n  ap  anorm  rcond  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cppcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cppequ <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPEQU computes row and column scalings intended to equilibrate a
;;*  Hermitian positive definite matrix A in packed storage and reduce
;;*  its condition number (with respect to the two-norm).  S contains the
;;*  scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
;;*  B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
;;*  This choice of S puts the condition number of B within a factor N of
;;*  the smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) REAL
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cppequ (uplo  n  ap  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ cppequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by SPPTRF/CPPTRF,
;;*          packed columnwise in a linear array in the same format as A
;;*          (see AP).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CPPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpprfs (uplo  n  nrhs  ap  afp  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) afp )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cpprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cppsv <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**H* U,  if UPLO = 'U', or
;;*     A = L * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.  
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, in the same storage
;;*          format as A.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cppsv (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cppsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cppsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
;;*  compute the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U'* U ,  if UPLO = 'U', or
;;*        A = L * L',  if UPLO = 'L',
;;*     where U is an upper triangular matrix, L is a lower triangular
;;*     matrix, and ' indicates conjugate transpose.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFP contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AP and AFP will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array, except if FACT = 'F'
;;*          and EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  The j-th column of A is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AFP is the factored
;;*          form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the original
;;*          matrix A.
;;*
;;*          If FACT = 'E', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the equilibrated
;;*          matrix A (see the description of AP for the form of the
;;*          equilibrated matrix).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) REAL array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cppsvx (fact  uplo  n  nrhs  ap  afp  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) afp )
	((-str-) equed )
	((-idx1- (-float-)) s )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cppsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), $equed->data, IDX_PTR($s,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpptrf <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPTRF computes the Cholesky factorization of a complex Hermitian
;;*  positive definite matrix A stored in packed format.
;;*
;;*  The factorization has the form
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L  * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**H*U or A = L*L**H, in the same
;;*          storage format as A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpptrf (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx0- (-int-)) info )
	#{ cpptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpptri <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPTRI computes the inverse of a complex Hermitian positive definite
;;*  matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
;;*  computed by CPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor is stored in AP;
;;*          = 'L':  Lower triangular factor is stored in AP.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, packed columnwise as
;;*          a linear array.  The j-th column of U or L is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*          On exit, the upper or lower triangle of the (Hermitian)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpptri (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx0- (-int-)) info )
	#{ cpptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpptrs <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPPTRS solves a system of linear equations A*X = B with a Hermitian
;;*  positive definite matrix A in packed storage using the Cholesky
;;*  factorization A = U**H*U or A = L*L**H computed by CPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cpptrs (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cpptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cptcon <n>  <d>  <e>  <anorm>  <rcond>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTCON computes the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite tridiagonal matrix
;;*  using the factorization A = L*D*L**H or A = U**H*D*U computed by
;;*  CPTTRF.
;;*
;;*  Norm(inv(A)) is computed by a direct method, and the reciprocal of
;;*  the condition number is computed as
;;*                   RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization of A, as computed by CPTTRF.
;;*
;;*  E       (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the unit bidiagonal factor
;;*          U or L from the factorization of A, as computed by CPTTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the
;;*          1-norm of inv(A) computed in this routine.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The method used is described in Nicholas J. Higham, "Efficient
;;*  Algorithms for Computing the Condition Number of a Tridiagonal
;;*  Matrix", SIAM J. Sci. Stat. Comput., Vol. 7, No. 1, January 1986.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cptcon (n  d  e  anorm  rcond  rwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cptcon_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric positive definite tridiagonal matrix by first factoring the
;;*  matrix using SPTTRF and then calling CBDSQR to compute the singular
;;*  values of the bidiagonal factor.
;;*
;;*  This routine computes the eigenvalues of the positive definite
;;*  tridiagonal matrix to high relative accuracy.  This means that if the
;;*  eigenvalues range over many orders of magnitude in size, then the
;;*  small eigenvalues and corresponding eigenvectors will be computed
;;*  more accurately than, for example, with the standard QR method.
;;*
;;*  The eigenvectors of a full or band positive definite Hermitian matrix
;;*  can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
;;*  reduce this matrix to tridiagonal form.  (The reduction to
;;*  tridiagonal form, however, may preclude the possibility of obtaining
;;*  high relative accuracy in the small eigenvalues of the original
;;*  matrix, if these eigenvalues range over many orders of magnitude.)
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvectors of original Hermitian
;;*                  matrix also.  Array Z contains the unitary matrix
;;*                  used to reduce the original matrix to tridiagonal
;;*                  form.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix.
;;*          On normal exit, D contains the eigenvalues, in descending
;;*          order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ, N)
;;*          On entry, if COMPZ = 'V', the unitary matrix used in the
;;*          reduction to tridiagonal form.
;;*          On exit, if COMPZ = 'V', the orthonormal eigenvectors of the
;;*          original Hermitian matrix;
;;*          if COMPZ = 'I', the orthonormal eigenvectors of the
;;*          tridiagonal matrix.
;;*          If INFO > 0 on exit, Z contains the eigenvectors associated
;;*          with only the stored eigenvalues.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          COMPZ = 'V' or 'I', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, and i is:
;;*                <= N  the Cholesky factorization of the matrix could
;;*                      not be performed because the i-th principal minor
;;*                      was not positive definite.
;;*                > N   the SVD algorithm failed to converge;
;;*                      if INFO = N+i, i off-diagonal elements of the
;;*                      bidiagonal factor did not converge to zero.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cpteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cptrfs <uplo>  <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite
;;*  and tridiagonal, and provides error bounds and backward error
;;*  estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the superdiagonal or the subdiagonal of the
;;*          tridiagonal matrix A is stored and the form of the
;;*          factorization:
;;*          = 'U':  E is the superdiagonal of A, and A = U**H*D*U;
;;*          = 'L':  E is the subdiagonal of A, and A = L*D*L**H.
;;*          (The two forms are equivalent if A is real.)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n real diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the tridiagonal matrix A
;;*          (see UPLO).
;;*
;;*  DF      (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from
;;*          the factorization computed by CPTTRF.
;;*
;;*  EF      (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the unit bidiagonal
;;*          factor U or L from the factorization computed by CPTTRF
;;*          (see UPLO).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CPTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cptrfs (uplo  n  nrhs  d  e  df  ef  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx1- (-float-)) df )
	((-idx2- (-float-)) ef )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cptrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($df,float), IDX_PTR($ef,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cptsv <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTSV computes the solution to a complex system of linear equations
;;*  A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
;;*  matrix, and X and B are N-by-NRHS matrices.
;;*
;;*  A is factored as A = L*D*L**H, and the factored form of A is then
;;*  used to solve the system of equations.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the factorization A = L*D*L**H.
;;*
;;*  E       (input/output) COMPLEX array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L**H factorization of
;;*          A.  E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U**H*D*U factorization of A.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the solution has not been
;;*                computed.  The factorization has not been completed
;;*                unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de cptsv (n  nrhs  d  e  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cptsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cptsvx <fact>  <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTSVX uses the factorization A = L*D*L**H to compute the solution
;;*  to a complex system of linear equations A*X = B, where A is an
;;*  N-by-N Hermitian positive definite tridiagonal matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the matrix A is factored as A = L*D*L**H, where L
;;*     is a unit lower bidiagonal matrix and D is diagonal.  The
;;*     factorization can also be regarded as having the form
;;*     A = U**H*D*U.
;;*
;;*  2. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix
;;*          A is supplied on entry.
;;*          = 'F':  On entry, DF and EF contain the factored form of A.
;;*                  D, E, DF, and EF will not be modified.
;;*          = 'N':  The matrix A will be copied to DF and EF and
;;*                  factored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) COMPLEX array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix A.
;;*
;;*  DF      (input or output) REAL array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**H factorization of A.
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**H factorization of A.
;;*
;;*  EF      (input or output) COMPLEX array, dimension (N-1)
;;*          If FACT = 'F', then EF is an input argument and on entry
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**H factorization of A.
;;*          If FACT = 'N', then EF is an output argument and on exit
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**H factorization of A.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal condition number of the matrix A.  If RCOND
;;*          is less than the machine precision (in particular, if
;;*          RCOND = 0), the matrix is singular to working precision.
;;*          This condition is indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in any
;;*          element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cptsvx (fact  n  nrhs  d  e  df  ef  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx1- (-float-)) df )
	((-idx2- (-float-)) ef )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cptsvx_($fact->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($df,float), IDX_PTR($ef,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpttrf <n>  <d>  <e>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTTRF computes the L*D*L' factorization of a complex Hermitian
;;*  positive definite tridiagonal matrix A.  The factorization may also
;;*  be regarded as having the form A = U'*D*U.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the L*D*L' factorization of A.
;;*
;;*  E       (input/output) COMPLEX array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L' factorization of A.
;;*          E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U'*D*U factorization of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite; if k < N, the factorization could not
;;*               be completed, while if k = N, the factorization was
;;*               completed, but D(N) = 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cpttrf (n  d  e  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx0- (-int-)) info )
	#{ cpttrf_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cpttrs <uplo>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTTRS solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the factorization A = U'*D*U or A = L*D*L' computed by CPTTRF.
;;*  D is a diagonal matrix specified in the vector D, U (or L) is a unit
;;*  bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
;;*  the vector E, and X and B are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the form of the factorization and whether the
;;*          vector E is the superdiagonal of the upper bidiagonal factor
;;*          U or the subdiagonal of the lower bidiagonal factor L.
;;*          = 'U':  A = U'*D*U, E is the superdiagonal of U
;;*          = 'L':  A = L*D*L', E is the subdiagonal of L
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization A = U'*D*U or A = L*D*L'.
;;*
;;*  E       (input) COMPLEX array, dimension (N-1)
;;*          If UPLO = 'U', the (n-1) superdiagonal elements of the unit
;;*          bidiagonal factor U from the factorization A = U'*D*U.
;;*          If UPLO = 'L', the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the factorization A = L*D*L'.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cpttrs (uplo  n  nrhs  d  e  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cpttrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cptts2 <iuplo>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CPTTS2 solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the factorization A = U'*D*U or A = L*D*L' computed by CPTTRF.
;;*  D is a diagonal matrix specified in the vector D, U (or L) is a unit
;;*  bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
;;*  the vector E, and X and B are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IUPLO   (input) INTEGER
;;*          Specifies the form of the factorization and whether the
;;*          vector E is the superdiagonal of the upper bidiagonal factor
;;*          U or the subdiagonal of the lower bidiagonal factor L.
;;*          = 1:  A = U'*D*U, E is the superdiagonal of U
;;*          = 0:  A = L*D*L', E is the subdiagonal of L
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization A = U'*D*U or A = L*D*L'.
;;*
;;*  E       (input) COMPLEX array, dimension (N-1)
;;*          If IUPLO = 1, the (n-1) superdiagonal elements of the unit
;;*          bidiagonal factor U from the factorization A = U'*D*U.
;;*          If IUPLO = 0, the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the factorization A = L*D*L'.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cptts2 (iuplo  n  nrhs  d  e  b  ldb  )
	((-idx0- (-int-)) iuplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) e )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ cptts2_(IDX_PTR($iuplo,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (crot <n>  <cx>  <incx>  <cy>  <incy>  <c>  <s>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CROT   applies a plane rotation, where the cos (C) is real and the
;;*  sin (S) is complex, and the vectors CX and CY are complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements in the vectors CX and CY.
;;*
;;*  CX      (input/output) COMPLEX array, dimension (N)
;;*          On input, the vector X.
;;*          On output, CX is overwritten with C*X + S*Y.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of CY.  INCX <> 0.
;;*
;;*  CY      (input/output) COMPLEX array, dimension (N)
;;*          On input, the vector Y.
;;*          On output, CY is overwritten with -CONJG(S)*X + C*Y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive values of CY.  INCX <> 0.
;;*
;;*  C       (input) REAL
;;*  S       (input) COMPLEX
;;*          C and S define a rotation
;;*             [  C          S  ]
;;*             [ -conjg(S)   C  ]
;;*          where C*C + S*CONJG(S) = 1.0.
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de crot (n  cx  incx  cy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	((-idx0- (-float-)) c )
	((-idx1- (-float-)) s )
	#{ crot_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($s,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cspcon <uplo>  <n>  <ap>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex symmetric packed matrix A using the
;;*  factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSPTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cspcon (uplo  n  ap  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cspcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cspmv <uplo>  <n>  <alpha>  <ap>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPMV  performs the matrix-vector operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric matrix, supplied in packed form.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX array, dimension at least
;;*           ( ( N*( N + 1 ) )/2 ).
;;*           Before entry, with UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on.
;;*           Before entry, with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cspmv (uplo  n  alpha  ap  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ cspmv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($ap,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The factored form of the matrix A.  AFP contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by CSPTRF, stored as a packed
;;*          triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSPTRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CSPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csprfs (uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ csprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cspr <uplo>  <n>  <alpha>  <x>  <incx>  <ap>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPR    performs the symmetric rank 1 operation
;;*
;;*     A := alpha*x*conjg( x' ) + A,
;;*
;;*  where alpha is a complex scalar, x is an n element vector and A is an
;;*  n by n symmetric matrix, supplied in packed form.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX array, dimension at least
;;*           ( ( N*( N + 1 ) )/2 ).
;;*           Before entry, with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the upper triangular part of the
;;*           updated matrix.
;;*           Before entry, with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the lower triangular part of the
;;*           updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set, they are assumed to be zero, and on exit they
;;*           are set to zero.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cspr (uplo  n  alpha  x  incx  ap  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) ap )
	#{ cspr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($ap,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cspsv <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix stored in packed format and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, D is symmetric and block diagonal with 1-by-1
;;*  and 2-by-2 diagonal blocks.  The factored form of A is then used to
;;*  solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by CSPTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, so the solution could not be
;;*                computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cspsv (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ cspsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cspsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
;;*  A = L*D*L**T to compute the solution to a complex system of linear
;;*  equations A * X = B, where A is an N-by-N symmetric matrix stored
;;*  in packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A as
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AFP and IPIV contain the factored form
;;*                  of A.  AP, AFP and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CSPTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CSPTRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cspsvx (fact  uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ cspsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csptrf <uplo>  <n>  <ap>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPTRF computes the factorization of a complex symmetric matrix A
;;*  stored in packed format using the Bunch-Kaufman diagonal pivoting
;;*  method:
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L, stored as a packed triangular
;;*          matrix overwriting A (see below for further details).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  5-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csptrf (uplo  n  ap  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ csptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csptri <uplo>  <n>  <ap>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPTRI computes the inverse of a complex symmetric indefinite matrix
;;*  A in packed storage using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by CSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by CSPTRF,
;;*          stored as a packed triangular matrix.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix, stored as a packed triangular matrix. The j-th column
;;*          of inv(A) is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
;;*          if UPLO = 'L',
;;*             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSPTRF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csptri (uplo  n  ap  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ csptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csptrs <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSPTRS solves a system of linear equations A*X = B with a complex
;;*  symmetric matrix A stored in packed format using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSPTRF.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csptrs (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ csptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csrot <n>  <cx>  <incx>  <cy>  <incy>  <c>  <s>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*     applies a plane rotation, where the cos and sin (c and s) are real
;;*     and the vectors cx and cy are complex.
;;*     jack dongarra, linpack, 3/11/78.
;;*
;;*  =====================================================================
;;*  =====================================================================

(de csrot (n  cx  incx  cy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) s )
	#{ csrot_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($s,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csrscl <n>  <sa>  <sx>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSRSCL multiplies an n-element complex vector x by the real scalar
;;*  1/a.  This is done without overflow or underflow as long as
;;*  the final result x/a does not overflow or underflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of components of the vector x.
;;*
;;*  SA      (input) REAL
;;*          The scalar a which is used to divide each component of x.
;;*          SA must be >= 0, or the subroutine will divide by zero.
;;*
;;*  SX      (input/output) COMPLEX array, dimension
;;*                         (1+(N-1)*abs(INCX))
;;*          The n-element vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector SX.
;;*          > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1< i<= n
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csrscl (n  sa  sx  incx  )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) sa )
	((-idx2- (-float-)) sx )
	((-idx0- (-int-)) incx )
	#{ csrscl_(IDX_PTR($n,int), IDX_PTR($sa,float), IDX_PTR($sx,float), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cstedc <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the divide and conquer method.
;;*  The eigenvectors of a full or band complex Hermitian matrix can also
;;*  be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
;;*  matrix to tridiagonal form.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.  See SLAED3 for details.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*          = 'V':  Compute eigenvectors of original Hermitian matrix
;;*                  also.  On entry, Z contains the unitary matrix used
;;*                  to reduce the original matrix to tridiagonal form.
;;*
;;*  N       (input) INTEGER
;;*          The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the subdiagonal elements of the tridiagonal matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          On entry, if COMPZ = 'V', then Z contains the unitary
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original Hermitian matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If eigenvectors are desired, then LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) REAL array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of the array RWORK.
;;*          If COMPZ = 'N' or N <= 1, LRWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1, LRWORK must be at least
;;*                         1 + 3*N + 2*N*lg N + 3*N**2 ,
;;*                         where lg( N ) = smallest integer k such
;;*                         that 2**k >= N.
;;*          If COMPZ = 'I' and N > 1, LRWORK must be at least
;;*                         1 + 4*N + 2*N**2 .
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If COMPZ = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If COMPZ = 'V' or N > 1,  LIWORK must be at least
;;*                                    6 + 6*N + 5*N*lg N.
;;*          If COMPZ = 'I' or N > 1,  LIWORK must be at least
;;*                                    3 + 5*N .
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cstedc (compz  n  d  e  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ cstedc_($compz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cstegr <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;* CSTEGR computes selected eigenvalues and, optionally, eigenvectors
;;* of a real symmetric tridiagonal matrix T.  Eigenvalues and
;;* eigenvectors can be selected by specifying either a range of values
;;* or a range of indices for the desired eigenvalues. The eigenvalues
;;* are computed by the dqds algorithm, while orthogonal eigenvectors are
;;* computed from various ``good'' L D L^T representations (also known as
;;* Relatively Robust Representations). Gram-Schmidt orthogonalization is
;;* avoided as far as possible. More specifically, the various steps of
;;* the algorithm are as follows. For the i-th unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*         is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB/CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*  Note 1 : Currently CSTEGR is only set up to find ALL the n
;;*  eigenvalues and eigenvectors of T in O(n^2) time
;;*  Note 2 : Currently the routine CSTEIN is called when an appropriate
;;*  sigma_i cannot be chosen in step (c) above. CSTEIN invokes modified
;;*  Gram-Schmidt when eigenvalues are close.
;;*  Note 3 : CSTEGR works only on machines which follow ieee-754
;;*  floating-point standard in their handling of infinities and NaNs.
;;*  Normal execution of CSTEGR may create NaNs and infinities and hence
;;*  may abort due to a floating point exception in environments which
;;*  do not conform to the ieee standard.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** Only RANGE = 'A' is currently supported *********************
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          T. On exit, D is overwritten.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix T in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E is overwritten.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors. IF JOBZ = 'V', the eigenvalues and
;;*          eigenvectors output have residual norms bounded by ABSTOL,
;;*          and the dot products between different eigenvectors are
;;*          bounded by ABSTOL. If ABSTOL is less than N*EPS*|T|, then
;;*          N*EPS*|T| will be used in its place, where EPS is the
;;*          machine precision and |T| is the 1-norm of the tridiagonal
;;*          matrix. The eigenvalues are computed to an accuracy of
;;*          EPS*|T| irrespective of ABSTOL. If high relative accuracy
;;*          is important, set ABSTOL to DLAMCH( 'Safe minimum' ).
;;*          See Barlow and Demmel "Computing Accurate Eigensystems of
;;*          Scaled Diagonally Dominant Matrices", LAPACK Working Note #7
;;*          for a discussion of which matrices define their eigenvalues
;;*          to high relative accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal
;;*          (and minimal) LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,18*N)
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= max(1,10*N)
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in SLARRE,
;;*                if INFO = 2, internal error in CLARRV.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cstegr (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ cstegr_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cstein <n>  <d>  <e>  <m>  <w>  <iblock>  <isplit>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSTEIN computes the eigenvectors of a real symmetric tridiagonal
;;*  matrix T corresponding to specified eigenvalues, using inverse
;;*  iteration.
;;*
;;*  The maximum number of iterations allowed for each eigenvector is
;;*  specified by an internal parameter MAXITS (currently set to 5).
;;*
;;*  Although the eigenvectors are real, they are stored in a complex
;;*  array, which may be passed to CUNMTR or CUPMTR for back
;;*  transformation to the eigenvectors of a complex Hermitian matrix
;;*  which was reduced to tridiagonal form.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) REAL array, dimension (N)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix
;;*          T, stored in elements 1 to N-1; E(N) need not be set.
;;*
;;*  M       (input) INTEGER
;;*          The number of eigenvectors to be found.  0 <= M <= N.
;;*
;;*  W       (input) REAL array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block.  ( The output array
;;*          W from SSTEBZ with ORDER = 'B' is expected here. )
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc.  ( The output array IBLOCK
;;*          from SSTEBZ is expected here. )
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*          ( The output array ISPLIT from SSTEBZ is expected here. )
;;*
;;*  Z       (output) COMPLEX array, dimension (LDZ, M)
;;*          The computed eigenvectors.  The eigenvector associated
;;*          with the eigenvalue W(i) is stored in the i-th column of
;;*          Z.  Any vector which fails to converge is set to its current
;;*          iterate after MAXITS iterations.
;;*          The imaginary parts of the eigenvectors are set to zero.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (5*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (M)
;;*          On normal exit, all elements of IFAIL are zero.
;;*          If one or more eigenvectors fail to converge after
;;*          MAXITS iterations, then their indices are stored in
;;*          array IFAIL.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, then i eigenvectors failed to converge
;;*               in MAXITS iterations.  Their indices are stored in
;;*               array IFAIL.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXITS  INTEGER, default = 5
;;*          The maximum number of iterations performed.
;;*
;;*  EXTRA   INTEGER, default = 2
;;*          The number of iterations performed after norm growth
;;*          criterion is satisfied, should be at least 1.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cstein (n  d  e  m  w  iblock  isplit  z  ldz  work  iwork  ifail  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-int-)) isplit )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ cstein_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($iblock,int), IDX_PTR($isplit,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the implicit QL or QR method.
;;*  The eigenvectors of a full or band complex Hermitian matrix can also
;;*  be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
;;*  matrix to tridiagonal form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvalues and eigenvectors of the original
;;*                  Hermitian matrix.  On entry, Z must contain the
;;*                  unitary matrix used to reduce the original matrix
;;*                  to tridiagonal form.
;;*          = 'I':  Compute eigenvalues and eigenvectors of the
;;*                  tridiagonal matrix.  Z is initialized to the identity
;;*                  matrix.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ, N)
;;*          On entry, if  COMPZ = 'V', then Z contains the unitary
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original Hermitian matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          eigenvectors are desired, then  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (max(1,2*N-2))
;;*          If COMPZ = 'N', then WORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm has failed to find all the eigenvalues in
;;*                a total of 30*N iterations; if INFO = i, then i
;;*                elements of E have not converged to zero; on exit, D
;;*                and E contain the elements of a symmetric tridiagonal
;;*                matrix which is unitarily similar to the original
;;*                matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ csteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csycon <uplo>  <n>  <a>  <lda>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex symmetric matrix A using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by CSYTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSYTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csycon (uplo  n  a  lda  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ csycon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csymv <uplo>  <n>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYMV  performs the matrix-vector  operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric matrix.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX array, dimension ( LDA, N )
;;*           Before entry, with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced.
;;*           Before entry, with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, N ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csymv (uplo  n  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ csymv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csyrfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite, and
;;*  provides error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX array, dimension (LDAF,N)
;;*          The factored form of the matrix A.  AF contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by CSYTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSYTRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by CSYTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csyrfs (uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ csyrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csyr <uplo>  <n>  <alpha>  <x>  <incx>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYR   performs the symmetric rank 1 operation
;;*
;;*     A := alpha*x*( x' ) + A,
;;*
;;*  where alpha is a complex scalar, x is an n element vector and A is an
;;*  n by n symmetric matrix.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX array, dimension ( LDA, N )
;;*           Before entry, with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced. On exit, the
;;*           upper triangular part of the array A is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry, with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced. On exit, the
;;*           lower triangular part of the array A is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDA    - INTEGER
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, N ).
;;*           Unchanged on exit.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csyr (uplo  n  alpha  x  incx  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ csyr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csysv <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with 
;;*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
;;*  used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the block diagonal matrix D and the
;;*          multipliers used to obtain the factor U or L from the
;;*          factorization A = U*D*U**T or A = L*D*L**T as computed by
;;*          CSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by CSYTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 1, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          CSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de csysv (uplo  n  nrhs  a  lda  ipiv  b  ldb  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ csysv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csysvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYSVX uses the diagonal pivoting factorization to compute the
;;*  solution to a complex system of linear equations A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A.
;;*     The form of the factorization is
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices, and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AF and IPIV contain the factored form
;;*                  of A.  A, AF and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by CSYTRF.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CSYTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by CSYTRF.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 2*N, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          CSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csysvx (fact  uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  lwork  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ csysvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csytf2 <uplo>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYTF2 computes the factorization of a complex symmetric matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U'  or  A = L*D*L'
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, U' is the transpose of U, and D is symmetric and
;;*  block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  1-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csytf2 (uplo  n  a  lda  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ csytf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csytrf <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYTRF computes the factorization of a complex symmetric matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method.  The form of the
;;*  factorization is
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >=1.  For best performance
;;*          LWORK >= N*NB, where NB is the block size returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, and division by zero will occur if it
;;*                is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de csytrf (uplo  n  a  lda  ipiv  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ csytrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csytri <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYTRI computes the inverse of a complex symmetric indefinite matrix
;;*  A using the factorization A = U*D*U**T or A = L*D*L**T computed by
;;*  CSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by CSYTRF.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix.  If UPLO = 'U', the upper triangular part of the
;;*          inverse is formed and the part of A below the diagonal is not
;;*          referenced; if UPLO = 'L' the lower triangular part of the
;;*          inverse is formed and the part of A above the diagonal is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSYTRF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csytri (uplo  n  a  lda  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ csytri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (csytrs <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CSYTRS solves a system of linear equations A*X = B with a complex
;;*  symmetric matrix A using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by CSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by CSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by CSYTRF.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de csytrs (uplo  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ csytrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctbcon <norm>  <uplo>  <diag>  <n>  <kd>  <ab>  <ldab>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTBCON estimates the reciprocal of the condition number of a
;;*  triangular band matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctbcon (norm  uplo  diag  n  kd  ab  ldab  rcond  work  rwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctbcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctbrfs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTBRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular band
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by CTBTRS or some other
;;*  means before entering this routine.  CTBRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) COMPLEX array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctbrfs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctbrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctbtrs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTBTRS solves a triangular system of the form
;;*
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*
;;*  where A is a triangular band matrix of order N, and B is an
;;*  N-by-NRHS matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctbtrs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ctbtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgevc <side>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGEVC computes some or all of the right and/or left generalized
;;*  eigenvectors of a pair of complex upper triangular matrices (A,B).
;;*
;;*  The right generalized eigenvector x and the left generalized
;;*  eigenvector y of (A,B) corresponding to a generalized eigenvalue
;;*  w are defined by:
;;*
;;*          (A - wB) * x = 0  and  y**H * (A - wB) = 0
;;*
;;*  where y**H denotes the conjugate tranpose of y.
;;*
;;*  If an eigenvalue w is determined by zero diagonal elements of both A
;;*  and B, a unit vector is returned as the corresponding eigenvector.
;;*
;;*  If all eigenvectors are requested, the routine may either return
;;*  the matrices X and/or Y of right or left eigenvectors of (A,B), or
;;*  the products Z*X and/or Q*Y, where Z and Q are input unitary
;;*  matrices.  If (A,B) was obtained from the generalized Schur
;;*  factorization of an original pair of matrices
;;*     (A0,B0) = (Q*A*Z**H,Q*B*Z**H),
;;*  then Z*X and Q*Y are the matrices of right or left eigenvectors of
;;*  A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute all right and/or left eigenvectors;
;;*          = 'B': compute all right and/or left eigenvectors, and
;;*                 backtransform them using the input matrices supplied
;;*                 in VR and/or VL;
;;*          = 'S': compute selected right and/or left eigenvectors,
;;*                 specified by the logical array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY='S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY='A' or 'B', SELECT is not referenced.
;;*          To select the eigenvector corresponding to the j-th
;;*          eigenvalue, SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The upper triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,N)
;;*          The upper triangular matrix B.  B must have real diagonal
;;*          elements.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of array B.  LDB >= max(1,N).
;;*
;;*  VL      (input/output) COMPLEX array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Q
;;*          of left Schur vectors returned by CHGEQZ).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VL, in the same order as their eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) COMPLEX array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Z
;;*          of right Schur vectors returned by CHGEQZ).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Z*X;
;;*          if HOWMNY = 'S', the right eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VR, in the same order as their eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
;;*          is set to N.  Each selected eigenvector occupies one column.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgevc (side  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  mm  m  work  rwork  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctgevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgex2 <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <j1>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
;;*  in an upper triangular matrix pair (A, B) by an unitary equivalence
;;*  transformation.
;;*
;;*  (A, B) must be in generalized Schur canonical form, that is, A and
;;*  B are both upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX arrays, dimensions (LDA,N)
;;*          On entry, the matrix A in the pair (A, B).
;;*          On exit, the updated matrix A.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX arrays, dimensions (LDB,N)
;;*          On entry, the matrix B in the pair (A, B).
;;*          On exit, the updated matrix B.
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          If WANTQ = .TRUE, on entry, the unitary matrix Q. On exit,
;;*          the updated matrix Q.
;;*          Not referenced if WANTQ = .FALSE..
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1;
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          If WANTZ = .TRUE, on entry, the unitary matrix Z. On exit,
;;*          the updated matrix Z.
;;*          Not referenced if WANTZ = .FALSE..
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1;
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  J1      (input) INTEGER
;;*          The index to the first block (A11, B11).
;;*
;;*  INFO    (output) INTEGER
;;*           =0:  Successful exit.
;;*           =1:  The transformed matrix pair (A, B) would be too far
;;*                from generalized Schur form; the problem is ill-
;;*                conditioned. (A, B) may have been partially reordered,
;;*                and ILST points to the first row of the current
;;*                position of the block being moved.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  In the current code both weak and strong stability tests are
;;*  performed. The user can omit the strong stability test by changing
;;*  the internal logical parameter WANDS to .FALSE.. See ref. [2] for
;;*  details.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report UMINF-94.04,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, 1994. Also as LAPACK Working Note 87. To appear in
;;*      Numerical Algorithms, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgex2 (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  j1  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) j1 )
	((-idx0- (-int-)) info )
	#{ ctgex2_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($j1,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgexc <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <ifst>  <ilst>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGEXC reorders the generalized Schur decomposition of a complex
;;*  matrix pair (A,B), using an unitary equivalence transformation
;;*  (A, B) := Q * (A, B) * Z', so that the diagonal block of (A, B) with
;;*  row index IFST is moved to row ILST.
;;*
;;*  (A, B) must be in generalized Schur canonical form, that is, A and
;;*  B are both upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the upper triangular matrix A in the pair (A, B).
;;*          On exit, the updated matrix A.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the upper triangular matrix B in the pair (A, B).
;;*          On exit, the updated matrix B.
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          On entry, if WANTQ = .TRUE., the unitary matrix Q.
;;*          On exit, the updated matrix Q.
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1;
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., the unitary matrix Z.
;;*          On exit, the updated matrix Z.
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1;
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  IFST    (input/output) INTEGER
;;*  ILST    (input/output) INTEGER
;;*          Specify the reordering of the diagonal blocks of (A, B).
;;*          The block with row index IFST is moved to row ILST, by a
;;*          sequence of swapping between adjacent blocks.
;;*
;;*  INFO    (output) INTEGER
;;*           =0:  Successful exit.
;;*           <0:  if INFO = -i, the i-th argument had an illegal value.
;;*           =1:  The transformed matrix pair (A, B) would be too far
;;*                from generalized Schur form; the problem is ill-
;;*                conditioned. (A, B) may have been partially reordered,
;;*                and ILST points to the first row of the current
;;*                position of the block being moved.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report
;;*      UMINF - 94.04, Department of Computing Science, Umea University,
;;*      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
;;*      To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK working
;;*      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
;;*      1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ctgexc (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  ifst  ilst  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx0- (-int-)) info )
	#{ ctgexc_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgsen <ijob>  <wantq>  <wantz>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <q>  <ldq>  <z>  <ldz>  <m>  <pl>  <pr>  <dif>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGSEN reorders the generalized Schur decomposition of a complex
;;*  matrix pair (A, B) (in terms of an unitary equivalence trans-
;;*  formation Q' * (A, B) * Z), so that a selected cluster of eigenvalues
;;*  appears in the leading diagonal blocks of the pair (A,B). The leading
;;*  columns of Q and Z form unitary bases of the corresponding left and
;;*  right eigenspaces (deflating subspaces). (A, B) must be in
;;*  generalized Schur canonical form, that is, A and B are both upper
;;*  triangular.
;;*
;;*  CTGSEN also computes the generalized eigenvalues
;;*
;;*           w(j)= ALPHA(j) / BETA(j)
;;*
;;*  of the reordered matrix pair (A, B).
;;*
;;*  Optionally, the routine computes estimates of reciprocal condition
;;*  numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
;;*  (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
;;*  between the matrix pairs (A11, B11) and (A22,B22) that correspond to
;;*  the selected cluster and the eigenvalues outside the cluster, resp.,
;;*  and norms of "projections" onto left and right eigenspaces w.r.t.
;;*  the selected cluster in the (1,1)-block.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) integer
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (PL and PR) or the deflating subspaces
;;*          (Difu and Difl):
;;*           =0: Only reorder w.r.t. SELECT. No extras.
;;*           =1: Reciprocal of norms of "projections" onto left and right
;;*               eigenspaces w.r.t. the selected cluster (PL and PR).
;;*           =2: Upper bounds on Difu and Difl. F-norm-based estimate
;;*               (DIF(1:2)).
;;*           =3: Estimate of Difu and Difl. 1-norm-based estimate
;;*               (DIF(1:2)).
;;*               About 5 times as expensive as IJOB = 2.
;;*           =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
;;*               version to get it all.
;;*           =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster. To
;;*          select an eigenvalue w(j), SELECT(j) must be set to
;;*          .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension(LDA,N)
;;*          On entry, the upper triangular matrix A, in generalized
;;*          Schur canonical form.
;;*          On exit, A is overwritten by the reordered matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension(LDB,N)
;;*          On entry, the upper triangular matrix B, in generalized
;;*          Schur canonical form.
;;*          On exit, B is overwritten by the reordered matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX array, dimension (N)
;;*  BETA    (output) COMPLEX array, dimension (N)
;;*          The diagonal elements of A and B, respectively,
;;*          when the pair (A,B) has been reduced to generalized Schur
;;*          form.  ALPHA(i)/BETA(i) i=1,...,N are the generalized
;;*          eigenvalues.
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ,N)
;;*          On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
;;*          On exit, Q has been postmultiplied by the left unitary
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Q form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1.
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
;;*          On exit, Z has been postmultiplied by the left unitary
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Z form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1.
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified pair of left and right
;;*          eigenspaces, (deflating subspaces) 0 <= M <= N.
;;*
;;*  PL, PR  (output) REAL
;;*          If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
;;*          reciprocal  of the norm of "projections" onto left and right
;;*          eigenspace with respect to the selected cluster.
;;*          0 < PL, PR <= 1.
;;*          If M = 0 or M = N, PL = PR  = 1.
;;*          If IJOB = 0, 2 or 3 PL, PR are not referenced.
;;*
;;*  DIF     (output) REAL array, dimension (2).
;;*          If IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.
;;*          If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
;;*          Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
;;*          estimates of Difu and Difl, computed using reversed
;;*          communication with CLACON.
;;*          If M = 0 or N, DIF(1:2) = F-norm([A, B]).
;;*          If IJOB = 0 or 1, DIF is not referenced.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          IF IJOB = 0, WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >=  1
;;*          If IJOB = 1, 2 or 4, LWORK >=  2*M*(N-M)
;;*          If IJOB = 3 or 5, LWORK >=  4*M*(N-M)
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER, dimension (LIWORK)
;;*          IF IJOB = 0, IWORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK. LIWORK >= 1.
;;*          If IJOB = 1, 2 or 4, LIWORK >=  N+2;
;;*          If IJOB = 3 or 5, LIWORK >= MAX(N+2, 2*M*(N-M));
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*            =0: Successful exit.
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            =1: Reordering of (A, B) failed because the transformed
;;*                matrix pair (A, B) would be too far from generalized
;;*                Schur form; the problem is very ill-conditioned.
;;*                (A, B) may have been partially reordered.
;;*                If requested, 0 is returned in DIF(*), PL and PR.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  CTGSEN first collects the selected eigenvalues by computing unitary
;;*  U and W that move them to the top left corner of (A, B). In other
;;*  words, the selected eigenvalues are the eigenvalues of (A11, B11) in
;;*
;;*                U'*(A, B)*W = (A11 A12) (B11 B12) n1
;;*                              ( 0  A22),( 0  B22) n2
;;*                                n1  n2    n1  n2
;;*
;;*  where N = n1+n2 and U' means the conjugate transpose of U. The first
;;*  n1 columns of U and W span the specified pair of left and right
;;*  eigenspaces (deflating subspaces) of (A, B).
;;*
;;*  If (A, B) has been obtained from the generalized real Schur
;;*  decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the
;;*  reordered generalized Schur form of (C, D) is given by
;;*
;;*           (C, D) = (Q*U)*(U'*(A, B)*W)*(Z*W)',
;;*
;;*  and the first n1 columns of Q*U and Z*W span the corresponding
;;*  deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).
;;*
;;*  Note that if the selected eigenvalue is sufficiently ill-conditioned,
;;*  then its value may differ significantly from its value before
;;*  reordering.
;;*
;;*  The reciprocal condition numbers of the left and right eigenspaces
;;*  spanned by the first n1 columns of U and W (or Q*U and Z*W) may
;;*  be returned in DIF(1:2), corresponding to Difu and Difl, resp.
;;*
;;*  The Difu and Difl are defined as:
;;*
;;*       Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
;;*  and
;;*       Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],
;;*
;;*  where sigma-min(Zu) is the smallest singular value of the
;;*  (2*n1*n2)-by-(2*n1*n2) matrix
;;*
;;*       Zu = [ kron(In2, A11)  -kron(A22', In1) ]
;;*            [ kron(In2, B11)  -kron(B22', In1) ].
;;*
;;*  Here, Inx is the identity matrix of size nx and A22' is the
;;*  transpose of A22. kron(X, Y) is the Kronecker product between
;;*  the matrices X and Y.
;;*
;;*  When DIF(2) is small, small changes in (A, B) can cause large changes
;;*  in the deflating subspace. An approximate (asymptotic) bound on the
;;*  maximum angular error in the computed deflating subspaces is
;;*
;;*       EPS * norm((A, B)) / DIF(2),
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal norm of the projectors on the left and right
;;*  eigenspaces associated with (A11, B11) may be returned in PL and PR.
;;*  They are computed as follows. First we compute L and R so that
;;*  P*(A, B)*Q is block diagonal, where
;;*
;;*       P = ( I -L ) n1           Q = ( I R ) n1
;;*           ( 0  I ) n2    and        ( 0 I ) n2
;;*             n1 n2                    n1 n2
;;*
;;*  and (L, R) is the solution to the generalized Sylvester equation
;;*
;;*       A11*R - L*A22 = -A12
;;*       B11*R - L*B22 = -B12
;;*
;;*  Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2).
;;*  An approximate (asymptotic) bound on the average absolute error of
;;*  the selected eigenvalues is
;;*
;;*       EPS * norm((A, B)) / PL.
;;*
;;*  There are also global error bounds which valid for perturbations up
;;*  to a certain restriction:  A lower bound (x) on the smallest
;;*  F-norm(E,F) for which an eigenvalue of (A11, B11) may move and
;;*  coalesce with an eigenvalue of (A22, B22) under perturbation (E,F),
;;*  (i.e. (A + E, B + F), is
;;*
;;*   x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).
;;*
;;*  An approximate bound on x can be computed from DIF(1:2), PL and PR.
;;*
;;*  If y = ( F-norm(E,F) / x) <= 1, the angles between the perturbed
;;*  (L', R') and unperturbed (L, R) left and right deflating subspaces
;;*  associated with the selected cluster in the (1,1)-blocks can be
;;*  bounded as
;;*
;;*   max-angle(L, L') <= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2))
;;*   max-angle(R, R') <= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))
;;*
;;*  See LAPACK User's Guide section 4.11 or the following references
;;*  for more information.
;;*
;;*  Note that if the default method for computing the Frobenius-norm-
;;*  based estimate DIF is not wanted (see CLATDF), then the parameter
;;*  IDIFJB (see below) should be changed from 3 to 4 (routine CLATDF
;;*  (IJOB = 2 will be used)). See CTGSYL for more details.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report
;;*      UMINF - 94.04, Department of Computing Science, Umea University,
;;*      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
;;*      To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK working
;;*      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
;;*      1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgsen (ijob  wantq  wantz  select  n  a  lda  b  ldb  alpha  beta  q  ldq  z  ldz  m  pl  pr  dif  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) alpha )
	((-idx2- (-float-)) beta )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) m )
	((-idx0- (-float-)) pl )
	((-idx0- (-float-)) pr )
	((-idx1- (-float-)) dif )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ctgsen_(IDX_PTR($ijob,int), IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($m,int), IDX_PTR($pl,float), IDX_PTR($pr,float), IDX_PTR($dif,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgsja <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <ncycle>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGSJA computes the generalized singular value decomposition (GSVD)
;;*  of two complex upper triangular (or trapezoidal) matrices A and B.
;;*
;;*  On entry, it is assumed that matrices A and B have the following
;;*  forms, which may be obtained by the preprocessing subroutine CGGSVP
;;*  from a general M-by-N matrix A and P-by-N matrix B:
;;*
;;*               N-K-L  K    L
;;*     A =    K ( 0    A12  A13 ) if M-K-L >= 0;
;;*            L ( 0     0   A23 )
;;*        M-K-L ( 0     0    0  )
;;*
;;*             N-K-L  K    L
;;*     A =  K ( 0    A12  A13 ) if M-K-L < 0;
;;*        M-K ( 0     0   A23 )
;;*
;;*             N-K-L  K    L
;;*     B =  L ( 0     0   B13 )
;;*        P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.
;;*
;;*  On exit,
;;*
;;*         U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
;;*
;;*  where U, V and Q are unitary matrices, Z' denotes the conjugate
;;*  transpose of Z, R is a nonsingular upper triangular matrix, and D1
;;*  and D2 are ``diagonal'' matrices, which are of the following
;;*  structures:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                     K  L
;;*         D2 = L   ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                 N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 ) K
;;*              L (  0    0   R22 ) L
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                 K M-K K+L-M
;;*      D1 =   K ( I  0    0   )
;;*           M-K ( 0  C    0   )
;;*
;;*                   K M-K K+L-M
;;*      D2 =   M-K ( 0  S    0   )
;;*           K+L-M ( 0  0    I   )
;;*             P-L ( 0  0    0   )
;;*
;;*                 N-K-L  K   M-K  K+L-M
;;* ( 0 R ) =    K ( 0    R11  R12  R13  )
;;*            M-K ( 0     0   R22  R23  )
;;*          K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*  C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*  S = diag( BETA(K+1),  ... , BETA(M) ),
;;*  C**2 + S**2 = I.
;;*
;;*  R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
;;*      (  0  R22 R23 )
;;*  in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The computation of the unitary transformation matrices U, V or Q
;;*  is optional.  These matrices may either be formed explicitly, or they
;;*  may be postmultiplied into input matrices U1, V1, or Q1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  U must contain a unitary matrix U1 on entry, and
;;*                  the product U1*U is returned;
;;*          = 'I':  U is initialized to the unit matrix, and the
;;*                  unitary matrix U is returned;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  V must contain a unitary matrix V1 on entry, and
;;*                  the product V1*V is returned;
;;*          = 'I':  V is initialized to the unit matrix, and the
;;*                  unitary matrix V is returned;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Q must contain a unitary matrix Q1 on entry, and
;;*                  the product Q1*Q is returned;
;;*          = 'I':  Q is initialized to the unit matrix, and the
;;*                  unitary matrix Q is returned;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  K       (input) INTEGER
;;*  L       (input) INTEGER
;;*          K and L specify the subblocks in the input matrices A and B:
;;*          A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,,N-L+1:N)
;;*          of A and B, whose GSVD is going to be computed by CTGSJA.
;;*          See Further details.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
;;*          matrix R or part of R.  See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
;;*          a part of R.  See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) REAL
;;*  TOLB    (input) REAL
;;*          TOLA and TOLB are the convergence criteria for the Jacobi-
;;*          Kogbetliantz iteration procedure. Generally, they are the
;;*          same as used in the preprocessing step, say
;;*              TOLA = MAX(M,N)*norm(A)*MACHEPS,
;;*              TOLB = MAX(P,N)*norm(B)*MACHEPS.
;;*
;;*  ALPHA   (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = diag(C),
;;*            BETA(K+1:K+L)  = diag(S),
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
;;*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
;;*          Furthermore, if K+L < N,
;;*            ALPHA(K+L+1:N) = 0
;;*            BETA(K+L+1:N)  = 0.
;;*
;;*  U       (input/output) COMPLEX array, dimension (LDU,M)
;;*          On entry, if JOBU = 'U', U must contain a matrix U1 (usually
;;*          the unitary matrix returned by CGGSVP).
;;*          On exit,
;;*          if JOBU = 'I', U contains the unitary matrix U;
;;*          if JOBU = 'U', U contains the product U1*U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (input/output) COMPLEX array, dimension (LDV,P)
;;*          On entry, if JOBV = 'V', V must contain a matrix V1 (usually
;;*          the unitary matrix returned by CGGSVP).
;;*          On exit,
;;*          if JOBV = 'I', V contains the unitary matrix V;
;;*          if JOBV = 'V', V contains the product V1*V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ,N)
;;*          On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
;;*          the unitary matrix returned by CGGSVP).
;;*          On exit,
;;*          if JOBQ = 'I', Q contains the unitary matrix Q;
;;*          if JOBQ = 'Q', Q contains the product Q1*Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  NCYCLE  (output) INTEGER
;;*          The number of cycles required for convergence.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1:  the procedure does not converge after MAXIT cycles.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXIT   INTEGER
;;*          MAXIT specifies the total loops that the iterative procedure
;;*          may take. If after MAXIT cycles, the routine fails to
;;*          converge, we return INFO = 1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  CTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
;;*  min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
;;*  matrix B13 to the form:
;;*
;;*           U1'*A13*Q1 = C1*R1; V1'*B13*Q1 = S1*R1,
;;*
;;*  where U1, V1 and Q1 are unitary matrix, and Z' is the conjugate
;;*  transpose of Z.  C1 and S1 are diagonal matrices satisfying
;;*
;;*                C1**2 + S1**2 = I,
;;*
;;*  and R1 is an L-by-L nonsingular upper triangular matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgsja (jobu  jobv  jobq  m  p  n  k  l  a  lda  b  ldb  tola  tolb  alpha  beta  u  ldu  v  ldv  q  ldq  work  ncycle  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) tola )
	((-idx0- (-float-)) tolb )
	((-idx1- (-float-)) alpha )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) ncycle )
	((-idx0- (-int-)) info )
	#{ ctgsja_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($tola,float), IDX_PTR($tolb,float), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($ncycle,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgsna <job>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <dif>  <mm>  <m>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or eigenvectors of a matrix pair (A, B).
;;*
;;*  (A, B) must be in generalized Schur canonical form, that is, A and
;;*  B are both upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (DIF):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (DIF);
;;*          = 'B': for both eigenvalues and eigenvectors (S and DIF).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the corresponding j-th eigenvalue and/or eigenvector,
;;*          SELECT(j) must be set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the square matrix pair (A, B). N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The upper triangular matrix A in the pair (A,B).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,N)
;;*          The upper triangular matrix B in the pair (A, B).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  VL      (input) COMPLEX array, dimension (LDVL,M)
;;*          IF JOB = 'E' or 'B', VL must contain left eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT.  The eigenvectors must be stored in consecutive
;;*          columns of VL, as returned by CTGEVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL. LDVL >= 1; and
;;*          If JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) COMPLEX array, dimension (LDVR,M)
;;*          IF JOB = 'E' or 'B', VR must contain right eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT.  The eigenvectors must be stored in consecutive
;;*          columns of VR, as returned by CTGEVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR. LDVR >= 1;
;;*          If JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) REAL array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array.
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  DIF     (output) REAL array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array.
;;*          If the eigenvalues cannot be reordered to compute DIF(j),
;;*          DIF(j) is set to 0; this can only occur when the true value
;;*          would be very small anyway.
;;*          For each eigenvalue/vector specified by SELECT, DIF stores
;;*          a Frobenius norm-based estimate of Difl.
;;*          If JOB = 'E', DIF is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S and DIF. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and DIF used to store
;;*          the specified condition numbers; for each selected eigenvalue
;;*          one element is used. If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          If JOB = 'E', WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK  (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          If JOB = 'V' or 'B', LWORK >= 2*N*N.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N+2)
;;*          If JOB = 'E', IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: Successful exit
;;*          < 0: If INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of the i-th generalized
;;*  eigenvalue w = (a, b) is defined as
;;*
;;*          S(I) = (|v'Au|**2 + |v'Bu|**2)**(1/2) / (norm(u)*norm(v))
;;*
;;*  where u and v are the right and left eigenvectors of (A, B)
;;*  corresponding to w; |z| denotes the absolute value of the complex
;;*  number, and norm(u) denotes the 2-norm of the vector u. The pair
;;*  (a, b) corresponds to an eigenvalue w = a/b (= v'Au/v'Bu) of the
;;*  matrix pair (A, B). If both a and b equal zero, then (A,B) is
;;*  singular and S(I) = -1 is returned.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*          chord(w, lambda) <=   EPS * norm(A, B) / S(I),
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number of the right eigenvector u
;;*  and left eigenvector v corresponding to the generalized eigenvalue w
;;*  is defined as follows. Suppose
;;*
;;*                   (A, B) = ( a   *  ) ( b  *  )  1
;;*                            ( 0  A22 ),( 0 B22 )  n-1
;;*                              1  n-1     1 n-1
;;*
;;*  Then the reciprocal condition number DIF(I) is
;;*
;;*          Difl[(a, b), (A22, B22)]  = sigma-min( Zl )
;;*
;;*  where sigma-min(Zl) denotes the smallest singular value of
;;*
;;*         Zl = [ kron(a, In-1) -kron(1, A22) ]
;;*              [ kron(b, In-1) -kron(1, B22) ].
;;*
;;*  Here In-1 is the identity matrix of size n-1 and X' is the conjugate
;;*  transpose of X. kron(X, Y) is the Kronecker product between the
;;*  matrices X and Y.
;;*
;;*  We approximate the smallest singular value of Zl with an upper
;;*  bound. This is done by CLATDF.
;;*
;;*  An approximate error bound for a computed eigenvector VL(i) or
;;*  VR(i) is given by
;;*
;;*                      EPS * norm(A, B) / DIF(i).
;;*
;;*  See ref. [2-3] for more details and further references.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report
;;*      UMINF - 94.04, Department of Computing Science, Umea University,
;;*      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
;;*      To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.
;;*      To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgsna (job  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  s  dif  mm  m  work  lwork  iwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) dif )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ctgsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($s,float), IDX_PTR($dif,float), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgsy2 <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <rdsum>  <rdscal>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGSY2 solves the generalized Sylvester equation
;;*
;;*              A * R - L * B = scale *   C               (1)
;;*              D * R - L * E = scale * F
;;*
;;*  using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
;;*  (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
;;*  N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
;;*  (i.e., (A,D) and (B,E) in generalized Schur form).
;;*
;;*  The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
;;*  scaling factor chosen to avoid overflow.
;;*
;;*  In matrix notation solving equation (1) corresponds to solve
;;*  Zx = scale * b, where Z is defined as
;;*
;;*         Z = [ kron(In, A)  -kron(B', Im) ]             (2)
;;*             [ kron(In, D)  -kron(E', Im) ],
;;*
;;*  Ik is the identity matrix of size k and X' is the transpose of X.
;;*  kron(X, Y) is the Kronecker product between the matrices X and Y.
;;*
;;*  If TRANS = 'C', y in the conjugate transposed system Z'y = scale*b
;;*  is solved for, which is equivalent to solve for R and L in
;;*
;;*              A' * R  + D' * L   = scale *  C           (3)
;;*              R  * B' + L  * E'  = scale * -F
;;*
;;*  This case is used to compute an estimate of Dif[(A, D), (B, E)] =
;;*  = sigma_min(Z) using reverse communicaton with CLACON.
;;*
;;*  CTGSY2 also (IJOB >= 1) contributes to the computation in CTGSYL
;;*  of an upper bound on the separation between to matrix pairs. Then
;;*  the input (A, D), (B, E) are sub-pencils of two matrix pairs in
;;*  CTGSYL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N', solve the generalized Sylvester equation (1).
;;*          = 'T': solve the 'transposed' system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*          =0: solve (1) only.
;;*          =1: A contribution from this subsystem to a Frobenius
;;*              norm-based estimate of the separation between two matrix
;;*              pairs is computed. (look ahead strategy is used).
;;*          =2: A contribution from this subsystem to a Frobenius
;;*              norm-based estimate of the separation between two matrix
;;*              pairs is computed. (SGECON on sub-systems is used.)
;;*          Not referenced if TRANS = 'T'.
;;*
;;*  M       (input) INTEGER
;;*          On entry, M specifies the order of A and D, and the row
;;*          dimension of C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the order of B and E, and the column
;;*          dimension of C, F, R and L.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA, M)
;;*          On entry, A contains an upper triangular matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the matrix A. LDA >= max(1, M).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB, N)
;;*          On entry, B contains an upper triangular matrix.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the matrix B. LDB >= max(1, N).
;;*
;;*  C       (input/ output) COMPLEX array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, C has been overwritten by the solution
;;*          R.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the matrix C. LDC >= max(1, M).
;;*
;;*  D       (input) COMPLEX array, dimension (LDD, M)
;;*          On entry, D contains an upper triangular matrix.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the matrix D. LDD >= max(1, M).
;;*
;;*  E       (input) COMPLEX array, dimension (LDE, N)
;;*          On entry, E contains an upper triangular matrix.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the matrix E. LDE >= max(1, N).
;;*
;;*  F       (input/ output) COMPLEX array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, F has been overwritten by the solution
;;*          L.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the matrix F. LDF >= max(1, M).
;;*
;;*  SCALE   (output) REAL
;;*          On exit, 0 <= SCALE <= 1. If 0 < SCALE < 1, the solutions
;;*          R and L (C and F on entry) will hold the solutions to a
;;*          slightly perturbed system but the input matrices A, B, D and
;;*          E have not been changed. If SCALE = 0, R and L will hold the
;;*          solutions to the homogeneous system with C = F = 0.
;;*          Normally, SCALE = 1.
;;*
;;*  RDSUM   (input/output) REAL
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by CTGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when CTGSY2 is called by
;;*          CTGSYL.
;;*
;;*  RDSCAL  (input/output) REAL
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when CTGSY2 is called by
;;*          CTGSYL.
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, if INFO is set to
;;*            =0: Successful exit
;;*            <0: If INFO = -i, input argument number i is illegal.
;;*            >0: The matrix pairs (A, D) and (B, E) have common or very
;;*                close eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgsy2 (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  rdsum  rdscal  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-float-)) d )
	((-idx0- (-int-)) ldd )
	((-idx3- (-float-)) e )
	((-idx0- (-int-)) lde )
	((-idx3- (-float-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) rdsum )
	((-idx0- (-float-)) rdscal )
	((-idx0- (-int-)) info )
	#{ ctgsy2_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($d,float), IDX_PTR($ldd,int), IDX_PTR($e,float), IDX_PTR($lde,int), IDX_PTR($f,float), IDX_PTR($ldf,int), IDX_PTR($scale,float), IDX_PTR($rdsum,float), IDX_PTR($rdscal,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctgsyl <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <dif>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTGSYL solves the generalized Sylvester equation:
;;*
;;*              A * R - L * B = scale * C            (1)
;;*              D * R - L * E = scale * F
;;*
;;*  where R and L are unknown m-by-n matrices, (A, D), (B, E) and
;;*  (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
;;*  respectively, with complex entries. A, B, D and E are upper
;;*  triangular (i.e., (A,D) and (B,E) in generalized Schur form).
;;*
;;*  The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
;;*  is an output scaling factor chosen to avoid overflow.
;;*
;;*  In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
;;*  is defined as
;;*
;;*         Z = [ kron(In, A)  -kron(B', Im) ]        (2)
;;*             [ kron(In, D)  -kron(E', Im) ],
;;*
;;*  Here Ix is the identity matrix of size x and X' is the conjugate
;;*  transpose of X. Kron(X, Y) is the Kronecker product between the
;;*  matrices X and Y.
;;*
;;*  If TRANS = 'C', y in the conjugate transposed system Z'*y = scale*b
;;*  is solved for, which is equivalent to solve for R and L in
;;*
;;*              A' * R + D' * L = scale * C           (3)
;;*              R * B' + L * E' = scale * -F
;;*
;;*  This case (TRANS = 'C') is used to compute an one-norm-based estimate
;;*  of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
;;*  and (B,E), using CLACON.
;;*
;;*  If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of
;;*  Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
;;*  reciprocal of the smallest singular value of Z.
;;*
;;*  This is a level-3 BLAS algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': solve the generalized sylvester equation (1).
;;*          = 'C': solve the "conjugate transposed" system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*          =0: solve (1) only.
;;*          =1: The functionality of 0 and 3.
;;*          =2: The functionality of 0 and 4.
;;*          =3: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*              (look ahead strategy is used).
;;*          =4: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*              (CGECON on sub-systems is used).
;;*          Not referenced if TRANS = 'C'.
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrices A and D, and the row dimension of
;;*          the matrices C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices B and E, and the column dimension
;;*          of the matrices C, F, R and L.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA, M)
;;*          The upper triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1, M).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB, N)
;;*          The upper triangular matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1, N).
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, C has been overwritten by
;;*          the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1, M).
;;*
;;*  D       (input) COMPLEX array, dimension (LDD, M)
;;*          The upper triangular matrix D.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the array D. LDD >= max(1, M).
;;*
;;*  E       (input) COMPLEX array, dimension (LDE, N)
;;*          The upper triangular matrix E.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the array E. LDE >= max(1, N).
;;*
;;*  F       (input/output) COMPLEX array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, F has been overwritten by
;;*          the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1, M).
;;*
;;*  DIF     (output) REAL
;;*          On exit DIF is the reciprocal of a lower bound of the
;;*          reciprocal of the Dif-function, i.e. DIF is an upper bound of
;;*          Dif[(A,D), (B,E)] = sigma-min(Z), where Z as in (2).
;;*          IF IJOB = 0 or TRANS = 'C', DIF is not referenced.
;;*
;;*  SCALE   (output) REAL
;;*          On exit SCALE is the scaling factor in (1) or (3).
;;*          If 0 < SCALE < 1, C and F hold the solutions R and L, resp.,
;;*          to a slightly perturbed system but the input matrices A, B,
;;*          D and E have not been changed. If SCALE = 0, R and L will
;;*          hold the solutions to the homogenious system with C = F = 0.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          IF IJOB = 0, WORK is not referenced.  Otherwise,
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK > = 1.
;;*          If IJOB = 1 or 2 and TRANS = 'N', LWORK >= 2*M*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (M+N+2)
;;*          If IJOB = 0, IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*            =0: successful exit
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            >0: (A, D) and (B, E) have common or very close
;;*                eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
;;*      No 1, 1996.
;;*
;;*  [2] B. Kagstrom, A Perturbation Analysis of the Generalized Sylvester
;;*      Equation (AR - LB, DR - LE ) = (C, F), SIAM J. Matrix Anal.
;;*      Appl., 15(4):1045-1060, 1994.
;;*
;;*  [3] B. Kagstrom and L. Westin, Generalized Schur Methods with
;;*      Condition Estimators for Solving the Generalized Sylvester
;;*      Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7,
;;*      July 1989, pp 745-751.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctgsyl (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  dif  work  lwork  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-float-)) d )
	((-idx0- (-int-)) ldd )
	((-idx3- (-float-)) e )
	((-idx0- (-int-)) lde )
	((-idx3- (-float-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) dif )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ctgsyl_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($d,float), IDX_PTR($ldd,int), IDX_PTR($e,float), IDX_PTR($lde,int), IDX_PTR($f,float), IDX_PTR($ldf,int), IDX_PTR($scale,float), IDX_PTR($dif,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctpcon <norm>  <uplo>  <diag>  <n>  <ap>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTPCON estimates the reciprocal of the condition number of a packed
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctpcon (norm  uplo  diag  n  ap  rcond  work  rwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctpcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctprfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTPRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular packed
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by CTPTRS or some other
;;*  means before entering this routine.  CTPRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B. 
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) COMPLEX array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctprfs (uplo  trans  diag  n  nrhs  ap  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctprfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctptri <uplo>  <diag>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTPTRI computes the inverse of a complex upper or lower triangular
;;*  matrix A stored in packed format.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangular matrix A, stored
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same packed storage format.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular
;;*                matrix is singular and its inverse can not be computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  A triangular matrix A can be transferred to packed storage using one
;;*  of the following program segments:
;;*
;;*  UPLO = 'U':                      UPLO = 'L':
;;*
;;*        JC = 1                           JC = 1
;;*        DO 2 J = 1, N                    DO 2 J = 1, N
;;*           DO 1 I = 1, J                    DO 1 I = J, N
;;*              AP(JC+I-1) = A(I,J)              AP(JC+I-J) = A(I,J)
;;*      1    CONTINUE                    1    CONTINUE
;;*           JC = JC + J                      JC = JC + N - J + 1
;;*      2 CONTINUE                       2 CONTINUE
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctptri (uplo  diag  n  ap  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx0- (-int-)) info )
	#{ ctptri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctptrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTPTRS solves a triangular system of the form
;;*
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*
;;*  where A is a triangular matrix of order N stored in packed format,
;;*  and B is an N-by-NRHS matrix.  A check is made to verify that A is
;;*  nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctptrs (uplo  trans  diag  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ap )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ctptrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrcon <norm>  <uplo>  <diag>  <n>  <a>  <lda>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRCON estimates the reciprocal of the condition number of a
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrcon (norm  uplo  diag  n  a  lda  rcond  work  rwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) rcond )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctrcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrevc <side>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTREVC computes some or all of the right and/or left eigenvectors of
;;*  a complex upper triangular matrix T.
;;*
;;*  The right eigenvector x and the left eigenvector y of T corresponding
;;*  to an eigenvalue w are defined by:
;;*
;;*               T*x = w*x,     y'*T = w*y'
;;*
;;*  where y' denotes the conjugate transpose of the vector y.
;;*
;;*  If all eigenvectors are requested, the routine may either return the
;;*  matrices X and/or Y of right or left eigenvectors of T, or the
;;*  products Q*X and/or Q*Y, where Q is an input unitary
;;*  matrix. If T was obtained from the Schur factorization of an
;;*  original matrix A = Q*T*Q', then Q*X and Q*Y are the matrices of
;;*  right or left eigenvectors of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  compute right eigenvectors only;
;;*          = 'L':  compute left eigenvectors only;
;;*          = 'B':  compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A':  compute all right and/or left eigenvectors;
;;*          = 'B':  compute all right and/or left eigenvectors,
;;*                  and backtransform them using the input matrices
;;*                  supplied in VR and/or VL;
;;*          = 'S':  compute selected right and/or left eigenvectors,
;;*                  specified by the logical array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY = 'A' or 'B', SELECT is not referenced.
;;*          To select the eigenvector corresponding to the j-th
;;*          eigenvalue, SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) COMPLEX array, dimension (LDT,N)
;;*          The upper triangular matrix T.  T is modified, but restored
;;*          on exit.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input/output) COMPLEX array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Q of
;;*          Schur vectors returned by CHSEQR).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
;;*                           VL is lower triangular. The i-th column
;;*                           VL(i) of VL is the eigenvector corresponding
;;*                           to T(i,i).
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VL, in the same order as their
;;*                           eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= max(1,N) if
;;*          SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) COMPLEX array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Q of
;;*          Schur vectors returned by CHSEQR).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of T;
;;*                           VR is upper triangular. The i-th column
;;*                           VR(i) of VR is the eigenvector corresponding
;;*                           to T(i,i).
;;*          if HOWMNY = 'B', the matrix Q*X;
;;*          if HOWMNY = 'S', the right eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VR, in the same order as their
;;*                           eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= max(1,N) if
;;*           SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
;;*          is set to N.  Each selected eigenvector occupies one
;;*          column.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The algorithm used in this program is basically backward (forward)
;;*  substitution, with scaling to make the the code robust against
;;*  possible overflow.
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x| + |y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrevc (side  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  mm  m  work  rwork  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctrevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrexc <compq>  <n>  <t_>  <ldt>  <q>  <ldq>  <ifst>  <ilst>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTREXC reorders the Schur factorization of a complex matrix
;;*  A = Q*T*Q**H, so that the diagonal element of T with row index IFST
;;*  is moved to row ILST.
;;*
;;*  The Schur form T is reordered by a unitary similarity transformation
;;*  Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
;;*  postmultplying it with Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V':  update the matrix Q of Schur vectors;
;;*          = 'N':  do not update Q.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) COMPLEX array, dimension (LDT,N)
;;*          On entry, the upper triangular matrix T.
;;*          On exit, the reordered upper triangular matrix.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          unitary transformation matrix Z which reorders T.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  IFST    (input) INTEGER
;;*  ILST    (input) INTEGER
;;*          Specify the reordering of the diagonal elements of T:
;;*          The element with row index IFST is moved to row ILST by a
;;*          sequence of transpositions between adjacent elements.
;;*          1 <= IFST <= N; 1 <= ILST <= N.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ctrexc (compq  n  t_  ldt  q  ldq  ifst  ilst  info  )
	((-str-) compq )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx0- (-int-)) info )
	#{ ctrexc_($compq->data, IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrrfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by CTRTRS or some other
;;*  means before entering this routine.  CTRRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) COMPLEX array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (2*N)
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrrfs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx2- (-float-)) work )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctrrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrsen <job>  <compq>  <select>  <n>  <t_>  <ldt>  <q>  <ldq>  <w>  <m>  <s>  <sep>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRSEN reorders the Schur factorization of a complex matrix
;;*  A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
;;*  the leading positions on the diagonal of the upper triangular matrix
;;*  T, and the leading columns of Q form an orthonormal basis of the
;;*  corresponding right invariant subspace.
;;*
;;*  Optionally the routine computes the reciprocal condition numbers of
;;*  the cluster of eigenvalues and/or the invariant subspace.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (S) or the invariant subspace (SEP):
;;*          = 'N': none;
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for invariant subspace only (SEP);
;;*          = 'B': for both eigenvalues and invariant subspace (S and
;;*                 SEP).
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V': update the matrix Q of Schur vectors;
;;*          = 'N': do not update Q.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster. To
;;*          select the j-th eigenvalue, SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) COMPLEX array, dimension (LDT,N)
;;*          On entry, the upper triangular matrix T.
;;*          On exit, T is overwritten by the reordered matrix T, with the
;;*          selected eigenvalues as the leading diagonal elements.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          unitary transformation matrix which reorders T; the leading M
;;*          columns of Q form an orthonormal basis for the specified
;;*          invariant subspace.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1; and if COMPQ = 'V', LDQ >= N.
;;*
;;*  W       (output) COMPLEX array, dimension (N)
;;*          The reordered eigenvalues of T, in the same order as they
;;*          appear on the diagonal of T.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified invariant subspace.
;;*          0 <= M <= N.
;;*
;;*  S       (output) REAL
;;*          If JOB = 'E' or 'B', S is a lower bound on the reciprocal
;;*          condition number for the selected cluster of eigenvalues.
;;*          S cannot underestimate the true reciprocal condition number
;;*          by more than a factor of sqrt(N). If M = 0 or N, S = 1.
;;*          If JOB = 'N' or 'V', S is not referenced.
;;*
;;*  SEP     (output) REAL
;;*          If JOB = 'V' or 'B', SEP is the estimated reciprocal
;;*          condition number of the specified invariant subspace. If
;;*          M = 0 or N, SEP = norm(T).
;;*          If JOB = 'N' or 'E', SEP is not referenced.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          If JOB = 'N', WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If JOB = 'N', LWORK >= 1;
;;*          if JOB = 'E', LWORK = M*(N-M);
;;*          if JOB = 'V' or 'B', LWORK >= 2*M*(N-M).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  CTRSEN first collects the selected eigenvalues by computing a unitary
;;*  transformation Z to move them to the top left corner of T. In other
;;*  words, the selected eigenvalues are the eigenvalues of T11 in:
;;*
;;*                Z'*T*Z = ( T11 T12 ) n1
;;*                         (  0  T22 ) n2
;;*                            n1  n2
;;*
;;*  where N = n1+n2 and Z' means the conjugate transpose of Z. The first
;;*  n1 columns of Z span the specified invariant subspace of T.
;;*
;;*  If T has been obtained from the Schur factorization of a matrix
;;*  A = Q*T*Q', then the reordered Schur factorization of A is given by
;;*  A = (Q*Z)*(Z'*T*Z)*(Q*Z)', and the first n1 columns of Q*Z span the
;;*  corresponding invariant subspace of A.
;;*
;;*  The reciprocal condition number of the average of the eigenvalues of
;;*  T11 may be returned in S. S lies between 0 (very badly conditioned)
;;*  and 1 (very well conditioned). It is computed as follows. First we
;;*  compute R so that
;;*
;;*                         P = ( I  R ) n1
;;*                             ( 0  0 ) n2
;;*                               n1 n2
;;*
;;*  is the projector on the invariant subspace associated with T11.
;;*  R is the solution of the Sylvester equation:
;;*
;;*                        T11*R - R*T22 = T12.
;;*
;;*  Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
;;*  the two-norm of M. Then S is computed as the lower bound
;;*
;;*                      (1 + F-norm(R)**2)**(-1/2)
;;*
;;*  on the reciprocal of 2-norm(P), the true reciprocal condition number.
;;*  S cannot underestimate 1 / 2-norm(P) by more than a factor of
;;*  sqrt(N).
;;*
;;*  An approximate error bound for the computed average of the
;;*  eigenvalues of T11 is
;;*
;;*                         EPS * norm(T) / S
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal condition number of the right invariant subspace
;;*  spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
;;*  SEP is defined as the separation of T11 and T22:
;;*
;;*                     sep( T11, T22 ) = sigma-min( C )
;;*
;;*  where sigma-min(C) is the smallest singular value of the
;;*  n1*n2-by-n1*n2 matrix
;;*
;;*     C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )
;;*
;;*  I(m) is an m by m identity matrix, and kprod denotes the Kronecker
;;*  product. We estimate sigma-min(C) by the reciprocal of an estimate of
;;*  the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
;;*  cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).
;;*
;;*  When SEP is small, small changes in T can cause large changes in
;;*  the invariant subspace. An approximate bound on the maximum angular
;;*  error in the computed right invariant subspace is
;;*
;;*                      EPS * norm(T) / SEP
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrsen (job  compq  select  n  t_  ldt  q  ldq  w  m  s  sep  work  lwork  info  )
	((-str-) job )
	((-str-) compq )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) w )
	((-idx0- (-int-)) m )
	((-idx0- (-float-)) s )
	((-idx0- (-float-)) sep )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ctrsen_($job->data, $compq->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($w,float), IDX_PTR($m,int), IDX_PTR($s,float), IDX_PTR($sep,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrsna <job>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <sep>  <mm>  <m>  <work>  <ldwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or right eigenvectors of a complex upper triangular
;;*  matrix T (or of any matrix Q*T*Q**H with Q unitary).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (SEP):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (SEP);
;;*          = 'B': for both eigenvalues and eigenvectors (S and SEP).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the j-th eigenpair, SELECT(j) must be set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input) COMPLEX array, dimension (LDT,N)
;;*          The upper triangular matrix T.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input) COMPLEX array, dimension (LDVL,M)
;;*          If JOB = 'E' or 'B', VL must contain left eigenvectors of T
;;*          (or of any Q*T*Q**H with Q unitary), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VL, as returned by
;;*          CHSEIN or CTREVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) COMPLEX array, dimension (LDVR,M)
;;*          If JOB = 'E' or 'B', VR must contain right eigenvectors of T
;;*          (or of any Q*T*Q**H with Q unitary), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VR, as returned by
;;*          CHSEIN or CTREVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) REAL array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array. Thus S(j), SEP(j), and the j-th columns of VL and VR
;;*          all correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  SEP     (output) REAL array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array.
;;*          If JOB = 'E', SEP is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S (if JOB = 'E' or 'B')
;;*           and/or SEP (if JOB = 'V' or 'B'). MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and/or SEP actually
;;*          used to store the estimated condition numbers.
;;*          If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (LDWORK,N+1)
;;*          If JOB = 'E', WORK is not referenced.
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N.
;;*
;;*  RWORK   (workspace) REAL array, dimension (N)
;;*          If JOB = 'E', RWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of an eigenvalue lambda is
;;*  defined as
;;*
;;*          S(lambda) = |v'*u| / (norm(u)*norm(v))
;;*
;;*  where u and v are the right and left eigenvectors of T corresponding
;;*  to lambda; v' denotes the conjugate transpose of v, and norm(u)
;;*  denotes the Euclidean norm. These reciprocal condition numbers always
;;*  lie between zero (very badly conditioned) and one (very well
;;*  conditioned). If n = 1, S(lambda) is defined to be 1.
;;*
;;*  An approximate error bound for a computed eigenvalue W(i) is given by
;;*
;;*                      EPS * norm(T) / S(i)
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number of the right eigenvector u
;;*  corresponding to lambda is defined as follows. Suppose
;;*
;;*              T = ( lambda  c  )
;;*                  (   0    T22 )
;;*
;;*  Then the reciprocal condition number is
;;*
;;*          SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )
;;*
;;*  where sigma-min denotes the smallest singular value. We approximate
;;*  the smallest singular value by the reciprocal of an estimate of the
;;*  one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is
;;*  defined to be abs(T(1,1)).
;;*
;;*  An approximate error bound for a computed right eigenvector VR(i)
;;*  is given by
;;*
;;*                      EPS * norm(T) / SEP(i)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrsna (job  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  s  sep  mm  m  work  ldwork  rwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) sep )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx3- (-float-)) work )
	((-idx0- (-int-)) ldwork )
	((-idx1- (-float-)) rwork )
	((-idx0- (-int-)) info )
	#{ ctrsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($s,float), IDX_PTR($sep,float), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($ldwork,int), IDX_PTR($rwork,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrsyl <trana>  <tranb>  <isgn>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRSYL solves the complex Sylvester matrix equation:
;;*
;;*     op(A)*X + X*op(B) = scale*C or
;;*     op(A)*X - X*op(B) = scale*C,
;;*
;;*  where op(A) = A or A**H, and A and B are both upper triangular. A is
;;*  M-by-M and B is N-by-N; the right hand side C and the solution X are
;;*  M-by-N; and scale is an output scale factor, set <= 1 to avoid
;;*  overflow in X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANA   (input) CHARACTER*1
;;*          Specifies the option op(A):
;;*          = 'N': op(A) = A    (No transpose)
;;*          = 'C': op(A) = A**H (Conjugate transpose)
;;*
;;*  TRANB   (input) CHARACTER*1
;;*          Specifies the option op(B):
;;*          = 'N': op(B) = B    (No transpose)
;;*          = 'C': op(B) = B**H (Conjugate transpose)
;;*
;;*  ISGN    (input) INTEGER
;;*          Specifies the sign in the equation:
;;*          = +1: solve op(A)*X + X*op(B) = scale*C
;;*          = -1: solve op(A)*X - X*op(B) = scale*C
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrix A, and the number of rows in the
;;*          matrices X and C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B, and the number of columns in the
;;*          matrices X and C. N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,M)
;;*          The upper triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input) COMPLEX array, dimension (LDB,N)
;;*          The upper triangular matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N right hand side matrix C.
;;*          On exit, C is overwritten by the solution matrix X.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M)
;;*
;;*  SCALE   (output) REAL
;;*          The scale factor, scale, set <= 1 to avoid overflow in X.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1: A and B have common or very close eigenvalues; perturbed
;;*               values were used to solve the equation (but the matrices
;;*               A and B are unchanged).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrsyl (trana  tranb  isgn  m  n  a  lda  b  ldb  c  ldc  scale  info  )
	((-str-) trana )
	((-str-) tranb )
	((-idx0- (-int-)) isgn )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx0- (-float-)) scale )
	((-idx0- (-int-)) info )
	#{ ctrsyl_($trana->data, $tranb->data, IDX_PTR($isgn,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($scale,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrti2 <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRTI2 computes the inverse of a complex upper or lower triangular
;;*  matrix.
;;*
;;*  This is the Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading n by n upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrti2 (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ ctrti2_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrtri <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRTRI computes the inverse of a complex upper or lower triangular
;;*  matrix A.
;;*
;;*  This is the Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
;;*               matrix is singular and its inverse can not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrtri (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ ctrtri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctrtrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTRTRS solves a triangular system of the form
;;*
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*
;;*  where A is a triangular matrix of order N, and B is an N-by-NRHS
;;*  matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the i-th diagonal element of A is zero,
;;*               indicating that the matrix is singular and the solutions
;;*               X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrtrs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ctrtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctzrqf <m>  <n>  <a>  <lda>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine CTZRZF.
;;*
;;*  CTZRQF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
;;*  to upper triangular form by means of unitary transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N unitary matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= M.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          unitary matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The  factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), whose conjugate transpose is used to
;;*  introduce zeros into the (m - k + 1)th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctzrqf (m  n  a  lda  tau  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ ctzrqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ctzrzf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
;;*  to upper triangular form by means of unitary transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N unitary matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          unitary matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctzrzf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ctzrzf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cung2l <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNG2L generates an m by n complex matrix Q with orthonormal columns,
;;*  which is defined as the last n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by CGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by CGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQLF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cung2l (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cung2l_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cung2r <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNG2R generates an m by n complex matrix Q with orthonormal columns,
;;*  which is defined as the first n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by CGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by CGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQRF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cung2r (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cung2r_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungbr <vect>  <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGBR generates one of the complex unitary matrices Q or P**H
;;*  determined by CGEBRD when reducing a complex matrix A to bidiagonal
;;*  form: A = Q * B * P**H.  Q and P**H are defined as products of
;;*  elementary reflectors H(i) or G(i) respectively.
;;*
;;*  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
;;*  is of order M:
;;*  if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
;;*  columns of Q, where m >= n >= k;
;;*  if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
;;*  M-by-M matrix.
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
;;*  is of order N:
;;*  if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
;;*  rows of P**H, where n >= m >= k;
;;*  if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
;;*  an N-by-N matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether the matrix Q or the matrix P**H is
;;*          required, as defined in the transformation applied by CGEBRD:
;;*          = 'Q':  generate Q;
;;*          = 'P':  generate P**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q or P**H to be returned.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q or P**H to be returned.
;;*          N >= 0.
;;*          If VECT = 'Q', M >= N >= min(M,K);
;;*          if VECT = 'P', N >= M >= min(N,K).
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original M-by-K
;;*          matrix reduced by CGEBRD.
;;*          If VECT = 'P', the number of rows in the original K-by-N
;;*          matrix reduced by CGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by CGEBRD.
;;*          On exit, the M-by-N matrix Q or P**H.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= M.
;;*
;;*  TAU     (input) COMPLEX array, dimension
;;*                                (min(M,K)) if VECT = 'Q'
;;*                                (min(N,K)) if VECT = 'P'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i), which determines Q or P**H, as
;;*          returned by CGEBRD in its array argument TAUQ or TAUP.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,min(M,N)).
;;*          For optimum performance LWORK >= min(M,N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungbr (vect  m  n  k  a  lda  tau  work  lwork  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cungbr_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunghr <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGHR generates a complex unitary matrix Q which is defined as the
;;*  product of IHI-ILO elementary reflectors of order N, as returned by
;;*  CGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of CGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by CGEHRD.
;;*          On exit, the N-by-N unitary matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEHRD.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= IHI-ILO.
;;*          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunghr (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunghr_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungl2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
;;*  which is defined as the first m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by CGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by CGELQF in the first k rows of its array argument A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGELQF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungl2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cungl2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunglq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
;;*  which is defined as the first M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by CGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by CGELQF in the first k rows of its array argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGELQF.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit;
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunglq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunglq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungql <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
;;*  which is defined as the last N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by CGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by CGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQLF.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungql (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cungql_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungqr <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
;;*  which is defined as the first N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by CGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by CGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQRF.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungqr (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cungqr_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungr2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGR2 generates an m by n complex matrix Q with orthonormal rows,
;;*  which is defined as the last m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by CGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by CGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGERQF.
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungr2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cungr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungrq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
;;*  which is defined as the last M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by CGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by CGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGERQF.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungrq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cungrq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cungtr <uplo>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNGTR generates a complex unitary matrix Q which is defined as the
;;*  product of n-1 elementary reflectors of order N, as returned by
;;*  CHETRD:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from CHETRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from CHETRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  A       (input/output) COMPLEX array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by CHETRD.
;;*          On exit, the N-by-N unitary matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= N.
;;*
;;*  TAU     (input) COMPLEX array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CHETRD.
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= N-1.
;;*          For optimum performance LWORK >= (N-1)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cungtr (uplo  n  a  lda  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cungtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunm2l <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNM2L overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQLF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunm2l (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cunm2l_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunm2r <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNM2R overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQRF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunm2r (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cunm2r_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmbr <vect>  <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      P * C          C * P
;;*  TRANS = 'C':      P**H * C       C * P**H
;;*
;;*  Here Q and P**H are the unitary matrices determined by CGEBRD when
;;*  reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
;;*  and P**H are defined as products of elementary reflectors H(i) and
;;*  G(i) respectively.
;;*
;;*  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
;;*  order of the unitary matrix Q or P**H that is applied.
;;*
;;*  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
;;*  if nq >= k, Q = H(1) H(2) . . . H(k);
;;*  if nq < k, Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
;;*  if k < nq, P = G(1) G(2) . . . G(k);
;;*  if k >= nq, P = G(1) G(2) . . . G(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'Q': apply Q or Q**H;
;;*          = 'P': apply P or P**H.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q, Q**H, P or P**H from the Left;
;;*          = 'R': apply Q, Q**H, P or P**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q or P;
;;*          = 'C':  Conjugate transpose, apply Q**H or P**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original
;;*          matrix reduced by CGEBRD.
;;*          If VECT = 'P', the number of rows in the original
;;*          matrix reduced by CGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                                (LDA,min(nq,K)) if VECT = 'Q'
;;*                                (LDA,nq)        if VECT = 'P'
;;*          The vectors which define the elementary reflectors H(i) and
;;*          G(i), whose products determine the matrices Q and P, as
;;*          returned by CGEBRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If VECT = 'Q', LDA >= max(1,nq);
;;*          if VECT = 'P', LDA >= max(1,min(nq,K)).
;;*
;;*  TAU     (input) COMPLEX array, dimension (min(nq,K))
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i) which determines Q or P, as returned
;;*          by CGEBRD in the array argument TAUQ or TAUP.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
;;*          or P*C or P**H*C or C*P or C*P**H.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cunmbr (vect  side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) vect )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmbr_($vect->data, $side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmhr <side>  <trans>  <m>  <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMHR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  IHI-ILO elementary reflectors, as returned by CGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q**H (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of CGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
;;*          ILO = 1 and IHI = 0, if M = 0;
;;*          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
;;*          ILO = 1 and IHI = 0, if N = 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by CGEHRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) COMPLEX array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEHRD.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cunmhr (side  trans  m  n  ilo  ihi  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmhr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunml2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNML2 overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGELQF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunml2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cunml2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmlq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMLQ overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGELQF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunmlq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmlq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmql <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMQL overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQLF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunmql (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmql_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmqr <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMQR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGEQRF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunmqr (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmqr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmr2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMR2 overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by CGERQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGERQF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunmr2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cunmr2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmr3 <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMR3 overwrites the general complex m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by CTZRZF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CTZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CTZRZF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cunmr3 (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cunmr3_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmrq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMRQ overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CGERQF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunmrq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmrq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmrz <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMRZ overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          CTZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CTZRZF.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cunmrz (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmrz_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cunmtr <side>  <uplo>  <trans>  <m>  <n>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUNMTR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by CHETRD:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from CHETRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from CHETRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  A       (input) COMPLEX array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by CHETRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) COMPLEX array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CHETRD.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >=M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de cunmtr (side  uplo  trans  m  n  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ cunmtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cupgtr <uplo>  <n>  <ap>  <tau>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUPGTR generates a complex unitary matrix Q which is defined as the
;;*  product of n-1 elementary reflectors H(i) of order n, as returned by
;;*  CHPTRD using packed storage:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to CHPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to CHPTRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)
;;*          The vectors which define the elementary reflectors, as
;;*          returned by CHPTRD.
;;*
;;*  TAU     (input) COMPLEX array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CHPTRD.
;;*
;;*  Q       (output) COMPLEX array, dimension (LDQ,N)
;;*          The N-by-N unitary matrix Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension (N-1)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cupgtr (uplo  n  ap  tau  q  ldq  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cupgtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($tau,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (cupmtr <side>  <uplo>  <trans>  <m>  <n>  <ap>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  CUPMTR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by CHPTRD using packed
;;*  storage:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to CHPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to CHPTRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  AP      (input) COMPLEX array, dimension
;;*                               (M*(M+1)/2) if SIDE = 'L'
;;*                               (N*(N+1)/2) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by CHPTRD.  AP is modified by the routine but
;;*          restored on exit.
;;*
;;*  TAU     (input) COMPLEX array, dimension (M-1) if SIDE = 'L'
;;*                                     or (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by CHPTRD.
;;*
;;*  C       (input/output) COMPLEX array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX array, dimension
;;*                                   (N) if SIDE = 'L'
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cupmtr (side  uplo  trans  m  n  ap  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) tau )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ cupmtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar lapack-c-funclist-nonintel ())

(defvar lapack-c-funclist
  '("cbdsqr" "cgbbrd" "cgbcon" "cgbequ" "cgbrfs" "cgbsv"
    "cgbsvx" "cgbtf2" "cgbtrf" "cgbtrs" "cgebak" "cgebal" "cgebd2"
    "cgebrd" "cgecon" "cgeequ" "cgees" "cgeesx" "cgeev" "cgeevx" "cgegs"
    "cgegv" "cgehd2" "cgehrd" "cgelq2" "cgelqf" "cgelsd" "cgels" "cgelss"
    "cgelsx" "cgelsy" "cgeql2" "cgeqlf" "cgeqp3" "cgeqpf" "cgeqr2"
    "cgeqrf" "cgerfs" "cgerq2" "cgerqf" "cgesc2" "cgesdd" "cgesvd" "cgesv"
    "cgesvx" "cgetc2" "cgetf2" "cgetrf" "cgetri" "cgetrs" "cggbak"
    "cggbal" "cgges" "cggesx" "cggev" "cggevx" "cggglm" "cgghrd" "cgglse"
    "cggqrf" "cggrqf" "cggsvd" "cggsvp" "cgtcon" "cgtrfs" "cgtsv" "cgtsvx"
    "cgttrf" "cgttrs" "cgtts2" "chbevd" "chbev" "chbevx" "chbgst" "chbgvd"
    "chbgv" "chbgvx" "chbtrd" "checon" "cheevd" "cheev" "cheevr" "cheevx"
    "chegs2" "chegst" "chegvd" "chegv" "chegvx" "cherfs" "chesv" "chesvx"
    "chetd2" "chetf2" "chetrd" "chetrf" "chetri" "chetrs" "chgeqz"
    "chpcon" "chpevd" "chpev" "chpevx" "chpgst" "chpgvd" "chpgv" "chpgvx"
    "chprfs" "chpsv" "chpsvx" "chptrd" "chptrf" "chptri" "chptrs" "chsein"
    "chseqr" "clabrd" "clacgv" "clacon" "clacp2" "clacpy" "clacrm"
    "clacrt" "cladiv" "claed0" "claed7" "claed8" "claein" "claesy"
    "claev2" "clags2" "clagtm" "clahef" "clahqr" "clahrd" "claic1"
    "clals0" "clalsa" "clalsd" "clangb" "clange" "clangt" "clanhb"
    "clanhe" "clanhp" "clanhs" "clanht" "clansb" "clansp" "clansy"
    "clantb" "clantp" "clantr" "clapll" "clapmt" "claqgb" "claqge"
    "claqhb" "claqhe" "claqhp" "claqp2" "claqps" "claqsb" "claqsp"
    "claqsy" "clar1v" "clar2v" "clarcm" "clarfb" "clarf" "clarfg" "clarft"
    "clarfx" "clargv" "clarnv" "clarrv" "clartg" "clartv" "clarzb" "clarz"
    "clarzt" "clascl" "claset" "clasr" "classq" "claswp" "clasyf" "clatbs"
    "clatdf" "clatps" "clatrd" "clatrs" "clatrz" "clatzm" "clauu2"
    "clauum" "cpbcon" "cpbequ" "cpbrfs" "cpbstf" "cpbsv" "cpbsvx" "cpbtf2"
    "cpbtrf" "cpbtrs" "cpocon" "cpoequ" "cporfs" "cposv" "cposvx" "cpotf2"
    "cpotrf" "cpotri" "cpotrs" "cppcon" "cppequ" "cpprfs" "cppsv" "cppsvx"
    "cpptrf" "cpptri" "cpptrs" "cptcon" "cpteqr" "cptrfs" "cptsv" "cptsvx"
    "cpttrf" "cpttrs" "cptts2" "crot" "cspcon" "cspmv" "cspr" "csprfs"
    "cspsv" "cspsvx" "csptrf" "csptri" "csptrs" "csrot" "csrscl" "cstedc"
    "cstegr" "cstein" "csteqr" "csycon" "csymv" "csyr" "csyrfs" "csysv"
    "csysvx" "csytf2" "csytrf" "csytri" "csytrs" "ctbcon" "ctbrfs"
    "ctbtrs" "ctgevc" "ctgex2" "ctgexc" "ctgsen" "ctgsja" "ctgsna"
    "ctgsy2" "ctgsyl" "ctpcon" "ctprfs" "ctptri" "ctptrs" "ctrcon"
    "ctrevc" "ctrexc" "ctrrfs" "ctrsen" "ctrsna" "ctrsyl" "ctrti2"
    "ctrtri" "ctrtrs" "ctzrqf" "ctzrzf" "cung2l" "cung2r" "cungbr"
    "cunghr" "cungl2" "cunglq" "cungql" "cungqr" "cungr2" "cungrq"
    "cungtr" "cunm2l" "cunm2r" "cunmbr" "cunmhr" "cunml2" "cunmlq"
    "cunmql" "cunmqr" "cunmr2" "cunmr3" "cunmrq" "cunmrz" "cunmtr"
    "cupgtr" "cupmtr" 
    ))

(with-namespace lush1-
(let ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags)))
  (dhc-make-all 
   ()
   (all ((x (cons "lapack-c-dummy" lapack-c-funclist)))
     (named (downcase x)))
   (append lapack-liblapack lapack-libfortran)))
)