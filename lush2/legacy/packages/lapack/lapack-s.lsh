#? * LAPACK: Single Precision Functions
;;.AUTHOR Fu Jie Huang, Yann LeCun
;; This provides a complete interface to the FORTRAN LAPACK
;; library of low-level linear algebra functions.

(libload "blas/blas-s")

(libload "lapack-config")
(libload "lapack-x")


;; Check if we can short-circuit by just mod-loading the object file
(let* ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags))
       (objfile (dhc-make-test ())) )
  (when objfile
    (mod-load objfile)
    (mapcar mod-load (append lapack-liblapack lapack-libfortran))
    (exit) ) )


(de lapack-s-dummy () (cheader "typedef int int_func();") ())

;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sbdsdc <uplo>  <compq>  <n>  <d>  <e>  <u>  <ldu>  <vt>  <ldvt>  <q>  <iq>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SBDSDC computes the singular value decomposition (SVD) of a real
;;*  N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
;;*  using a divide and conquer method, where S is a diagonal matrix
;;*  with non-negative diagonal elements (the singular values of B), and
;;*  U and VT are orthogonal matrices of left and right singular vectors,
;;*  respectively. SBDSDC can be used to compute all singular values,
;;*  and optionally, singular vectors or singular vectors in compact form.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.  See SLASD3 for details.
;;*
;;*  The code currently call SLASDQ if singular values only are desired.
;;*  However, it can be slightly modified to compute singular values
;;*  using the divide and conquer method.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  B is upper bidiagonal.
;;*          = 'L':  B is lower bidiagonal.
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          Specifies whether singular vectors are to be computed
;;*          as follows:
;;*          = 'N':  Compute singular values only;
;;*          = 'P':  Compute singular values and compute singular
;;*                  vectors in compact form;
;;*          = 'I':  Compute singular values and singular vectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the bidiagonal matrix B.
;;*          On exit, if INFO=0, the singular values of B.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the elements of E contain the offdiagonal
;;*          elements of the bidiagonal matrix whose SVD is desired.
;;*          On exit, E has been destroyed.
;;*
;;*  U       (output) REAL array, dimension (LDU,N)
;;*          If  COMPQ = 'I', then:
;;*             On exit, if INFO = 0, U contains the left singular vectors
;;*             of the bidiagonal matrix.
;;*          For other values of COMPQ, U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1.
;;*          If singular vectors are desired, then LDU >= max( 1, N ).
;;*
;;*  VT      (output) REAL array, dimension (LDVT,N)
;;*          If  COMPQ = 'I', then:
;;*             On exit, if INFO = 0, VT' contains the right singular
;;*             vectors of the bidiagonal matrix.
;;*          For other values of COMPQ, VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1.
;;*          If singular vectors are desired, then LDVT >= max( 1, N ).
;;*
;;*  Q       (output) REAL array, dimension (LDQ)
;;*          If  COMPQ = 'P', then:
;;*             On exit, if INFO = 0, Q and IQ contain the left
;;*             and right singular vectors in a compact form,
;;*             requiring O(N log N) space instead of 2*N**2.
;;*             In particular, Q contains all the REAL data in
;;*             LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
;;*             words of memory, where SMLSIZ is returned by ILAENV and
;;*             is equal to the maximum size of the subproblems at the
;;*             bottom of the computation tree (usually about 25).
;;*          For other values of COMPQ, Q is not referenced.
;;*
;;*  IQ      (output) INTEGER array, dimension (LDIQ)
;;*          If  COMPQ = 'P', then:
;;*             On exit, if INFO = 0, Q and IQ contain the left
;;*             and right singular vectors in a compact form,
;;*             requiring O(N log N) space instead of 2*N**2.
;;*             In particular, IQ contains all INTEGER data in
;;*             LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
;;*             words of memory, where SMLSIZ is returned by ILAENV and
;;*             is equal to the maximum size of the subproblems at the
;;*             bottom of the computation tree (usually about 25).
;;*          For other values of COMPQ, IQ is not referenced.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK)
;;*          If COMPQ = 'N' then LWORK >= (4 * N).
;;*          If COMPQ = 'P' then LWORK >= (6 * N).
;;*          If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (8*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an singular value.
;;*                The update process of divide and conquer failed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sbdsdc (uplo  compq  n  d  e  u  ldu  vt  ldvt  q  iq  work  iwork  info  )
	((-str-) uplo )
	((-str-) compq )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-float-)) q )
	((-idx1- (-int-)) iq )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sbdsdc_($uplo->data, $compq->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($q,float), IDX_PTR($iq,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sbdsqr <uplo>  <n>  <ncvt>  <nru>  <ncc>  <d>  <e>  <vt>  <ldvt>  <u>  <ldu>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SBDSQR computes the singular value decomposition (SVD) of a real
;;*  N-by-N (upper or lower) bidiagonal matrix B:  B = Q * S * P' (P'
;;*  denotes the transpose of P), where S is a diagonal matrix with
;;*  non-negative diagonal elements (the singular values of B), and Q
;;*  and P are orthogonal matrices.
;;*
;;*  The routine computes S, and optionally computes U * Q, P' * VT,
;;*  or Q' * C, for given real input matrices U, VT, and C.
;;*
;;*  See "Computing  Small Singular Values of Bidiagonal Matrices With
;;*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
;;*  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
;;*  no. 5, pp. 873-912, Sept 1990) and
;;*  "Accurate singular values and differential qd algorithms," by
;;*  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
;;*  Department, University of California at Berkeley, July 1992
;;*  for a detailed description of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  B is upper bidiagonal;
;;*          = 'L':  B is lower bidiagonal.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B.  N >= 0.
;;*
;;*  NCVT    (input) INTEGER
;;*          The number of columns of the matrix VT. NCVT >= 0.
;;*
;;*  NRU     (input) INTEGER
;;*          The number of rows of the matrix U. NRU >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C. NCC >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the bidiagonal matrix B.
;;*          On exit, if INFO=0, the singular values of B in decreasing
;;*          order.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the elements of E contain the
;;*          offdiagonal elements of the bidiagonal matrix whose SVD
;;*          is desired. On normal exit (INFO = 0), E is destroyed.
;;*          If the algorithm does not converge (INFO > 0), D and E
;;*          will contain the diagonal and superdiagonal elements of a
;;*          bidiagonal matrix orthogonally equivalent to the one given
;;*          as input. E(N) is used for workspace.
;;*
;;*  VT      (input/output) REAL array, dimension (LDVT, NCVT)
;;*          On entry, an N-by-NCVT matrix VT.
;;*          On exit, VT is overwritten by P' * VT.
;;*          VT is not referenced if NCVT = 0.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.
;;*          LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
;;*
;;*  U       (input/output) REAL array, dimension (LDU, N)
;;*          On entry, an NRU-by-N matrix U.
;;*          On exit, U is overwritten by U * Q.
;;*          U is not referenced if NRU = 0.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= max(1,NRU).
;;*
;;*  C       (input/output) REAL array, dimension (LDC, NCC)
;;*          On entry, an N-by-NCC matrix C.
;;*          On exit, C is overwritten by Q' * C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
;;*
;;*  WORK    (workspace) REAL array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  If INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm did not converge; D and E contain the
;;*                elements of a bidiagonal matrix which is orthogonally
;;*                similar to the input matrix B;  if INFO = i, i
;;*                elements of E have not converged to zero.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLMUL  REAL, default = max(10,min(100,EPS**(-1/8)))
;;*          TOLMUL controls the convergence criterion of the QR loop.
;;*          If it is positive, TOLMUL*EPS is the desired relative
;;*             precision in the computed singular values.
;;*          If it is negative, abs(TOLMUL*EPS*sigma_max) is the
;;*             desired absolute accuracy in the computed singular
;;*             values (corresponds to relative accuracy
;;*             abs(TOLMUL*EPS) in the largest singular value.
;;*          abs(TOLMUL) should be between 1 and 1/EPS, and preferably
;;*             between 10 (for fast convergence) and .1/EPS
;;*             (for there to be some accuracy in the results).
;;*          Default is to lose at either one eighth or 2 of the
;;*             available decimal digits in each computed singular value
;;*             (whichever is smaller).
;;*
;;*  MAXITR  INTEGER, default = 6
;;*          MAXITR controls the maximum number of passes of the
;;*          algorithm through its inner loop. The algorithms stops
;;*          (and so fails to converge) if the number of passes
;;*          through the inner loop exceeds MAXITR*N**2.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sbdsqr (uplo  n  ncvt  nru  ncc  d  e  vt  ldvt  u  ldu  c  ldc  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncvt )
	((-idx0- (-int-)) nru )
	((-idx0- (-int-)) ncc )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sbdsqr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ncvt,int), IDX_PTR($nru,int), IDX_PTR($ncc,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (scsum1 <n>  <cx>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SCSUM1 takes the sum of the absolute values of a complex
;;*  vector and returns a single precision result.
;;*
;;*  Based on SCASUM from the Level 1 BLAS.
;;*  The change is to use the 'genuine' absolute value.
;;*
;;*  Contributed by Nick Higham for use with CLACON.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements in the vector CX.
;;*
;;*  CX      (input) COMPLEX array, dimension (N)
;;*          The vector whose elements will be summed.
;;*
;;*  INCX    (input) INTEGER
;;*          The spacing between successive values of CX.  INCX > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de scsum1 (n  cx  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=scsum1_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sdisna <job>  <m>  <n>  <d>  <sep>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SDISNA computes the reciprocal condition numbers for the eigenvectors
;;*  of a real symmetric or complex Hermitian matrix or for the left or
;;*  right singular vectors of a general m-by-n matrix. The reciprocal
;;*  condition number is the 'gap' between the corresponding eigenvalue or
;;*  singular value and the nearest other one.
;;*
;;*  The bound on the error, measured by angle in radians, in the I-th
;;*  computed vector is given by
;;*
;;*         SLAMCH( 'E' ) * ( ANORM / SEP( I ) )
;;*
;;*  where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
;;*  to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of
;;*  the error bound.
;;*
;;*  SDISNA may also be used to compute error bounds for eigenvectors of
;;*  the generalized symmetric definite eigenproblem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies for which problem the reciprocal condition numbers
;;*          should be computed:
;;*          = 'E':  the eigenvectors of a symmetric/Hermitian matrix;
;;*          = 'L':  the left singular vectors of a general matrix;
;;*          = 'R':  the right singular vectors of a general matrix.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          If JOB = 'L' or 'R', the number of columns of the matrix,
;;*          in which case N >= 0. Ignored if JOB = 'E'.
;;*
;;*  D       (input) REAL array, dimension (M) if JOB = 'E'
;;*                              dimension (min(M,N)) if JOB = 'L' or 'R'
;;*          The eigenvalues (if JOB = 'E') or singular values (if JOB =
;;*          'L' or 'R') of the matrix, in either increasing or decreasing
;;*          order. If singular values, they must be non-negative.
;;*
;;*  SEP     (output) REAL array, dimension (M) if JOB = 'E'
;;*                               dimension (min(M,N)) if JOB = 'L' or 'R'
;;*          The reciprocal condition numbers of the vectors.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sdisna (job  m  n  d  sep  info  )
	((-str-) job )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) sep )
	((-idx0- (-int-)) info )
	#{ sdisna_($job->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($sep,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (second <>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SECOND returns the user time for a process in seconds.
;;*  This version gets the time from the system function ETIME.
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de second (  )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=second_() #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbbrd <vect>  <m>  <n>  <ncc>  <kl>  <ku>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <pt>  <ldpt>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBBRD reduces a real general m-by-n band matrix A to upper
;;*  bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
;;*
;;*  The routine computes B, and optionally forms Q or P', or computes
;;*  Q'*C for a given matrix C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether or not the matrices Q and P' are to be
;;*          formed.
;;*          = 'N': do not form Q or P';
;;*          = 'Q': form Q only;
;;*          = 'P': form P' only;
;;*          = 'B': form both.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C.  NCC >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals of the matrix A. KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals of the matrix A. KU >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the m-by-n band matrix A, stored in rows 1 to
;;*          KL+KU+1. The j-th column of A is stored in the j-th column of
;;*          the array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*          On exit, A is overwritten by values generated during the
;;*          reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A. LDAB >= KL+KU+1.
;;*
;;*  D       (output) REAL array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B.
;;*
;;*  E       (output) REAL array, dimension (min(M,N)-1)
;;*          The superdiagonal elements of the bidiagonal matrix B.
;;*
;;*  Q       (output) REAL array, dimension (LDQ,M)
;;*          If VECT = 'Q' or 'B', the m-by-m orthogonal matrix Q.
;;*          If VECT = 'N' or 'P', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= max(1,M) if VECT = 'Q' or 'B'; LDQ >= 1 otherwise.
;;*
;;*  PT      (output) REAL array, dimension (LDPT,N)
;;*          If VECT = 'P' or 'B', the n-by-n orthogonal matrix P'.
;;*          If VECT = 'N' or 'Q', the array PT is not referenced.
;;*
;;*  LDPT    (input) INTEGER
;;*          The leading dimension of the array PT.
;;*          LDPT >= max(1,N) if VECT = 'P' or 'B'; LDPT >= 1 otherwise.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,NCC)
;;*          On entry, an m-by-ncc matrix C.
;;*          On exit, C is overwritten by Q'*C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,M) if NCC > 0; LDC >= 1 if NCC = 0.
;;*
;;*  WORK    (workspace) REAL array, dimension (2*max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbbrd (vect  m  n  ncc  kl  ku  ab  ldab  d  e  q  ldq  pt  ldpt  c  ldc  work  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncc )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) pt )
	((-idx0- (-int-)) ldpt )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgbbrd_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ncc,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($pt,float), IDX_PTR($ldpt,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbcon <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBCON estimates the reciprocal of the condition number of a real
;;*  general band matrix A, in either the 1-norm or the infinity-norm,
;;*  using the LU factorization computed by SGBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by SGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  ANORM   (input) REAL
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbcon (norm  n  kl  ku  ab  ldab  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgbcon_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbequ <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N band matrix A and reduce its condition number.  R returns the
;;*  row scale factors and C the column scale factors, chosen to try to
;;*  make the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  R       (output) REAL array, dimension (M)
;;*          If INFO = 0, or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) REAL array, dimension (N)
;;*          If INFO = 0, C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) REAL
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) REAL
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbequ (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ sgbequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbrfs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is banded, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The original band matrix A, stored in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input) REAL array, dimension (LDAFB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by SGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from SGBTRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SGBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbrfs (trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgbrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbsv <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBSV computes the solution to a real system of linear equations
;;*  A * X = B, where A is a band matrix of order N with KL subdiagonals
;;*  and KU superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as A = L * U, where L is a product of permutation
;;*  and unit lower triangular matrices with KL subdiagonals, and U is
;;*  upper triangular with KL+KU superdiagonals.  The factored form of A
;;*  is then used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de sgbsv (n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sgbsv_(IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbsvx <fact>  <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBSVX uses the LU factorization to compute the solution to a real
;;*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
;;*  where A is a band matrix of order N with KL subdiagonals and KU
;;*  superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed by this subroutine:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = L * U,
;;*     where L is a product of permutation and unit lower triangular
;;*     matrices with KL subdiagonals, and U is upper triangular with
;;*     KL+KU superdiagonals.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB and IPIV contain the factored form of
;;*                  A.  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  AB, AFB, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)
;;*
;;*          If FACT = 'F' and EQUED is not 'N', then A must have been
;;*          equilibrated by the scaling factors in R and/or C.  AB is not
;;*          modified if FACT = 'F' or 'N', or if FACT = 'E' and
;;*          EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input or output) REAL array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains details of the LU factorization of the band matrix
;;*          A, as computed by SGBTRF.  U is stored as an upper triangular
;;*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
;;*          and the multipliers used during the factorization are stored
;;*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. 'N', then AFB is
;;*          the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of A.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of the equilibrated
;;*          matrix A (see the description of AB for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = L*U
;;*          as computed by SGBTRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) REAL array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) REAL array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (3*N)
;;*          On exit, WORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If WORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          WORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbsvx (fact  trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgbsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbtf2 <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBTF2 computes an LU factorization of a real m-by-n band matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U, because of fill-in resulting from the row
;;*  interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbtf2 (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ sgbtf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbtrf <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBTRF computes an LU factorization of a real m-by-n band matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbtrf (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ sgbtrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgbtrs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGBTRS solves a system of linear equations
;;*     A * X = B  or  A' * X = B
;;*  with a general band matrix A using the LU factorization computed
;;*  by SGBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A'* X = B  (Transpose)
;;*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by SGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgbtrs (trans  n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sgbtrs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgebak <job>  <side>  <n>  <ilo>  <ihi>  <scale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEBAK forms the right or left eigenvectors of a real general matrix
;;*  by backward transformation on the computed eigenvectors of the
;;*  balanced matrix output by SGEBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N', do nothing, return immediately;
;;*          = 'P', do backward transformation for permutation only;
;;*          = 'S', do backward transformation for scaling only;
;;*          = 'B', do backward transformations for both permutation and
;;*                 scaling.
;;*          JOB must be the same as the argument JOB supplied to SGEBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by SGEBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  SCALE   (input) REAL array, dimension (N)
;;*          Details of the permutation and scaling factors, as returned
;;*          by SGEBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) REAL array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by SHSEIN or STREVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgebak (job  side  n  ilo  ihi  scale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) scale )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ sgebak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,float), IDX_PTR($m,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgebal <job>  <n>  <a>  <lda>  <ilo>  <ihi>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEBAL balances a general real matrix A.  This involves, first,
;;*  permuting A by a similarity transformation to isolate eigenvalues
;;*  in the first 1 to ILO-1 and last IHI+1 to N elements on the
;;*  diagonal; and second, applying a diagonal similarity transformation
;;*  to rows and columns ILO to IHI to make the rows and columns as
;;*  close in norm as possible.  Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrix, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
;;*                  for i = 1,...,N;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit,  A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  SCALE   (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied to
;;*          A.  If P(j) is the index of the row and column interchanged
;;*          with row and column j and D(j) is the scaling factor
;;*          applied to row and column j, then
;;*          SCALE(j) = P(j)    for j = 1,...,ILO-1
;;*                   = D(j)    for j = ILO,...,IHI
;;*                   = P(j)    for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The permutations consist of row and column interchanges which put
;;*  the matrix in the form
;;*
;;*             ( T1   X   Y  )
;;*     P A P = (  0   B   Z  )
;;*             (  0   0   T2 )
;;*
;;*  where T1 and T2 are upper triangular matrices whose eigenvalues lie
;;*  along the diagonal.  The column indices ILO and IHI mark the starting
;;*  and ending columns of the submatrix B. Balancing consists of applying
;;*  a diagonal similarity transformation inv(D) * B * D to make the
;;*  1-norms of each row of B and its corresponding column nearly equal.
;;*  The output matrix is
;;*
;;*     ( T1     X*D          Y    )
;;*     (  0  inv(D)*B*D  inv(D)*Z ).
;;*     (  0      0           T2   )
;;*
;;*  Information about the permutations P and the diagonal matrix D is
;;*  returned in the vector SCALE.
;;*
;;*  This subroutine is based on the EISPACK routine BALANC.
;;*
;;*  Modified by Tzu-Yi Chen, Computer Science Division, University of
;;*    California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgebal (job  n  a  lda  ilo  ihi  scale  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) scale )
	((-idx0- (-int-)) info )
	#{ sgebal_($job->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgebd2 <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEBD2 reduces a real general m by n matrix A to upper or lower
;;*  bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the orthogonal matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the orthogonal matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) REAL array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) REAL array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q. See Further Details.
;;*
;;*  TAUP    (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix P. See Further Details.
;;*
;;*  WORK    (workspace) REAL array, dimension (max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
;;*  u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
;;*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgebd2 (m  n  a  lda  d  e  tauq  taup  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tauq )
	((-idx1- (-float-)) taup )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgebd2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tauq,float), IDX_PTR($taup,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgebrd <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEBRD reduces a general real M-by-N matrix A to upper or lower
;;*  bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the orthogonal matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the orthogonal matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) REAL array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) REAL array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q. See Further Details.
;;*
;;*  TAUP    (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix P. See Further Details.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,M,N).
;;*          For optimum performance LWORK >= (M+N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit 
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
;;*  u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
;;*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgebrd (m  n  a  lda  d  e  tauq  taup  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tauq )
	((-idx1- (-float-)) taup )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgebrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tauq,float), IDX_PTR($taup,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgecon <norm>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGECON estimates the reciprocal of the condition number of a general
;;*  real matrix A, in either the 1-norm or the infinity-norm, using
;;*  the LU factorization computed by SGETRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by SGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) REAL
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) REAL array, dimension (4*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgecon (norm  n  a  lda  anorm  rcond  work  iwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgecon_($norm->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeequ <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N matrix A and reduce its condition number.  R returns the row
;;*  scale factors and C the column scale factors, chosen to try to make
;;*  the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The M-by-N matrix whose equilibration factors are
;;*          to be computed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  R       (output) REAL array, dimension (M)
;;*          If INFO = 0 or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) REAL array, dimension (N)
;;*          If INFO = 0,  C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) REAL
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) REAL
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i,  and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeequ (m  n  a  lda  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ sgeequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgees <jobvs>  <sort>  <select>  <n>  <a>  <lda>  <sdim>  <wr>  <wi>  <vs>  <ldvs>  <work>  <lwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEES computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues, the real Schur form T, and, optionally, the matrix of
;;*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  real Schur form so that selected eigenvalues are at the top left.
;;*  The leading columns of Z then form an orthonormal basis for the
;;*  invariant subspace corresponding to the selected eigenvalues.
;;*
;;*  A matrix is in real Schur form if it is upper quasi-triangular with
;;*  1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
;;*  form
;;*          [  a  b  ]
;;*          [  c  a  ]
;;*
;;*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered;
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of two REAL arguments
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          If SORT = 'N', SELECT is not referenced.
;;*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
;;*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
;;*          conjugate pair of eigenvalues is selected, then both complex
;;*          eigenvalues are selected.
;;*          Note that a selected complex eigenvalue may no longer
;;*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned); in this
;;*          case INFO is set to N+2 (see INFO below).
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten by its real Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*                         for which SELECT is true. (Complex conjugate
;;*                         pairs for which SELECT is true for either
;;*                         eigenvalue count as 2.)
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          WR and WI contain the real and imaginary parts,
;;*          respectively, of the computed eigenvalues in the same order
;;*          that they appear on the diagonal of the output Schur form T.
;;*          Complex conjugate pairs of eigenvalues will appear
;;*          consecutively with the eigenvalue having the positive
;;*          imaginary part first.
;;*
;;*  VS      (output) REAL array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1; if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) contains the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,3*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*             <= N: the QR algorithm failed to compute all the
;;*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
;;*                   contain those eigenvalues which have converged; if
;;*                   JOBVS = 'V', VS contains the matrix which reduces A
;;*                   to its partially converged Schur form.
;;*             = N+1: the eigenvalues could not be reordered because some
;;*                   eigenvalues were too close to separate (the problem
;;*                   is very ill-conditioned);
;;*             = N+2: after reordering, roundoff changed values of some
;;*                   complex eigenvalues so that leading eigenvalues in
;;*                   the Schur form no longer satisfy SELECT=.TRUE.  This
;;*                   could also be caused by underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgees (jobvs  sort  select  n  a  lda  sdim  wr  wi  vs  ldvs  work  lwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx2- (-float-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ sgees_($jobvs->data, $sort->data, $select, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($vs,float), IDX_PTR($ldvs,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeesx <jobvs>  <sort>  <select>  <sense>  <n>  <a>  <lda>  <sdim>  <wr>  <wi>  <vs>  <ldvs>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <liwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEESX computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues, the real Schur form T, and, optionally, the matrix of
;;*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  real Schur form so that selected eigenvalues are at the top left;
;;*  computes a reciprocal condition number for the average of the
;;*  selected eigenvalues (RCONDE); and computes a reciprocal condition
;;*  number for the right invariant subspace corresponding to the
;;*  selected eigenvalues (RCONDV).  The leading columns of Z form an
;;*  orthonormal basis for this invariant subspace.
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
;;*  these quantities are called s and sep respectively).
;;*
;;*  A real matrix is in real Schur form if it is upper quasi-triangular
;;*  with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
;;*  the form
;;*            [  a  b  ]
;;*            [  c  a  ]
;;*
;;*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered;
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of two REAL arguments
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          If SORT = 'N', SELECT is not referenced.
;;*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
;;*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a
;;*          complex conjugate pair of eigenvalues is selected, then both
;;*          are.  Note that a selected complex eigenvalue may no longer
;;*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned); in this
;;*          case INFO may be set to N+3 (see INFO below).
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for average of selected eigenvalues only;
;;*          = 'V': Computed for selected right invariant subspace only;
;;*          = 'B': Computed for both.
;;*          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A is overwritten by its real Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*                         for which SELECT is true. (Complex conjugate
;;*                         pairs for which SELECT is true for either
;;*                         eigenvalue count as 2.)
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          WR and WI contain the real and imaginary parts, respectively,
;;*          of the computed eigenvalues, in the same order that they
;;*          appear on the diagonal of the output Schur form T.  Complex
;;*          conjugate pairs of eigenvalues appear consecutively with the
;;*          eigenvalue having the positive imaginary part first.
;;*
;;*  VS      (output) REAL array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1, and if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  RCONDE  (output) REAL
;;*          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
;;*          condition number for the average of the selected eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) REAL
;;*          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
;;*          condition number for the selected right invariant subspace.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,3*N).
;;*          Also, if SENSE = 'E' or 'V' or 'B',
;;*          LWORK >= N+2*SDIM*(N-SDIM), where SDIM is the number of
;;*          selected eigenvalues computed by this routine.  Note that
;;*          N+2*SDIM*(N-SDIM) <= N+N*N/2.
;;*          For good performance, LWORK must generally be larger.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          LIWORK >= 1; if SENSE = 'V' or 'B', LIWORK >= SDIM*(N-SDIM).
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*             <= N: the QR algorithm failed to compute all the
;;*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
;;*                   contain those eigenvalues which have converged; if
;;*                   JOBVS = 'V', VS contains the transformation which
;;*                   reduces A to its partially converged Schur form.
;;*             = N+1: the eigenvalues could not be reordered because some
;;*                   eigenvalues were too close to separate (the problem
;;*                   is very ill-conditioned);
;;*             = N+2: after reordering, roundoff changed values of some
;;*                   complex eigenvalues so that leading eigenvalues in
;;*                   the Schur form no longer satisfy SELECT=.TRUE.  This
;;*                   could also be caused by underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeesx (jobvs  sort  select  sense  n  a  lda  sdim  wr  wi  vs  ldvs  rconde  rcondv  work  lwork  iwork  liwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx2- (-float-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx0- (-float-)) rconde )
	((-idx0- (-float-)) rcondv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ sgeesx_($jobvs->data, $sort->data, $select, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($vs,float), IDX_PTR($ldvs,int), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeev <jobvl>  <jobvr>  <n>  <a>  <lda>  <wr>  <wi>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEEV computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of A are computed.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          WR and WI contain the real and imaginary parts,
;;*          respectively, of the computed eigenvalues.  Complex
;;*          conjugate pairs of eigenvalues appear consecutively
;;*          with the eigenvalue having the positive imaginary part
;;*          first.
;;*
;;*  VL      (output) REAL array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          If the j-th eigenvalue is real, then u(j) = VL(:,j),
;;*          the j-th column of VL.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
;;*          u(j+1) = VL(:,j) - i*VL(:,j+1).
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) REAL array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          If the j-th eigenvalue is real, then v(j) = VR(:,j),
;;*          the j-th column of VR.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
;;*          v(j+1) = VR(:,j) - i*VR(:,j+1).
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1; if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,3*N), and
;;*          if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
;;*          performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors have been computed;
;;*                elements i+1:N of WR and WI contain eigenvalues which
;;*                have converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeev (jobvl  jobvr  n  a  lda  wr  wi  vl  ldvl  vr  ldvr  work  lwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgeev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <wr>  <wi>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <scale>  <abnrm>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEEVX computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  Optionally also, it computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
;;*  (RCONDE), and reciprocal condition numbers for the right
;;*  eigenvectors (RCONDV).
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Balancing a matrix means permuting the rows and columns to make it
;;*  more nearly upper triangular, and applying a diagonal similarity
;;*  transformation D * A * D**(-1), where D is a diagonal matrix, to
;;*  make its rows and columns closer in norm and the condition numbers
;;*  of its eigenvalues and eigenvectors smaller.  The computed
;;*  reciprocal condition numbers correspond to the balanced matrix.
;;*  Permuting rows and columns will not change the condition numbers
;;*  (in exact arithmetic) but diagonal scaling will.  For further
;;*  explanation of balancing, see section 4.10.2 of the LAPACK
;;*  Users' Guide.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Indicates how the input matrix should be diagonally scaled
;;*          and/or permuted to improve the conditioning of its
;;*          eigenvalues.
;;*          = 'N': Do not diagonally scale or permute;
;;*          = 'P': Perform permutations to make the matrix more nearly
;;*                 upper triangular. Do not diagonally scale;
;;*          = 'S': Diagonally scale the matrix, i.e. replace A by
;;*                 D*A*D**(-1), where D is a diagonal matrix chosen
;;*                 to make the rows and columns of A more equal in
;;*                 norm. Do not permute;
;;*          = 'B': Both diagonally scale and permute A.
;;*
;;*          Computed reciprocal condition numbers will be for the matrix
;;*          after balancing and/or permuting. Permuting does not change
;;*          condition numbers (in exact arithmetic), but balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVL must = 'V'.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVR must = 'V'.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for eigenvalues only;
;;*          = 'V': Computed for right eigenvectors only;
;;*          = 'B': Computed for eigenvalues and right eigenvectors.
;;*
;;*          If SENSE = 'E' or 'B', both left and right eigenvectors
;;*          must also be computed (JOBVL = 'V' and JOBVR = 'V').
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.  If JOBVL = 'V' or
;;*          JOBVR = 'V', A contains the real Schur form of the balanced
;;*          version of the input matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          WR and WI contain the real and imaginary parts,
;;*          respectively, of the computed eigenvalues.  Complex
;;*          conjugate pairs of eigenvalues will appear consecutively
;;*          with the eigenvalue having the positive imaginary part
;;*          first.
;;*
;;*  VL      (output) REAL array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          If the j-th eigenvalue is real, then u(j) = VL(:,j),
;;*          the j-th column of VL.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
;;*          u(j+1) = VL(:,j) - i*VL(:,j+1).
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) REAL array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          If the j-th eigenvalue is real, then v(j) = VR(:,j),
;;*          the j-th column of VR.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
;;*          v(j+1) = VR(:,j) - i*VR(:,j+1).
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1, and if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values determined when A was
;;*          balanced.  The balanced A(i,j) = 0 if I > J and 
;;*          J = 1,...,ILO-1 or I = IHI+1,...,N.
;;*
;;*  SCALE   (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          when balancing A.  If P(j) is the index of the row and column
;;*          interchanged with row and column j, and D(j) is the scaling
;;*          factor applied to row and column j, then
;;*          SCALE(J) = P(J),    for J = 1,...,ILO-1
;;*                   = D(J),    for J = ILO,...,IHI
;;*                   = P(J)     for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) REAL
;;*          The one-norm of the balanced matrix (the maximum
;;*          of the sum of absolute values of elements of any column).
;;*
;;*  RCONDE  (output) REAL array, dimension (N)
;;*          RCONDE(j) is the reciprocal condition number of the j-th
;;*          eigenvalue.
;;*
;;*  RCONDV  (output) REAL array, dimension (N)
;;*          RCONDV(j) is the reciprocal condition number of the j-th
;;*          right eigenvector.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.   If SENSE = 'N' or 'E',
;;*          LWORK >= max(1,2*N), and if JOBVL = 'V' or JOBVR = 'V',
;;*          LWORK >= 3*N.  If SENSE = 'V' or 'B', LWORK >= N*(N+6).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (2*N-2)
;;*          If SENSE = 'N' or 'E', not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors or condition numbers
;;*                have been computed; elements 1:ILO-1 and i+1:N of WR
;;*                and WI contain eigenvalues which have converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeevx (balanc  jobvl  jobvr  sense  n  a  lda  wr  wi  vl  ldvl  vr  ldvr  ilo  ihi  scale  abnrm  rconde  rcondv  work  lwork  iwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) scale )
	((-idx0- (-float-)) abnrm )
	((-idx1- (-float-)) rconde )
	((-idx1- (-float-)) rcondv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgeevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,float), IDX_PTR($abnrm,float), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgegs <jobvsl>  <jobvsr>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine SGGES.
;;*
;;*  SGEGS computes for a pair of N-by-N real nonsymmetric matrices A, B:
;;*  the generalized eigenvalues (alphar +/- alphai*i, beta), the real
;;*  Schur form (A, B), and optionally left and/or right Schur vectors
;;*  (VSL and VSR).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver SGEGV
;;*  instead.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  The (generalized) Schur form of a pair of matrices is the result of
;;*  multiplying both matrices on the left by one orthogonal matrix and
;;*  both on the right by another orthogonal matrix, these two orthogonal
;;*  matrices being chosen so as to bring the pair of matrices into
;;*  (real) Schur form.
;;*
;;*  A pair of matrices A, B is in generalized real Schur form if B is
;;*  upper triangular with non-negative diagonal and A is block upper
;;*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
;;*  to real generalized eigenvalues, while 2-by-2 blocks of A will be
;;*  "standardized" by making the corresponding elements of B have the
;;*  form:
;;*          [  a  0  ]
;;*          [  0  b  ]
;;*
;;*  and the pair of corresponding 2-by-2 blocks in A and B will
;;*  have a complex conjugate pair of generalized eigenvalues.
;;*
;;*  The left and right Schur vectors are the columns of VSL and VSR,
;;*  respectively, where VSL and VSR are the orthogonal matrices
;;*  which reduce A and B to Schur form:
;;*
;;*  Schur form of (A,B) = ( (VSL)**T A (VSR), (VSL)**T B (VSR) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose generalized
;;*          eigenvalues and (optionally) Schur vectors are to be
;;*          computed.
;;*          On exit, the generalized Schur form of A.
;;*          Note: to avoid overflow, the Frobenius norm of the matrix
;;*          A should be less than the overflow threshold.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) Schur vectors are
;;*          to be computed.
;;*          On exit, the generalized Schur form of B.
;;*          Note: to avoid overflow, the Frobenius norm of the matrix
;;*          B should be less than the overflow threshold.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
;;*          j=1,...,N  and  BETA(j),j=1,...,N  are the diagonals of the
;;*          complex Schur form (A,B) that would result if the 2-by-2
;;*          diagonal blocks of the real Schur form of (A,B) were further
;;*          reduced to triangular form using 2-by-2 complex unitary
;;*          transformations.  If ALPHAI(j) is zero, then the j-th
;;*          eigenvalue is real; if positive, then the j-th and (j+1)-st
;;*          eigenvalues are a complex conjugate pair, with ALPHAI(j+1)
;;*          negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          alpha/beta.  However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VSL     (output) REAL array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) REAL array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,4*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for SGEQRF, SORMQR, and SORGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for SGEQRF, SORMQR, and SORGQR
;;*          The optimal LWORK is  2*N + N*(NB+1).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
;;*                be correct for j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from SGGBAL
;;*                =N+2: error return from SGEQRF
;;*                =N+3: error return from SORMQR
;;*                =N+4: error return from SORGQR
;;*                =N+5: error return from SGGHRD
;;*                =N+6: error return from SHGEQZ (other than failed
;;*                                                iteration)
;;*                =N+7: error return from SGGBAK (computing VSL)
;;*                =N+8: error return from SGGBAK (computing VSR)
;;*                =N+9: error return from SLASCL (various places)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgegs (jobvsl  jobvsr  n  a  lda  b  ldb  alphar  alphai  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx2- (-float-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgegs_($jobvsl->data, $jobvsr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($vsl,float), IDX_PTR($ldvsl,int), IDX_PTR($vsr,float), IDX_PTR($ldvsr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgegv <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine SGGEV.
;;*
;;*  SGEGV computes for a pair of n-by-n real nonsymmetric matrices A and
;;*  B, the generalized eigenvalues (alphar +/- alphai*i, beta), and
;;*  optionally, the left and/or right generalized eigenvectors (VL and
;;*  VR).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  A right generalized eigenvector corresponding to a generalized
;;*  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
;;*  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
;;*  l such that l**H * (A - w B) = 0, where l**H is the
;;*  conjugate-transpose of l.
;;*
;;*  Note: this routine performs "full balancing" on A and B -- see
;;*  "Further Details", below.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of A on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of B on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
;;*          the j-th eigenvalue is real; if positive, then the j-th and
;;*          (j+1)-st eigenvalues are a complex conjugate pair, with
;;*          ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          alpha/beta.  However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VL      (output) REAL array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors.  (See
;;*          "Purpose", above.)  Real eigenvectors take one column,
;;*          complex take two columns, the first for the real part and
;;*          the second for the imaginary part.  Complex eigenvectors
;;*          correspond to an eigenvalue with positive imaginary part.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) REAL array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors.  (See
;;*          "Purpose", above.)  Real eigenvectors take one column,
;;*          complex take two columns, the first for the real part and
;;*          the second for the imaginary part.  Complex eigenvectors
;;*          correspond to an eigenvalue with positive imaginary part.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,8*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for SGEQRF, SORMQR, and SORGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for SGEQRF, SORMQR, and SORGQR;
;;*          The optimal LWORK is:
;;*              2*N + MAX( 6*N, N*(NB+1) ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
;;*                should be correct for j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from SGGBAL
;;*                =N+2: error return from SGEQRF
;;*                =N+3: error return from SORMQR
;;*                =N+4: error return from SORGQR
;;*                =N+5: error return from SGGHRD
;;*                =N+6: error return from SHGEQZ (other than failed
;;*                                                iteration)
;;*                =N+7: error return from STGEVC
;;*                =N+8: error return from SGGBAK (computing VL)
;;*                =N+9: error return from SGGBAK (computing VR)
;;*                =N+10: error return from SLASCL (various calls)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing
;;*  ---------
;;*
;;*  This driver calls SGGBAL to both permute and scale rows and columns
;;*  of A and B.  The permutations PL and PR are chosen so that PL*A*PR
;;*  and PL*B*R will be upper triangular except for the diagonal blocks
;;*  A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
;;*  possible.  The diagonal scaling matrices DL and DR are chosen so
;;*  that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
;;*  one (except for the elements that start out zero.)
;;*
;;*  After the eigenvalues and eigenvectors of the balanced matrices
;;*  have been computed, SGGBAK transforms the eigenvectors back to what
;;*  they would have been (in perfect arithmetic) if they had not been
;;*  balanced.
;;*
;;*  Contents of A and B on Exit
;;*  -------- -- - --- - -- ----
;;*
;;*  If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
;;*  both), then on exit the arrays A and B will contain the real Schur
;;*  form[*] of the "balanced" versions of A and B.  If no eigenvectors
;;*  are computed, then only the diagonal blocks will be correct.
;;*
;;*  [*] See SHGEQZ, SGEGS, or read the book "Matrix Computations",
;;*      by Golub & van Loan, pub. by Johns Hopkins U. Press.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgegv (jobvl  jobvr  n  a  lda  b  ldb  alphar  alphai  beta  vl  ldvl  vr  ldvr  work  lwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgegv_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgehd2 <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEHD2 reduces a real general matrix A to upper Hessenberg form H by
;;*  an orthogonal similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to SGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= max(1,N).
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the n by n general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the orthogonal matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) REAL array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgehd2 (n  ilo  ihi  a  lda  tau  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgehd2_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgehrd <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEHRD reduces a real general matrix A to upper Hessenberg form H by
;;*  an orthogonal similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to SGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the orthogonal matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) REAL array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
;;*          zero.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgehrd (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgehrd_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgelq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGELQ2 computes an LQ factorization of a real m by n matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m by min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) REAL array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgelq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgelq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgelqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGELQF computes an LQ factorization of a real M-by-N matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sgelqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgelqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgelsd <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGELSD computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize 2-norm(| b - A*x |)
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The problem is solved in three steps:
;;*  (1) Reduce the coefficient matrix A to bidiagonal form with
;;*      Householder transformations, reducing the original problem
;;*      into a "bidiagonal least squares problem" (BLS)
;;*  (2) Solve the BLS using a divide and conquer approach.
;;*  (3) Apply back all the Householder tranformations to solve
;;*      the original least squares problem.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution
;;*          matrix X.  If m >= n and RANK = n, the residual
;;*          sum-of-squares for the solution in the i-th column is given
;;*          by the sum of squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,max(M,N)).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK must be at least 1.
;;*          The exact minimum amount of workspace needed depends on M,
;;*          N and NRHS. As long as LWORK is at least
;;*              12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,
;;*          if M is greater than or equal to N or
;;*              12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,
;;*          if M is less than N, the code will execute correctly.
;;*          SMLSIZ is returned by ILAENV and is equal to the maximum
;;*          size of the subproblems at the bottom of the computation
;;*          tree (usually about 25), and
;;*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          LIWORK >= 3 * MINMN * NLVL + 11 * MINMN,
;;*          where MINMN = MIN( M,N ).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgelsd (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  iwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgelsd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($s,float), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgels <trans>  <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGELS solves overdetermined or underdetermined real linear systems
;;*  involving an M-by-N matrix A, or its transpose, using a QR or LQ
;;*  factorization of A.  It is assumed that A has full rank.
;;*
;;*  The following options are provided: 
;;*
;;*  1. If TRANS = 'N' and m >= n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A*X ||.
;;*
;;*  2. If TRANS = 'N' and m < n:  find the minimum norm solution of
;;*     an underdetermined system A * X = B.
;;*
;;*  3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
;;*     an undetermined system A**T * X = B.
;;*
;;*  4. If TRANS = 'T' and m < n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A**T * X ||.
;;*
;;*  Several right hand side vectors b and solution vectors x can be 
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution 
;;*  matrix X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N': the linear system involves A;
;;*          = 'T': the linear system involves A**T. 
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of the matrices B and X. NRHS >=0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*            if M >= N, A is overwritten by details of its QR
;;*                       factorization as returned by SGEQRF;
;;*            if M <  N, A is overwritten by details of its LQ
;;*                       factorization as returned by SGELQF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the matrix B of right hand side vectors, stored
;;*          columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
;;*          if TRANS = 'T'.  
;;*          On exit, B is overwritten by the solution vectors, stored
;;*          columnwise:
;;*          if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
;;*          squares solution vectors; the residual sum of squares for the
;;*          solution in each column is given by the sum of squares of
;;*          elements N+1 to M in that column;
;;*          if TRANS = 'N' and m < n, rows 1 to N of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'T' and m >= n, rows 1 to M of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'T' and m < n, rows 1 to M of B contain the
;;*          least squares solution vectors; the residual sum of squares
;;*          for the solution in each column is given by the sum of
;;*          squares of elements M+1 to N in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= MAX(1,M,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          LWORK >= max( 1, MN + max( MN, NRHS ) ).
;;*          For optimal performance,
;;*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).
;;*          where MN = min(M,N) and NB is the optimum block size.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgels (trans  m  n  nrhs  a  lda  b  ldb  work  lwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgels_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgelss <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGELSS computes the minimum norm solution to a real linear least
;;*  squares problem:
;;*
;;*  Minimize 2-norm(| b - A*x |).
;;*
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
;;*  X.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the first min(m,n) rows of A are overwritten with
;;*          its right singular vectors, stored rowwise.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution
;;*          matrix X.  If m >= n and RANK = n, the residual
;;*          sum-of-squares for the solution in the i-th column is given
;;*          by the sum of squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,max(M,N)).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1, and also:
;;*          LWORK >= 3*min(M,N) + max( 2*min(M,N), max(M,N), NRHS )
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgelss (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgelss_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($s,float), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgelsx <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine SGELSY.
;;*
;;*  SGELSX computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be 
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by orthogonal transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements N+1:M in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is an
;;*          initial column, otherwise it is a free column.  Before
;;*          the QR factorization of A, all initial columns are
;;*          permuted to the leading positions; only the remaining
;;*          free columns are moved as a result of column pivoting
;;*          during the factorization.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                      (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgelsx (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgelsx_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgelsy <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGELSY computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by orthogonal transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  This routine is basically identical to the original xGELSX except
;;*  three differences:
;;*    o The call to the subroutine xGEQPF has been substituted by the
;;*      the call to the subroutine xGEQP3. This subroutine is a Blas-3
;;*      version of the QR factorization with column pivoting.
;;*    o Matrix B (the right hand side) is updated with Blas-3.
;;*    o The permutation of matrix B (the right hand side) is faster and
;;*      more simple.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of AP, otherwise column i is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of AP
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) REAL
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          The unblocked strategy requires that:
;;*             LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
;;*          where MN = min( M, N ).
;;*          The block algorithm requires that:
;;*             LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
;;*          where NB is an upper bound on the blocksize returned
;;*          by ILAENV for the routines SGEQP3, STZRZF, STZRQF, SORMQR,
;;*          and SORMRZ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: If INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgelsy (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgelsy_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeql2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEQL2 computes a QL factorization of a real m by n matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the m by n lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          orthogonal matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeql2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgeql2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeqlf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEQLF computes a QL factorization of a real M-by-N matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the M-by-N lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          orthogonal matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sgeqlf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgeqlf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeqp3 <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEQP3 computes a QR factorization with column pivoting of a
;;*  matrix A:  A*P = Q*R  using Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper trapezoidal matrix R; the elements below
;;*          the diagonal, together with the array TAU, represent the
;;*          orthogonal matrix Q as a product of min(M,N) elementary
;;*          reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(J).ne.0, the J-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(J)=0,
;;*          the J-th column of A is a free column.
;;*          On exit, if JPVT(J)=K, then the J-th column of A*P was the
;;*          the K-th column of A.
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 3*N+1.
;;*          For optimal performance LWORK >= 2*N+( N+1 )*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real/complex scalar, and v is a real/complex vector
;;*  with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
;;*  A(i+1:m,i), and tau in TAU(i).
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeqp3 (m  n  a  lda  jpvt  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgeqp3_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeqpf <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine SGEQP3.
;;*
;;*  SGEQPF computes a QR factorization with column pivoting of a
;;*  real M-by-N matrix A: A*P = Q*R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper triangular matrix R; the elements
;;*          below the diagonal, together with the array TAU,
;;*          represent the orthogonal matrix Q as a product of
;;*          min(m,n) elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n)
;;*
;;*  Each H(i) has the form
;;*
;;*     H = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
;;*
;;*  The matrix P is represented in jpvt as follows: If
;;*     jpvt(j) = i
;;*  then the jth column of P is the ith canonical unit vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeqpf (m  n  a  lda  jpvt  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgeqpf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeqr2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEQR2 computes a QR factorization of a real m by n matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(m,n) by n upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgeqr2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgeqr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgeqrf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGEQRF computes a QR factorization of a real M-by-N matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of min(m,n) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is 
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sgeqrf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgeqrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgerfs <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGERFS improves the computed solution to a system of linear
;;*  equations and provides error bounds and backward error estimates for
;;*  the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The original N-by-N matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) REAL array, dimension (LDAF,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by SGETRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from SGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SGETRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgerfs (trans  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgerfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgerq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGERQ2 computes an RQ factorization of a real m by n matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the m by n upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAU, represent the orthogonal matrix
;;*          Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) REAL array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgerq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sgerq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgerqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGERQF computes an RQ factorization of a real M-by-N matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R;
;;*          the remaining elements, with the array TAU, represent the
;;*          orthogonal matrix Q as a product of min(m,n) elementary
;;*          reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sgerqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgerqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgesc2 <n>  <a>  <lda>  <rhs>  <ipiv>  <jpiv>  <scale>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGESC2 solves a system of linear equations
;;*
;;*            A * X = scale* RHS
;;*
;;*  with a general N-by-N matrix A using the LU factorization with
;;*  complete pivoting computed by SGETC2.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          On entry, the  LU part of the factorization of the n-by-n
;;*          matrix A computed by SGETC2:  A = P * L * U * Q
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) REAL array, dimension (N).
;;*          On entry, the right hand side vector b.
;;*          On exit, the solution vector X.
;;*
;;*  IPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  SCALE    (output) REAL
;;*           On exit, SCALE contains the scale factor. SCALE is chosen
;;*           0 <= SCALE <= 1 to prevent owerflow in the solution.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgesc2 (n  a  lda  rhs  ipiv  jpiv  scale  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) rhs )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-float-)) scale )
	#{ sgesc2_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($rhs,float), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($scale,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgesdd <jobz>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGESDD computes the singular value decomposition (SVD) of a real
;;*  M-by-N matrix A, optionally computing the left and right singular
;;*  vectors.  If singular vectors are desired, it uses a
;;*  divide-and-conquer algorithm.
;;*
;;*  The SVD is written
;;*
;;*       A = U * SIGMA * transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
;;*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns VT = V**T, not V.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U and all N rows of V**T are
;;*                  returned in the arrays U and VT;
;;*          = 'S':  the first min(M,N) columns of U and the first
;;*                  min(M,N) rows of V**T are returned in the arrays U
;;*                  and VT;
;;*          = 'O':  If M >= N, the first N columns of U are overwritten
;;*                  on the array A and all rows of V**T are returned in
;;*                  the array VT;
;;*                  otherwise, all columns of U are returned in the
;;*                  array U and the first M rows of V**T are overwritten
;;*                  in the array VT;
;;*          = 'N':  no columns of U or rows of V**T are computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBZ = 'O',  A is overwritten with the first N columns
;;*                          of U (the left singular vectors, stored
;;*                          columnwise) if M >= N;
;;*                          A is overwritten with the first M rows
;;*                          of V**T (the right singular vectors, stored
;;*                          rowwise) otherwise.
;;*          if JOBZ .ne. 'O', the contents of A are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) REAL array, dimension (LDU,UCOL)
;;*          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
;;*          UCOL = min(M,N) if JOBZ = 'S'.
;;*          If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
;;*          orthogonal matrix U;
;;*          if JOBZ = 'S', U contains the first min(M,N) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
;;*
;;*  VT      (output) REAL array, dimension (LDVT,N)
;;*          If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
;;*          N-by-N orthogonal matrix V**T;
;;*          if JOBZ = 'S', VT contains the first min(M,N) rows of
;;*          V**T (the right singular vectors, stored rowwise);
;;*          if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
;;*          if JOBZ = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          If JOBZ = 'N',
;;*            LWORK >= 3*min(M,N) + max(max(M,N),6*min(M,N)).
;;*          If JOBZ = 'O',
;;*            LWORK >= 3*min(M,N)*min(M,N) + 
;;*                     max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
;;*          If JOBZ = 'S' or 'A'
;;*            LWORK >= 3*min(M,N)*min(M,N) +
;;*                     max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
;;*          For good performance, LWORK should generally be larger.
;;*          If LWORK < 0 but other input arguments are legal, WORK(1)
;;*          returns the optimal LWORK.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  SBDSDC did not converge, updating process failed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgesdd (jobz  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  iwork  info  )
	((-str-) jobz )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgesdd_($jobz->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgesvd <jobu>  <jobvt>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGESVD computes the singular value decomposition (SVD) of a real
;;*  M-by-N matrix A, optionally computing the left and/or right singular
;;*  vectors. The SVD is written
;;*
;;*       A = U * SIGMA * transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
;;*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns V**T, not V.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U are returned in array U:
;;*          = 'S':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are returned in the array U;
;;*          = 'O':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no columns of U (no left singular vectors) are
;;*                  computed.
;;*
;;*  JOBVT   (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix
;;*          V**T:
;;*          = 'A':  all N rows of V**T are returned in the array VT;
;;*          = 'S':  the first min(m,n) rows of V**T (the right singular
;;*                  vectors) are returned in the array VT;
;;*          = 'O':  the first min(m,n) rows of V**T (the right singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no rows of V**T (no right singular vectors) are
;;*                  computed.
;;*
;;*          JOBVT and JOBU cannot both be 'O'.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBU = 'O',  A is overwritten with the first min(m,n)
;;*                          columns of U (the left singular vectors,
;;*                          stored columnwise);
;;*          if JOBVT = 'O', A is overwritten with the first min(m,n)
;;*                          rows of V**T (the right singular vectors,
;;*                          stored rowwise);
;;*          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
;;*                          are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) REAL array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) REAL array, dimension (LDU,UCOL)
;;*          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
;;*          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
;;*          if JOBU = 'S', U contains the first min(m,n) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBU = 'N' or 'O', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBU = 'S' or 'A', LDU >= M.
;;*
;;*  VT      (output) REAL array, dimension (LDVT,N)
;;*          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
;;*          V**T;
;;*          if JOBVT = 'S', VT contains the first min(m,n) rows of
;;*          V**T (the right singular vectors, stored rowwise);
;;*          if JOBVT = 'N' or 'O', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
;;*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
;;*          superdiagonal elements of an upper bidiagonal matrix B
;;*          whose diagonal is in S (not necessarily sorted). B
;;*          satisfies A = U * B * VT, so it has the same singular values
;;*          as A, and singular vectors related by U and VT.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if SBDSQR did not converge, INFO specifies how many
;;*                superdiagonals of an intermediate bidiagonal form B
;;*                did not converge to zero. See the description of WORK
;;*                above for details.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgesvd (jobu  jobvt  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  info  )
	((-str-) jobu )
	((-str-) jobvt )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgesvd_($jobu->data, $jobvt->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgesv <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGESV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as
;;*     A = P * L * U,
;;*  where P is a permutation matrix, L is unit lower triangular, and U is
;;*  upper triangular.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the N-by-N coefficient matrix A.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS matrix of right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de sgesv (n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sgesv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgesvx <fact>  <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGESVX uses the LU factorization to compute the solution to a real
;;*  system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = P * L * U,
;;*     where P is a permutation matrix, L is a unit lower triangular
;;*     matrix, and U is upper triangular.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF and IPIV contain the factored form of A.
;;*                  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  A, AF, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
;;*          not 'N', then A must have been equilibrated by the scaling
;;*          factors in R and/or C.  A is not modified if FACT = 'F' or
;;*          'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) REAL array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the factors L and U from the factorization
;;*          A = P*L*U as computed by SGETRF.  If EQUED .ne. 'N', then
;;*          AF is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the equilibrated matrix A (see the description of A for
;;*          the form of the equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          as computed by SGETRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) REAL array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) REAL array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (4*N)
;;*          On exit, WORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If WORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          WORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization has
;;*                       been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgesvx (fact  trans  n  nrhs  a  lda  af  ldaf  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgesvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgetc2 <n>  <a>  <lda>  <ipiv>  <jpiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGETC2 computes an LU factorization with complete pivoting of the
;;*  n-by-n matrix A. The factorization has the form A = P * L * U * Q,
;;*  where P and Q are permutation matrices, L is lower triangular with
;;*  unit diagonal elements and U is upper triangular.
;;*
;;*  This is the Level 2 BLAS algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the n-by-n matrix A to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U*Q; the unit diagonal elements of L are not stored.
;;*          If U(k, k) appears to be less than SMIN, U(k, k) is given the
;;*          value of SMIN, i.e., giving a nonsingular perturbed system.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension(N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (output) INTEGER array, dimension(N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  INFO    (output) INTEGER
;;*           = 0: successful exit
;;*           > 0: if INFO = k, U(k, k) is likely to produce owerflow if
;;*                we try to solve for x in Ax = b. So U is perturbed to
;;*                avoid the overflow.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgetc2 (n  a  lda  ipiv  jpiv  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-int-)) info )
	#{ sgetc2_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgetf2 <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGETF2 computes an LU factorization of a general m-by-n matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgetf2 (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ sgetf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgetrf <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGETRF computes an LU factorization of a general M-by-N matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgetrf (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ sgetrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgetri <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGETRI computes the inverse of a matrix using the LU factorization
;;*  computed by SGETRF.
;;*
;;*  This method inverts U and then computes inv(A) by solving the system
;;*  inv(A)*L = inv(U) for inv(A).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the factors L and U from the factorization
;;*          A = P*L*U as computed by SGETRF.
;;*          On exit, if INFO = 0, the inverse of the original matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from SGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimal performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
;;*                singular and its inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgetri (n  a  lda  ipiv  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgetri_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgetrs <trans>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGETRS solves a system of linear equations
;;*     A * X = B  or  A' * X = B
;;*  with a general N-by-N matrix A using the LU factorization computed
;;*  by SGETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A'* X = B  (Transpose)
;;*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by SGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from SGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgetrs (trans  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sgetrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggbak <job>  <side>  <n>  <ilo>  <ihi>  <lscale>  <rscale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGBAK forms the right or left eigenvectors of a real generalized
;;*  eigenvalue problem A*x = lambda*B*x, by backward transformation on
;;*  the computed eigenvectors of the balanced pair of matrices output by
;;*  SGGBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N':  do nothing, return immediately;
;;*          = 'P':  do backward transformation for permutation only;
;;*          = 'S':  do backward transformation for scaling only;
;;*          = 'B':  do backward transformations for both permutation and
;;*                  scaling.
;;*          JOB must be the same as the argument JOB supplied to SGGBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by SGGBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  LSCALE  (input) REAL array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the left side of A and B, as returned by SGGBAL.
;;*
;;*  RSCALE  (input) REAL array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the right side of A and B, as returned by SGGBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) REAL array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by STGEVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the matrix V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. Ward, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sggbak (job  side  n  ilo  ihi  lscale  rscale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) lscale )
	((-idx1- (-float-)) rscale )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ sggbak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,float), IDX_PTR($rscale,float), IDX_PTR($m,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggbal <job>  <n>  <a>  <lda>  <b>  <ldb>  <ilo>  <ihi>  <lscale>  <rscale>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGBAL balances a pair of general real matrices (A,B).  This
;;*  involves, first, permuting A and B by similarity transformations to
;;*  isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
;;*  elements on the diagonal; and second, applying a diagonal similarity
;;*  transformation to rows and columns ILO to IHI to make the rows
;;*  and columns as close in norm as possible. Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrices, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors in the
;;*  generalized eigenvalue problem A*x = lambda*B*x.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A and B:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
;;*                  and RSCALE(I) = 1.0 for i = 1,...,N.
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit,  A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the input matrix B.
;;*          On exit,  B is overwritten by the balanced matrix.
;;*          If JOB = 'N', B is not referenced.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If P(j) is the index of the
;;*          row interchanged with row j, and D(j)
;;*          is the scaling factor applied to row j, then
;;*            LSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If P(j) is the index of the
;;*          column interchanged with column j, and D(j)
;;*          is the scaling factor applied to column j, then
;;*            LSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  WORK    (workspace) REAL array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. WARD, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sggbal (job  n  a  lda  b  ldb  ilo  ihi  lscale  rscale  work  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) lscale )
	((-idx1- (-float-)) rscale )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sggbal_($job->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,float), IDX_PTR($rscale,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgges <jobvsl>  <jobvsr>  <sort>  <selctg>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alphar>  <alphai>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
;;*  the generalized eigenvalues, the generalized real Schur form (S,T),
;;*  optionally, the left and/or right matrices of Schur vectors (VSL and
;;*  VSR). This gives the generalized Schur factorization
;;*
;;*           (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  quasi-triangular matrix S and the upper triangular matrix T.The
;;*  leading columns of VSL and VSR then form an orthonormal basis for the
;;*  corresponding left and right eigenspaces (deflating subspaces).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver
;;*  SGGEV instead, which is faster.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0 or both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized real Schur form if T is
;;*  upper triangular with non-negative diagonal and S is block upper
;;*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
;;*  to real generalized eigenvalues, while 2-by-2 blocks of S will be
;;*  "standardized" by making the corresponding elements of T have the
;;*  form:
;;*          [  a  0  ]
;;*          [  0  b  ]
;;*
;;*  and the pair of corresponding 2-by-2 blocks in S and T will have a
;;*  complex conjugate pair of generalized eigenvalues.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see SELCTG);
;;*
;;*  SELCTG  (input) LOGICAL FUNCTION of three REAL arguments
;;*          SELCTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', SELCTG is not referenced.
;;*          If SORT = 'S', SELCTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
;;*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
;;*          one of a complex conjugate pair of eigenvalues is selected,
;;*          then both complex eigenvalues are selected.
;;*
;;*          Note that in the ill-conditioned case, a selected complex
;;*          eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),
;;*          BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
;;*          in this case.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which SELCTG is true.  (Complex conjugate pairs for which
;;*          SELCTG is true for either eigenvalue count as 2.)
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
;;*          and  BETA(j),j=1,...,N are the diagonals of the complex Schur
;;*          form (S,T) that would result if the 2-by-2 diagonal blocks of
;;*          the real Schur form of (A,B) were further reduced to
;;*          triangular form using 2-by-2 complex unitary transformations.
;;*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
;;*          positive, then the j-th and (j+1)-st eigenvalues are a
;;*          complex conjugate pair, with ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio.
;;*          However, ALPHAR and ALPHAI will be always less than and
;;*          usually comparable with norm(A) in magnitude, and BETA always
;;*          less than and usually comparable with norm(B).
;;*
;;*  VSL     (output) REAL array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) REAL array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 8*N+16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
;;*                be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in SHGEQZ.
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy SELCTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering failed in STGSEN.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgges (jobvsl  jobvsr  sort  selctg  n  a  lda  b  ldb  sdim  alphar  alphai  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")selctg )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx2- (-float-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ sgges_($jobvsl->data, $jobvsr->data, $sort->data, $selctg, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($vsl,float), IDX_PTR($ldvsl,int), IDX_PTR($vsr,float), IDX_PTR($ldvsr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggesx <jobvsl>  <jobvsr>  <sort>  <selctg>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alphar>  <alphai>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <liwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGESX computes for a pair of N-by-N real nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
;;*  optionally, the left and/or right matrices of Schur vectors (VSL and
;;*  VSR).  This gives the generalized Schur factorization
;;*
;;*       (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  quasi-triangular matrix S and the upper triangular matrix T; computes
;;*  a reciprocal condition number for the average of the selected
;;*  eigenvalues (RCONDE); and computes a reciprocal condition number for
;;*  the right and left deflating subspaces corresponding to the selected
;;*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form
;;*  an orthonormal basis for the corresponding left and right eigenspaces
;;*  (deflating subspaces).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0 or for both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized real Schur form if T is
;;*  upper triangular with non-negative diagonal and S is block upper
;;*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
;;*  to real generalized eigenvalues, while 2-by-2 blocks of S will be
;;*  "standardized" by making the corresponding elements of T have the
;;*  form:
;;*          [  a  0  ]
;;*          [  0  b  ]
;;*
;;*  and the pair of corresponding 2-by-2 blocks in S and T will have a
;;*  complex conjugate pair of generalized eigenvalues.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see SELCTG).
;;*
;;*  SELCTG  (input) LOGICAL FUNCTION of three REAL arguments
;;*          SELCTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', SELCTG is not referenced.
;;*          If SORT = 'S', SELCTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
;;*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
;;*          one of a complex conjugate pair of eigenvalues is selected,
;;*          then both complex eigenvalues are selected.
;;*          Note that a selected complex eigenvalue may no longer satisfy
;;*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,
;;*          since ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned), in this
;;*          case INFO is set to N+3.
;;*
;;*  SENSE   (input) CHARACTER
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N' : None are computed;
;;*          = 'E' : Computed for average of selected eigenvalues only;
;;*          = 'V' : Computed for selected deflating subspaces only;
;;*          = 'B' : Computed for both.
;;*          If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which SELCTG is true.  (Complex conjugate pairs for which
;;*          SELCTG is true for either eigenvalue count as 2.)
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i
;;*          and BETA(j),j=1,...,N  are the diagonals of the complex Schur
;;*          form (S,T) that would result if the 2-by-2 diagonal blocks of
;;*          the real Schur form of (A,B) were further reduced to
;;*          triangular form using 2-by-2 complex unitary transformations.
;;*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
;;*          positive, then the j-th and (j+1)-st eigenvalues are a
;;*          complex conjugate pair, with ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio.
;;*          However, ALPHAR and ALPHAI will be always less than and
;;*          usually comparable with norm(A) in magnitude, and BETA always
;;*          less than and usually comparable with norm(B).
;;*
;;*  VSL     (output) REAL array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) REAL array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  RCONDE  (output) REAL array, dimension ( 2 )
;;*          If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
;;*          reciprocal condition numbers for the average of the selected
;;*          eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) REAL array, dimension ( 2 )
;;*          If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
;;*          reciprocal condition numbers for the selected deflating
;;*          subspaces.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 8*(N+1)+16.
;;*          If SENSE = 'E', 'V', or 'B',
;;*          LWORK >= MAX( 8*(N+1)+16, 2*SDIM*(N-SDIM) ).
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          Not referenced if SENSE = 'N'.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array WORK.  LIWORK >= N+6.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
;;*                be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in SHGEQZ
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy SELCTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering failed in STGSEN.
;;*
;;*  Further details
;;*  ===============
;;*
;;*  An approximate (asymptotic) bound on the average absolute error of
;;*  the selected eigenvalues is
;;*
;;*       EPS * norm((A, B)) / RCONDE( 1 ).
;;*
;;*  An approximate (asymptotic) bound on the maximum angular error in
;;*  the computed deflating subspaces is
;;*
;;*       EPS * norm((A, B)) / RCONDV( 2 ).
;;*
;;*  See LAPACK User's Guide, section 4.11 for more information.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sggesx (jobvsl  jobvsr  sort  selctg  sense  n  a  lda  b  ldb  sdim  alphar  alphai  beta  vsl  ldvsl  vsr  ldvsr  rconde  rcondv  work  lwork  iwork  liwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")selctg )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx2- (-float-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-float-)) rconde )
	((-idx1- (-float-)) rcondv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ sggesx_($jobvsl->data, $jobvsr->data, $sort->data, $selctg, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($vsl,float), IDX_PTR($ldvsl,int), IDX_PTR($vsr,float), IDX_PTR($ldvsr,int), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggev <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
;;*  the generalized eigenvalues, and optionally, the left and/or right
;;*  generalized eigenvectors.
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   A * v(j) = lambda(j) * B * v(j).
;;*
;;*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   u(j)**H * A  = lambda(j) * u(j)**H * B .
;;*
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
;;*          the j-th eigenvalue is real; if positive, then the j-th and
;;*          (j+1)-st eigenvalues are a complex conjugate pair, with
;;*          ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          alpha/beta.  However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VL      (output) REAL array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          u(j) = VL(:,j), the j-th column of VL. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part)+abs(imag. part)=1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) REAL array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          v(j) = VR(:,j), the j-th column of VR. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part)+abs(imag. part)=1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,8*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
;;*                should be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in SHGEQZ.
;;*                =N+2: error return from STGEVC.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sggev (jobvl  jobvr  n  a  lda  b  ldb  alphar  alphai  beta  vl  ldvl  vr  ldvr  work  lwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sggev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <lscale>  <rscale>  <abnrm>  <bbnrm>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
;;*  the generalized eigenvalues, and optionally, the left and/or right
;;*  generalized eigenvectors.
;;*
;;*  Optionally also, it computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
;;*  the eigenvalues (RCONDE), and reciprocal condition numbers for the
;;*  right eigenvectors (RCONDV).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   A * v(j) = lambda(j) * B * v(j) .
;;*
;;*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   u(j)**H * A  = lambda(j) * u(j)**H * B.
;;*
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Specifies the balance option to be performed.
;;*          = 'N':  do not diagonally scale or permute;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*          Computed reciprocal condition numbers will be for the
;;*          matrices after permuting and/or balancing. Permuting does
;;*          not change condition numbers (in exact arithmetic), but
;;*          balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': none are computed;
;;*          = 'E': computed for eigenvalues only;
;;*          = 'V': computed for eigenvectors only;
;;*          = 'B': computed for eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then A contains the first part of the real Schur
;;*          form of the "balanced" versions of the input A and B.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then B contains the second part of the real Schur
;;*          form of the "balanced" versions of the input A and B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
;;*          the j-th eigenvalue is real; if positive, then the j-th and
;;*          (j+1)-st eigenvalues are a complex conjugate pair, with
;;*          ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VL      (output) REAL array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          u(j) = VL(:,j), the j-th column of VL. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) REAL array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          v(j) = VR(:,j), the j-th column of VR. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If BALANC = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If PL(j) is the index of the
;;*          row interchanged with row j, and DL(j) is the scaling
;;*          factor applied to row j, then
;;*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1
;;*                      = DL(j)  for j = ILO,...,IHI
;;*                      = PL(j)  for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) REAL array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If PR(j) is the index of the
;;*          column interchanged with column j, and DR(j) is the scaling
;;*          factor applied to column j, then
;;*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1
;;*                      = DR(j)  for j = ILO,...,IHI
;;*                      = PR(j)  for j = IHI+1,...,N
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) REAL
;;*          The one-norm of the balanced matrix A.
;;*
;;*  BBNRM   (output) REAL
;;*          The one-norm of the balanced matrix B.
;;*
;;*  RCONDE  (output) REAL array, dimension (N)
;;*          If SENSE = 'E' or 'B', the reciprocal condition numbers of
;;*          the selected eigenvalues, stored in consecutive elements of
;;*          the array. For a complex conjugate pair of eigenvalues two
;;*          consecutive elements of RCONDE are set to the same value.
;;*          Thus RCONDE(j), RCONDV(j), and the j-th columns of VL and VR
;;*          all correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If SENSE = 'V', RCONDE is not referenced.
;;*
;;*  RCONDV  (output) REAL array, dimension (N)
;;*          If SENSE = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. For a complex eigenvector two
;;*          consecutive elements of RCONDV are set to the same value. If
;;*          the eigenvalues cannot be reordered to compute RCONDV(j),
;;*          RCONDV(j) is set to 0; this can only occur when the true
;;*          value would be very small anyway.
;;*          If SENSE = 'E', RCONDV is not referenced.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,6*N).
;;*          If SENSE = 'E', LWORK >= 12*N.
;;*          If SENSE = 'V' or 'B', LWORK >= 2*N*N+12*N+16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N+6)
;;*          If SENSE = 'E', IWORK is not referenced.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          If SENSE = 'N', BWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
;;*                should be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in SHGEQZ.
;;*                =N+2: error return from STGEVC.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing a matrix pair (A,B) includes, first, permuting rows and
;;*  columns to isolate eigenvalues, second, applying diagonal similarity
;;*  transformation to the rows and columns to make the rows and columns
;;*  as close in norm as possible. The computed reciprocal condition
;;*  numbers correspond to the balanced matrix. Permuting rows and columns
;;*  will not change the condition numbers (in exact arithmetic) but
;;*  diagonal scaling will.  For further explanation of balancing, see
;;*  section 4.11.1.2 of LAPACK Users' Guide.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)
;;*
;;*  An approximate error bound for the angle between the i-th computed
;;*  eigenvector VL(i) or VR(i) is given by
;;*
;;*       EPS * norm(ABNRM, BBNRM) / DIF(i).
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see section 4.11 of LAPACK User's Guide.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sggevx (balanc  jobvl  jobvr  sense  n  a  lda  b  ldb  alphar  alphai  beta  vl  ldvl  vr  ldvr  ilo  ihi  lscale  rscale  abnrm  bbnrm  rconde  rcondv  work  lwork  iwork  bwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-float-)) lscale )
	((-idx1- (-float-)) rscale )
	((-idx0- (-float-)) abnrm )
	((-idx0- (-float-)) bbnrm )
	((-idx1- (-float-)) rconde )
	((-idx1- (-float-)) rcondv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ sggevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,float), IDX_PTR($rscale,float), IDX_PTR($abnrm,float), IDX_PTR($bbnrm,float), IDX_PTR($rconde,float), IDX_PTR($rcondv,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggglm <n>  <m>  <p>  <a>  <lda>  <b>  <ldb>  <d>  <x>  <y>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGGLM solves a general Gauss-Markov linear model (GLM) problem:
;;*
;;*          minimize || y ||_2   subject to   d = A*x + B*y
;;*              x
;;*
;;*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
;;*  given N-vector. It is assumed that M <= N <= M+P, and
;;*
;;*             rank(A) = M    and    rank( A B ) = N.
;;*
;;*  Under these assumptions, the constrained equation is always
;;*  consistent, and there is a unique solution x and a minimal 2-norm
;;*  solution y, which is obtained using a generalized QR factorization
;;*  of A and B.
;;*
;;*  In particular, if matrix B is square nonsingular, then the problem
;;*  GLM is equivalent to the following weighted linear least squares
;;*  problem
;;*
;;*               minimize || inv(B)*(d-A*x) ||_2
;;*                   x
;;*
;;*  where inv(B) denotes the inverse of B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B.  N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  0 <= M <= N.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= N-M.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, D is the left hand side of the GLM equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) REAL array, dimension (M)
;;*  Y       (output) REAL array, dimension (P)
;;*          On exit, X and Y are the solutions of the GLM problem.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N+M+P).
;;*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          SGEQRF, SGERQF, SORMQR and SORMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  ===================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sggglm (n  m  p  a  lda  b  ldb  d  x  y  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) x )
	((-idx1- (-float-)) y )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sggglm_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($d,float), IDX_PTR($x,float), IDX_PTR($y,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgghrd <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGHRD reduces a pair of real matrices (A,B) to generalized upper
;;*  Hessenberg form using orthogonal transformations, where A is a
;;*  general matrix and B is upper triangular:  Q' * A * Z = H and
;;*  Q' * B * Z = T, where H is upper Hessenberg, T is upper triangular,
;;*  and Q and Z are orthogonal, and ' means transpose.
;;*
;;*  The orthogonal matrices Q and Z are determined as products of Givens
;;*  rotations.  They may either be formed explicitly, or they may be
;;*  postmultiplied into input matrices Q1 and Z1, so that 
;;*
;;*       Q1 * A * Z1' = (Q1*Q) * H * (Z1*Z)'
;;*       Q1 * B * Z1' = (Q1*Q) * T * (Z1*Z)'
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not compute Q;
;;*          = 'I': Q is initialized to the unit matrix, and the
;;*                 orthogonal matrix Q is returned;
;;*          = 'V': Q must contain an orthogonal matrix Q1 on entry,
;;*                 and the product Q1*Q is returned.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not compute Z;
;;*          = 'I': Z is initialized to the unit matrix, and the
;;*                 orthogonal matrix Z is returned;
;;*          = 'V': Z must contain an orthogonal matrix Z1 on entry,
;;*                 and the product Z1*Z is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.  ILO and IHI are normally set
;;*          by a previous call to SGGBAL; otherwise they should be set
;;*          to 1 and N respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          rest is set to zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.
;;*          On exit, the upper triangular matrix T = Q' B Z.  The
;;*          elements below the diagonal are set to zero.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ, N)
;;*          If COMPQ='N':  Q is not referenced.
;;*          If COMPQ='I':  on entry, Q need not be set, and on exit it
;;*                         contains the orthogonal matrix Q, where Q'
;;*                         is the product of the Givens transformations
;;*                         which are applied to A and B on the left.
;;*          If COMPQ='V':  on entry, Q must contain an orthogonal matrix
;;*                         Q1, and on exit this is overwritten by Q1*Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ, N)
;;*          If COMPZ='N':  Z is not referenced.
;;*          If COMPZ='I':  on entry, Z need not be set, and on exit it 
;;*                         contains the orthogonal matrix Z, which is
;;*                         the product of the Givens transformations
;;*                         which are applied to A and B on the right.
;;*          If COMPZ='V':  on entry, Z must contain an orthogonal matrix
;;*                         Z1, and on exit this is overwritten by Z1*Z.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine reduces A to Hessenberg and B to triangular form by
;;*  an unblocked reduction, as described in _Matrix_Computations_,
;;*  by Golub and Van Loan (Johns Hopkins Press.)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgghrd (compq  compz  n  ilo  ihi  a  lda  b  ldb  q  ldq  z  ldz  info  )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ sgghrd_($compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgglse <m>  <n>  <p>  <a>  <lda>  <b>  <ldb>  <c>  <d>  <x>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGLSE solves the linear equality-constrained least squares (LSE)
;;*  problem:
;;*
;;*          minimize || c - A*x ||_2   subject to   B*x = d
;;*
;;*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
;;*  M-vector, and d is a given P-vector. It is assumed that
;;*  P <= N <= M+P, and
;;*
;;*           rank(B) = P and  rank( ( A ) ) = N.
;;*                                ( ( B ) )
;;*
;;*  These conditions ensure that the LSE problem has a unique solution,
;;*  which is obtained using a GRQ factorization of the matrices B and A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B. 0 <= P <= N <= M+P.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  C       (input/output) REAL array, dimension (M)
;;*          On entry, C contains the right hand side vector for the
;;*          least squares part of the LSE problem.
;;*          On exit, the residual sum of squares for the solution
;;*          is given by the sum of squares of elements N-P+1 to M of
;;*          vector C.
;;*
;;*  D       (input/output) REAL array, dimension (P)
;;*          On entry, D contains the right hand side vector for the
;;*          constrained equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) REAL array, dimension (N)
;;*          On exit, X is the solution of the LSE problem.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M+N+P).
;;*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          SGEQRF, SGERQF, SORMQR and SORMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgglse (m  n  p  a  lda  b  ldb  c  d  x  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) x )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sgglse_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($d,float), IDX_PTR($x,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggqrf <n>  <m>  <p>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGQRF computes a generalized QR factorization of an N-by-M matrix A
;;*  and an N-by-P matrix B:
;;*
;;*              A = Q*R,        B = Q*T*Z,
;;*
;;*  where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
;;*  matrix, and R and T assume one of the forms:
;;*
;;*  if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
;;*                  (  0  ) N-M                         N   M-N
;;*                     M
;;*
;;*  where R11 is upper triangular, and
;;*
;;*  if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
;;*                   P-N  N                           ( T21 ) P
;;*                                                       P
;;*
;;*  where T12 or T21 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GQR factorization
;;*  of A and B implicitly gives the QR factorization of inv(B)*A:
;;*
;;*               inv(B)*A = Z'*(inv(T)*R)
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  transpose of the matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B. N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(N,M)-by-M upper trapezoidal matrix R (R is
;;*          upper triangular if N >= M); the elements below the diagonal,
;;*          with the array TAUA, represent the orthogonal matrix Q as a
;;*          product of min(N,M) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAUA    (output) REAL array, dimension (min(N,M))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q (see Further Details).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, if N <= P, the upper triangle of the subarray
;;*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
;;*          if N > P, the elements on and above the (N-P)-th subdiagonal
;;*          contain the N-by-P upper trapezoidal matrix T; the remaining
;;*          elements, with the array TAUB, represent the orthogonal
;;*          matrix Z as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  TAUB    (output) REAL array, dimension (min(N,P))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the QR factorization
;;*          of an N-by-M matrix, NB2 is the optimal blocksize for the
;;*          RQ factorization of an N-by-P matrix, and NB3 is the optimal
;;*          blocksize for a call of SORMQR.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(n,m).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine SORGQR.
;;*  To use Q to update another matrix, use LAPACK subroutine SORMQR.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(n,p).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a real scalar, and v is a real vector with
;;*  v(p-k+i+1:p) = 0 and v(p-k+i) = 1; v(1:p-k+i-1) is stored on exit in
;;*  B(n-k+i,1:p-k+i-1), and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine SORGRQ.
;;*  To use Z to update another matrix, use LAPACK subroutine SORMRQ.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sggqrf (n  m  p  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) taua )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) taub )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sggqrf_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($taua,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($taub,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggrqf <m>  <p>  <n>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGRQF computes a generalized RQ factorization of an M-by-N matrix A
;;*  and a P-by-N matrix B:
;;*
;;*              A = R*Q,        B = Z*T*Q,
;;*
;;*  where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
;;*  matrix, and R and T assume one of the forms:
;;*
;;*  if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
;;*                   N-M  M                           ( R21 ) N
;;*                                                       N
;;*
;;*  where R12 or R21 is upper triangular, and
;;*
;;*  if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
;;*                  (  0  ) P-N                         P   N-P
;;*                     N
;;*
;;*  where T11 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GRQ factorization
;;*  of A and B implicitly gives the RQ factorization of A*inv(B):
;;*
;;*               A*inv(B) = (R*inv(T))*Z'
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  transpose of the matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, if M <= N, the upper triangle of the subarray
;;*          A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
;;*          if M > N, the elements on and above the (M-N)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAUA, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAUA    (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q (see Further Details).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(P,N)-by-N upper trapezoidal matrix T (T is
;;*          upper triangular if P >= N); the elements below the diagonal,
;;*          with the array TAUB, represent the orthogonal matrix Z as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TAUB    (output) REAL array, dimension (min(P,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the RQ factorization
;;*          of an M-by-N matrix, NB2 is the optimal blocksize for the
;;*          QR factorization of a P-by-N matrix, and NB3 is the optimal
;;*          blocksize for a call of SORMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INF0= -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a real scalar, and v is a real vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine SORGRQ.
;;*  To use Q to update another matrix, use LAPACK subroutine SORMRQ.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(p,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i),
;;*  and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine SORGQR.
;;*  To use Z to update another matrix, use LAPACK subroutine SORMQR.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sggrqf (m  p  n  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) taua )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) taub )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sggrqf_(IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($taua,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($taub,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggsvd <jobu>  <jobv>  <jobq>  <m>  <n>  <p>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGSVD computes the generalized singular value decomposition (GSVD)
;;*  of an M-by-N real matrix A and P-by-N real matrix B:
;;*
;;*      U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
;;*
;;*  where U, V and Q are orthogonal matrices, and Z' is the transpose
;;*  of Z.  Let K+L = the effective numerical rank of the matrix (A',B')',
;;*  then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
;;*  D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
;;*  following structures, respectively:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                    K  L
;;*         D2 =   L ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                  N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 )
;;*              L (  0    0   R22 )
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                    K M-K K+L-M
;;*         D1 =   K ( I  0    0   )
;;*              M-K ( 0  C    0   )
;;*
;;*                      K M-K K+L-M
;;*         D2 =   M-K ( 0  S    0  )
;;*              K+L-M ( 0  0    I  )
;;*                P-L ( 0  0    0  )
;;*
;;*                     N-K-L  K   M-K  K+L-M
;;*    ( 0 R ) =     K ( 0    R11  R12  R13  )
;;*                M-K ( 0     0   R22  R23  )
;;*              K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*    S = diag( BETA(K+1),  ... , BETA(M) ),
;;*    C**2 + S**2 = I.
;;*
;;*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
;;*    ( 0  R22 R23 )
;;*    in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The routine computes C, S, R, and optionally the orthogonal
;;*  transformation matrices U, V and Q.
;;*
;;*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
;;*  A and B implicitly gives the SVD of A*inv(B):
;;*                       A*inv(B) = U*(D1*inv(D2))*V'.
;;*  If ( A',B')' has orthonormal columns, then the GSVD of A and B is
;;*  also equal to the CS decomposition of A and B. Furthermore, the GSVD
;;*  can be used to derive the solution of the eigenvalue problem:
;;*                       A'*A x = lambda* B'*B x.
;;*  In some literature, the GSVD of A and B is presented in the form
;;*                   U'*A*X = ( 0 D1 ),   V'*B*X = ( 0 D2 )
;;*  where U and V are orthogonal and X is nonsingular, D1 and D2 are
;;*  ``diagonal''.  The former GSVD form can be converted to the latter
;;*  form by taking the nonsingular matrix X as
;;*
;;*                       X = Q*( I   0    )
;;*                             ( 0 inv(R) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Orthogonal matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Orthogonal matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Orthogonal matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in the Purpose section.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular matrix R, or part of R.
;;*          See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains the triangular matrix R if M-K-L < 0.
;;*          See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDA >= max(1,P).
;;*
;;*  ALPHA   (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = C,
;;*            BETA(K+1:K+L)  = S,
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
;;*            BETA(K+1:M) =S, BETA(M+1:K+L) =1
;;*          and
;;*            ALPHA(K+L+1:N) = 0
;;*            BETA(K+L+1:N)  = 0
;;*
;;*  U       (output) REAL array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the M-by-M orthogonal matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) REAL array, dimension (LDV,P)
;;*          If JOBV = 'V', V contains the P-by-P orthogonal matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) REAL array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) REAL array,
;;*                      dimension (max(3*N,M,P)+N)
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (N)
;;*          On exit, IWORK stores the sorting information. More
;;*          precisely, the following loop will sort ALPHA
;;*             for I = K+1, min(M,K+L)
;;*                 swap ALPHA(I) and ALPHA(IWORK(I))
;;*             endfor
;;*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
;;*
;;*  INFO    (output)INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, the Jacobi-type procedure failed to
;;*                converge.  For further details, see subroutine STGSJA.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLA    REAL
;;*  TOLB    REAL
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          rank of (A',B')'. Generally, they are set to
;;*                   TOLA = MAX(M,N)*norm(A)*MACHEPS,
;;*                   TOLB = MAX(P,N)*norm(B)*MACHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  2-96 Based on modifications by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sggsvd (jobu  jobv  jobq  m  n  p  k  l  a  lda  b  ldb  alpha  beta  u  ldu  v  ldv  q  ldq  work  iwork  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alpha )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sggsvd_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sggsvp <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <k>  <l>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <iwork>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGGSVP computes orthogonal matrices U, V and Q such that
;;*
;;*                   N-K-L  K    L
;;*   U'*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
;;*                L ( 0     0   A23 )
;;*            M-K-L ( 0     0    0  )
;;*
;;*                   N-K-L  K    L
;;*          =     K ( 0    A12  A13 )  if M-K-L < 0;
;;*              M-K ( 0     0   A23 )
;;*
;;*                 N-K-L  K    L
;;*   V'*B*Q =   L ( 0     0   B13 )
;;*            P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
;;*  numerical rank of the (M+P)-by-N matrix (A',B')'.  Z' denotes the
;;*  transpose of Z.
;;*
;;*  This decomposition is the preprocessing step for computing the
;;*  Generalized Singular Value Decomposition (GSVD), see subroutine
;;*  SGGSVD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Orthogonal matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Orthogonal matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Orthogonal matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular (or trapezoidal) matrix
;;*          described in the Purpose section.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains the triangular matrix described in
;;*          the Purpose section.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) REAL
;;*  TOLB    (input) REAL
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          numerical rank of matrix B and a subblock of A. Generally,
;;*          they are set to
;;*             TOLA = MAX(M,N)*norm(A)*MACHEPS,
;;*             TOLB = MAX(P,N)*norm(B)*MACHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in Purpose.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  U       (output) REAL array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the orthogonal matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) REAL array, dimension (LDV,M)
;;*          If JOBV = 'V', V contains the orthogonal matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) REAL array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the orthogonal matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  TAU     (workspace) REAL array, dimension (N)
;;*
;;*  WORK    (workspace) REAL array, dimension (max(3*N,M,P))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The subroutine uses LAPACK subroutine SGEQPF for the QR factorization
;;*  with column pivoting to detect the effective numerical rank of the
;;*  a matrix. It may be replaced by a better rank determination strategy.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sggsvp (jobu  jobv  jobq  m  p  n  a  lda  b  ldb  tola  tolb  k  l  u  ldu  v  ldv  q  ldq  iwork  tau  work  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) tola )
	((-idx0- (-float-)) tolb )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) iwork )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sggsvp_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($tola,float), IDX_PTR($tolb,float), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($iwork,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgtcon <norm>  <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTCON estimates the reciprocal of the condition number of a real
;;*  tridiagonal matrix A using the LU factorization as computed by
;;*  SGTTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by SGTTRF.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) REAL array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  ANORM   (input) REAL
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgtcon (norm  n  dl  d  du  du2  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx1- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgtcon_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgtrfs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is tridiagonal, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input) REAL array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by SGTTRF.
;;*
;;*  DF      (input) REAL array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DUF     (input) REAL array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) REAL array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SGTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgtrfs (trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx1- (-float-)) dlf )
	((-idx1- (-float-)) df )
	((-idx1- (-float-)) duf )
	((-idx1- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgtrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($dlf,float), IDX_PTR($df,float), IDX_PTR($duf,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgtsv <n>  <nrhs>  <dl>  <d>  <du>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTSV  solves the equation
;;*
;;*     A*X = B,
;;*
;;*  where A is an n by n tridiagonal matrix, by Gaussian elimination with
;;*  partial pivoting.
;;*
;;*  Note that the equation  A'*X = B  may be solved by interchanging the
;;*  order of the arguments DU and DL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input/output) REAL array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) sub-diagonal elements of
;;*          A.
;;*
;;*          On exit, DL is overwritten by the (n-2) elements of the
;;*          second super-diagonal of the upper triangular matrix U from
;;*          the LU factorization of A, in DL(1), ..., DL(n-2).
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*
;;*          On exit, D is overwritten by the n diagonal elements of U.
;;*
;;*  DU      (input/output) REAL array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) super-diagonal elements
;;*          of A.
;;*
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          super-diagonal of U.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N by NRHS matrix of right hand side matrix B.
;;*          On exit, if INFO = 0, the N by NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, U(i,i) is exactly zero, and the solution
;;*               has not been computed.  The factorization has not been
;;*               completed unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgtsv (n  nrhs  dl  d  du  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sgtsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgtsvx <fact>  <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTSVX uses the LU factorization to compute the solution to a real
;;*  system of linear equations A * X = B or A**T * X = B,
;;*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the LU decomposition is used to factor the matrix A
;;*     as A = L * U, where L is a product of permutation and unit lower
;;*     bidiagonal matrices and U is upper triangular with nonzeros in
;;*     only the main diagonal and first two superdiagonals.
;;*
;;*  2. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  DLF, DF, DUF, DU2, and IPIV contain the factored
;;*                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV
;;*                  will not be modified.
;;*          = 'N':  The matrix will be copied to DLF, DF, and DUF
;;*                  and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of A.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input or output) REAL array, dimension (N-1)
;;*          If FACT = 'F', then DLF is an input argument and on entry
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A as computed by SGTTRF.
;;*
;;*          If FACT = 'N', then DLF is an output argument and on exit
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A.
;;*
;;*  DF      (input or output) REAL array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*  DUF     (input or output) REAL array, dimension (N-1)
;;*          If FACT = 'F', then DUF is an input argument and on entry
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*          If FACT = 'N', then DUF is an output argument and on exit
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input or output) REAL array, dimension (N-2)
;;*          If FACT = 'F', then DU2 is an input argument and on entry
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*          If FACT = 'N', then DU2 is an output argument and on exit
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the LU factorization of A as
;;*          computed by SGTTRF.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the LU factorization of A;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates
;;*          a row interchange was not required.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has not been completed unless i = N, but the
;;*                       factor U is exactly singular, so the solution
;;*                       and error bounds could not be computed.
;;*                       RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgtsvx (fact  trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx1- (-float-)) dlf )
	((-idx1- (-float-)) df )
	((-idx1- (-float-)) duf )
	((-idx1- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sgtsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($dlf,float), IDX_PTR($df,float), IDX_PTR($duf,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgttrf <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTTRF computes an LU factorization of a real tridiagonal matrix A
;;*  using elimination with partial pivoting and row interchanges.
;;*
;;*  The factorization has the form
;;*     A = L * U
;;*  where L is a product of permutation and unit lower bidiagonal
;;*  matrices and U is upper triangular with nonzeros in only the main
;;*  diagonal and first two superdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  DL      (input/output) REAL array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) sub-diagonal elements of
;;*          A.
;;*
;;*          On exit, DL is overwritten by the (n-1) multipliers that
;;*          define the matrix L from the LU factorization of A.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*
;;*          On exit, D is overwritten by the n diagonal elements of the
;;*          upper triangular matrix U from the LU factorization of A.
;;*
;;*  DU      (input/output) REAL array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) super-diagonal elements
;;*          of A.
;;*
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          super-diagonal of U.
;;*
;;*  DU2     (output) REAL array, dimension (N-2)
;;*          On exit, DU2 is overwritten by the (n-2) elements of the
;;*          second super-diagonal of U.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*          > 0:  if INFO = k, U(k,k) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sgttrf (n  dl  d  du  du2  ipiv  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx1- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ sgttrf_(IDX_PTR($n,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgttrs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTTRS solves one of the systems of equations
;;*     A*X = B  or  A'*X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by SGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A'* X = B  (Transpose)
;;*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) REAL array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sgttrs (trans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx1- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sgttrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sgtts2 <itrans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SGTTS2 solves one of the systems of equations
;;*     A*X = B  or  A'*X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by SGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITRANS  (input) INTEGER
;;*          Specifies the form of the system of equations.
;;*          = 0:  A * X = B  (No transpose)
;;*          = 1:  A'* X = B  (Transpose)
;;*          = 2:  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) REAL array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sgtts2 (itrans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  )
	((-idx0- (-int-)) itrans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx1- (-float-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ sgtts2_(IDX_PTR($itrans,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($du2,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (shgeqz <job>  <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <q>  <ldq>  <z>  <ldz>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SHGEQZ implements a single-/double-shift version of the QZ method for
;;*  finding the generalized eigenvalues
;;*
;;*  w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation
;;*
;;*       det( A - w(i) B ) = 0
;;*
;;*  In addition, the pair A,B may be reduced to generalized Schur form:
;;*  B is upper triangular, and A is block upper triangular, where the
;;*  diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having
;;*  complex generalized eigenvalues (see the description of the argument
;;*  JOB.)
;;*
;;*  If JOB='S', then the pair (A,B) is simultaneously reduced to Schur
;;*  form by applying one orthogonal tranformation (usually called Q) on
;;*  the left and another (usually called Z) on the right.  The 2-by-2
;;*  upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks
;;*  of A will be reduced to positive diagonal matrices.  (I.e.,
;;*  if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and
;;*  B(j+1,j+1) will be positive.)
;;*
;;*  If JOB='E', then at each iteration, the same transformations
;;*  are computed, but they are only applied to those parts of A and B
;;*  which are needed to compute ALPHAR, ALPHAI, and BETAR.
;;*
;;*  If JOB='S' and COMPQ and COMPZ are 'V' or 'I', then the orthogonal
;;*  transformations used to reduce (A,B) are accumulated into the arrays
;;*  Q and Z s.t.:
;;*
;;*       Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
;;*       Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*
;;*
;;*  Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
;;*       Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
;;*       pp. 241--256.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E': compute only ALPHAR, ALPHAI, and BETA.  A and B will
;;*                 not necessarily be put into generalized Schur form.
;;*          = 'S': put A and B into generalized Schur form, as well
;;*                 as computing ALPHAR, ALPHAI, and BETA.
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not modify Q.
;;*          = 'V': multiply the array Q on the right by the transpose of
;;*                 the orthogonal tranformation that is applied to the
;;*                 left side of A and B to reduce them to Schur form.
;;*          = 'I': like COMPQ='V', except that Q will be initialized to
;;*                 the identity first.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not modify Z.
;;*          = 'V': multiply the array Z on the right by the orthogonal
;;*                 tranformation that is applied to the right side of
;;*                 A and B to reduce them to Schur form.
;;*          = 'I': like COMPZ='V', except that Z will be initialized to
;;*                 the identity first.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, Q, and Z.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the N-by-N upper Hessenberg matrix A.  Elements
;;*          below the subdiagonal must be zero.
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to generalized Schur form.
;;*          If JOB='E', then on exit A will have been destroyed.
;;*             The diagonal blocks will be correct, but the off-diagonal
;;*             portion will be meaningless.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max( 1, N ).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.  Elements
;;*          below the diagonal must be zero.  2-by-2 blocks in B
;;*          corresponding to 2-by-2 blocks in A will be reduced to
;;*          positive diagonal form.  (I.e., if A(j+1,j) is non-zero,
;;*          then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be
;;*          positive.)
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to Schur form.
;;*          If JOB='E', then on exit B will have been destroyed.
;;*             Elements corresponding to diagonal blocks of A will be
;;*             correct, but the off-diagonal portion will be meaningless.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max( 1, N ).
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*          ALPHAR(1:N) will be set to real parts of the diagonal
;;*          elements of A that would result from reducing A and B to
;;*          Schur form and then further reducing them both to triangular
;;*          form using unitary transformations s.t. the diagonal of B
;;*          was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
;;*          (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).
;;*          Note that the (real or complex) values
;;*          (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
;;*          generalized eigenvalues of the matrix pencil A - wB.
;;*
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*          ALPHAI(1:N) will be set to imaginary parts of the diagonal
;;*          elements of A that would result from reducing A and B to
;;*          Schur form and then further reducing them both to triangular
;;*          form using unitary transformations s.t. the diagonal of B
;;*          was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
;;*          (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.
;;*          Note that the (real or complex) values
;;*          (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
;;*          generalized eigenvalues of the matrix pencil A - wB.
;;*
;;*  BETA    (output) REAL array, dimension (N)
;;*          BETA(1:N) will be set to the (real) diagonal elements of B
;;*          that would result from reducing A and B to Schur form and
;;*          then further reducing them both to triangular form using
;;*          unitary transformations s.t. the diagonal of B was
;;*          non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
;;*          (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).
;;*          Note that the (real or complex) values
;;*          (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
;;*          generalized eigenvalues of the matrix pencil A - wB.
;;*          (Note that BETA(1:N) will always be non-negative, and no
;;*          BETAI is necessary.)
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ, N)
;;*          If COMPQ='N', then Q will not be referenced.
;;*          If COMPQ='V' or 'I', then the transpose of the orthogonal
;;*             transformations which are applied to A and B on the left
;;*             will be applied to the array Q on the right.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= 1.
;;*          If COMPQ='V' or 'I', then LDQ >= N.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ, N)
;;*          If COMPZ='N', then Z will not be referenced.
;;*          If COMPZ='V' or 'I', then the orthogonal transformations
;;*             which are applied to A and B on the right will be applied
;;*             to the array Z on the right.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If COMPZ='V' or 'I', then LDZ >= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1,...,N: the QZ iteration did not converge.  (A,B) is not
;;*                     in Schur form, but ALPHAR(i), ALPHAI(i), and
;;*                     BETA(i), i=INFO+1,...,N should be correct.
;;*          = N+1,...,2*N: the shift calculation failed.  (A,B) is not
;;*                     in Schur form, but ALPHAR(i), ALPHAI(i), and
;;*                     BETA(i), i=INFO-N+1,...,N should be correct.
;;*          > 2*N:     various "impossible" errors.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Iteration counters:
;;*
;;*  JITER  -- counts iterations.
;;*  IITER  -- counts iterations run since ILAST was last
;;*            changed.  This is therefore reset only when a 1-by-1 or
;;*            2-by-2 block deflates off the bottom.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*    $                     SAFETY = 1.0E+0 )
;;*  =====================================================================

(de shgeqz (job  compq  compz  n  ilo  ihi  a  lda  b  ldb  alphar  alphai  beta  q  ldq  z  ldz  work  lwork  info  )
	((-str-) job )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ shgeqz_($job->data, $compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (shsein <side>  <eigsrc>  <initv>  <select>  <n>  <h>  <ldh>  <wr>  <wi>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <ifaill>  <ifailr>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SHSEIN uses inverse iteration to find specified right and/or left
;;*  eigenvectors of a real upper Hessenberg matrix H.
;;*
;;*  The right eigenvector x and the left eigenvector y of the matrix H
;;*  corresponding to an eigenvalue w are defined by:
;;*
;;*               H * x = w * x,     y**h * H = w * y**h
;;*
;;*  where y**h denotes the conjugate transpose of the vector y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  EIGSRC  (input) CHARACTER*1
;;*          Specifies the source of eigenvalues supplied in (WR,WI):
;;*          = 'Q': the eigenvalues were found using SHSEQR; thus, if
;;*                 H has zero subdiagonal elements, and so is
;;*                 block-triangular, then the j-th eigenvalue can be
;;*                 assumed to be an eigenvalue of the block containing
;;*                 the j-th row/column.  This property allows SHSEIN to
;;*                 perform inverse iteration on just one diagonal block.
;;*          = 'N': no assumptions are made on the correspondence
;;*                 between eigenvalues and diagonal blocks.  In this
;;*                 case, SHSEIN must always perform inverse iteration
;;*                 using the whole matrix H.
;;*
;;*  INITV   (input) CHARACTER*1
;;*          = 'N': no initial vectors are supplied;
;;*          = 'U': user-supplied initial vectors are stored in the arrays
;;*                 VL and/or VR.
;;*
;;*  SELECT  (input/output) LOGICAL array, dimension (N)
;;*          Specifies the eigenvectors to be computed. To select the
;;*          real eigenvector corresponding to a real eigenvalue WR(j),
;;*          SELECT(j) must be set to .TRUE.. To select the complex
;;*          eigenvector corresponding to a complex eigenvalue
;;*          (WR(j),WI(j)), with complex conjugate (WR(j+1),WI(j+1)),
;;*          either SELECT(j) or SELECT(j+1) or both must be set to
;;*          .TRUE.; then on exit SELECT(j) is .TRUE. and SELECT(j+1) is
;;*          .FALSE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) REAL array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  WR      (input/output) REAL array, dimension (N)
;;*  WI      (input) REAL array, dimension (N)
;;*          On entry, the real and imaginary parts of the eigenvalues of
;;*          H; a complex conjugate pair of eigenvalues must be stored in
;;*          consecutive elements of WR and WI.
;;*          On exit, WR may have been altered since close eigenvalues
;;*          are perturbed slightly in searching for independent
;;*          eigenvectors.
;;*
;;*  VL      (input/output) REAL array, dimension (LDVL,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
;;*          contain starting vectors for the inverse iteration for the
;;*          left eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column(s) in which the eigenvector will
;;*          be stored.
;;*          On exit, if SIDE = 'L' or 'B', the left eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VL, in the same order as their eigenvalues. A
;;*          complex eigenvector corresponding to a complex eigenvalue is
;;*          stored in two consecutive columns, the first holding the real
;;*          part and the second the imaginary part.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) REAL array, dimension (LDVR,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
;;*          contain starting vectors for the inverse iteration for the
;;*          right eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column(s) in which the eigenvector will
;;*          be stored.
;;*          On exit, if SIDE = 'R' or 'B', the right eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VR, in the same order as their eigenvalues. A
;;*          complex eigenvector corresponding to a complex eigenvalue is
;;*          stored in two consecutive columns, the first holding the real
;;*          part and the second the imaginary part.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR required to
;;*          store the eigenvectors; each selected real eigenvector
;;*          occupies one column and each selected complex eigenvector
;;*          occupies two columns.
;;*
;;*  WORK    (workspace) REAL array, dimension ((N+2)*N)
;;*
;;*  IFAILL  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
;;*          eigenvector in the i-th column of VL (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
;;*          eigenvector converged satisfactorily. If the i-th and (i+1)th
;;*          columns of VL hold a complex eigenvector, then IFAILL(i) and
;;*          IFAILL(i+1) are set to the same value.
;;*          If SIDE = 'R', IFAILL is not referenced.
;;*
;;*  IFAILR  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
;;*          eigenvector in the i-th column of VR (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
;;*          eigenvector converged satisfactorily. If the i-th and (i+1)th
;;*          columns of VR hold a complex eigenvector, then IFAILR(i) and
;;*          IFAILR(i+1) are set to the same value.
;;*          If SIDE = 'L', IFAILR is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, i is the number of eigenvectors which
;;*                failed to converge; see IFAILL and IFAILR for further
;;*                details.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x|+|y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de shsein (side  eigsrc  initv  select  n  h  ldh  wr  wi  vl  ldvl  vr  ldvr  mm  m  work  ifaill  ifailr  info  )
	((-str-) side )
	((-str-) eigsrc )
	((-str-) initv )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) ifaill )
	((-idx1- (-int-)) ifailr )
	((-idx0- (-int-)) info )
	#{ shsein_($side->data, $eigsrc->data, $initv->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($ifaill,int), IDX_PTR($ifailr,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (shseqr <job>  <compz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <wr>  <wi>  <z>  <ldz>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SHSEQR computes the eigenvalues of a real upper Hessenberg matrix H
;;*  and, optionally, the matrices T and Z from the Schur decomposition
;;*  H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur
;;*  form), and Z is the orthogonal matrix of Schur vectors.
;;*
;;*  Optionally Z may be postmultiplied into an input orthogonal matrix Q,
;;*  so that this routine can give the Schur factorization of a matrix A
;;*  which has been reduced to the Hessenberg form H by the orthogonal
;;*  matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E':  compute eigenvalues only;
;;*          = 'S':  compute eigenvalues and the Schur form T.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  no Schur vectors are computed;
;;*          = 'I':  Z is initialized to the unit matrix and the matrix Z
;;*                  of Schur vectors of H is returned;
;;*          = 'V':  Z must contain an orthogonal matrix Q on entry, and
;;*                  the product Q*Z is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to SGEBAL, and then passed to SGEHRD
;;*          when the matrix output by SGEBAL is reduced to Hessenberg
;;*          form. Otherwise ILO and IHI should be set to 1 and N
;;*          respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  H       (input/output) REAL array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if JOB = 'S', H contains the upper quasi-triangular
;;*          matrix T from the Schur decomposition (the Schur form);
;;*          2-by-2 diagonal blocks (corresponding to complex conjugate
;;*          pairs of eigenvalues) are returned in standard form, with
;;*          H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) < 0. If JOB = 'E',
;;*          the contents of H are unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          The real and imaginary parts, respectively, of the computed
;;*          eigenvalues. If two eigenvalues are computed as a complex
;;*          conjugate pair, they are stored in consecutive elements of
;;*          WR and WI, say the i-th and (i+1)th, with WI(i) > 0 and
;;*          WI(i+1) < 0. If JOB = 'S', the eigenvalues are stored in the
;;*          same order as on the diagonal of the Schur form returned in
;;*          H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
;;*          diagonal block, WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and
;;*          WI(i+1) = -WI(i).
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ,N)
;;*          If COMPZ = 'N': Z is not referenced.
;;*          If COMPZ = 'I': on entry, Z need not be set, and on exit, Z
;;*          contains the orthogonal matrix Z of the Schur vectors of H.
;;*          If COMPZ = 'V': on entry Z must contain an N-by-N matrix Q,
;;*          which is assumed to be equal to the unit matrix except for
;;*          the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
;;*          Normally Q is the orthogonal matrix generated by SORGHR after
;;*          the call to SGEHRD which formed the Hessenberg matrix H.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= max(1,N) if COMPZ = 'I' or 'V'; LDZ >= 1 otherwise.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, SHSEQR failed to compute all of the
;;*                eigenvalues in a total of 30*(IHI-ILO+1) iterations;
;;*                elements 1:ilo-1 and i+1:n of WR and WI contain those
;;*                eigenvalues which have been successfully computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de shseqr (job  compz  n  ilo  ihi  h  ldh  wr  wi  z  ldz  work  lwork  info  )
	((-str-) job )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ shseqr_($job->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slabad <small>  <large>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLABAD takes as input the values computed by SLAMCH for underflow and
;;*  overflow, and returns the square root of each of these values if the
;;*  log of LARGE is sufficiently large.  This subroutine is intended to
;;*  identify machines with a large exponent range, such as the Crays, and
;;*  redefine the underflow and overflow limits to be the square roots of
;;*  the values computed by SLAMCH.  This subroutine is needed because
;;*  SLAMCH does not compensate for poor arithmetic in the upper half of
;;*  the exponent range, as is found on a Cray.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SMALL   (input/output) REAL
;;*          On entry, the underflow threshold as computed by SLAMCH.
;;*          On exit, if LOG10(LARGE) is sufficiently large, the square
;;*          root of SMALL, otherwise unchanged.
;;*
;;*  LARGE   (input/output) REAL
;;*          On entry, the overflow threshold as computed by SLAMCH.
;;*          On exit, if LOG10(LARGE) is sufficiently large, the square
;;*          root of LARGE, otherwise unchanged.
;;*
;;*  =====================================================================
;;*
;;*     .. Intrinsic Functions ..
;;*  =====================================================================

(de slabad (small  large  )
	((-idx0- (-float-)) small )
	((-idx0- (-float-)) large )
	#{ slabad_(IDX_PTR($small,float), IDX_PTR($large,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slabrd <m>  <n>  <nb>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <x>  <ldx>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLABRD reduces the first NB rows and columns of a real general
;;*  m by n matrix A to upper or lower bidiagonal form by an orthogonal
;;*  transformation Q' * A * P, and returns the matrices X and Y which
;;*  are needed to apply the transformation to the unreduced part of A.
;;*
;;*  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
;;*  bidiagonal form.
;;*
;;*  This is an auxiliary routine called by SGEBRD
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of leading rows and columns of A to be reduced.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit, the first NB rows and columns of the matrix are
;;*          overwritten; the rest of the array is unchanged.
;;*          If m >= n, elements on and below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the orthogonal
;;*            matrix Q as a product of elementary reflectors; and
;;*            elements above the diagonal in the first NB rows, with the
;;*            array TAUP, represent the orthogonal matrix P as a product
;;*            of elementary reflectors.
;;*          If m < n, elements below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the orthogonal
;;*            matrix Q as a product of elementary reflectors, and
;;*            elements on and above the diagonal in the first NB rows,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) REAL array, dimension (NB)
;;*          The diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.  D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (NB)
;;*          The off-diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.
;;*
;;*  TAUQ    (output) REAL array dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q. See Further Details.
;;*
;;*  TAUP    (output) REAL array, dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix P. See Further Details.
;;*
;;*  X       (output) REAL array, dimension (LDX,NB)
;;*          The m-by-nb matrix X required to update the unreduced part
;;*          of A.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X. LDX >= M.
;;*
;;*  Y       (output) REAL array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y required to update the unreduced part
;;*          of A.
;;*
;;*  LDY     (output) INTEGER
;;*          The leading dimension of the array Y. LDY >= N.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors.
;;*
;;*  If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
;;*  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The elements of the vectors v and u together form the m-by-nb matrix
;;*  V and the nb-by-n matrix U' which are needed, with X and Y, to apply
;;*  the transformation to the unreduced part of the matrix, using a block
;;*  update of the form:  A := A - V*Y' - X*U'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with nb = 2:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
;;*    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
;;*    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )
;;*
;;*  where a denotes an element of the original matrix which is unchanged,
;;*  vi denotes an element of the vector defining H(i), and ui an element
;;*  of the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slabrd (m  n  nb  a  lda  d  e  tauq  taup  x  ldx  y  ldy  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tauq )
	((-idx1- (-float-)) taup )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) ldy )
	#{ slabrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tauq,float), IDX_PTR($taup,float), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($y,float), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slacon <n>  <v>  <x>  <isgn>  <est>  <kase>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLACON estimates the 1-norm of a square, real matrix A.
;;*  Reverse communication is used for evaluating matrix-vector products.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The order of the matrix.  N >= 1.
;;*
;;*  V      (workspace) REAL array, dimension (N)
;;*         On the final return, V = A*W,  where  EST = norm(V)/norm(W)
;;*         (W is not returned).
;;*
;;*  X      (input/output) REAL array, dimension (N)
;;*         On an intermediate return, X should be overwritten by
;;*               A * X,   if KASE=1,
;;*               A' * X,  if KASE=2,
;;*         and SLACON must be re-called with all the other parameters
;;*         unchanged.
;;*
;;*  ISGN   (workspace) INTEGER array, dimension (N)
;;*
;;*  EST    (output) REAL
;;*         An estimate (a lower bound) for norm(A).
;;*
;;*  KASE   (input/output) INTEGER
;;*         On the initial call to SLACON, KASE should be 0.
;;*         On an intermediate return, KASE will be 1 or 2, indicating
;;*         whether X should be overwritten by A * X  or A' * X.
;;*         On the final return from SLACON, KASE will again be 0.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  Contributed by Nick Higham, University of Manchester.
;;*  Originally named SONEST, dated March 16, 1988.
;;*
;;*  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of
;;*  a real or complex matrix, with applications to condition estimation",
;;*  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slacon (n  v  x  isgn  est  kase  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) v )
	((-idx1- (-float-)) x )
	((-idx1- (-int-)) isgn )
	((-idx0- (-float-)) est )
	((-idx0- (-int-)) kase )
	#{ slacon_(IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($x,float), IDX_PTR($isgn,int), IDX_PTR($est,float), IDX_PTR($kase,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slacpy <uplo>  <m>  <n>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLACPY copies all or part of a two-dimensional matrix A to another
;;*  matrix B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be copied to B.
;;*          = 'U':      Upper triangular part
;;*          = 'L':      Lower triangular part
;;*          Otherwise:  All of the matrix A
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The m by n matrix A.  If UPLO = 'U', only the upper triangle
;;*          or trapezoid is accessed; if UPLO = 'L', only the lower
;;*          triangle or trapezoid is accessed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (output) REAL array, dimension (LDB,N)
;;*          On exit, B = A in the locations specified by UPLO.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slacpy (uplo  m  n  a  lda  b  ldb  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ slacpy_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sladiv <a>  <b>  <c>  <d>  <p>  <q>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLADIV performs complex division in  real arithmetic
;;*
;;*                        a + i*b
;;*             p + i*q = ---------
;;*                        c + i*d
;;*
;;*  The algorithm is due to Robert L. Smith and can be found
;;*  in D. Knuth, The art of Computer Programming, Vol.2, p.195
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) REAL
;;*  B       (input) REAL
;;*  C       (input) REAL
;;*  D       (input) REAL
;;*          The scalars a, b, c, and d in the above expression.
;;*
;;*  P       (output) REAL
;;*  Q       (output) REAL
;;*          The scalars p and q in the above expression.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sladiv (a  b  c  d  p  q  )
	((-idx0- (-float-)) a )
	((-idx0- (-float-)) b )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) d )
	((-idx0- (-float-)) p )
	((-idx0- (-float-)) q )
	#{ sladiv_(IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($d,float), IDX_PTR($p,float), IDX_PTR($q,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slae2 <a>  <b>  <c>  <rt1>  <rt2>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
;;*     [  A   B  ]
;;*     [  B   C  ].
;;*  On return, RT1 is the eigenvalue of larger absolute value, and RT2
;;*  is the eigenvalue of smaller absolute value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) REAL
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  B       (input) REAL
;;*          The (1,2) and (2,1) elements of the 2-by-2 matrix.
;;*
;;*  C       (input) REAL
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  RT1     (output) REAL
;;*          The eigenvalue of larger absolute value.
;;*
;;*  RT2     (output) REAL
;;*          The eigenvalue of smaller absolute value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  RT1 is accurate to a few ulps barring over/underflow.
;;*
;;*  RT2 may be inaccurate if there is massive cancellation in the
;;*  determinant A*C-B*B; higher precision or correctly rounded or
;;*  correctly truncated arithmetic would be needed to compute RT2
;;*  accurately in all cases.
;;*
;;*  Overflow is possible only if RT1 is within a factor of 5 of overflow.
;;*  Underflow is harmless if the input data is 0 or exceeds
;;*     underflow_threshold / macheps.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slae2 (a  b  c  rt1  rt2  )
	((-idx0- (-float-)) a )
	((-idx0- (-float-)) b )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) rt1 )
	((-idx0- (-float-)) rt2 )
	#{ slae2_(IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($rt1,float), IDX_PTR($rt2,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaebz <ijob>  <nitmax>  <n>  <mmax>  <minp>  <nbmin>  <abstol>  <reltol>  <pivmin>  <d>  <e>  <e2>  <nval>  <ab>  <c>  <mout>  <nab>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAEBZ contains the iteration loops which compute and use the
;;*  function N(w), which is the count of eigenvalues of a symmetric
;;*  tridiagonal matrix T less than or equal to its argument  w.  It
;;*  performs a choice of two types of loops:
;;*
;;*  IJOB=1, followed by
;;*  IJOB=2: It takes as input a list of intervals and returns a list of
;;*          sufficiently small intervals whose union contains the same
;;*          eigenvalues as the union of the original intervals.
;;*          The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
;;*          The output interval (AB(j,1),AB(j,2)] will contain
;;*          eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
;;*
;;*  IJOB=3: It performs a binary search in each input interval
;;*          (AB(j,1),AB(j,2)] for a point  w(j)  such that
;;*          N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
;;*          the search.  If such a w(j) is found, then on output
;;*          AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
;;*          (AB(j,1),AB(j,2)] will be a small interval containing the
;;*          point where N(w) jumps through NVAL(j), unless that point
;;*          lies outside the initial interval.
;;*
;;*  Note that the intervals are in all cases half-open intervals,
;;*  i.e., of the form  (a,b] , which includes  b  but not  a .
;;*
;;*  To avoid underflow, the matrix should be scaled so that its largest
;;*  element is no greater than  overflow**(1/2) * underflow**(1/4)
;;*  in absolute value.  To assure the most accurate computation
;;*  of small eigenvalues, the matrix should be scaled to be
;;*  not much smaller than that, either.
;;*
;;*  See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
;;*  Matrix", Report CS41, Computer Science Dept., Stanford
;;*  University, July 21, 1966
;;*
;;*  Note: the arguments are, in general, *not* checked for unreasonable
;;*  values.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what is to be done:
;;*          = 1:  Compute NAB for the initial intervals.
;;*          = 2:  Perform bisection iteration to find eigenvalues of T.
;;*          = 3:  Perform bisection iteration to invert N(w), i.e.,
;;*                to find a point which has a specified number of
;;*                eigenvalues of T to its left.
;;*          Other values will cause SLAEBZ to return with INFO=-1.
;;*
;;*  NITMAX  (input) INTEGER
;;*          The maximum number of "levels" of bisection to be
;;*          performed, i.e., an interval of width W will not be made
;;*          smaller than 2^(-NITMAX) * W.  If not all intervals
;;*          have converged after NITMAX iterations, then INFO is set
;;*          to the number of non-converged intervals.
;;*
;;*  N       (input) INTEGER
;;*          The dimension n of the tridiagonal matrix T.  It must be at
;;*          least 1.
;;*
;;*  MMAX    (input) INTEGER
;;*          The maximum number of intervals.  If more than MMAX intervals
;;*          are generated, then SLAEBZ will quit with INFO=MMAX+1.
;;*
;;*  MINP    (input) INTEGER
;;*          The initial number of intervals.  It may not be greater than
;;*          MMAX.
;;*
;;*  NBMIN   (input) INTEGER
;;*          The smallest number of intervals that should be processed
;;*          using a vector loop.  If zero, then only the scalar loop
;;*          will be used.
;;*
;;*  ABSTOL  (input) REAL
;;*          The minimum (absolute) width of an interval.  When an
;;*          interval is narrower than ABSTOL, or than RELTOL times the
;;*          larger (in magnitude) endpoint, then it is considered to be
;;*          sufficiently small, i.e., converged.  This must be at least
;;*          zero.
;;*
;;*  RELTOL  (input) REAL
;;*          The minimum relative width of an interval.  When an interval
;;*          is narrower than ABSTOL, or than RELTOL times the larger (in
;;*          magnitude) endpoint, then it is considered to be
;;*          sufficiently small, i.e., converged.  Note: this should
;;*          always be at least radix*machine epsilon.
;;*
;;*  PIVMIN  (input) REAL
;;*          The minimum absolute value of a "pivot" in the Sturm
;;*          sequence loop.  This *must* be at least  max |e(j)**2| *
;;*          safe_min  and at least safe_min, where safe_min is at least
;;*          the smallest number that can divide one without overflow.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) REAL array, dimension (N)
;;*          The offdiagonal elements of the tridiagonal matrix T in
;;*          positions 1 through N-1.  E(N) is arbitrary.
;;*
;;*  E2      (input) REAL array, dimension (N)
;;*          The squares of the offdiagonal elements of the tridiagonal
;;*          matrix T.  E2(N) is ignored.
;;*
;;*  NVAL    (input/output) INTEGER array, dimension (MINP)
;;*          If IJOB=1 or 2, not referenced.
;;*          If IJOB=3, the desired values of N(w).  The elements of NVAL
;;*          will be reordered to correspond with the intervals in AB.
;;*          Thus, NVAL(j) on output will not, in general be the same as
;;*          NVAL(j) on input, but it will correspond with the interval
;;*          (AB(j,1),AB(j,2)] on output.
;;*
;;*  AB      (input/output) REAL array, dimension (MMAX,2)
;;*          The endpoints of the intervals.  AB(j,1) is  a(j), the left
;;*          endpoint of the j-th interval, and AB(j,2) is b(j), the
;;*          right endpoint of the j-th interval.  The input intervals
;;*          will, in general, be modified, split, and reordered by the
;;*          calculation.
;;*
;;*  C       (input/output) REAL array, dimension (MMAX)
;;*          If IJOB=1, ignored.
;;*          If IJOB=2, workspace.
;;*          If IJOB=3, then on input C(j) should be initialized to the
;;*          first search point in the binary search.
;;*
;;*  MOUT    (output) INTEGER
;;*          If IJOB=1, the number of eigenvalues in the intervals.
;;*          If IJOB=2 or 3, the number of intervals output.
;;*          If IJOB=3, MOUT will equal MINP.
;;*
;;*  NAB     (input/output) INTEGER array, dimension (MMAX,2)
;;*          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j)).
;;*          If IJOB=2, then on input, NAB(i,j) should be set.  It must
;;*             satisfy the condition:
;;*             N(AB(i,1)) <= NAB(i,1) <= NAB(i,2) <= N(AB(i,2)),
;;*             which means that in interval i only eigenvalues
;;*             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,
;;*             NAB(i,j)=N(AB(i,j)), from a previous call to SLAEBZ with
;;*             IJOB=1.
;;*             On output, NAB(i,j) will contain
;;*             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
;;*             the input interval that the output interval
;;*             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the
;;*             the input values of NAB(k,1) and NAB(k,2).
;;*          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),
;;*             unless N(w) > NVAL(i) for all search points  w , in which
;;*             case NAB(i,1) will not be modified, i.e., the output
;;*             value will be the same as the input value (modulo
;;*             reorderings -- see NVAL and AB), or unless N(w) < NVAL(i)
;;*             for all search points  w , in which case NAB(i,2) will
;;*             not be modified.  Normally, NAB should be set to some
;;*             distinctive value(s) before SLAEBZ is called.
;;*
;;*  WORK    (workspace) REAL array, dimension (MMAX)
;;*          Workspace.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (MMAX)
;;*          Workspace.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:       All intervals converged.
;;*          = 1--MMAX: The last INFO intervals did not converge.
;;*          = MMAX+1:  More than MMAX intervals were generated.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*      This routine is intended to be called only by other LAPACK
;;*  routines, thus the interface is less user-friendly.  It is intended
;;*  for two purposes:
;;*
;;*  (a) finding eigenvalues.  In this case, SLAEBZ should have one or
;;*      more initial intervals set up in AB, and SLAEBZ should be called
;;*      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
;;*      Intervals with no eigenvalues would usually be thrown out at
;;*      this point.  Also, if not all the eigenvalues in an interval i
;;*      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.
;;*      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest
;;*      eigenvalue.  SLAEBZ is then called with IJOB=2 and MMAX
;;*      no smaller than the value of MOUT returned by the call with
;;*      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1
;;*      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the
;;*      tolerance specified by ABSTOL and RELTOL.
;;*
;;*  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l).
;;*      In this case, start with a Gershgorin interval  (a,b).  Set up
;;*      AB to contain 2 search intervals, both initially (a,b).  One
;;*      NVAL element should contain  f-1  and the other should contain  l
;;*      , while C should contain a and b, resp.  NAB(i,1) should be -1
;;*      and NAB(i,2) should be N+1, to flag an error if the desired
;;*      interval does not lie in (a,b).  SLAEBZ is then called with
;;*      IJOB=3.  On exit, if w(f-1) < w(f), then one of the intervals --
;;*      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while
;;*      if, to the specified tolerance, w(f-k)=...=w(f+r), k > 0 and r
;;*      >= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and
;;*      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) < w(l+1) and
;;*      w(l-r)=...=w(l+k) are handled similarly.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaebz (ijob  nitmax  n  mmax  minp  nbmin  abstol  reltol  pivmin  d  e  e2  nval  ab  c  mout  nab  work  iwork  info  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) nitmax )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) mmax )
	((-idx0- (-int-)) minp )
	((-idx0- (-int-)) nbmin )
	((-idx0- (-float-)) abstol )
	((-idx0- (-float-)) reltol )
	((-idx0- (-float-)) pivmin )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) e2 )
	((-idx1- (-int-)) nval )
	((-idx2- (-float-)) ab )
	((-idx1- (-float-)) c )
	((-idx0- (-int-)) mout )
	((-idx2- (-int-)) nab )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slaebz_(IDX_PTR($ijob,int), IDX_PTR($nitmax,int), IDX_PTR($n,int), IDX_PTR($mmax,int), IDX_PTR($minp,int), IDX_PTR($nbmin,int), IDX_PTR($abstol,float), IDX_PTR($reltol,float), IDX_PTR($pivmin,float), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($e2,float), IDX_PTR($nval,int), IDX_PTR($ab,float), IDX_PTR($c,float), IDX_PTR($mout,int), IDX_PTR($nab,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed0 <icompq>  <qsiz>  <n>  <d>  <e>  <q>  <ldq>  <qstore>  <ldqs>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED0 computes all eigenvalues and corresponding eigenvectors of a
;;*  symmetric tridiagonal matrix using the divide and conquer method.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          = 0:  Compute eigenvalues only.
;;*          = 1:  Compute eigenvectors of original dense symmetric matrix
;;*                also.  On entry, Q contains the orthogonal matrix used
;;*                to reduce the original matrix to tridiagonal form.
;;*          = 2:  Compute eigenvalues and eigenvectors of tridiagonal
;;*                matrix.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the orthogonal matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, the main diagonal of the tridiagonal matrix.
;;*         On exit, its eigenvalues.
;;*
;;*  E      (input) REAL array, dimension (N-1)
;;*         The off-diagonal elements of the tridiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  Q      (input/output) REAL array, dimension (LDQ, N)
;;*         On entry, Q must contain an N-by-N orthogonal matrix.
;;*         If ICOMPQ = 0    Q is not referenced.
;;*         If ICOMPQ = 1    On entry, Q is a subset of the columns of the
;;*                          orthogonal matrix used to reduce the full
;;*                          matrix to tridiagonal form corresponding to
;;*                          the subset of the full matrix which is being
;;*                          decomposed at this time.
;;*         If ICOMPQ = 2    On entry, Q will be the identity matrix.
;;*                          On exit, Q contains the eigenvectors of the
;;*                          tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  If eigenvectors are
;;*         desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.
;;*
;;*  QSTORE (workspace) REAL array, dimension (LDQS, N)
;;*         Referenced only when ICOMPQ = 1.  Used to store parts of
;;*         the eigenvector matrix when the updating matrix multiplies
;;*         take place.
;;*
;;*  LDQS   (input) INTEGER
;;*         The leading dimension of the array QSTORE.  If ICOMPQ = 1,
;;*         then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
;;*
;;*  WORK   (workspace) REAL array,
;;*         If ICOMPQ = 0 or 1, the dimension of WORK must be at least
;;*                     1 + 3*N + 2*N*lg N + 2*N**2
;;*                     ( lg( N ) = smallest integer k
;;*                                 such that 2^k >= N )
;;*         If ICOMPQ = 2, the dimension of WORK must be at least
;;*                     4*N + N**2.
;;*
;;*  IWORK  (workspace) INTEGER array,
;;*         If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
;;*                        6 + 6*N + 5*N*lg N.
;;*                        ( lg( N ) = smallest integer k
;;*                                    such that 2^k >= N )
;;*         If ICOMPQ = 2, the dimension of IWORK must be at least
;;*                        3 + 5*N.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed0 (icompq  qsiz  n  d  e  q  ldq  qstore  ldqs  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) qstore )
	((-idx0- (-int-)) ldqs )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slaed0_(IDX_PTR($icompq,int), IDX_PTR($qsiz,int), IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($qstore,float), IDX_PTR($ldqs,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed1 <n>  <d>  <q>  <ldq>  <indxq>  <rho>  <cutpnt>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED1 computes the updated eigensystem of a diagonal
;;*  matrix after modification by a rank-one symmetric matrix.  This
;;*  routine is used only for the eigenproblem which requires all
;;*  eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles
;;*  the case in which eigenvalues only or eigenvalues and eigenvectors
;;*  of a full symmetric matrix (which was reduced to tridiagonal form)
;;*  are desired.
;;*
;;*    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
;;*
;;*     where Z = Q'u, u is a vector of length N with ones in the
;;*     CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
;;*
;;*     The eigenvectors of the original matrix are stored in Q, and the
;;*     eigenvalues are in D.  The algorithm consists of three stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple eigenvalues or if there is a zero in
;;*        the Z vector.  For each such occurence the dimension of the
;;*        secular equation problem is reduced by one.  This stage is
;;*        performed by the routine SLAED2.
;;*
;;*        The second stage consists of calculating the updated
;;*        eigenvalues. This is done by finding the roots of the secular
;;*        equation via the routine SLAED4 (as called by SLAED3).
;;*        This routine also calculates the eigenvectors of the current
;;*        problem.
;;*
;;*        The final stage consists of computing the updated eigenvectors
;;*        directly using the updated eigenvalues.  The eigenvectors for
;;*        the current problem are multiplied with the eigenvectors from
;;*        the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, the eigenvalues of the rank-1-perturbed matrix.
;;*         On exit, the eigenvalues of the repaired matrix.
;;*
;;*  Q      (input/output) REAL array, dimension (LDQ,N)
;;*         On entry, the eigenvectors of the rank-1-perturbed matrix.
;;*         On exit, the eigenvectors of the repaired tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (input/output) INTEGER array, dimension (N)
;;*         On entry, the permutation which separately sorts the two
;;*         subproblems in D into ascending order.
;;*         On exit, the permutation which will reintegrate the
;;*         subproblems back into sorted order,
;;*         i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  RHO    (input) REAL
;;*         The subdiagonal entry used to create the rank-1 modification.
;;*
;;*  CUTPNT (input) INTEGER
;;*         The location of the last eigenvalue in the leading sub-matrix.
;;*         min(1,N) <= CUTPNT <= N/2.
;;*
;;*  WORK   (workspace) REAL array, dimension (4*N + N**2)
;;*
;;*  IWORK  (workspace) INTEGER array, dimension (4*N)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slaed1 (n  d  q  ldq  indxq  rho  cutpnt  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-float-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slaed1_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,float), IDX_PTR($cutpnt,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed2 <k>  <n>  <n1>  <d>  <q>  <ldq>  <indxq>  <rho>  <z>  <dlamda>  <w>  <q2>  <indx>  <indxc>  <indxp>  <coltyp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED2 merges the two sets of eigenvalues together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  eigenvalues are close together or if there is a tiny entry in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K      (output) INTEGER
;;*         The number of non-deflated eigenvalues, and the order of the
;;*         related secular equation. 0 <= K <=N.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  N1     (input) INTEGER
;;*         The location of the last eigenvalue in the leading sub-matrix.
;;*         min(1,N) <= N1 <= N/2.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, D contains the eigenvalues of the two submatrices to
;;*         be combined.
;;*         On exit, D contains the trailing (N-K) updated eigenvalues
;;*         (those which were deflated) sorted into increasing order.
;;*
;;*  Q      (input/output) REAL array, dimension (LDQ, N)
;;*         On entry, Q contains the eigenvectors of two submatrices in
;;*         the two square blocks with corners at (1,1), (N1,N1)
;;*         and (N1+1, N1+1), (N,N).
;;*         On exit, Q contains the trailing (N-K) updated eigenvectors
;;*         (those which were deflated) in its last N-K columns.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (input/output) INTEGER array, dimension (N)
;;*         The permutation which separately sorts the two sub-problems
;;*         in D into ascending order.  Note that elements in the second
;;*         half of this permutation must first have N1 added to their
;;*         values. Destroyed on exit.
;;*
;;*  RHO    (input/output) REAL
;;*         On entry, the off-diagonal element associated with the rank-1
;;*         cut which originally split the two submatrices which are now
;;*         being recombined.
;;*         On exit, RHO has been modified to the value required by
;;*         SLAED3.
;;*
;;*  Z      (input) REAL array, dimension (N)
;;*         On entry, Z contains the updating vector (the last
;;*         row of the first sub-eigenvector matrix and the first row of
;;*         the second sub-eigenvector matrix).
;;*         On exit, the contents of Z have been destroyed by the updating
;;*         process.
;;*
;;*  DLAMDA (output) REAL array, dimension (N)
;;*         A copy of the first K eigenvalues which will be used by
;;*         SLAED3 to form the secular equation.
;;*
;;*  W      (output) REAL array, dimension (N)
;;*         The first k values of the final deflation-altered z-vector
;;*         which will be passed to SLAED3.
;;*
;;*  Q2     (output) REAL array, dimension (N1**2+(N-N1)**2)
;;*         A copy of the first K eigenvectors which will be used by
;;*         SLAED3 in a matrix multiply (SGEMM) to solve for the new
;;*         eigenvectors.
;;*
;;*  INDX   (workspace) INTEGER array, dimension (N)
;;*         The permutation used to sort the contents of DLAMDA into
;;*         ascending order.
;;*
;;*  INDXC  (output) INTEGER array, dimension (N)
;;*         The permutation used to arrange the columns of the deflated
;;*         Q matrix into three groups:  the first group contains non-zero
;;*         elements only at and above N1, the second contains
;;*         non-zero elements only below N1, and the third is dense.
;;*
;;*  INDXP  (workspace) INTEGER array, dimension (N)
;;*         The permutation used to place deflated values of D at the end
;;*         of the array.  INDXP(1:K) points to the nondeflated D-values
;;*         and INDXP(K+1:N) points to the deflated eigenvalues.
;;*
;;*  COLTYP (workspace/output) INTEGER array, dimension (N)
;;*         During execution, a label which will indicate which of the
;;*         following types a column in the Q2 matrix is:
;;*         1 : non-zero in the upper half only;
;;*         2 : dense;
;;*         3 : non-zero in the lower half only;
;;*         4 : deflated.
;;*         On exit, COLTYP(i) is the number of columns of type i,
;;*         for i=1 to 4 only.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed2 (k  n  n1  d  q  ldq  indxq  rho  z  dlamda  w  q2  indx  indxc  indxp  coltyp  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) n1 )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-float-)) rho )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) dlamda )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) q2 )
	((-idx1- (-int-)) indx )
	((-idx1- (-int-)) indxc )
	((-idx1- (-int-)) indxp )
	((-idx1- (-int-)) coltyp )
	((-idx0- (-int-)) info )
	#{ slaed2_(IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($n1,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,float), IDX_PTR($z,float), IDX_PTR($dlamda,float), IDX_PTR($w,float), IDX_PTR($q2,float), IDX_PTR($indx,int), IDX_PTR($indxc,int), IDX_PTR($indxp,int), IDX_PTR($coltyp,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed3 <k>  <n>  <n1>  <d>  <q>  <ldq>  <rho>  <dlamda>  <q2>  <indx>  <ctot>  <w>  <s>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED3 finds the roots of the secular equation, as defined by the
;;*  values in D, W, and RHO, between 1 and K.  It makes the
;;*  appropriate calls to SLAED4 and then updates the eigenvectors by
;;*  multiplying the matrix of eigenvectors of the pair of eigensystems
;;*  being combined by the matrix of eigenvectors of the K-by-K system
;;*  which is solved here.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved by
;;*          SLAED4.  K >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows and columns in the Q matrix.
;;*          N >= K (deflation may result in N>K).
;;*
;;*  N1      (input) INTEGER
;;*          The location of the last eigenvalue in the leading submatrix.
;;*          min(1,N) <= N1 <= N/2.
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          D(I) contains the updated eigenvalues for
;;*          1 <= I <= K.
;;*
;;*  Q       (output) REAL array, dimension (LDQ,N)
;;*          Initially the first K columns are used as workspace.
;;*          On output the columns 1 to K contain
;;*          the updated eigenvectors.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  RHO     (input) REAL
;;*          The value of the parameter in the rank one update equation.
;;*          RHO >= 0 required.
;;*
;;*  DLAMDA  (input/output) REAL array, dimension (K)
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation. May be changed on output by
;;*          having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
;;*          Cray-2, or Cray C-90, as described above.
;;*
;;*  Q2      (input) REAL array, dimension (LDQ2, N)
;;*          The first K columns of this matrix contain the non-deflated
;;*          eigenvectors for the split problem.
;;*
;;*  INDX    (input) INTEGER array, dimension (N)
;;*          The permutation used to arrange the columns of the deflated
;;*          Q matrix into three groups (see SLAED2).
;;*          The rows of the eigenvectors found by SLAED4 must be likewise
;;*          permuted before the matrix multiply can take place.
;;*
;;*  CTOT    (input) INTEGER array, dimension (4)
;;*          A count of the total number of the various types of columns
;;*          in Q, as described in INDX.  The fourth column type is any
;;*          column which has been deflated.
;;*
;;*  W       (input/output) REAL array, dimension (K)
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating vector. Destroyed on
;;*          output.
;;*
;;*  S       (workspace) REAL array, dimension (N1 + 1)*K
;;*          Will contain the eigenvectors of the repaired matrix which
;;*          will be multiplied by the previously accumulated eigenvectors
;;*          to update the system.
;;*
;;*  LDS     (input) INTEGER
;;*          The leading dimension of S.  LDS >= max(1,K).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed3 (k  n  n1  d  q  ldq  rho  dlamda  q2  indx  ctot  w  s  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) n1 )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) rho )
	((-idx1- (-float-)) dlamda )
	((-idx1- (-float-)) q2 )
	((-idx1- (-int-)) indx )
	((-idx1- (-int-)) ctot )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) s )
	((-idx0- (-int-)) info )
	#{ slaed3_(IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($n1,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($rho,float), IDX_PTR($dlamda,float), IDX_PTR($q2,float), IDX_PTR($indx,int), IDX_PTR($ctot,int), IDX_PTR($w,float), IDX_PTR($s,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed4 <n>  <i>  <d>  <z>  <delta>  <rho>  <dlam>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the I-th updated eigenvalue of a symmetric
;;*  rank-one modification to a diagonal matrix whose elements are
;;*  given in the array d, and that
;;*
;;*             D(i) < D(j)  for  i < j
;;*
;;*  and that RHO > 0.  This is arranged by the calling routine, and is
;;*  no loss in generality.  The rank-one modified system is thus
;;*
;;*             diag( D )  +  RHO *  Z * Z_transpose.
;;*
;;*  where we assume the Euclidean norm of Z is 1.
;;*
;;*  The method consists of approximating the rational functions in the
;;*  secular equation by simpler interpolating rational functions.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The length of all arrays.
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  1 <= I <= N.
;;*
;;*  D      (input) REAL array, dimension (N)
;;*         The original eigenvalues.  It is assumed that they are in
;;*         order, D(I) < D(J)  for I < J.
;;*
;;*  Z      (input) REAL array, dimension (N)
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) REAL array, dimension (N)
;;*         If N .ne. 1, DELTA contains (D(j) - lambda_I) in its  j-th
;;*         component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
;;*         contains the information necessary to construct the
;;*         eigenvectors.
;;*
;;*  RHO    (input) REAL
;;*         The scalar in the symmetric updating formula.
;;*
;;*  DLAM   (output) REAL
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit
;;*         > 0:  if INFO = 1, the updating process failed.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  Logical variable ORGATI (origin-at-i?) is used for distinguishing
;;*  whether D(i) or D(i+1) is treated as the origin.
;;*
;;*            ORGATI = .true.    origin at i
;;*            ORGATI = .false.   origin at i+1
;;*
;;*   Logical variable SWTCH3 (switch-for-3-poles?) is for noting
;;*   if we are working with THREE poles!
;;*
;;*   MAXIT is the maximum number of iterations allowed for each
;;*   eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed4 (n  i  d  z  delta  rho  dlam  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) i )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) delta )
	((-idx0- (-float-)) rho )
	((-idx0- (-float-)) dlam )
	((-idx0- (-int-)) info )
	#{ slaed4_(IDX_PTR($n,int), IDX_PTR($i,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($delta,float), IDX_PTR($rho,float), IDX_PTR($dlam,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed5 <i>  <d>  <z>  <delta>  <rho>  <dlam>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the I-th eigenvalue of a symmetric rank-one
;;*  modification of a 2-by-2 diagonal matrix
;;*
;;*             diag( D )  +  RHO *  Z * transpose(Z) .
;;*
;;*  The diagonal elements in the array D are assumed to satisfy
;;*
;;*             D(i) < D(j)  for  i < j .
;;*
;;*  We also assume RHO > 0 and that the Euclidean norm of the vector
;;*  Z is one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  I = 1 or I = 2.
;;*
;;*  D      (input) REAL array, dimension (2)
;;*         The original eigenvalues.  We assume D(1) < D(2).
;;*
;;*  Z      (input) REAL array, dimension (2)
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) REAL array, dimension (2)
;;*         The vector DELTA contains the information necessary
;;*         to construct the eigenvectors.
;;*
;;*  RHO    (input) REAL
;;*         The scalar in the symmetric updating formula.
;;*
;;*  DLAM   (output) REAL
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed5 (i  d  z  delta  rho  dlam  )
	((-idx0- (-int-)) i )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) delta )
	((-idx0- (-float-)) rho )
	((-idx0- (-float-)) dlam )
	#{ slaed5_(IDX_PTR($i,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($delta,float), IDX_PTR($rho,float), IDX_PTR($dlam,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed6 <kniter>  <orgati>  <rho>  <d>  <z>  <finit>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED6 computes the positive or negative root (closest to the origin)
;;*  of
;;*                   z(1)        z(2)        z(3)
;;*  f(x) =   rho + --------- + ---------- + ---------
;;*                  d(1)-x      d(2)-x      d(3)-x
;;*
;;*  It is assumed that
;;*
;;*        if ORGATI = .true. the root is between d(2) and d(3);
;;*        otherwise it is between d(1) and d(2)
;;*
;;*  This routine will be called by SLAED4 when necessary. In most cases,
;;*  the root sought is the smallest in magnitude, though it might not be
;;*  in some extremely rare situations.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  KNITER       (input) INTEGER
;;*               Refer to SLAED4 for its significance.
;;*
;;*  ORGATI       (input) LOGICAL
;;*               If ORGATI is true, the needed root is between d(2) and
;;*               d(3); otherwise it is between d(1) and d(2).  See
;;*               SLAED4 for further details.
;;*
;;*  RHO          (input) REAL
;;*               Refer to the equation f(x) above.
;;*
;;*  D            (input) REAL array, dimension (3)
;;*               D satisfies d(1) < d(2) < d(3).
;;*
;;*  Z            (input) REAL array, dimension (3)
;;*               Each of the elements in z must be positive.
;;*
;;*  FINIT        (input) REAL
;;*               The value of f at 0. It is more accurate than the one
;;*               evaluated inside this routine (if someone wants to do
;;*               so).
;;*
;;*  TAU          (output) REAL
;;*               The root of the equation f(x).
;;*
;;*  INFO         (output) INTEGER
;;*               = 0: successful exit
;;*               > 0: if INFO = 1, failure to converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed6 (kniter  orgati  rho  d  z  finit  tau  info  )
	((-idx0- (-int-)) kniter )
	((-idx0- (-int-)) orgati )
	((-idx0- (-float-)) rho )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx0- (-float-)) finit )
	((-idx0- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ slaed6_(IDX_PTR($kniter,int), IDX_PTR($orgati,int), IDX_PTR($rho,float), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($finit,float), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed7 <icompq>  <n>  <qsiz>  <tlvls>  <curlvl>  <curpbm>  <d>  <q>  <ldq>  <indxq>  <rho>  <cutpnt>  <qstore>  <qptr>  <prmptr>  <perm>  <givptr>  <givcol>  <givnum>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED7 computes the updated eigensystem of a diagonal
;;*  matrix after modification by a rank-one symmetric matrix. This
;;*  routine is used only for the eigenproblem which requires all
;;*  eigenvalues and optionally eigenvectors of a dense symmetric matrix
;;*  that has been reduced to tridiagonal form.  SLAED1 handles
;;*  the case in which all eigenvalues and eigenvectors of a symmetric
;;*  tridiagonal matrix are desired.
;;*
;;*    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
;;*
;;*     where Z = Q'u, u is a vector of length N with ones in the
;;*     CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
;;*
;;*     The eigenvectors of the original matrix are stored in Q, and the
;;*     eigenvalues are in D.  The algorithm consists of three stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple eigenvalues or if there is a zero in
;;*        the Z vector.  For each such occurence the dimension of the
;;*        secular equation problem is reduced by one.  This stage is
;;*        performed by the routine SLAED8.
;;*
;;*        The second stage consists of calculating the updated
;;*        eigenvalues. This is done by finding the roots of the secular
;;*        equation via the routine SLAED4 (as called by SLAED9).
;;*        This routine also calculates the eigenvectors of the current
;;*        problem.
;;*
;;*        The final stage consists of computing the updated eigenvectors
;;*        directly using the updated eigenvalues.  The eigenvectors for
;;*        the current problem are multiplied with the eigenvectors from
;;*        the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          = 0:  Compute eigenvalues only.
;;*          = 1:  Compute eigenvectors of original dense symmetric matrix
;;*                also.  On entry, Q contains the orthogonal matrix used
;;*                to reduce the original matrix to tridiagonal form.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the orthogonal matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  TLVLS  (input) INTEGER
;;*         The total number of merging levels in the overall divide and
;;*         conquer tree.
;;*
;;*  CURLVL (input) INTEGER
;;*         The current level in the overall merge routine,
;;*         0 <= CURLVL <= TLVLS.
;;*
;;*  CURPBM (input) INTEGER
;;*         The current problem in the current level in the overall
;;*         merge routine (counting from upper left to lower right).
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, the eigenvalues of the rank-1-perturbed matrix.
;;*         On exit, the eigenvalues of the repaired matrix.
;;*
;;*  Q      (input/output) REAL array, dimension (LDQ, N)
;;*         On entry, the eigenvectors of the rank-1-perturbed matrix.
;;*         On exit, the eigenvectors of the repaired tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (output) INTEGER array, dimension (N)
;;*         The permutation which will reintegrate the subproblem just
;;*         solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
;;*         will be in ascending order.
;;*
;;*  RHO    (input) REAL
;;*         The subdiagonal element used to create the rank-1
;;*         modification.
;;*
;;*  CUTPNT (input) INTEGER
;;*         Contains the location of the last eigenvalue in the leading
;;*         sub-matrix.  min(1,N) <= CUTPNT <= N.
;;*
;;*  QSTORE (input/output) REAL array, dimension (N**2+1)
;;*         Stores eigenvectors of submatrices encountered during
;;*         divide and conquer, packed together. QPTR points to
;;*         beginning of the submatrices.
;;*
;;*  QPTR   (input/output) INTEGER array, dimension (N+2)
;;*         List of indices pointing to beginning of submatrices stored
;;*         in QSTORE. The submatrices are numbered starting at the
;;*         bottom left of the divide and conquer tree, from left to
;;*         right and bottom to top.
;;*
;;*  PRMPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in PERM a
;;*         level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
;;*         indicates the size of the permutation and also the size of
;;*         the full, non-deflated problem.
;;*
;;*  PERM   (input) INTEGER array, dimension (N lg N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in GIVCOL a
;;*         level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
;;*         indicates the number of Givens rotations.
;;*
;;*  GIVCOL (input) INTEGER array, dimension (2, N lg N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (input) REAL array, dimension (2, N lg N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  WORK   (workspace) REAL array, dimension (3*N+QSIZ*N)
;;*
;;*  IWORK  (workspace) INTEGER array, dimension (4*N)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed7 (icompq  n  qsiz  tlvls  curlvl  curpbm  d  q  ldq  indxq  rho  cutpnt  qstore  qptr  prmptr  perm  givptr  givcol  givnum  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) tlvls )
	((-idx0- (-int-)) curlvl )
	((-idx0- (-int-)) curpbm )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-float-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-float-)) qstore )
	((-idx1- (-int-)) qptr )
	((-idx1- (-int-)) prmptr )
	((-idx1- (-int-)) perm )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-float-)) givnum )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slaed7_(IDX_PTR($icompq,int), IDX_PTR($n,int), IDX_PTR($qsiz,int), IDX_PTR($tlvls,int), IDX_PTR($curlvl,int), IDX_PTR($curpbm,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,float), IDX_PTR($cutpnt,int), IDX_PTR($qstore,float), IDX_PTR($qptr,int), IDX_PTR($prmptr,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed8 <icompq>  <k>  <n>  <qsiz>  <d>  <q>  <ldq>  <indxq>  <rho>  <cutpnt>  <z>  <dlamda>  <q2>  <ldq2>  <w>  <perm>  <givptr>  <givcol>  <givnum>  <indxp>  <indx>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED8 merges the two sets of eigenvalues together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  eigenvalues are close together or if there is a tiny element in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          = 0:  Compute eigenvalues only.
;;*          = 1:  Compute eigenvectors of original dense symmetric matrix
;;*                also.  On entry, Q contains the orthogonal matrix used
;;*                to reduce the original matrix to tridiagonal form.
;;*
;;*  K      (output) INTEGER
;;*         The number of non-deflated eigenvalues, and the order of the
;;*         related secular equation.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the orthogonal matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry, the eigenvalues of the two submatrices to be
;;*         combined.  On exit, the trailing (N-K) updated eigenvalues
;;*         (those which were deflated) sorted into increasing order.
;;*
;;*  Q      (input/output) REAL array, dimension (LDQ,N)
;;*         If ICOMPQ = 0, Q is not referenced.  Otherwise,
;;*         on entry, Q contains the eigenvectors of the partially solved
;;*         system which has been previously updated in matrix
;;*         multiplies with other partially solved eigensystems.
;;*         On exit, Q contains the trailing (N-K) updated eigenvectors
;;*         (those which were deflated) in its last N-K columns.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (input) INTEGER array, dimension (N)
;;*         The permutation which separately sorts the two sub-problems
;;*         in D into ascending order.  Note that elements in the second
;;*         half of this permutation must first have CUTPNT added to
;;*         their values in order to be accurate.
;;*
;;*  RHO    (input/output) REAL
;;*         On entry, the off-diagonal element associated with the rank-1
;;*         cut which originally split the two submatrices which are now
;;*         being recombined.
;;*         On exit, RHO has been modified to the value required by
;;*         SLAED3.
;;*
;;*  CUTPNT (input) INTEGER
;;*         The location of the last eigenvalue in the leading
;;*         sub-matrix.  min(1,N) <= CUTPNT <= N.
;;*
;;*  Z      (input) REAL array, dimension (N)
;;*         On entry, Z contains the updating vector (the last row of
;;*         the first sub-eigenvector matrix and the first row of the
;;*         second sub-eigenvector matrix).
;;*         On exit, the contents of Z are destroyed by the updating
;;*         process.
;;*
;;*  DLAMDA (output) REAL array, dimension (N)
;;*         A copy of the first K eigenvalues which will be used by
;;*         SLAED3 to form the secular equation.
;;*
;;*  Q2     (output) REAL array, dimension (LDQ2,N)
;;*         If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
;;*         a copy of the first K eigenvectors which will be used by
;;*         SLAED7 in a matrix multiply (SGEMM) to update the new
;;*         eigenvectors.
;;*
;;*  LDQ2   (input) INTEGER
;;*         The leading dimension of the array Q2.  LDQ2 >= max(1,N).
;;*
;;*  W      (output) REAL array, dimension (N)
;;*         The first k values of the final deflation-altered z-vector and
;;*         will be passed to SLAED3.
;;*
;;*  PERM   (output) INTEGER array, dimension (N)
;;*         The permutations (from deflation and sorting) to be applied
;;*         to each eigenblock.
;;*
;;*  GIVPTR (output) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem.
;;*
;;*  GIVCOL (output) INTEGER array, dimension (2, N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (output) REAL array, dimension (2, N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  INDXP  (workspace) INTEGER array, dimension (N)
;;*         The permutation used to place deflated values of D at the end
;;*         of the array.  INDXP(1:K) points to the nondeflated D-values
;;*         and INDXP(K+1:N) points to the deflated eigenvalues.
;;*
;;*  INDX   (workspace) INTEGER array, dimension (N)
;;*         The permutation used to sort the contents of D into ascending
;;*         order.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaed8 (icompq  k  n  qsiz  d  q  ldq  indxq  rho  cutpnt  z  dlamda  q2  ldq2  w  perm  givptr  givcol  givnum  indxp  indx  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) qsiz )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-float-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) dlamda )
	((-idx2- (-float-)) q2 )
	((-idx0- (-int-)) ldq2 )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-float-)) givnum )
	((-idx1- (-int-)) indxp )
	((-idx1- (-int-)) indx )
	((-idx0- (-int-)) info )
	#{ slaed8_(IDX_PTR($icompq,int), IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($qsiz,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,float), IDX_PTR($cutpnt,int), IDX_PTR($z,float), IDX_PTR($dlamda,float), IDX_PTR($q2,float), IDX_PTR($ldq2,int), IDX_PTR($w,float), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,float), IDX_PTR($indxp,int), IDX_PTR($indx,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaed9 <k>  <kstart>  <kstop>  <n>  <d>  <q>  <ldq>  <rho>  <dlamda>  <w>  <s>  <lds>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAED9 finds the roots of the secular equation, as defined by the
;;*  values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
;;*  appropriate calls to SLAED4 and then stores the new matrix of
;;*  eigenvectors for use in calculating the next level of Z vectors.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved by
;;*          SLAED4.  K >= 0.
;;*
;;*  KSTART  (input) INTEGER
;;*  KSTOP   (input) INTEGER
;;*          The updated eigenvalues Lambda(I), KSTART <= I <= KSTOP
;;*          are to be computed.  1 <= KSTART <= KSTOP <= K.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows and columns in the Q matrix.
;;*          N >= K (delation may result in N > K).
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          D(I) contains the updated eigenvalues
;;*          for KSTART <= I <= KSTOP.
;;*
;;*  Q       (workspace) REAL array, dimension (LDQ,N)
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max( 1, N ).
;;*
;;*  RHO     (input) REAL
;;*          The value of the parameter in the rank one update equation.
;;*          RHO >= 0 required.
;;*
;;*  DLAMDA  (input) REAL array, dimension (K)
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation.
;;*
;;*  W       (input) REAL array, dimension (K)
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating vector.
;;*
;;*  S       (output) REAL array, dimension (LDS, K)
;;*          Will contain the eigenvectors of the repaired matrix which
;;*          will be stored for subsequent Z vector calculation and
;;*          multiplied by the previously accumulated eigenvectors
;;*          to update the system.
;;*
;;*  LDS     (input) INTEGER
;;*          The leading dimension of S.  LDS >= max( 1, K ).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slaed9 (k  kstart  kstop  n  d  q  ldq  rho  dlamda  w  s  lds  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) kstart )
	((-idx0- (-int-)) kstop )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) rho )
	((-idx1- (-float-)) dlamda )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) s )
	((-idx0- (-int-)) lds )
	((-idx0- (-int-)) info )
	#{ slaed9_(IDX_PTR($k,int), IDX_PTR($kstart,int), IDX_PTR($kstop,int), IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($rho,float), IDX_PTR($dlamda,float), IDX_PTR($w,float), IDX_PTR($s,float), IDX_PTR($lds,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaeda <n>  <tlvls>  <curlvl>  <curpbm>  <prmptr>  <perm>  <givptr>  <givcol>  <givnum>  <q>  <qptr>  <z>  <ztemp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAEDA computes the Z vector corresponding to the merge step in the
;;*  CURLVLth step of the merge process with TLVLS steps for the CURPBMth
;;*  problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  TLVLS  (input) INTEGER
;;*         The total number of merging levels in the overall divide and
;;*         conquer tree.
;;*
;;*  CURLVL (input) INTEGER
;;*         The current level in the overall merge routine,
;;*         0 <= curlvl <= tlvls.
;;*
;;*  CURPBM (input) INTEGER
;;*         The current problem in the current level in the overall
;;*         merge routine (counting from upper left to lower right).
;;*
;;*  PRMPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in PERM a
;;*         level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
;;*         indicates the size of the permutation and incidentally the
;;*         size of the full, non-deflated problem.
;;*
;;*  PERM   (input) INTEGER array, dimension (N lg N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in GIVCOL a
;;*         level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
;;*         indicates the number of Givens rotations.
;;*
;;*  GIVCOL (input) INTEGER array, dimension (2, N lg N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (input) REAL array, dimension (2, N lg N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  Q      (input) REAL array, dimension (N**2)
;;*         Contains the square eigenblocks from previous levels, the
;;*         starting positions for blocks are given by QPTR.
;;*
;;*  QPTR   (input) INTEGER array, dimension (N+2)
;;*         Contains a list of pointers which indicate where in Q an
;;*         eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
;;*         the size of the block.
;;*
;;*  Z      (output) REAL array, dimension (N)
;;*         On output this vector contains the updating vector (the last
;;*         row of the first sub-eigenvector matrix and the first row of
;;*         the second sub-eigenvector matrix).
;;*
;;*  ZTEMP  (workspace) REAL array, dimension (N)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaeda (n  tlvls  curlvl  curpbm  prmptr  perm  givptr  givcol  givnum  q  qptr  z  ztemp  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) tlvls )
	((-idx0- (-int-)) curlvl )
	((-idx0- (-int-)) curpbm )
	((-idx1- (-int-)) prmptr )
	((-idx1- (-int-)) perm )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-float-)) givnum )
	((-idx1- (-float-)) q )
	((-idx1- (-int-)) qptr )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) ztemp )
	((-idx0- (-int-)) info )
	#{ slaeda_(IDX_PTR($n,int), IDX_PTR($tlvls,int), IDX_PTR($curlvl,int), IDX_PTR($curpbm,int), IDX_PTR($prmptr,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,float), IDX_PTR($q,float), IDX_PTR($qptr,int), IDX_PTR($z,float), IDX_PTR($ztemp,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaein <rightv>  <noinit>  <n>  <h>  <ldh>  <wr>  <wi>  <vr>  <vi>  <b>  <ldb>  <work>  <eps3>  <smlnum>  <bignum>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAEIN uses inverse iteration to find a right or left eigenvector
;;*  corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
;;*  matrix H.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  RIGHTV   (input) LOGICAL
;;*          = .TRUE. : compute right eigenvector;
;;*          = .FALSE.: compute left eigenvector.
;;*
;;*  NOINIT   (input) LOGICAL
;;*          = .TRUE. : no initial vector supplied in (VR,VI).
;;*          = .FALSE.: initial vector supplied in (VR,VI).
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) REAL array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  WR      (input) REAL
;;*  WI      (input) REAL
;;*          The real and imaginary parts of the eigenvalue of H whose
;;*          corresponding right or left eigenvector is to be computed.
;;*
;;*  VR      (input/output) REAL array, dimension (N)
;;*  VI      (input/output) REAL array, dimension (N)
;;*          On entry, if NOINIT = .FALSE. and WI = 0.0, VR must contain
;;*          a real starting vector for inverse iteration using the real
;;*          eigenvalue WR; if NOINIT = .FALSE. and WI.ne.0.0, VR and VI
;;*          must contain the real and imaginary parts of a complex
;;*          starting vector for inverse iteration using the complex
;;*          eigenvalue (WR,WI); otherwise VR and VI need not be set.
;;*          On exit, if WI = 0.0 (real eigenvalue), VR contains the
;;*          computed real eigenvector; if WI.ne.0.0 (complex eigenvalue),
;;*          VR and VI contain the real and imaginary parts of the
;;*          computed complex eigenvector. The eigenvector is normalized
;;*          so that the component of largest magnitude has magnitude 1;
;;*          here the magnitude of a complex number (x,y) is taken to be
;;*          |x| + |y|.
;;*          VI is not referenced if WI = 0.0.
;;*
;;*  B       (workspace) REAL array, dimension (LDB,N)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= N+1.
;;*
;;*  WORK   (workspace) REAL array, dimension (N)
;;*
;;*  EPS3    (input) REAL
;;*          A small machine-dependent value which is used to perturb
;;*          close eigenvalues, and to replace zero pivots.
;;*
;;*  SMLNUM  (input) REAL
;;*          A machine-dependent value close to the underflow threshold.
;;*
;;*  BIGNUM  (input) REAL
;;*          A machine-dependent value close to the overflow threshold.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          = 1:  inverse iteration did not converge; VR is set to the
;;*                last iterate, and so is VI if WI.ne.0.0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaein (rightv  noinit  n  h  ldh  wr  wi  vr  vi  b  ldb  work  eps3  smlnum  bignum  info  )
	((-idx0- (-int-)) rightv )
	((-idx0- (-int-)) noinit )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx0- (-float-)) wr )
	((-idx0- (-float-)) wi )
	((-idx1- (-float-)) vr )
	((-idx1- (-float-)) vi )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) work )
	((-idx0- (-float-)) eps3 )
	((-idx0- (-float-)) smlnum )
	((-idx0- (-float-)) bignum )
	((-idx0- (-int-)) info )
	#{ slaein_(IDX_PTR($rightv,int), IDX_PTR($noinit,int), IDX_PTR($n,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($vr,float), IDX_PTR($vi,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($work,float), IDX_PTR($eps3,float), IDX_PTR($smlnum,float), IDX_PTR($bignum,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaev2 <a>  <b>  <c>  <rt1>  <rt2>  <cs1>  <sn1>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
;;*     [  A   B  ]
;;*     [  B   C  ].
;;*  On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
;;*  eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
;;*  eigenvector for RT1, giving the decomposition
;;*
;;*     [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
;;*     [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) REAL
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  B       (input) REAL
;;*          The (1,2) element and the conjugate of the (2,1) element of
;;*          the 2-by-2 matrix.
;;*
;;*  C       (input) REAL
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  RT1     (output) REAL
;;*          The eigenvalue of larger absolute value.
;;*
;;*  RT2     (output) REAL
;;*          The eigenvalue of smaller absolute value.
;;*
;;*  CS1     (output) REAL
;;*  SN1     (output) REAL
;;*          The vector (CS1, SN1) is a unit right eigenvector for RT1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  RT1 is accurate to a few ulps barring over/underflow.
;;*
;;*  RT2 may be inaccurate if there is massive cancellation in the
;;*  determinant A*C-B*B; higher precision or correctly rounded or
;;*  correctly truncated arithmetic would be needed to compute RT2
;;*  accurately in all cases.
;;*
;;*  CS1 and SN1 are accurate to a few ulps barring over/underflow.
;;*
;;*  Overflow is possible only if RT1 is within a factor of 5 of overflow.
;;*  Underflow is harmless if the input data is 0 or exceeds
;;*     underflow_threshold / macheps.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaev2 (a  b  c  rt1  rt2  cs1  sn1  )
	((-idx0- (-float-)) a )
	((-idx0- (-float-)) b )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) rt1 )
	((-idx0- (-float-)) rt2 )
	((-idx0- (-float-)) cs1 )
	((-idx0- (-float-)) sn1 )
	#{ slaev2_(IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($rt1,float), IDX_PTR($rt2,float), IDX_PTR($cs1,float), IDX_PTR($sn1,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaexc <wantq>  <n>  <t_>  <ldt>  <q>  <ldq>  <j1>  <n1>  <n2>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
;;*  an upper quasi-triangular matrix T by an orthogonal similarity
;;*  transformation.
;;*
;;*  T must be in Schur canonical form, that is, block upper triangular
;;*  with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
;;*  has its diagonal elemnts equal and its off-diagonal elements of
;;*  opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          = .TRUE. : accumulate the transformation in the matrix Q;
;;*          = .FALSE.: do not accumulate the transformation.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) REAL array, dimension (LDT,N)
;;*          On entry, the upper quasi-triangular matrix T, in Schur
;;*          canonical form.
;;*          On exit, the updated matrix T, again in Schur canonical form.
;;*
;;*  LDT     (input)  INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ,N)
;;*          On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
;;*          On exit, if WANTQ is .TRUE., the updated matrix Q.
;;*          If WANTQ is .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.
;;*
;;*  J1      (input) INTEGER
;;*          The index of the first row of the first block T11.
;;*
;;*  N1      (input) INTEGER
;;*          The order of the first block T11. N1 = 0, 1 or 2.
;;*
;;*  N2      (input) INTEGER
;;*          The order of the second block T22. N2 = 0, 1 or 2.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          = 1: the transformed matrix T would be too far from Schur
;;*               form; the blocks are not swapped and T and Q are
;;*               unchanged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaexc (wantq  n  t_  ldt  q  ldq  j1  n1  n2  work  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-int-)) j1 )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slaexc_(IDX_PTR($wantq,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($j1,int), IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slag2 <a>  <lda>  <b>  <ldb>  <safmin>  <scale1>  <scale2>  <wr1>  <wr2>  <wi>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue
;;*  problem  A - w B, with scaling as necessary to avoid over-/underflow.
;;*
;;*  The scaling factor "s" results in a modified eigenvalue equation
;;*
;;*      s A - w B
;;*
;;*  where  s  is a non-negative scaling factor chosen so that  w,  w B,
;;*  and  s A  do not overflow and, if possible, do not underflow, either.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) REAL array, dimension (LDA, 2)
;;*          On entry, the 2 x 2 matrix A.  It is assumed that its 1-norm
;;*          is less than 1/SAFMIN.  Entries less than
;;*          sqrt(SAFMIN)*norm(A) are subject to being treated as zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= 2.
;;*
;;*  B       (input) REAL array, dimension (LDB, 2)
;;*          On entry, the 2 x 2 upper triangular matrix B.  It is
;;*          assumed that the one-norm of B is less than 1/SAFMIN.  The
;;*          diagonals should be at least sqrt(SAFMIN) times the largest
;;*          element of B (in absolute value); if a diagonal is smaller
;;*          than that, then  +/- sqrt(SAFMIN) will be used instead of
;;*          that diagonal.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= 2.
;;*
;;*  SAFMIN  (input) REAL
;;*          The smallest positive number s.t. 1/SAFMIN does not
;;*          overflow.  (This should always be SLAMCH('S') -- it is an
;;*          argument in order to avoid having to call SLAMCH frequently.)
;;*
;;*  SCALE1  (output) REAL
;;*          A scaling factor used to avoid over-/underflow in the
;;*          eigenvalue equation which defines the first eigenvalue.  If
;;*          the eigenvalues are complex, then the eigenvalues are
;;*          ( WR1  +/-  WI i ) / SCALE1  (which may lie outside the
;;*          exponent range of the machine), SCALE1=SCALE2, and SCALE1
;;*          will always be positive.  If the eigenvalues are real, then
;;*          the first (real) eigenvalue is  WR1 / SCALE1 , but this may
;;*          overflow or underflow, and in fact, SCALE1 may be zero or
;;*          less than the underflow threshhold if the exact eigenvalue
;;*          is sufficiently large.
;;*
;;*  SCALE2  (output) REAL
;;*          A scaling factor used to avoid over-/underflow in the
;;*          eigenvalue equation which defines the second eigenvalue.  If
;;*          the eigenvalues are complex, then SCALE2=SCALE1.  If the
;;*          eigenvalues are real, then the second (real) eigenvalue is
;;*          WR2 / SCALE2 , but this may overflow or underflow, and in
;;*          fact, SCALE2 may be zero or less than the underflow
;;*          threshhold if the exact eigenvalue is sufficiently large.
;;*
;;*  WR1     (output) REAL
;;*          If the eigenvalue is real, then WR1 is SCALE1 times the
;;*          eigenvalue closest to the (2,2) element of A B**(-1).  If the
;;*          eigenvalue is complex, then WR1=WR2 is SCALE1 times the real
;;*          part of the eigenvalues.
;;*
;;*  WR2     (output) REAL
;;*          If the eigenvalue is real, then WR2 is SCALE2 times the
;;*          other eigenvalue.  If the eigenvalue is complex, then
;;*          WR1=WR2 is SCALE1 times the real part of the eigenvalues.
;;*
;;*  WI      (output) REAL
;;*          If the eigenvalue is real, then WI is zero.  If the
;;*          eigenvalue is complex, then WI is SCALE1 times the imaginary
;;*          part of the eigenvalues.  WI will always be non-negative.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slag2 (a  lda  b  ldb  safmin  scale1  scale2  wr1  wr2  wi  )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) safmin )
	((-idx0- (-float-)) scale1 )
	((-idx0- (-float-)) scale2 )
	((-idx0- (-float-)) wr1 )
	((-idx0- (-float-)) wr2 )
	((-idx0- (-float-)) wi )
	#{ slag2_(IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($safmin,float), IDX_PTR($scale1,float), IDX_PTR($scale2,float), IDX_PTR($wr1,float), IDX_PTR($wr2,float), IDX_PTR($wi,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slags2 <upper>  <a1>  <a2>  <a3>  <b1>  <b2>  <b3>  <csu>  <snu>  <csv>  <snv>  <csq>  <snq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
;;*  that if ( UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 A2 )*Q = ( x  0  )
;;*                        ( 0  A3 )     ( x  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 B2 )*Q = ( x  0  )
;;*                        ( 0  B3 )     ( x  x  )
;;*
;;*  or if ( .NOT.UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 0  )*Q = ( x  x  )
;;*                        ( A2 A3 )     ( 0  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 0  )*Q = ( x  x  )
;;*                        ( B2 B3 )     ( 0  x  )
;;*
;;*  The rows of the transformed A and B are parallel, where
;;*
;;*    U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
;;*        ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
;;*
;;*  Z' denotes the transpose of Z.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPPER   (input) LOGICAL
;;*          = .TRUE.: the input matrices A and B are upper triangular.
;;*          = .FALSE.: the input matrices A and B are lower triangular.
;;*
;;*  A1      (input) REAL
;;*  A2      (input) REAL
;;*  A3      (input) REAL
;;*          On entry, A1, A2 and A3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix A.
;;*
;;*  B1      (input) REAL
;;*  B2      (input) REAL
;;*  B3      (input) REAL
;;*          On entry, B1, B2 and B3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix B.
;;*
;;*  CSU     (output) REAL
;;*  SNU     (output) REAL
;;*          The desired orthogonal matrix U.
;;*
;;*  CSV     (output) REAL
;;*  SNV     (output) REAL
;;*          The desired orthogonal matrix V.
;;*
;;*  CSQ     (output) REAL
;;*  SNQ     (output) REAL
;;*          The desired orthogonal matrix Q.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slags2 (upper  a1  a2  a3  b1  b2  b3  csu  snu  csv  snv  csq  snq  )
	((-idx0- (-int-)) upper )
	((-idx0- (-float-)) a1 )
	((-idx0- (-float-)) a2 )
	((-idx0- (-float-)) a3 )
	((-idx0- (-float-)) b1 )
	((-idx0- (-float-)) b2 )
	((-idx0- (-float-)) b3 )
	((-idx0- (-float-)) csu )
	((-idx0- (-float-)) snu )
	((-idx0- (-float-)) csv )
	((-idx0- (-float-)) snv )
	((-idx0- (-float-)) csq )
	((-idx0- (-float-)) snq )
	#{ slags2_(IDX_PTR($upper,int), IDX_PTR($a1,float), IDX_PTR($a2,float), IDX_PTR($a3,float), IDX_PTR($b1,float), IDX_PTR($b2,float), IDX_PTR($b3,float), IDX_PTR($csu,float), IDX_PTR($snu,float), IDX_PTR($csv,float), IDX_PTR($snv,float), IDX_PTR($csq,float), IDX_PTR($snq,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slagtf <n>  <a>  <lambda>  <b>  <c>  <tol>  <d>  <in>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
;;*  tridiagonal matrix and lambda is a scalar, as
;;*
;;*     T - lambda*I = PLU,
;;*
;;*  where P is a permutation matrix, L is a unit lower tridiagonal matrix
;;*  with at most one non-zero sub-diagonal elements per column and U is
;;*  an upper triangular matrix with at most two non-zero super-diagonal
;;*  elements per column.
;;*
;;*  The factorization is obtained by Gaussian elimination with partial
;;*  pivoting and implicit row scaling.
;;*
;;*  The parameter LAMBDA is included in the routine so that SLAGTF may
;;*  be used, in conjunction with SLAGTS, to obtain eigenvectors of T by
;;*  inverse iteration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T.
;;*
;;*  A       (input/output) REAL array, dimension (N)
;;*          On entry, A must contain the diagonal elements of T.
;;*
;;*          On exit, A is overwritten by the n diagonal elements of the
;;*          upper triangular matrix U of the factorization of T.
;;*
;;*  LAMBDA  (input) REAL
;;*          On entry, the scalar lambda.
;;*
;;*  B       (input/output) REAL array, dimension (N-1)
;;*          On entry, B must contain the (n-1) super-diagonal elements of
;;*          T.
;;*
;;*          On exit, B is overwritten by the (n-1) super-diagonal
;;*          elements of the matrix U of the factorization of T.
;;*
;;*  C       (input/output) REAL array, dimension (N-1)
;;*          On entry, C must contain the (n-1) sub-diagonal elements of
;;*          T.
;;*
;;*          On exit, C is overwritten by the (n-1) sub-diagonal elements
;;*          of the matrix L of the factorization of T.
;;*
;;*  TOL     (input) REAL
;;*          On entry, a relative tolerance used to indicate whether or
;;*          not the matrix (T - lambda*I) is nearly singular. TOL should
;;*          normally be chose as approximately the largest relative error
;;*          in the elements of T. For example, if the elements of T are
;;*          correct to about 4 significant figures, then TOL should be
;;*          set to about 5*10**(-4). If TOL is supplied as less than eps,
;;*          where eps is the relative machine precision, then the value
;;*          eps is used in place of TOL.
;;*
;;*  D       (output) REAL array, dimension (N-2)
;;*          On exit, D is overwritten by the (n-2) second super-diagonal
;;*          elements of the matrix U of the factorization of T.
;;*
;;*  IN      (output) INTEGER array, dimension (N)
;;*          On exit, IN contains details of the permutation matrix P. If
;;*          an interchange occurred at the kth step of the elimination,
;;*          then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)
;;*          returns the smallest positive integer j such that
;;*
;;*             abs( u(j,j) ).le. norm( (T - lambda*I)(j) )*TOL,
;;*
;;*          where norm( A(j) ) denotes the sum of the absolute values of
;;*          the jth row of the matrix A. If no such j exists then IN(n)
;;*          is returned as zero. If IN(n) is returned as positive, then a
;;*          diagonal element of U is small, indicating that
;;*          (T - lambda*I) is singular or nearly singular,
;;*
;;*  INFO    (output) INTEGER
;;*          = 0   : successful exit
;;*          .lt. 0: if INFO = -k, the kth argument had an illegal value
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slagtf (n  a  lambda  b  c  tol  d  in  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) a )
	((-idx0- (-float-)) lambda )
	((-idx1- (-float-)) b )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) tol )
	((-idx1- (-float-)) d )
	((-idx1- (-int-)) in )
	((-idx0- (-int-)) info )
	#{ slagtf_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lambda,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($tol,float), IDX_PTR($d,float), IDX_PTR($in,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slagtm <trans>  <n>  <nrhs>  <alpha>  <dl>  <d>  <du>  <x>  <ldx>  <beta>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAGTM performs a matrix-vector product of the form
;;*
;;*     B := alpha * A * X + beta * B
;;*
;;*  where A is a tridiagonal matrix of order N, B and X are N by NRHS
;;*  matrices, and alpha and beta are real scalars, each of which may be
;;*  0., 1., or -1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the operation applied to A.
;;*          = 'N':  No transpose, B := alpha * A * X + beta * B
;;*          = 'T':  Transpose,    B := alpha * A'* X + beta * B
;;*          = 'C':  Conjugate transpose = Transpose
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices X and B.
;;*
;;*  ALPHA   (input) REAL
;;*          The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 0.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of T.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The diagonal elements of T.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of T.
;;*
;;*  X       (input) REAL array, dimension (LDX,NRHS)
;;*          The N by NRHS matrix X.
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(N,1).
;;*
;;*  BETA    (input) REAL
;;*          The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 1.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N by NRHS matrix B.
;;*          On exit, B is overwritten by the matrix expression
;;*          B := alpha * A * X + beta * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(N,1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slagtm (trans  n  nrhs  alpha  dl  d  du  x  ldx  beta  b  ldb  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx0- (-float-)) alpha )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) beta )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ slagtm_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($alpha,float), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($beta,float), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slagts <job>  <n>  <a>  <b>  <c>  <d>  <in>  <y>  <tol>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAGTS may be used to solve one of the systems of equations
;;*
;;*     (T - lambda*I)*x = y   or   (T - lambda*I)'*x = y,
;;*
;;*  where T is an n by n tridiagonal matrix, for x, following the
;;*  factorization of (T - lambda*I) as
;;*
;;*     (T - lambda*I) = P*L*U ,
;;*
;;*  by routine SLAGTF. The choice of equation to be solved is
;;*  controlled by the argument JOB, and in each case there is an option
;;*  to perturb zero or very small diagonal elements of U, this option
;;*  being intended for use in applications such as inverse iteration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) INTEGER
;;*          Specifies the job to be performed by SLAGTS as follows:
;;*          =  1: The equations  (T - lambda*I)x = y  are to be solved,
;;*                but diagonal elements of U are not to be perturbed.
;;*          = -1: The equations  (T - lambda*I)x = y  are to be solved
;;*                and, if overflow would otherwise occur, the diagonal
;;*                elements of U are to be perturbed. See argument TOL
;;*                below.
;;*          =  2: The equations  (T - lambda*I)'x = y  are to be solved,
;;*                but diagonal elements of U are not to be perturbed.
;;*          = -2: The equations  (T - lambda*I)'x = y  are to be solved
;;*                and, if overflow would otherwise occur, the diagonal
;;*                elements of U are to be perturbed. See argument TOL
;;*                below.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T.
;;*
;;*  A       (input) REAL array, dimension (N)
;;*          On entry, A must contain the diagonal elements of U as
;;*          returned from SLAGTF.
;;*
;;*  B       (input) REAL array, dimension (N-1)
;;*          On entry, B must contain the first super-diagonal elements of
;;*          U as returned from SLAGTF.
;;*
;;*  C       (input) REAL array, dimension (N-1)
;;*          On entry, C must contain the sub-diagonal elements of L as
;;*          returned from SLAGTF.
;;*
;;*  D       (input) REAL array, dimension (N-2)
;;*          On entry, D must contain the second super-diagonal elements
;;*          of U as returned from SLAGTF.
;;*
;;*  IN      (input) INTEGER array, dimension (N)
;;*          On entry, IN must contain details of the matrix P as returned
;;*          from SLAGTF.
;;*
;;*  Y       (input/output) REAL array, dimension (N)
;;*          On entry, the right hand side vector y.
;;*          On exit, Y is overwritten by the solution vector x.
;;*
;;*  TOL     (input/output) REAL
;;*          On entry, with  JOB .lt. 0, TOL should be the minimum
;;*          perturbation to be made to very small diagonal elements of U.
;;*          TOL should normally be chosen as about eps*norm(U), where eps
;;*          is the relative machine precision, but if TOL is supplied as
;;*          non-positive, then it is reset to eps*max( abs( u(i,j) ) ).
;;*          If  JOB .gt. 0  then TOL is not referenced.
;;*
;;*          On exit, TOL is changed as described above, only if TOL is
;;*          non-positive on entry. Otherwise TOL is unchanged.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0   : successful exit
;;*          .lt. 0: if INFO = -i, the i-th argument had an illegal value
;;*          .gt. 0: overflow would occur when computing the INFO(th)
;;*                  element of the solution vector x. This can only occur
;;*                  when JOB is supplied as positive and either means
;;*                  that a diagonal element of U is very small, or that
;;*                  the elements of the right-hand side vector y are very
;;*                  large.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slagts (job  n  a  b  c  d  in  y  tol  info  )
	((-idx0- (-int-)) job )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) a )
	((-idx1- (-float-)) b )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) d )
	((-idx1- (-int-)) in )
	((-idx1- (-float-)) y )
	((-idx0- (-float-)) tol )
	((-idx0- (-int-)) info )
	#{ slagts_(IDX_PTR($job,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($d,float), IDX_PTR($in,int), IDX_PTR($y,float), IDX_PTR($tol,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slagv2 <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <csl>  <snl>  <csr>  <snr>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAGV2 computes the Generalized Schur factorization of a real 2-by-2
;;*  matrix pencil (A,B) where B is upper triangular. This routine
;;*  computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
;;*  SNR such that
;;*
;;*  1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
;;*     types), then
;;*
;;*     [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
;;*     [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
;;*
;;*     [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
;;*     [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
;;*
;;*  2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
;;*     then
;;*
;;*     [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
;;*     [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
;;*
;;*     [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
;;*     [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
;;*
;;*     where b11 >= b22 > 0.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input/output) REAL array, dimension (LDA, 2)
;;*          On entry, the 2 x 2 matrix A.
;;*          On exit, A is overwritten by the ``A-part'' of the
;;*          generalized Schur form.
;;*
;;*  LDA     (input) INTEGER
;;*          THe leading dimension of the array A.  LDA >= 2.
;;*
;;*  B       (input/output) REAL array, dimension (LDB, 2)
;;*          On entry, the upper triangular 2 x 2 matrix B.
;;*          On exit, B is overwritten by the ``B-part'' of the
;;*          generalized Schur form.
;;*
;;*  LDB     (input) INTEGER
;;*          THe leading dimension of the array B.  LDB >= 2.
;;*
;;*  ALPHAR  (output) REAL array, dimension (2)
;;*  ALPHAI  (output) REAL array, dimension (2)
;;*  BETA    (output) REAL array, dimension (2)
;;*          (ALPHAR(k)+i*ALPHAI(k))/BETA(k) are the eigenvalues of the
;;*          pencil (A,B), k=1,2, i = sqrt(-1).  Note that BETA(k) may
;;*          be zero.
;;*
;;*  CSL     (output) REAL
;;*          The cosine of the left rotation matrix.
;;*
;;*  SNL     (output) REAL
;;*          The sine of the left rotation matrix.
;;*
;;*  CSR     (output) REAL
;;*          The cosine of the right rotation matrix.
;;*
;;*  SNR     (output) REAL
;;*          The sine of the right rotation matrix.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slagv2 (a  lda  b  ldb  alphar  alphai  beta  csl  snl  csr  snr  )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx0- (-float-)) csl )
	((-idx0- (-float-)) snl )
	((-idx0- (-float-)) csr )
	((-idx0- (-float-)) snr )
	#{ slagv2_(IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($csl,float), IDX_PTR($snl,float), IDX_PTR($csr,float), IDX_PTR($snr,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slahqr <wantt>  <wantz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <wr>  <wi>  <iloz>  <ihiz>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAHQR is an auxiliary routine called by SHSEQR to update the
;;*  eigenvalues and Schur decomposition already computed by SHSEQR, by
;;*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTT   (input) LOGICAL
;;*          = .TRUE. : the full Schur form T is required;
;;*          = .FALSE.: only eigenvalues are required.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          = .TRUE. : the matrix of Schur vectors Z is required;
;;*          = .FALSE.: Schur vectors are not required.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper quasi-triangular in
;;*          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
;;*          ILO = 1). SLAHQR works primarily with the Hessenberg
;;*          submatrix in rows and columns ILO to IHI, but applies
;;*          transformations to all of H if WANTT is .TRUE..
;;*          1 <= ILO <= max(1,IHI); IHI <= N.
;;*
;;*  H       (input/output) REAL array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
;;*          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
;;*          standard form. If WANTT is .FALSE., the contents of H are
;;*          unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          The real and imaginary parts, respectively, of the computed
;;*          eigenvalues ILO to IHI are stored in the corresponding
;;*          elements of WR and WI. If two eigenvalues are computed as a
;;*          complex conjugate pair, they are stored in consecutive
;;*          elements of WR and WI, say the i-th and (i+1)th, with
;;*          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
;;*          eigenvalues are stored in the same order as on the diagonal
;;*          of the Schur form returned in H, with WR(i) = H(i,i), and, if
;;*          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
;;*          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
;;*
;;*  ILOZ    (input) INTEGER
;;*  IHIZ    (input) INTEGER
;;*          Specify the rows of Z to which transformations must be
;;*          applied if WANTZ is .TRUE..
;;*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ,N)
;;*          If WANTZ is .TRUE., on entry Z must contain the current
;;*          matrix Z of transformations accumulated by SHSEQR, and on
;;*          exit Z has been updated; transformations are applied only to
;;*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
;;*          If WANTZ is .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: SLAHQR failed to compute all the eigenvalues ILO to IHI
;;*               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
;;*               elements i+1:ihi of WR and WI contain those eigenvalues
;;*               which have been successfully computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  2-96 Based on modifications by
;;*     David Day, Sandia National Laboratory, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slahqr (wantt  wantz  n  ilo  ihi  h  ldh  wr  wi  iloz  ihiz  z  ldz  info  )
	((-idx0- (-int-)) wantt )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx0- (-int-)) iloz )
	((-idx0- (-int-)) ihiz )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ slahqr_(IDX_PTR($wantt,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,float), IDX_PTR($ldh,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($iloz,int), IDX_PTR($ihiz,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slahrd <n>  <k>  <nb>  <a>  <lda>  <tau>  <t_>  <ldt>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAHRD reduces the first NB columns of a real general n-by-(n-k+1)
;;*  matrix A so that elements below the k-th subdiagonal are zero. The
;;*  reduction is performed by an orthogonal similarity transformation
;;*  Q' * A * Q. The routine returns the matrices V and T which determine
;;*  Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
;;*
;;*  This is an auxiliary routine called by SGEHRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  K       (input) INTEGER
;;*          The offset for the reduction. Elements below the k-th
;;*          subdiagonal in the first NB columns are reduced to zero.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to be reduced.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N-K+1)
;;*          On entry, the n-by-(n-k+1) general matrix A.
;;*          On exit, the elements on and above the k-th subdiagonal in
;;*          the first NB columns are overwritten with the corresponding
;;*          elements of the reduced matrix; the elements below the k-th
;;*          subdiagonal, with the array TAU, represent the matrix Q as a
;;*          product of elementary reflectors. The other columns of A are
;;*          unchanged. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) REAL array, dimension (NB)
;;*          The scalar factors of the elementary reflectors. See Further
;;*          Details.
;;*
;;*  T       (output) REAL array, dimension (LDT,NB)
;;*          The upper triangular matrix T.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T.  LDT >= NB.
;;*
;;*  Y       (output) REAL array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y.
;;*
;;*  LDY     (input) INTEGER
;;*          The leading dimension of the array Y. LDY >= N.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of nb elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
;;*  A(i+k+1:n,i), and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the (n-k+1)-by-nb matrix
;;*  V which is needed, with T and Y, to apply the transformation to the
;;*  unreduced part of the matrix, using an update of the form:
;;*  A := (I - V*T*V') * (A - Y*V').
;;*
;;*  The contents of A on exit are illustrated by the following example
;;*  with n = 7, k = 3 and nb = 2:
;;*
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( h   h   a   a   a )
;;*     ( v1  h   a   a   a )
;;*     ( v1  v2  a   a   a )
;;*     ( v1  v2  a   a   a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slahrd (n  k  nb  a  lda  tau  t_  ldt  y  ldy  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) nb )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) ldy )
	#{ slahrd_(IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($nb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($y,float), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaic1 <job>  <j>  <x>  <sest>  <w>  <gamma>  <sestpr>  <s>  <c>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAIC1 applies one step of incremental condition estimation in
;;*  its simplest version:
;;*
;;*  Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
;;*  lower triangular matrix L, such that
;;*           twonorm(L*x) = sest
;;*  Then SLAIC1 computes sestpr, s, c such that
;;*  the vector
;;*                  [ s*x ]
;;*           xhat = [  c  ]
;;*  is an approximate singular vector of
;;*                  [ L     0  ]
;;*           Lhat = [ w' gamma ]
;;*  in the sense that
;;*           twonorm(Lhat*xhat) = sestpr.
;;*
;;*  Depending on JOB, an estimate for the largest or smallest singular
;;*  value is computed.
;;*
;;*  Note that [s c]' and sestpr**2 is an eigenpair of the system
;;*
;;*      diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
;;*                                            [ gamma ]
;;*
;;*  where  alpha =  x'*w.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) INTEGER
;;*          = 1: an estimate for the largest singular value is computed.
;;*          = 2: an estimate for the smallest singular value is computed.
;;*
;;*  J       (input) INTEGER
;;*          Length of X and W
;;*
;;*  X       (input) REAL array, dimension (J)
;;*          The j-vector x.
;;*
;;*  SEST    (input) REAL
;;*          Estimated singular value of j by j matrix L
;;*
;;*  W       (input) REAL array, dimension (J)
;;*          The j-vector w.
;;*
;;*  GAMMA   (input) REAL
;;*          The diagonal element gamma.
;;*
;;*  SESTPR  (output) REAL
;;*          Estimated singular value of (j+1) by (j+1) matrix Lhat.
;;*
;;*  S       (output) REAL
;;*          Sine needed in forming xhat.
;;*
;;*  C       (output) REAL
;;*          Cosine needed in forming xhat.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaic1 (job  j  x  sest  w  gamma  sestpr  s  c  )
	((-idx0- (-int-)) job )
	((-idx0- (-int-)) j )
	((-idx1- (-float-)) x )
	((-idx0- (-float-)) sest )
	((-idx1- (-float-)) w )
	((-idx0- (-float-)) gamma )
	((-idx0- (-float-)) sestpr )
	((-idx0- (-float-)) s )
	((-idx0- (-float-)) c )
	#{ slaic1_(IDX_PTR($job,int), IDX_PTR($j,int), IDX_PTR($x,float), IDX_PTR($sest,float), IDX_PTR($w,float), IDX_PTR($gamma,float), IDX_PTR($sestpr,float), IDX_PTR($s,float), IDX_PTR($c,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaln2 <ltrans>  <na>  <nw>  <smin>  <ca>  <a>  <lda>  <d1>  <d2>  <b>  <ldb>  <wr>  <wi>  <x>  <ldx>  <scale>  <xnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLALN2 solves a system of the form  (ca A - w D ) X = s B
;;*  or (ca A' - w D) X = s B   with possible scaling ("s") and
;;*  perturbation of A.  (A' means A-transpose.)
;;*
;;*  A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
;;*  real diagonal matrix, w is a real or complex value, and X and B are
;;*  NA x 1 matrices -- real if w is real, complex if w is complex.  NA
;;*  may be 1 or 2.
;;*
;;*  If w is complex, X and B are represented as NA x 2 matrices,
;;*  the first column of each being the real part and the second
;;*  being the imaginary part.
;;*
;;*  "s" is a scaling factor (.LE. 1), computed by SLALN2, which is
;;*  so chosen that X can be computed without overflow.  X is further
;;*  scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
;;*  than overflow.
;;*
;;*  If both singular values of (ca A - w D) are less than SMIN,
;;*  SMIN*identity will be used instead of (ca A - w D).  If only one
;;*  singular value is less than SMIN, one element of (ca A - w D) will be
;;*  perturbed enough to make the smallest singular value roughly SMIN.
;;*  If both singular values are at least SMIN, (ca A - w D) will not be
;;*  perturbed.  In any case, the perturbation will be at most some small
;;*  multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
;;*  are computed by infinity-norm approximations, and thus will only be
;;*  correct to a factor of 2 or so.
;;*
;;*  Note: all input quantities are assumed to be smaller than overflow
;;*  by a reasonable factor.  (See BIGNUM.)
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  LTRANS  (input) LOGICAL
;;*          =.TRUE.:  A-transpose will be used.
;;*          =.FALSE.: A will be used (not transposed.)
;;*
;;*  NA      (input) INTEGER
;;*          The size of the matrix A.  It may (only) be 1 or 2.
;;*
;;*  NW      (input) INTEGER
;;*          1 if "w" is real, 2 if "w" is complex.  It may only be 1
;;*          or 2.
;;*
;;*  SMIN    (input) REAL
;;*          The desired lower bound on the singular values of A.  This
;;*          should be a safe distance away from underflow or overflow,
;;*          say, between (underflow/machine precision) and  (machine
;;*          precision * overflow ).  (See BIGNUM and ULP.)
;;*
;;*  CA      (input) REAL
;;*          The coefficient c, which A is multiplied by.
;;*
;;*  A       (input) REAL array, dimension (LDA,NA)
;;*          The NA x NA matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  It must be at least NA.
;;*
;;*  D1      (input) REAL
;;*          The 1,1 element in the diagonal matrix D.
;;*
;;*  D2      (input) REAL
;;*          The 2,2 element in the diagonal matrix D.  Not used if NW=1.
;;*
;;*  B       (input) REAL array, dimension (LDB,NW)
;;*          The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
;;*          complex), column 1 contains the real part of B and column 2
;;*          contains the imaginary part.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  It must be at least NA.
;;*
;;*  WR      (input) REAL
;;*          The real part of the scalar "w".
;;*
;;*  WI      (input) REAL
;;*          The imaginary part of the scalar "w".  Not used if NW=1.
;;*
;;*  X       (output) REAL array, dimension (LDX,NW)
;;*          The NA x NW matrix X (unknowns), as computed by SLALN2.
;;*          If NW=2 ("w" is complex), on exit, column 1 will contain
;;*          the real part of X and column 2 will contain the imaginary
;;*          part.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of X.  It must be at least NA.
;;*
;;*  SCALE   (output) REAL
;;*          The scale factor that B must be multiplied by to insure
;;*          that overflow does not occur when computing X.  Thus,
;;*          (ca A - w D) X  will be SCALE*B, not B (ignoring
;;*          perturbations of A.)  It will be at most 1.
;;*
;;*  XNORM   (output) REAL
;;*          The infinity-norm of X, when X is regarded as an NA x NW
;;*          real matrix.
;;*
;;*  INFO    (output) INTEGER
;;*          An error flag.  It will be set to zero if no error occurs,
;;*          a negative number if an argument is in error, or a positive
;;*          number if  ca A - w D  had to be perturbed.
;;*          The possible values are:
;;*          = 0: No error occurred, and (ca A - w D) did not have to be
;;*                 perturbed.
;;*          = 1: (ca A - w D) had to be perturbed to make its smallest
;;*               (or only) singular value greater than SMIN.
;;*          NOTE: In the interests of speed, this routine does not
;;*                check the inputs for errors.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaln2 (ltrans  na  nw  smin  ca  a  lda  d1  d2  b  ldb  wr  wi  x  ldx  scale  xnorm  info  )
	((-idx0- (-int-)) ltrans )
	((-idx0- (-int-)) na )
	((-idx0- (-int-)) nw )
	((-idx0- (-float-)) smin )
	((-idx0- (-float-)) ca )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) d1 )
	((-idx0- (-float-)) d2 )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) wr )
	((-idx0- (-float-)) wi )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) xnorm )
	((-idx0- (-int-)) info )
	#{ slaln2_(IDX_PTR($ltrans,int), IDX_PTR($na,int), IDX_PTR($nw,int), IDX_PTR($smin,float), IDX_PTR($ca,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d1,float), IDX_PTR($d2,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($scale,float), IDX_PTR($xnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slals0 <icompq>  <nl>  <nr>  <sqre>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <poles>  <difl>  <difr>  <z>  <k>  <c>  <s>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLALS0 applies back the multiplying factors of either the left or the
;;*  right singular vector matrix of a diagonal matrix appended by a row
;;*  to the right hand side matrix B in solving the least squares problem
;;*  using the divide-and-conquer SVD approach.
;;*
;;*  For the left singular vector matrix, three types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1L) Givens rotations: the number of such rotations is GIVPTR; the
;;*       pairs of columns/rows they were applied to are stored in GIVCOL;
;;*       and the C- and S-values of these rotations are stored in GIVNUM.
;;*
;;*  (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
;;*       row, and for J=2:N, PERM(J)-th row of B is to be moved to the
;;*       J-th row.
;;*
;;*  (3L) The left singular vector matrix of the remaining matrix.
;;*
;;*  For the right singular vector matrix, four types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1R) The right singular vector matrix of the remaining matrix.
;;*
;;*  (2R) If SQRE = 1, one extra Givens rotation to generate the right
;;*       null space.
;;*
;;*  (3R) The inverse transformation of (2L).
;;*
;;*  (4R) The inverse transformation of (1L).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed in
;;*         factored form:
;;*         = 0: Left singular vector matrix.
;;*         = 1: Right singular vector matrix.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block. NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block. NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input/output) REAL array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B. LDB must be at least
;;*         max(1,MAX( M, N ) ).
;;*
;;*  BX     (workspace) REAL array, dimension ( LDBX, NRHS )
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  PERM   (input) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) applied
;;*         to the two blocks.
;;*
;;*  GIVPTR (input) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of rows/columns
;;*         involved in a Givens rotation.
;;*
;;*  LDGCOL (input) INTEGER
;;*         The leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (input) REAL array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value used in the
;;*         corresponding Givens rotation.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of arrays DIFR, POLES and
;;*         GIVNUM, must be at least K.
;;*
;;*  POLES  (input) REAL array, dimension ( LDGNUM, 2 )
;;*         On entry, POLES(1:K, 1) contains the new singular
;;*         values obtained from solving the secular equation, and
;;*         POLES(1:K, 2) is an array containing the poles in the secular
;;*         equation.
;;*
;;*  DIFL   (input) REAL array, dimension ( K ).
;;*         On entry, DIFL(I) is the distance between I-th updated
;;*         (undeflated) singular value and the I-th (undeflated) old
;;*         singular value.
;;*
;;*  DIFR   (input) REAL array, dimension ( LDGNUM, 2 ).
;;*         On entry, DIFR(I, 1) contains the distances between I-th
;;*         updated (undeflated) singular value and the I+1-th
;;*         (undeflated) old singular value. And DIFR(I, 2) is the
;;*         normalizing factor for the I-th right singular vector.
;;*
;;*  Z      (input) REAL array, dimension ( K )
;;*         Contain the components of the deflation-adjusted updating row
;;*         vector.
;;*
;;*  K      (input) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  C      (input) REAL
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (input) REAL
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  WORK   (workspace) REAL array, dimension ( K )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slals0 (icompq  nl  nr  sqre  nrhs  b  ldb  bx  ldbx  perm  givptr  givcol  ldgcol  givnum  ldgnum  poles  difl  difr  z  k  c  s  work  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-float-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx2- (-float-)) poles )
	((-idx1- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) k )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) s )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slals0_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($nrhs,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($bx,float), IDX_PTR($ldbx,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,float), IDX_PTR($ldgnum,int), IDX_PTR($poles,float), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($z,float), IDX_PTR($k,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slalsa <icompq>  <smlsiz>  <n>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <u>  <ldu>  <vt>  <k>  <difl>  <difr>  <z>  <poles>  <givptr>  <givcol>  <ldgcol>  <perm>  <givnum>  <c>  <s>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLALSA is an itermediate step in solving the least squares problem
;;*  by computing the SVD of the coefficient matrix in compact form (The
;;*  singular vectors are computed as products of simple orthorgonal
;;*  matrices.).
;;*
;;*  If ICOMPQ = 0, SLALSA applies the inverse of the left singular vector
;;*  matrix of an upper bidiagonal matrix to the right hand side; and if
;;*  ICOMPQ = 1, SLALSA applies the right singular vector matrix to the
;;*  right hand side. The singular vector matrices were generated in
;;*  compact form by SLALSA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether the left or the right singular vector
;;*         matrix is involved.
;;*         = 0: Left singular vector matrix
;;*         = 1: Right singular vector matrix
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The row and column dimensions of the upper bidiagonal matrix.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input) REAL array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,MAX( M, N ) ).
;;*
;;*  BX     (output) REAL array, dimension ( LDBX, NRHS )
;;*         On exit, the result of applying the left or right singular
;;*         vector matrix to B.
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  U      (input) REAL array, dimension ( LDU, SMLSIZ ).
;;*         On entry, U contains the left singular vector matrices of all
;;*         subproblems at the bottom level.
;;*
;;*  LDU    (input) INTEGER, LDU = > N.
;;*         The leading dimension of arrays U, VT, DIFL, DIFR,
;;*         POLES, GIVNUM, and Z.
;;*
;;*  VT     (input) REAL array, dimension ( LDU, SMLSIZ+1 ).
;;*         On entry, VT' contains the right singular vector matrices of
;;*         all subproblems at the bottom level.
;;*
;;*  K      (input) INTEGER array, dimension ( N ).
;;*
;;*  DIFL   (input) REAL array, dimension ( LDU, NLVL ).
;;*         where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.
;;*
;;*  DIFR   (input) REAL array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
;;*         distances between singular values on the I-th level and
;;*         singular values on the (I -1)-th level, and DIFR(*, 2 * I)
;;*         record the normalizing factors of the right singular vectors
;;*         matrices of subproblems on I-th level.
;;*
;;*  Z      (input) REAL array, dimension ( LDU, NLVL ).
;;*         On entry, Z(1, I) contains the components of the deflation-
;;*         adjusted updating row vector for subproblems on the I-th
;;*         level.
;;*
;;*  POLES  (input) REAL array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
;;*         singular values involved in the secular equations on the I-th
;;*         level.
;;*
;;*  GIVPTR (input) INTEGER array, dimension ( N ).
;;*         On entry, GIVPTR( I ) records the number of Givens
;;*         rotations performed on the I-th problem on the computation
;;*         tree.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
;;*         On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
;;*         locations of Givens rotations performed on the I-th level on
;;*         the computation tree.
;;*
;;*  LDGCOL (input) INTEGER, LDGCOL = > N.
;;*         The leading dimension of arrays GIVCOL and PERM.
;;*
;;*  PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
;;*         On entry, PERM(*, I) records permutations done on the I-th
;;*         level of the computation tree.
;;*
;;*  GIVNUM (input) REAL array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
;;*         values of Givens rotations performed on the I-th level on the
;;*         computation tree.
;;*
;;*  C      (input) REAL array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         C( I ) contains the C-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  S      (input) REAL array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         S( I ) contains the S-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  WORK   (workspace) REAL array.
;;*         The dimension must be at least N.
;;*
;;*  IWORK  (workspace) INTEGER array.
;;*         The dimension must be at least 3 * N
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slalsa (icompq  smlsiz  n  nrhs  b  ldb  bx  ldbx  u  ldu  vt  k  difl  difr  z  poles  givptr  givcol  ldgcol  perm  givnum  c  s  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx1- (-int-)) k )
	((-idx2- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx2- (-float-)) z )
	((-idx2- (-float-)) poles )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-int-)) perm )
	((-idx2- (-float-)) givnum )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slalsa_(IDX_PTR($icompq,int), IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($bx,float), IDX_PTR($ldbx,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($k,int), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($z,float), IDX_PTR($poles,float), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($perm,int), IDX_PTR($givnum,float), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slalsd <uplo>  <smlsiz>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <rcond>  <rank>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLALSD uses the singular value decomposition of A to solve the least
;;*  squares problem of finding X to minimize the Euclidean norm of each
;;*  column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
;;*  are N-by-NRHS. The solution X overwrites B.
;;*
;;*  The singular values of A smaller than RCOND times the largest
;;*  singular value are treated as zero in solving the least squares
;;*  problem; in this case a minimum norm solution is returned.
;;*  The actual singular values are returned in D in ascending order.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO   (input) CHARACTER*1
;;*         = 'U': D and E define an upper bidiagonal matrix.
;;*         = 'L': D and E define a  lower bidiagonal matrix.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the  bidiagonal matrix.  N >= 0.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B. NRHS must be at least 1.
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix. On exit, if INFO = 0, D contains its singular values.
;;*
;;*  E      (input) REAL array, dimension (N-1)
;;*         Contains the super-diagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  B      (input/output) REAL array, dimension (LDB,NRHS)
;;*         On input, B contains the right hand sides of the least
;;*         squares problem. On output, B contains the solution X.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,N).
;;*
;;*  RCOND  (input) REAL
;;*         The singular values of A less than or equal to RCOND times
;;*         the largest singular value are treated as zero in solving
;;*         the least squares problem. If RCOND is negative,
;;*         machine precision is used instead.
;;*         For example, if diag(S)*X=B were the least squares problem,
;;*         where diag(S) is a diagonal matrix of singular values, the
;;*         solution would be X(i) = B(i) / S(i) if S(i) is greater than
;;*         RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
;;*         RCOND*max(S).
;;*
;;*  RANK   (output) INTEGER
;;*         The number of singular values of A greater than RCOND times
;;*         the largest singular value.
;;*
;;*  WORK   (workspace) REAL array, dimension at least
;;*         (9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2),
;;*         where NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1).
;;*
;;*  IWORK  (workspace) INTEGER array, dimension at least
;;*         (3*N*NLVL + 11*N)
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*         > 0:  The algorithm failed to compute an singular value while
;;*               working on the submatrix lying in rows and columns
;;*               INFO/(N+1) through MOD(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slalsd (uplo  smlsiz  n  nrhs  d  e  b  ldb  rcond  rank  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slalsd_($uplo->data, IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($rcond,float), IDX_PTR($rank,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slamch <cmach>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAMCH determines single precision machine parameters.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  CMACH   (input) CHARACTER*1
;;*          Specifies the value to be returned by SLAMCH:
;;*          = 'E' or 'e',   SLAMCH := eps
;;*          = 'S' or 's ,   SLAMCH := sfmin
;;*          = 'B' or 'b',   SLAMCH := base
;;*          = 'P' or 'p',   SLAMCH := eps*base
;;*          = 'N' or 'n',   SLAMCH := t
;;*          = 'R' or 'r',   SLAMCH := rnd
;;*          = 'M' or 'm',   SLAMCH := emin
;;*          = 'U' or 'u',   SLAMCH := rmin
;;*          = 'L' or 'l',   SLAMCH := emax
;;*          = 'O' or 'o',   SLAMCH := rmax
;;*
;;*          where
;;*
;;*          eps   = relative machine precision
;;*          sfmin = safe minimum, such that 1/sfmin does not overflow
;;*          base  = base of the machine
;;*          prec  = eps*base
;;*          t     = number of (base) digits in the mantissa
;;*          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
;;*          emin  = minimum exponent before (gradual) underflow
;;*          rmin  = underflow threshold - base**(emin-1)
;;*          emax  = largest exponent before overflow
;;*          rmax  = overflow threshold  - (base**emax)*(1-eps)
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slamch (cmach  )
	((-str-) cmach )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slamch_($cmach->data) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slamrg <n1>  <n2>  <a>  <strd1>  <strd2>  <index>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAMRG will create a permutation list which will merge the elements
;;*  of A (which is composed of two independently sorted sets) into a
;;*  single set which is sorted in ascending order.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N1     (input) INTEGER
;;*  N2     (input) INTEGER
;;*         These arguements contain the respective lengths of the two
;;*         sorted lists to be merged.
;;*
;;*  A      (input) REAL array, dimension (N1+N2)
;;*         The first N1 elements of A contain a list of numbers which
;;*         are sorted in either ascending or descending order.  Likewise
;;*         for the final N2 elements.
;;*
;;*  STRD1  (input) INTEGER
;;*  STRD2  (input) INTEGER
;;*         These are the strides to be taken through the array A.
;;*         Allowable strides are 1 and -1.  They indicate whether a
;;*         subset of A is sorted in ascending (STRDx = 1) or descending
;;*         (STRDx = -1) order.
;;*
;;*  INDEX  (output) INTEGER array, dimension (N1+N2)
;;*         On exit this array will contain a permutation such that
;;*         if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
;;*         sorted in ascending order.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slamrg (n1  n2  a  strd1  strd2  index  )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx1- (-float-)) a )
	((-idx0- (-int-)) strd1 )
	((-idx0- (-int-)) strd2 )
	((-idx1- (-int-)) index )
	#{ slamrg_(IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($a,float), IDX_PTR($strd1,int), IDX_PTR($strd2,int), IDX_PTR($index,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slangb <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANGB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANGB returns the value
;;*
;;*     SLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANGB as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANGB is
;;*          set to zero.
;;*
;;*  KL      (input) INTEGER
;;*          The number of sub-diagonals of the matrix A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of super-diagonals of the matrix A.  KU >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slangb (norm  n  kl  ku  ab  ldab  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slangb_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slange <norm>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANGE  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANGE returns the value
;;*
;;*     SLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANGE as described
;;*          above.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.  When M = 0,
;;*          SLANGE is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.  When N = 0,
;;*          SLANGE is set to zero.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The m by n matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slange (norm  m  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slange_($norm->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slangt <norm>  <n>  <dl>  <d>  <du>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANGT  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANGT returns the value
;;*
;;*     SLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANGT as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANGT is
;;*          set to zero.
;;*
;;*  DL      (input) REAL array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of A.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) REAL array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slangt (norm  n  dl  d  du  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) dl )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) du )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slangt_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,float), IDX_PTR($d,float), IDX_PTR($du,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slanhs <norm>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANHS  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  Hessenberg matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANHS returns the value
;;*
;;*     SLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANHS as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANHS is
;;*          set to zero.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The n by n upper Hessenberg matrix A; the part of A below the
;;*          first sub-diagonal is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slanhs (norm  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slanhs_($norm->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slansb <norm>  <uplo>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANSB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n symmetric band matrix A,  with k super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANSB returns the value
;;*
;;*     SLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANSB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          band matrix A is supplied.
;;*          = 'U':  Upper triangular part is supplied
;;*          = 'L':  Lower triangular part is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANSB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals or sub-diagonals of the
;;*          band matrix A.  K >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first K+1 rows of AB.  The j-th column of A is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slansb (norm  uplo  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slansb_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slansp <norm>  <uplo>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANSP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real symmetric matrix A,  supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANSP returns the value
;;*
;;*     SLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANSP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is supplied.
;;*          = 'U':  Upper triangular part of A is supplied
;;*          = 'L':  Lower triangular part of A is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANSP is
;;*          set to zero.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slansp (norm  uplo  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slansp_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slanst <norm>  <n>  <d>  <e>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANST  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real symmetric tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANST returns the value
;;*
;;*     SLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANST as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANST is
;;*          set to zero.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) sub-diagonal or super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slanst (norm  n  d  e  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slanst_($norm->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slansy <norm>  <uplo>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANSY  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real symmetric matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANSY returns the value
;;*
;;*     SLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANSY as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is to be referenced.
;;*          = 'U':  Upper triangular part of A is referenced
;;*          = 'L':  Lower triangular part of A is referenced
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANSY is
;;*          set to zero.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slansy (norm  uplo  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slansy_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slantb <norm>  <uplo>  <diag>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANTB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n triangular band matrix A,  with ( k + 1 ) diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANTB returns the value
;;*
;;*     SLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANTB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANTB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals of the matrix A if UPLO = 'L'.
;;*          K >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first k+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*          Note that when DIAG = 'U', the elements of the array AB
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slantb (norm  uplo  diag  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slantb_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slantp <norm>  <uplo>  <diag>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANTP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  triangular matrix A, supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANTP returns the value
;;*
;;*     SLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANTP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, SLANTP is
;;*          set to zero.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          Note that when DIAG = 'U', the elements of the array AP
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slantp (norm  uplo  diag  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slantp_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slantr <norm>  <uplo>  <diag>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANTR  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  trapezoidal or triangular matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  SLANTR returns the value
;;*
;;*     SLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in SLANTR as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower trapezoidal.
;;*          = 'U':  Upper trapezoidal
;;*          = 'L':  Lower trapezoidal
;;*          Note that A is triangular instead of trapezoidal if M = N.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A has unit diagonal.
;;*          = 'N':  Non-unit diagonal
;;*          = 'U':  Unit diagonal
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0, and if
;;*          UPLO = 'U', M <= N.  When M = 0, SLANTR is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0, and if
;;*          UPLO = 'L', N <= M.  When N = 0, SLANTR is set to zero.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The trapezoidal matrix A (A is triangular if M = N).
;;*          If UPLO = 'U', the leading m by n upper trapezoidal part of
;;*          the array A contains the upper trapezoidal matrix, and the
;;*          strictly lower triangular part of A is not referenced.
;;*          If UPLO = 'L', the leading m by n lower trapezoidal part of
;;*          the array A contains the lower trapezoidal matrix, and the
;;*          strictly upper triangular part of A is not referenced.  Note
;;*          that when DIAG = 'U', the diagonal elements of A are not
;;*          referenced and are assumed to be one.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slantr (norm  uplo  diag  m  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) work )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slantr_($norm->data, $uplo->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($work,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slanv2 <a>  <b>  <c>  <d>  <rt1r>  <rt1i>  <rt2r>  <rt2i>  <cs>  <sn>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
;;*  matrix in standard form:
;;*
;;*       [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
;;*       [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
;;*
;;*  where either
;;*  1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
;;*  2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
;;*  conjugate eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input/output) REAL            
;;*  B       (input/output) REAL            
;;*  C       (input/output) REAL            
;;*  D       (input/output) REAL            
;;*          On entry, the elements of the input matrix.
;;*          On exit, they are overwritten by the elements of the
;;*          standardised Schur form.
;;*
;;*  RT1R    (output) REAL 
;;*  RT1I    (output) REAL            
;;*  RT2R    (output) REAL            
;;*  RT2I    (output) REAL            
;;*          The real and imaginary parts of the eigenvalues. If the
;;*          eigenvalues are a complex conjugate pair, RT1I > 0.
;;*
;;*  CS      (output) REAL            
;;*  SN      (output) REAL            
;;*          Parameters of the rotation matrix.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by V. Sima, Research Institute for Informatics, Bucharest,
;;*  Romania, to reduce the risk of cancellation errors,
;;*  when computing real eigenvalues, and to ensure, if possible, that
;;*  abs(RT1R) >= abs(RT2R).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slanv2 (a  b  c  d  rt1r  rt1i  rt2r  rt2i  cs  sn  )
	((-idx0- (-float-)) a )
	((-idx0- (-float-)) b )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) d )
	((-idx0- (-float-)) rt1r )
	((-idx0- (-float-)) rt1i )
	((-idx0- (-float-)) rt2r )
	((-idx0- (-float-)) rt2i )
	((-idx0- (-float-)) cs )
	((-idx0- (-float-)) sn )
	#{ slanv2_(IDX_PTR($a,float), IDX_PTR($b,float), IDX_PTR($c,float), IDX_PTR($d,float), IDX_PTR($rt1r,float), IDX_PTR($rt1i,float), IDX_PTR($rt2r,float), IDX_PTR($rt2i,float), IDX_PTR($cs,float), IDX_PTR($sn,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slapll <n>  <x>  <incx>  <y>  <incy>  <ssmin>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given two column vectors X and Y, let
;;*
;;*                       A = ( X Y ).
;;*
;;*  The subroutine first computes the QR factorization of A = Q*R,
;;*  and then computes the SVD of the 2-by-2 upper triangular matrix R.
;;*  The smaller singular value of R is returned in SSMIN, which is used
;;*  as the measurement of the linear dependency of the vectors X and Y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The length of the vectors X and Y.
;;*
;;*  X       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCX)
;;*          On entry, X contains the N-vector X.
;;*          On exit, X is overwritten.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive elements of X. INCX > 0.
;;*
;;*  Y       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCY)
;;*          On entry, Y contains the N-vector Y.
;;*          On exit, Y is overwritten.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive elements of Y. INCY > 0.
;;*
;;*  SSMIN   (output) REAL
;;*          The smallest singular value of the N-by-2 matrix A = ( X Y ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slapll (n  x  incx  y  incy  ssmin  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx0- (-float-)) ssmin )
	#{ slapll_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($ssmin,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slapmt <forwrd>  <m>  <n>  <x>  <ldx>  <k>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAPMT rearranges the columns of the M by N matrix X as specified
;;*  by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
;;*  If FORWRD = .TRUE.,  forward permutation:
;;*
;;*       X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
;;*
;;*  If FORWRD = .FALSE., backward permutation:
;;*
;;*       X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FORWRD  (input) LOGICAL
;;*          = .TRUE., forward permutation
;;*          = .FALSE., backward permutation
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix X. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix X. N >= 0.
;;*
;;*  X       (input/output) REAL array, dimension (LDX,N)
;;*          On entry, the M by N matrix X.
;;*          On exit, X contains the permuted matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X, LDX >= MAX(1,M).
;;*
;;*  K       (input) INTEGER array, dimension (N)
;;*          On entry, K contains the permutation vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slapmt (forwrd  m  n  x  ldx  k  )
	((-idx0- (-int-)) forwrd )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-int-)) k )
	#{ slapmt_(IDX_PTR($forwrd,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($k,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slapy2 <x>  <y>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
;;*  overflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  X       (input) REAL
;;*  Y       (input) REAL
;;*          X and Y specify the values x and y.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slapy2 (x  y  )
	((-idx0- (-float-)) x )
	((-idx0- (-float-)) y )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slapy2_(IDX_PTR($x,float), IDX_PTR($y,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slapy3 <x>  <y>  <z>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
;;*  unnecessary overflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  X       (input) REAL
;;*  Y       (input) REAL
;;*  Z       (input) REAL
;;*          X, Y and Z specify the values x, y and z.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slapy3 (x  y  z  )
	((-idx0- (-float-)) x )
	((-idx0- (-float-)) y )
	((-idx0- (-float-)) z )
	(let ((rval 0))
	((-float-) rval)
	#{ $rval=slapy3_(IDX_PTR($x,float), IDX_PTR($y,float), IDX_PTR($z,float)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqgb <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQGB equilibrates a general M by N band matrix A with KL
;;*  subdiagonals and KU superdiagonals using the row and scaling factors
;;*  in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, the equilibrated matrix, in the same storage format
;;*          as A.  See EQUED for the form of the equilibrated matrix.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDA >= KL+KU+1.
;;*
;;*  R       (output) REAL array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (output) REAL array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (output) REAL
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (output) REAL
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqgb (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ slaqgb_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqge <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQGE equilibrates a general M by N matrix A using the row and
;;*  scaling factors in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M by N matrix A.
;;*          On exit, the equilibrated matrix.  See EQUED for the form of
;;*          the equilibrated matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  R       (input) REAL array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (input) REAL array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (input) REAL
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (input) REAL
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqge (m  n  a  lda  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) r )
	((-idx1- (-float-)) c )
	((-idx0- (-float-)) rowcnd )
	((-idx0- (-float-)) colcnd )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ slaqge_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($r,float), IDX_PTR($c,float), IDX_PTR($rowcnd,float), IDX_PTR($colcnd,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqp2 <m>  <n>  <offset>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQP2 computes a QR factorization with column pivoting of
;;*  the block A(OFFSET+1:M,1:N).
;;*  The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of the matrix A that must be pivoted
;;*          but no factorized. OFFSET >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of block A(OFFSET+1:M,1:N) is 
;;*          the triangular factor obtained; the elements in block 
;;*          A(OFFSET+1:M,1:N) below the diagonal, together with the 
;;*          array TAU, represent the orthogonal matrix Q as a product of
;;*          elementary reflectors. Block A(1:OFFSET,1:N) has been 
;;*          accordingly pivoted, but no factorized.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) REAL array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) REAL array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) REAL array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqp2 (m  n  offset  a  lda  jpvt  tau  vn1  vn2  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) vn1 )
	((-idx1- (-float-)) vn2 )
	((-idx1- (-float-)) work )
	#{ slaqp2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($vn1,float), IDX_PTR($vn2,float), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqps <m>  <n>  <offset>  <nb>  <kb>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <auxv>  <f>  <ldf>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQPS computes a step of QR factorization with column pivoting
;;*  of a real M-by-N matrix A by using Blas-3.  It tries to factorize
;;*  NB columns from A starting from the row OFFSET+1, and updates all
;;*  of the matrix with Blas-3 xGEMM.
;;*
;;*  In some cases, due to catastrophic cancellations, it cannot
;;*  factorize NB columns.  Hence, the actual number of factorized
;;*  columns is returned in KB.
;;*
;;*  Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of A that have been factorized in
;;*          previous steps.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to factorize.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns actually factorized.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, block A(OFFSET+1:M,1:KB) is the triangular
;;*          factor obtained and block A(1:OFFSET,1:N) has been
;;*          accordingly pivoted, but no factorized.
;;*          The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
;;*          been updated.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          JPVT(I) = K <==> Column K of the full matrix A has been
;;*          permuted into position I in AP.
;;*
;;*  TAU     (output) REAL array, dimension (KB)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) REAL array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) REAL array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  AUXV    (input/output) REAL array, dimension (NB)
;;*          Auxiliar vector.
;;*
;;*  F       (input/output) REAL array, dimension (LDF,NB)
;;*          Matrix F' = L*Y'*A.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqps (m  n  offset  nb  kb  a  lda  jpvt  tau  vn1  vn2  auxv  f  ldf  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) vn1 )
	((-idx1- (-float-)) vn2 )
	((-idx1- (-float-)) auxv )
	((-idx2- (-float-)) f )
	((-idx0- (-int-)) ldf )
	#{ slaqps_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,float), IDX_PTR($vn1,float), IDX_PTR($vn2,float), IDX_PTR($auxv,float), IDX_PTR($f,float), IDX_PTR($ldf,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqsb <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQSB equilibrates a symmetric band matrix A using the scaling
;;*  factors in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqsb (uplo  n  kd  ab  ldab  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ slaqsb_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqsp <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQSP equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
;;*          the same storage format as A.
;;*
;;*  S       (input) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqsp (uplo  n  ap  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ slaqsp_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqsy <uplo>  <n>  <a>  <lda>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQSY equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if EQUED = 'Y', the equilibrated matrix:
;;*          diag(S) * A * diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  S       (input) REAL array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) REAL
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) REAL
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqsy (uplo  n  a  lda  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-str-) equed )
	#{ slaqsy_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaqtr <ltran>  <lreal>  <n>  <t_>  <ldt>  <b>  <w>  <scale>  <x>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAQTR solves the real quasi-triangular system
;;*
;;*               op(T)*p = scale*c,               if LREAL = .TRUE.
;;*
;;*  or the complex quasi-triangular systems
;;*
;;*             op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
;;*
;;*  in real arithmetic, where T is upper quasi-triangular.
;;*  If LREAL = .FALSE., then the first diagonal block of T must be
;;*  1 by 1, B is the specially structured matrix
;;*
;;*                 B = [ b(1) b(2) ... b(n) ]
;;*                     [       w            ]
;;*                     [           w        ]
;;*                     [              .     ]
;;*                     [                 w  ]
;;*
;;*  op(A) = A or A', A' denotes the conjugate transpose of
;;*  matrix A.
;;*
;;*  On input, X = [ c ].  On output, X = [ p ].
;;*                [ d ]                  [ q ]
;;*
;;*  This subroutine is designed for the condition number estimation
;;*  in routine STRSNA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  LTRAN   (input) LOGICAL
;;*          On entry, LTRAN specifies the option of conjugate transpose:
;;*             = .FALSE.,    op(T+i*B) = T+i*B,
;;*             = .TRUE.,     op(T+i*B) = (T+i*B)'.
;;*
;;*  LREAL   (input) LOGICAL
;;*          On entry, LREAL specifies the input matrix structure:
;;*             = .FALSE.,    the input is complex
;;*             = .TRUE.,     the input is real
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the order of T+i*B. N >= 0.
;;*
;;*  T       (input) REAL array, dimension (LDT,N)
;;*          On entry, T contains a matrix in Schur canonical form.
;;*          If LREAL = .FALSE., then the first diagonal block of T must
;;*          be 1 by 1.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the matrix T. LDT >= max(1,N).
;;*
;;*  B       (input) REAL array, dimension (N)
;;*          On entry, B contains the elements to form the matrix
;;*          B as described above.
;;*          If LREAL = .TRUE., B is not referenced.
;;*
;;*  W       (input) REAL
;;*          On entry, W is the diagonal element of the matrix B.
;;*          If LREAL = .TRUE., W is not referenced.
;;*
;;*  SCALE   (output) REAL
;;*          On exit, SCALE is the scale factor.
;;*
;;*  X       (input/output) REAL array, dimension (2*N)
;;*          On entry, X contains the right hand side of the system.
;;*          On exit, X is overwritten by the solution.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, INFO is set to
;;*             0: successful exit.
;;*               1: the some diagonal 1 by 1 block has been perturbed by
;;*                  a small number SMIN to keep nonsingularity.
;;*               2: the some diagonal 2 by 2 block has been perturbed by
;;*                  a small number in SLALN2 to keep nonsingularity.
;;*          NOTE: In the interests of speed, this routine does not
;;*                check the inputs for errors.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaqtr (ltran  lreal  n  t_  ldt  b  w  scale  x  work  info  )
	((-idx0- (-int-)) ltran )
	((-idx0- (-int-)) lreal )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx1- (-float-)) b )
	((-idx0- (-float-)) w )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) x )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slaqtr_(IDX_PTR($ltran,int), IDX_PTR($lreal,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($b,float), IDX_PTR($w,float), IDX_PTR($scale,float), IDX_PTR($x,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slar1v <n>  <b1>  <bn>  <sigma>  <d>  <l>  <ld>  <lld>  <gersch>  <z>  <ztz>  <mingma>  <r>  <isuppz>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAR1V computes the (scaled) r-th column of the inverse of
;;*  the sumbmatrix in rows B1 through BN of the tridiagonal matrix
;;*  L D L^T - sigma I. The following steps accomplish this computation :
;;*  (a) Stationary qd transform,  L D L^T - sigma I = L(+) D(+) L(+)^T,
;;*  (b) Progressive qd transform, L D L^T - sigma I = U(-) D(-) U(-)^T,
;;*  (c) Computation of the diagonal elements of the inverse of
;;*      L D L^T - sigma I by combining the above transforms, and choosing
;;*      r as the index where the diagonal of the inverse is (one of the)
;;*      largest in magnitude.
;;*  (d) Computation of the (scaled) r-th column of the inverse using the
;;*      twisted factorization obtained by combining the top part of the
;;*      the stationary and the bottom part of the progressive transform.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N        (input) INTEGER
;;*           The order of the matrix L D L^T.
;;*
;;*  B1       (input) INTEGER
;;*           First index of the submatrix of L D L^T.
;;*
;;*  BN       (input) INTEGER
;;*           Last index of the submatrix of L D L^T.
;;*
;;*  SIGMA    (input) REAL
;;*           The shift. Initially, when R = 0, SIGMA should be a good
;;*           approximation to an eigenvalue of L D L^T.
;;*
;;*  L        (input) REAL array, dimension (N-1)
;;*           The (n-1) subdiagonal elements of the unit bidiagonal matrix
;;*           L, in elements 1 to N-1.
;;*
;;*  D        (input) REAL array, dimension (N)
;;*           The n diagonal elements of the diagonal matrix D.
;;*
;;*  LD       (input) REAL array, dimension (N-1)
;;*           The n-1 elements L(i)*D(i).
;;*
;;*  LLD      (input) REAL array, dimension (N-1)
;;*           The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  GERSCH   (input) REAL array, dimension (2*N)
;;*           The n Gerschgorin intervals. These are used to restrict
;;*           the initial search for R, when R is input as 0.
;;*
;;*  Z        (output) REAL array, dimension (N)
;;*           The (scaled) r-th column of the inverse. Z(R) is returned
;;*           to be 1.
;;*
;;*  ZTZ      (output) REAL
;;*           The square of the norm of Z.
;;*
;;*  MINGMA   (output) REAL
;;*           The reciprocal of the largest (in magnitude) diagonal
;;*           element of the inverse of L D L^T - sigma I.
;;*
;;*  R        (input/output) INTEGER
;;*           Initially, R should be input to be 0 and is then output as
;;*           the index where the diagonal element of the inverse is
;;*           largest in magnitude. In later iterations, this same value
;;*           of R should be input.
;;*
;;*  ISUPPZ   (output) INTEGER array, dimension (2)
;;*           The support of the vector in Z, i.e., the vector Z is
;;*           nonzero only in elements ISUPPZ(1) through ISUPPZ( 2 ).
;;*
;;*  WORK     (workspace) REAL array, dimension (4*N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slar1v (n  b1  bn  sigma  d  l  ld  lld  gersch  z  ztz  mingma  r  isuppz  work  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) b1 )
	((-idx0- (-int-)) bn )
	((-idx0- (-float-)) sigma )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) l )
	((-idx1- (-float-)) ld )
	((-idx1- (-float-)) lld )
	((-idx1- (-float-)) gersch )
	((-idx1- (-float-)) z )
	((-idx0- (-float-)) ztz )
	((-idx0- (-float-)) mingma )
	((-idx0- (-int-)) r )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	#{ slar1v_(IDX_PTR($n,int), IDX_PTR($b1,int), IDX_PTR($bn,int), IDX_PTR($sigma,float), IDX_PTR($d,float), IDX_PTR($l,float), IDX_PTR($ld,float), IDX_PTR($lld,float), IDX_PTR($gersch,float), IDX_PTR($z,float), IDX_PTR($ztz,float), IDX_PTR($mingma,float), IDX_PTR($r,int), IDX_PTR($isuppz,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slar2v <n>  <x>  <y>  <z>  <incx>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAR2V applies a vector of real plane rotations from both sides to
;;*  a sequence of 2-by-2 real symmetric matrices, defined by the elements
;;*  of the vectors x, y and z. For i = 1,2,...,n
;;*
;;*     ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
;;*     ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector x.
;;*
;;*  Y       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector y.
;;*
;;*  Z       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector z.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X, Y and Z. INCX > 0.
;;*
;;*  C       (input) REAL array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) REAL array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slar2v (n  x  y  z  incx  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	((-idx1- (-float-)) y )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx0- (-int-)) incc )
	#{ slar2v_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($y,float), IDX_PTR($z,float), IDX_PTR($incx,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarfb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARFB applies a real block reflector H or its transpose H' to a
;;*  real m by n matrix C, from either the left or the right.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'T': apply H' (Transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  V       (input) REAL array, dimension
;;*                                (LDV,K) if STOREV = 'C'
;;*                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
;;*                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
;;*          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
;;*          if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) REAL array, dimension (LDT,K)
;;*          The triangular k by k matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDA >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarfb (side  trans  direct  storev  m  n  k  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) ldwork )
	#{ slarfb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarfg <n>  <alpha>  <x>  <incx>  <tau>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARFG generates a real elementary reflector H of order n, such
;;*  that
;;*
;;*        H * ( alpha ) = ( beta ),   H' * H = I.
;;*            (   x   )   (   0  )
;;*
;;*  where alpha and beta are scalars, and x is an (n-1)-element real
;;*  vector. H is represented in the form
;;*
;;*        H = I - tau * ( 1 ) * ( 1 v' ) ,
;;*                      ( v )
;;*
;;*  where tau is a real scalar and v is a real (n-1)-element
;;*  vector.
;;*
;;*  If the elements of x are all zero, then tau = 0 and H is taken to be
;;*  the unit matrix.
;;*
;;*  Otherwise  1 <= tau <= 2.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the elementary reflector.
;;*
;;*  ALPHA   (input/output) REAL
;;*          On entry, the value alpha.
;;*          On exit, it is overwritten with the value beta.
;;*
;;*  X       (input/output) REAL array, dimension
;;*                         (1+(N-2)*abs(INCX))
;;*          On entry, the vector x.
;;*          On exit, it is overwritten with the vector v.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  TAU     (output) REAL
;;*          The value tau.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarfg (n  alpha  x  incx  tau  )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) alpha )
	((-idx1- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-float-)) tau )
	#{ slarfg_(IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($tau,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarf <side>  <m>  <n>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARF applies a real elementary reflector H to a real m by n matrix
;;*  C, from either the left or the right. H is represented in the form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a real scalar and v is a real vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) REAL array, dimension
;;*                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of H. V is not used if
;;*          TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) REAL
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarf (side  m  n  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) v )
	((-idx0- (-int-)) incv )
	((-idx0- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	#{ slarf_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($incv,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarft <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARFT forms the triangular factor T of a real block reflector H
;;*  of order n, which is defined as a product of k elementary reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) REAL array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) REAL array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
;;*                   ( v1  1    )                     (     1 v2 v2 v2 )
;;*                   ( v1 v2  1 )                     (        1 v3 v3 )
;;*                   ( v1 v2 v3 )
;;*                   ( v1 v2 v3 )
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
;;*                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
;;*                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
;;*                   (     1 v3 )
;;*                   (        1 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarft (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ slarft_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($tau,float), IDX_PTR($t_,float), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarfx <side>  <m>  <n>  <v>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARFX applies a real elementary reflector H to a real m by n
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a real scalar and v is a real vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix
;;*
;;*  This version uses inline code if H has order < 11.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) REAL array, dimension (M) if SIDE = 'L'
;;*                                     or (N) if SIDE = 'R'
;;*          The vector v in the representation of H.
;;*
;;*  TAU     (input) REAL
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDA >= (1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                      (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*          WORK is not referenced if H has order < 11.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarfx (side  m  n  v  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) v )
	((-idx0- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	#{ slarfx_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slargv <n>  <x>  <incx>  <y>  <incy>  <c>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARGV generates a vector of real plane rotations, determined by
;;*  elements of the real vectors x and y. For i = 1,2,...,n
;;*
;;*     (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
;;*     ( -s(i)  c(i) ) ( y(i) ) = (   0  )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be generated.
;;*
;;*  X       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCX)
;;*          On entry, the vector x.
;;*          On exit, x(i) is overwritten by a(i), for i = 1,...,n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCY)
;;*          On entry, the vector y.
;;*          On exit, the sines of the plane rotations.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (output) REAL array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slargv (n  x  incx  y  incy  c  incc  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-float-)) c )
	((-idx0- (-int-)) incc )
	#{ slargv_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarnv <idist>  <iseed>  <n>  <x>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARNV returns a vector of n random real numbers from a uniform or
;;*  normal distribution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IDIST   (input) INTEGER
;;*          Specifies the distribution of the random numbers:
;;*          = 1:  uniform (0,1)
;;*          = 2:  uniform (-1,1)
;;*          = 3:  normal (0,1)
;;*
;;*  ISEED   (input/output) INTEGER array, dimension (4)
;;*          On entry, the seed of the random number generator; the array
;;*          elements must be between 0 and 4095, and ISEED(4) must be
;;*          odd.
;;*          On exit, the seed is updated.
;;*
;;*  N       (input) INTEGER
;;*          The number of random numbers to be generated.
;;*
;;*  X       (output) REAL array, dimension (N)
;;*          The generated random numbers.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine calls the auxiliary routine SLARUV to generate random
;;*  real numbers from a uniform (0,1) distribution, in batches of up to
;;*  128 using vectorisable code. The Box-Muller method is used to
;;*  transform numbers from a uniform to a normal distribution.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarnv (idist  iseed  n  x  )
	((-idx0- (-int-)) idist )
	((-idx1- (-int-)) iseed )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	#{ slarnv_(IDX_PTR($idist,int), IDX_PTR($iseed,int), IDX_PTR($n,int), IDX_PTR($x,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarrb <n>  <d>  <l>  <ld>  <lld>  <ifirst>  <ilast>  <sigma>  <reltol>  <w>  <wgap>  <werr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given the relatively robust representation(RRR) L D L^T, SLARRB
;;*  does ``limited'' bisection to locate the eigenvalues of L D L^T,
;;*  W( IFIRST ) thru' W( ILAST ), to more accuracy. Intervals
;;*  [left, right] are maintained by storing their mid-points and
;;*  semi-widths in the arrays W and WERR respectively.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D.
;;*
;;*  L       (input) REAL array, dimension (N-1)
;;*          The n-1 subdiagonal elements of the unit bidiagonal matrix L.
;;*
;;*  LD      (input) REAL array, dimension (N-1)
;;*          The n-1 elements L(i)*D(i).
;;*
;;*  LLD     (input) REAL array, dimension (N-1)
;;*          The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  IFIRST  (input) INTEGER
;;*          The index of the first eigenvalue in the cluster.
;;*
;;*  ILAST   (input) INTEGER
;;*          The index of the last eigenvalue in the cluster.
;;*
;;*  SIGMA   (input) REAL
;;*          The shift used to form L D L^T (see SLARRF).
;;*
;;*  RELTOL  (input) REAL
;;*          The relative tolerance.
;;*
;;*  W       (input/output) REAL array, dimension (N)
;;*          On input, W( IFIRST ) thru' W( ILAST ) are estimates of the
;;*          corresponding eigenvalues of L D L^T.
;;*          On output, these estimates are ``refined''.
;;*
;;*  WGAP    (input/output) REAL array, dimension (N)
;;*          The gaps between the eigenvalues of L D L^T. Very small
;;*          gaps are changed on output.
;;*
;;*  WERR    (input/output) REAL array, dimension (N)
;;*          On input, WERR( IFIRST ) thru' WERR( ILAST ) are the errors
;;*          in the estimates W( IFIRST ) thru' W( ILAST ).
;;*          On output, these are the ``refined'' errors.
;;*
;;*****Reminder to Inder --- WORK is never used in this subroutine *****
;;*  WORK    (input) REAL array, dimension (???)
;;*          Workspace.
;;*
;;*  IWORK   (input) INTEGER array, dimension (2*N)
;;*          Workspace.
;;*
;;*****Reminder to Inder --- INFO is never set in this subroutine ******
;;*  INFO    (output) INTEGER
;;*          Error flag.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarrb (n  d  l  ld  lld  ifirst  ilast  sigma  reltol  w  wgap  werr  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) l )
	((-idx1- (-float-)) ld )
	((-idx1- (-float-)) lld )
	((-idx0- (-int-)) ifirst )
	((-idx0- (-int-)) ilast )
	((-idx0- (-float-)) sigma )
	((-idx0- (-float-)) reltol )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) wgap )
	((-idx1- (-float-)) werr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slarrb_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($l,float), IDX_PTR($ld,float), IDX_PTR($lld,float), IDX_PTR($ifirst,int), IDX_PTR($ilast,int), IDX_PTR($sigma,float), IDX_PTR($reltol,float), IDX_PTR($w,float), IDX_PTR($wgap,float), IDX_PTR($werr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarre <n>  <d>  <e>  <tol>  <nsplit>  <isplit>  <m>  <w>  <woff>  <gersch>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given the tridiagonal matrix T, SLARRE sets "small" off-diagonal
;;*  elements to zero, and for each unreduced block T_i, it finds
;;*  (i) the numbers sigma_i
;;*  (ii) the base T_i - sigma_i I = L_i D_i L_i^T representations and
;;*  (iii) eigenvalues of each L_i D_i L_i^T.
;;*  The representations and eigenvalues found are then used by
;;*  SSTEGR to compute the eigenvectors of a symmetric tridiagonal
;;*  matrix. Currently, the base representations are limited to being
;;*  positive or negative definite, and the eigenvalues of the definite
;;*  matrices are found by the dqds algorithm (subroutine SLASQ2). As
;;*  an added benefit, SLARRE also outputs the n Gerschgorin
;;*  intervals for each L_i D_i L_i^T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal
;;*          matrix T.
;;*          On exit, the n diagonal elements of the diagonal
;;*          matrices D_i.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix T; E(N) need not be set.
;;*          On exit, the subdiagonal elements of the unit bidiagonal
;;*          matrices L_i.
;;*
;;*  TOL     (input) REAL
;;*          The threshold for splitting. If on input |E(i)| < TOL, then
;;*          the matrix T is split into smaller blocks.
;;*
;;*  NSPLIT  (input) INTEGER
;;*          The number of blocks T splits into. 1 <= NSPLIT <= N.
;;*
;;*  ISPLIT  (output) INTEGER array, dimension (2*N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to ISPLIT(1),
;;*          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
;;*          etc., and the NSPLIT-th consists of rows/columns
;;*          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues (of all the L_i D_i L_i^T)
;;*          found.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the eigenvalues. The
;;*          eigenvalues of each of the blocks, L_i D_i L_i^T, are
;;*          sorted in ascending order.
;;*
;;*  WOFF    (output) REAL array, dimension (N)
;;*          The NSPLIT base points sigma_i.
;;*
;;*  GERSCH  (output) REAL array, dimension (2*N)
;;*          The n Gerschgorin intervals.
;;*
;;*  WORK    (input) REAL array, dimension (4*N???)
;;*          Workspace.
;;*
;;*  INFO    (output) INTEGER
;;*          Output error code from SLASQ2
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarre (n  d  e  tol  nsplit  isplit  m  w  woff  gersch  work  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-float-)) tol )
	((-idx0- (-int-)) nsplit )
	((-idx1- (-int-)) isplit )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) woff )
	((-idx1- (-float-)) gersch )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slarre_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tol,float), IDX_PTR($nsplit,int), IDX_PTR($isplit,int), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($woff,float), IDX_PTR($gersch,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarrf <n>  <d>  <l>  <ld>  <lld>  <ifirst>  <ilast>  <w>  <dplus>  <lplus>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given the initial representation L D L^T and its cluster of close
;;*  eigenvalues (in a relative measure), W( IFIRST ), W( IFIRST+1 ), ...
;;*  W( ILAST ), SLARRF finds a new relatively robust representation
;;*  L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
;;*  eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D.
;;*
;;*  L       (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal
;;*          matrix L.
;;*
;;*  LD      (input) REAL array, dimension (N-1)
;;*          The n-1 elements L(i)*D(i).
;;*
;;*  LLD     (input) REAL array, dimension (N-1)
;;*          The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  IFIRST  (input) INTEGER
;;*          The index of the first eigenvalue in the cluster.
;;*
;;*  ILAST   (input) INTEGER
;;*          The index of the last eigenvalue in the cluster.
;;*
;;*  W       (input/output) REAL array, dimension (N)
;;*          On input, the eigenvalues of L D L^T in ascending order.
;;*          W( IFIRST ) through W( ILAST ) form the cluster of relatively
;;*          close eigenalues.
;;*          On output, W( IFIRST ) thru' W( ILAST ) are estimates of the
;;*          corresponding eigenvalues of L(+) D(+) L(+)^T.
;;*
;;*  SIGMA   (input) REAL
;;*          The shift used to form L(+) D(+) L(+)^T.
;;*
;;*  DPLUS   (output) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D(+).
;;*
;;*  LPLUS   (output) REAL array, dimension (N)
;;*          The first (n-1) elements of LPLUS contain the subdiagonal
;;*          elements of the unit bidiagonal matrix L(+). LPLUS( N ) is
;;*          set to SIGMA.
;;*
;;*  WORK    (input) REAL array, dimension (???)
;;*          Workspace.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarrf (n  d  l  ld  lld  ifirst  ilast  w  dplus  lplus  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) l )
	((-idx1- (-float-)) ld )
	((-idx1- (-float-)) lld )
	((-idx0- (-int-)) ifirst )
	((-idx0- (-int-)) ilast )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) dplus )
	((-idx1- (-float-)) lplus )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slarrf_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($l,float), IDX_PTR($ld,float), IDX_PTR($lld,float), IDX_PTR($ifirst,int), IDX_PTR($ilast,int), IDX_PTR($w,float), IDX_PTR($dplus,float), IDX_PTR($lplus,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarrv <n>  <d>  <l>  <isplit>  <m>  <w>  <iblock>  <gersch>  <tol>  <z>  <ldz>  <isuppz>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARRV computes the eigenvectors of the tridiagonal matrix
;;*  T = L D L^T given L, D and the eigenvalues of L D L^T.
;;*  The input eigenvalues should have high relative accuracy with
;;*  respect to the entries of L and D. The desired accuracy of the
;;*  output can be specified by the input parameter TOL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the diagonal matrix D.
;;*          On exit, D may be overwritten.
;;*
;;*  L       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the unit
;;*          bidiagonal matrix L in elements 1 to N-1 of L. L(N) need
;;*          not be set. On exit, L is overwritten.
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*
;;*  TOL     (input) REAL
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors.
;;*          Errors in the input eigenvalues must be bounded by TOL.
;;*          The eigenvectors output have residual norms
;;*          bounded by TOL, and the dot products between different
;;*          eigenvectors are bounded by TOL. TOL must be at least
;;*          N*EPS*|T|, where EPS is the machine precision and |T| is
;;*          the 1-norm of the tridiagonal matrix.
;;*
;;*  M       (input) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (input) REAL array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block ( The output array
;;*          W from SLARRE is expected here ).
;;*          Errors in W must be bounded by TOL (see above).
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc. 
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace) REAL array, dimension (13*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in SLARRB
;;*                if INFO = 2, internal error in SSTEIN
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarrv (n  d  l  isplit  m  w  iblock  gersch  tol  z  ldz  isuppz  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) l )
	((-idx1- (-int-)) isplit )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-float-)) gersch )
	((-idx0- (-float-)) tol )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slarrv_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($l,float), IDX_PTR($isplit,int), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($iblock,int), IDX_PTR($gersch,float), IDX_PTR($tol,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slartg <f>  <g>  <cs>  <sn>  <r>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARTG generate a plane rotation so that
;;*
;;*     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
;;*     [ -SN  CS  ]     [ G ]     [ 0 ]
;;*
;;*  This is a slower, more accurate version of the BLAS1 routine SROTG,
;;*  with the following other differences:
;;*     F and G are unchanged on return.
;;*     If G=0, then CS=1 and SN=0.
;;*     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
;;*        floating point operations (saves work in SBDSQR when
;;*        there are zeros on the diagonal).
;;*
;;*  If F exceeds G in magnitude, CS will be positive.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) REAL
;;*          The first component of vector to be rotated.
;;*
;;*  G       (input) REAL
;;*          The second component of vector to be rotated.
;;*
;;*  CS      (output) REAL
;;*          The cosine of the rotation.
;;*
;;*  SN      (output) REAL
;;*          The sine of the rotation.
;;*
;;*  R       (output) REAL
;;*          The nonzero component of the rotated vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slartg (f  g  cs  sn  r  )
	((-idx0- (-float-)) f )
	((-idx0- (-float-)) g )
	((-idx0- (-float-)) cs )
	((-idx0- (-float-)) sn )
	((-idx0- (-float-)) r )
	#{ slartg_(IDX_PTR($f,float), IDX_PTR($g,float), IDX_PTR($cs,float), IDX_PTR($sn,float), IDX_PTR($r,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slartv <n>  <x>  <incx>  <y>  <incy>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARTV applies a vector of real plane rotations to elements of the
;;*  real vectors x and y. For i = 1,2,...,n
;;*
;;*     ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
;;*     ( y(i) )    ( -s(i)  c(i) ) ( y(i) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) REAL array,
;;*                         dimension (1+(N-1)*INCY)
;;*          The vector y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (input) REAL array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) REAL array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slartv (n  x  incx  y  incy  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx0- (-int-)) incc )
	#{ slartv_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaruv <iseed>  <n>  <x>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARUV returns a vector of n random real numbers from a uniform (0,1)
;;*  distribution (n <= 128).
;;*
;;*  This is an auxiliary routine called by SLARNV and CLARNV.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ISEED   (input/output) INTEGER array, dimension (4)
;;*          On entry, the seed of the random number generator; the array
;;*          elements must be between 0 and 4095, and ISEED(4) must be
;;*          odd.
;;*          On exit, the seed is updated.
;;*
;;*  N       (input) INTEGER
;;*          The number of random numbers to be generated. N <= 128.
;;*
;;*  X       (output) REAL array, dimension (N)
;;*          The generated random numbers.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine uses a multiplicative congruential method with modulus
;;*  2**48 and multiplier 33952834046453 (see G.S.Fishman,
;;*  'Multiplicative congruential random number generators with modulus
;;*  2**b: an exhaustive analysis for b = 32 and a partial analysis for
;;*  b = 48', Math. Comp. 189, pp 331-344, 1990).
;;*
;;*  48-bit integers are stored in 4 integer array elements with 12 bits
;;*  per element. Hence the routine is portable across machines with
;;*  integers of 32 bits or more.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slaruv (iseed  n  x  )
	((-idx1- (-int-)) iseed )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	#{ slaruv_(IDX_PTR($iseed,int), IDX_PTR($n,int), IDX_PTR($x,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarzb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <l>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARZB applies a real block reflector H or its transpose H**T to
;;*  a real distributed M-by-N  C from the left or the right.
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'C': apply H' (Transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise                        (not supported yet)
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix V containing the
;;*          meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) REAL array, dimension (LDV,NV).
;;*          If STOREV = 'C', NV = K; if STOREV = 'R', NV = L.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= L; if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) REAL array, dimension (LDT,K)
;;*          The triangular K-by-K matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarzb (side  trans  direct  storev  m  n  k  l  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) ldwork )
	#{ slarzb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarz <side>  <m>  <n>  <l>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARZ applies a real elementary reflector H to a real M-by-N
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a real scalar and v is a real vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*
;;*  H is a product of k elementary reflectors as returned by STZRZF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  L       (input) INTEGER
;;*          The number of entries of the vector V containing
;;*          the meaningful part of the Householder vectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) REAL array, dimension (1+(L-1)*abs(INCV))
;;*          The vector v in the representation of H as returned by
;;*          STZRZF. V is not used if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) REAL
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarz (side  m  n  l  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx1- (-float-)) v )
	((-idx0- (-int-)) incv )
	((-idx0- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	#{ slarz_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($v,float), IDX_PTR($incv,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slarzt <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLARZT forms the triangular factor T of a real block reflector
;;*  H of order > n, which is defined as a product of k elementary
;;*  reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise                        (not supported yet)
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) REAL array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) REAL array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*                                              ______V_____
;;*         ( v1 v2 v3 )                        /            \
;;*         ( v1 v2 v3 )                      ( v1 v1 v1 v1 v1 . . . . 1 )
;;*     V = ( v1 v2 v3 )                      ( v2 v2 v2 v2 v2 . . . 1   )
;;*         ( v1 v2 v3 )                      ( v3 v3 v3 v3 v3 . . 1     )
;;*         ( v1 v2 v3 )
;;*            .  .  .
;;*            .  .  .
;;*            1  .  .
;;*               1  .
;;*                  1
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*                                                        ______V_____
;;*            1                                          /            \
;;*            .  1                           ( 1 . . . . v1 v1 v1 v1 v1 )
;;*            .  .  1                        ( . 1 . . . v2 v2 v2 v2 v2 )
;;*            .  .  .                        ( . . 1 . . v3 v3 v3 v3 v3 )
;;*            .  .  .
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*     V = ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slarzt (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ slarzt_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($tau,float), IDX_PTR($t_,float), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slas2 <f>  <g>  <h>  <ssmin>  <ssmax>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAS2  computes the singular values of the 2-by-2 matrix
;;*     [  F   G  ]
;;*     [  0   H  ].
;;*  On return, SSMIN is the smaller singular value and SSMAX is the
;;*  larger singular value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) REAL
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  G       (input) REAL
;;*          The (1,2) element of the 2-by-2 matrix.
;;*
;;*  H       (input) REAL
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  SSMIN   (output) REAL
;;*          The smaller singular value.
;;*
;;*  SSMAX   (output) REAL
;;*          The larger singular value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Barring over/underflow, all output quantities are correct to within
;;*  a few units in the last place (ulps), even in the absence of a guard
;;*  digit in addition/subtraction.
;;*
;;*  In IEEE arithmetic, the code works correctly if one matrix element is
;;*  infinite.
;;*
;;*  Overflow will not occur unless the largest singular value itself
;;*  overflows, or is within a few ulps of overflow. (On machines with
;;*  partial overflow, like the Cray, overflow may occur if the largest
;;*  singular value is within a factor of 2 of overflow.)
;;*
;;*  Underflow is harmless if underflow is gradual. Otherwise, results
;;*  may correspond to a matrix modified by perturbations of size near
;;*  the underflow threshold.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slas2 (f  g  h  ssmin  ssmax  )
	((-idx0- (-float-)) f )
	((-idx0- (-float-)) g )
	((-idx0- (-float-)) h )
	((-idx0- (-float-)) ssmin )
	((-idx0- (-float-)) ssmax )
	#{ slas2_(IDX_PTR($f,float), IDX_PTR($g,float), IDX_PTR($h,float), IDX_PTR($ssmin,float), IDX_PTR($ssmax,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slascl <type>  <kl>  <ku>  <cfrom>  <cto>  <m>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASCL multiplies the M by N real matrix A by the real scalar
;;*  CTO/CFROM.  This is done without over/underflow as long as the final
;;*  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
;;*  A may be full, upper triangular, lower triangular, upper Hessenberg,
;;*  or banded.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TYPE    (input) CHARACTER*1
;;*          TYPE indices the storage type of the input matrix.
;;*          = 'G':  A is a full matrix.
;;*          = 'L':  A is a lower triangular matrix.
;;*          = 'U':  A is an upper triangular matrix.
;;*          = 'H':  A is an upper Hessenberg matrix.
;;*          = 'B':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the lower
;;*                  half stored.
;;*          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the upper
;;*                  half stored.
;;*          = 'Z':  A is a band matrix with lower bandwidth KL and upper
;;*                  bandwidth KU.
;;*
;;*  KL      (input) INTEGER
;;*          The lower bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  KU      (input) INTEGER
;;*          The upper bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  CFROM   (input) REAL
;;*  CTO     (input) REAL
;;*          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
;;*          without over/underflow if the final result CTO*A(I,J)/CFROM
;;*          can be represented without over/underflow.  CFROM must be
;;*          nonzero.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,M)
;;*          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
;;*          storage type.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  INFO    (output) INTEGER
;;*          0  - successful exit
;;*          <0 - if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slascl (type  kl  ku  cfrom  cto  m  n  a  lda  info  )
	((-str-) type )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-float-)) cfrom )
	((-idx0- (-float-)) cto )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ slascl_($type->data, IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($cfrom,float), IDX_PTR($cto,float), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd0 <n>  <sqre>  <d>  <e>  <u>  <ldu>  <vt>  <ldvt>  <smlsiz>  <iwork>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Using a divide and conquer approach, SLASD0 computes the singular
;;*  value decomposition (SVD) of a real upper bidiagonal N-by-M
;;*  matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
;;*  The algorithm computes orthogonal matrices U and VT such that
;;*  B = U * S * VT. The singular values S are overwritten on D.
;;*
;;*  A related subroutine, SLASDA, computes only the singular values,
;;*  and optionally, the singular vectors in compact form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         On entry, the row dimension of the upper bidiagonal matrix.
;;*         This is also the dimension of the main diagonal array D.
;;*
;;*  SQRE   (input) INTEGER
;;*         Specifies the column dimension of the bidiagonal matrix.
;;*         = 0: The bidiagonal matrix has column dimension M = N;
;;*         = 1: The bidiagonal matrix has column dimension M = N+1;
;;*
;;*  D      (input/output) REAL array, dimension (N)
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix.
;;*         On exit D, if INFO = 0, contains its singular values.
;;*
;;*  E      (input) REAL array, dimension (M-1)
;;*         Contains the subdiagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  U      (output) REAL array, dimension at least (LDQ, N)
;;*         On exit, U contains the left singular vectors.
;;*
;;*  LDU    (input) INTEGER
;;*         On entry, leading dimension of U.
;;*
;;*  VT     (output) REAL array, dimension at least (LDVT, M)
;;*         On exit, VT' contains the right singular vectors.
;;*
;;*  LDVT   (input) INTEGER
;;*         On entry, leading dimension of VT.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         On entry, maximum size of the subproblems at the
;;*         bottom of the computation tree.
;;*
;;*  IWORK  INTEGER work array.
;;*         Dimension must be at least (8 * N)
;;*
;;*  WORK   REAL work array.
;;*         Dimension must be at least (3 * M**2 + 2 * M)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slasd0 (n  sqre  d  e  u  ldu  vt  ldvt  smlsiz  iwork  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) sqre )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx0- (-int-)) smlsiz )
	((-idx1- (-int-)) iwork )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasd0_(IDX_PTR($n,int), IDX_PTR($sqre,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($smlsiz,int), IDX_PTR($iwork,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd1 <nl>  <nr>  <sqre>  <d>  <alpha>  <beta>  <u>  <ldu>  <vt>  <ldvt>  <idxq>  <iwork>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
;;*  where N = NL + NR + 1 and M = N + SQRE. SLASD1 is called from SLASD0.
;;*
;;*  A related subroutine SLASD7 handles the case in which the singular
;;*  values (and the singular vectors in factored form) are desired.
;;*
;;*  SLASD1 computes the SVD as follows:
;;*
;;*                ( D1(in)  0    0     0 )
;;*    B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
;;*                (   0     0   D2(in) 0 )
;;*
;;*      = U(out) * ( D(out) 0) * VT(out)
;;*
;;*  where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
;;*  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
;;*  elsewhere; and the entry b is empty if SQRE = 0.
;;*
;;*  The left singular vectors of the original matrix are stored in U, and
;;*  the transpose of the right singular vectors are stored in VT, and the
;;*  singular values are in D.  The algorithm consists of three stages:
;;*
;;*     The first stage consists of deflating the size of the problem
;;*     when there are multiple singular values or when there are zeros in
;;*     the Z vector.  For each such occurence the dimension of the
;;*     secular equation problem is reduced by one.  This stage is
;;*     performed by the routine SLASD2.
;;*
;;*     The second stage consists of calculating the updated
;;*     singular values. This is done by finding the square roots of the
;;*     roots of the secular equation via the routine SLASD4 (as called
;;*     by SLASD3). This routine also calculates the singular vectors of
;;*     the current problem.
;;*
;;*     The final stage consists of computing the updated singular vectors
;;*     directly using the updated singular values.  The singular vectors
;;*     for the current problem are multiplied with the singular vectors
;;*     from the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  D      (input/output) REAL array,
;;*                        dimension (N = NL+NR+1).
;;*         On entry D(1:NL,1:NL) contains the singular values of the
;;*         upper block; and D(NL+2:N) contains the singular values of
;;*         the lower block. On exit D(1:N) contains the singular values
;;*         of the modified matrix.
;;*
;;*  ALPHA  (input) REAL
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) REAL
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  U      (input/output) REAL array, dimension(LDU,N)
;;*         On entry U(1:NL, 1:NL) contains the left singular vectors of
;;*         the upper block; U(NL+2:N, NL+2:N) contains the left singular
;;*         vectors of the lower block. On exit U contains the left
;;*         singular vectors of the bidiagonal matrix.
;;*
;;*  LDU    (input) INTEGER
;;*         The leading dimension of the array U.  LDU >= max( 1, N ).
;;*
;;*  VT     (input/output) REAL array, dimension(LDVT,M)
;;*         where M = N + SQRE.
;;*         On entry VT(1:NL+1, 1:NL+1)' contains the right singular
;;*         vectors of the upper block; VT(NL+2:M, NL+2:M)' contains
;;*         the right singular vectors of the lower block. On exit
;;*         VT' contains the right singular vectors of the
;;*         bidiagonal matrix.
;;*
;;*  LDVT   (input) INTEGER
;;*         The leading dimension of the array VT.  LDVT >= max( 1, M ).
;;*
;;*  IDXQ  (output) INTEGER array, dimension(N)
;;*         This contains the permutation which will reintegrate the
;;*         subproblem just solved back into sorted order, i.e.
;;*         D( IDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  IWORK  (workspace) INTEGER array, dimension( 4 * N )
;;*
;;*  WORK   (workspace) REAL array, dimension( 3*M**2 + 2*M )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*
;;*  =====================================================================

(de slasd1 (nl  nr  sqre  d  alpha  beta  u  ldu  vt  ldvt  idxq  iwork  work  info  )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx1- (-float-)) d )
	((-idx0- (-float-)) alpha )
	((-idx0- (-float-)) beta )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) iwork )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasd1_(IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($d,float), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($idxq,int), IDX_PTR($iwork,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd2 <nl>  <nr>  <sqre>  <k>  <d>  <z>  <alpha>  <beta>  <u>  <ldu>  <vt>  <ldvt>  <dsigma>  <u2>  <ldu2>  <vt2>  <ldvt2>  <idxp>  <idx>  <idxc>  <idxq>  <coltyp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD2 merges the two sets of singular values together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  singular values are close together or if there is a tiny entry in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  SLASD2 is called from SLASD1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has N = NL + NR + 1 rows and
;;*         M = N + SQRE >= N columns.
;;*
;;*  K      (output) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  D      (input/output) REAL array, dimension(N)
;;*         On entry D contains the singular values of the two submatrices
;;*         to be combined.  On exit D contains the trailing (N-K) updated
;;*         singular values (those which were deflated) sorted into
;;*         increasing order.
;;*
;;*  ALPHA  (input) REAL
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) REAL
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  U      (input/output) REAL array, dimension(LDU,N)
;;*         On entry U contains the left singular vectors of two
;;*         submatrices in the two square blocks with corners at (1,1),
;;*         (NL, NL), and (NL+2, NL+2), (N,N).
;;*         On exit U contains the trailing (N-K) updated left singular
;;*         vectors (those which were deflated) in its last N-K columns.
;;*
;;*  LDU    (input) INTEGER
;;*         The leading dimension of the array U.  LDU >= N.
;;*
;;*  Z      (output) REAL array, dimension(N)
;;*         On exit Z contains the updating row vector in the secular
;;*         equation.
;;*
;;*  DSIGMA (output) REAL array, dimension (N)
;;*         Contains a copy of the diagonal elements (K-1 singular values
;;*         and one zero) in the secular equation.
;;*
;;*  U2     (output) REAL array, dimension(LDU2,N)
;;*         Contains a copy of the first K-1 left singular vectors which
;;*         will be used by SLASD3 in a matrix multiply (SGEMM) to solve
;;*         for the new left singular vectors. U2 is arranged into four
;;*         blocks. The first block contains a column with 1 at NL+1 and
;;*         zero everywhere else; the second block contains non-zero
;;*         entries only at and above NL; the third contains non-zero
;;*         entries only below NL+1; and the fourth is dense.
;;*
;;*  LDU2   (input) INTEGER
;;*         The leading dimension of the array U2.  LDU2 >= N.
;;*
;;*  VT     (input/output) REAL array, dimension(LDVT,M)
;;*         On entry VT' contains the right singular vectors of two
;;*         submatrices in the two square blocks with corners at (1,1),
;;*         (NL+1, NL+1), and (NL+2, NL+2), (M,M).
;;*         On exit VT' contains the trailing (N-K) updated right singular
;;*         vectors (those which were deflated) in its last N-K columns.
;;*         In case SQRE =1, the last row of VT spans the right null
;;*         space.
;;*
;;*  LDVT   (input) INTEGER
;;*         The leading dimension of the array VT.  LDVT >= M.
;;*
;;*  VT2    (output) REAL array, dimension(LDVT2,N)
;;*         VT2' contains a copy of the first K right singular vectors
;;*         which will be used by SLASD3 in a matrix multiply (SGEMM) to
;;*         solve for the new right singular vectors. VT2 is arranged into
;;*         three blocks. The first block contains a row that corresponds
;;*         to the special 0 diagonal element in SIGMA; the second block
;;*         contains non-zeros only at and before NL +1; the third block
;;*         contains non-zeros only at and after  NL +2.
;;*
;;*  LDVT2  (input) INTEGER
;;*         The leading dimension of the array VT2.  LDVT2 >= M.
;;*
;;*  IDXP   (workspace) INTEGER array, dimension(N)
;;*         This will contain the permutation used to place deflated
;;*         values of D at the end of the array. On output IDXP(2:K)
;;*         points to the nondeflated D-values and IDXP(K+1:N)
;;*         points to the deflated singular values.
;;*
;;*  IDX    (workspace) INTEGER array, dimension(N)
;;*         This will contain the permutation used to sort the contents of
;;*         D into ascending order.
;;*
;;*  IDXC   (output) INTEGER array, dimension(N)
;;*         This will contain the permutation used to arrange the columns
;;*         of the deflated U matrix into three groups:  the first group
;;*         contains non-zero entries only at and above NL, the second
;;*         contains non-zero entries only below NL+2, and the third is
;;*         dense.
;;*
;;*  COLTYP (workspace/output) INTEGER array, dimension(N)
;;*         As workspace, this will contain a label which will indicate
;;*         which of the following types a column in the U2 matrix or a
;;*         row in the VT2 matrix is:
;;*         1 : non-zero in the upper half only
;;*         2 : non-zero in the lower half only
;;*         3 : dense
;;*         4 : deflated
;;*
;;*         On exit, it is an array of dimension 4, with COLTYP(I) being
;;*         the dimension of the I-th type columns.
;;*
;;*  IDXQ   (input) INTEGER array, dimension(N)
;;*         This contains the permutation which separately sorts the two
;;*         sub-problems in D into ascending order.  Note that entries in
;;*         the first hlaf of this permutation must first be moved one
;;*         position backward; and entries in the second half
;;*         must first have NL+1 added to their values.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd2 (nl  nr  sqre  k  d  z  alpha  beta  u  ldu  vt  ldvt  dsigma  u2  ldu2  vt2  ldvt2  idxp  idx  idxc  idxq  coltyp  info  )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx0- (-float-)) alpha )
	((-idx0- (-float-)) beta )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-float-)) dsigma )
	((-idx2- (-float-)) u2 )
	((-idx0- (-int-)) ldu2 )
	((-idx2- (-float-)) vt2 )
	((-idx0- (-int-)) ldvt2 )
	((-idx1- (-int-)) idxp )
	((-idx1- (-int-)) idx )
	((-idx1- (-int-)) idxc )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) coltyp )
	((-idx0- (-int-)) info )
	#{ slasd2_(IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($k,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($dsigma,float), IDX_PTR($u2,float), IDX_PTR($ldu2,int), IDX_PTR($vt2,float), IDX_PTR($ldvt2,int), IDX_PTR($idxp,int), IDX_PTR($idx,int), IDX_PTR($idxc,int), IDX_PTR($idxq,int), IDX_PTR($coltyp,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd3 <nl>  <nr>  <sqre>  <k>  <d>  <q>  <ldq>  <dsigma>  <u>  <ldu>  <u2>  <ldu2>  <vt>  <ldvt>  <vt2>  <ldvt2>  <idxc>  <ctot>  <z>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD3 finds all the square roots of the roots of the secular
;;*  equation, as defined by the values in D and Z.  It makes the
;;*  appropriate calls to SLASD4 and then updates the singular
;;*  vectors by matrix multiplication.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  SLASD3 is called from SLASD1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has N = NL + NR + 1 rows and
;;*         M = N + SQRE >= N columns.
;;*
;;*  K      (input) INTEGER
;;*         The size of the secular equation, 1 =< K = < N.
;;*
;;*  D      (output) REAL array, dimension(K)
;;*         On exit the square roots of the roots of the secular equation,
;;*         in ascending order.
;;*
;;*  Q      (workspace) REAL array,
;;*                     dimension at least (LDQ,K).
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= K.
;;*
;;*  DSIGMA (input) REAL array, dimension(K)
;;*         The first K elements of this array contain the old roots
;;*         of the deflated updating problem.  These are the poles
;;*         of the secular equation.
;;*
;;*  U      (input) REAL array, dimension (LDU, N)
;;*         The last N - K columns of this matrix contain the deflated
;;*         left singular vectors.
;;*
;;*  LDU    (input) INTEGER
;;*         The leading dimension of the array U.  LDU >= N.
;;*
;;*  U2     (input) REAL array, dimension (LDU2, N)
;;*         The first K columns of this matrix contain the non-deflated
;;*         left singular vectors for the split problem.
;;*
;;*  LDU2   (input) INTEGER
;;*         The leading dimension of the array U2.  LDU2 >= N.
;;*
;;*  VT     (input) REAL array, dimension (LDVT, M)
;;*         The last M - K columns of VT' contain the deflated
;;*         right singular vectors.
;;*
;;*  LDVT   (input) INTEGER
;;*         The leading dimension of the array VT.  LDVT >= N.
;;*
;;*  VT2    (input) REAL array, dimension (LDVT2, N)
;;*         The first K columns of VT2' contain the non-deflated
;;*         right singular vectors for the split problem.
;;*
;;*  LDVT2  (input) INTEGER
;;*         The leading dimension of the array VT2.  LDVT2 >= N.
;;*
;;*  IDXC   (input) INTEGER array, dimension ( N )
;;*         The permutation used to arrange the columns of U (and rows of
;;*         VT) into three groups:  the first group contains non-zero
;;*         entries only at and above (or before) NL +1; the second
;;*         contains non-zero entries only at and below (or after) NL+2;
;;*         and the third is dense. The first column of U and the row of
;;*         VT are treated separately, however.
;;*
;;*         The rows of the singular vectors found by SLASD4
;;*         must be likewise permuted before the matrix multiplies can
;;*         take place.
;;*
;;*  CTOT   (input) INTEGER array, dimension ( 4 )
;;*         A count of the total number of the various types of columns
;;*         in U (or rows in VT), as described in IDXC. The fourth column
;;*         type is any column which has been deflated.
;;*
;;*  Z      (input) REAL array, dimension (K)
;;*         The first K elements of this array contain the components
;;*         of the deflation-adjusted updating row vector.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*         > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd3 (nl  nr  sqre  k  d  q  ldq  dsigma  u  ldu  u2  ldu2  vt  ldvt  vt2  ldvt2  idxc  ctot  z  info  )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) d )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) dsigma )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) u2 )
	((-idx0- (-int-)) ldu2 )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-float-)) vt2 )
	((-idx0- (-int-)) ldvt2 )
	((-idx1- (-int-)) idxc )
	((-idx1- (-int-)) ctot )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) info )
	#{ slasd3_(IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($k,int), IDX_PTR($d,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($dsigma,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($u2,float), IDX_PTR($ldu2,int), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($vt2,float), IDX_PTR($ldvt2,int), IDX_PTR($idxc,int), IDX_PTR($ctot,int), IDX_PTR($z,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd4 <n>  <i>  <d>  <z>  <delta>  <rho>  <sigma>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the square root of the I-th updated
;;*  eigenvalue of a positive symmetric rank-one modification to
;;*  a positive diagonal matrix whose entries are given as the squares
;;*  of the corresponding entries in the array d, and that
;;*
;;*         0 <= D(i) < D(j)  for  i < j
;;*
;;*  and that RHO > 0. This is arranged by the calling routine, and is
;;*  no loss in generality.  The rank-one modified system is thus
;;*
;;*         diag( D ) * diag( D ) +  RHO *  Z * Z_transpose.
;;*
;;*  where we assume the Euclidean norm of Z is 1.
;;*
;;*  The method consists of approximating the rational functions in the
;;*  secular equation by simpler interpolating rational functions.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The length of all arrays.
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  1 <= I <= N.
;;*
;;*  D      (input) REAL array, dimension ( N )
;;*         The original eigenvalues.  It is assumed that they are in
;;*         order, 0 <= D(I) < D(J)  for I < J.
;;*
;;*  Z      (input) REAL array, dimension ( N )
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) REAL array, dimension ( N )
;;*         If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
;;*         component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
;;*         contains the information necessary to construct the
;;*         (singular) eigenvectors.
;;*
;;*  RHO    (input) REAL
;;*         The scalar in the symmetric updating formula.
;;*
;;*  SIGMA  (output) REAL
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  WORK   (workspace) REAL array, dimension ( N )
;;*         If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
;;*         component.  If N = 1, then WORK( 1 ) = 1.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit
;;*         > 0:  if INFO = 1, the updating process failed.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  Logical variable ORGATI (origin-at-i?) is used for distinguishing
;;*  whether D(i) or D(i+1) is treated as the origin.
;;*
;;*            ORGATI = .true.    origin at i
;;*            ORGATI = .false.   origin at i+1
;;*
;;*  Logical variable SWTCH3 (switch-for-3-poles?) is for noting
;;*  if we are working with THREE poles!
;;*
;;*  MAXIT is the maximum number of iterations allowed for each
;;*  eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd4 (n  i  d  z  delta  rho  sigma  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) i )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) delta )
	((-idx0- (-float-)) rho )
	((-idx0- (-float-)) sigma )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasd4_(IDX_PTR($n,int), IDX_PTR($i,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($delta,float), IDX_PTR($rho,float), IDX_PTR($sigma,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd5 <i>  <d>  <z>  <delta>  <rho>  <dsigma>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the square root of the I-th eigenvalue
;;*  of a positive symmetric rank-one modification of a 2-by-2 diagonal
;;*  matrix
;;*
;;*             diag( D ) * diag( D ) +  RHO *  Z * transpose(Z) .
;;*
;;*  The diagonal entries in the array D are assumed to satisfy
;;*
;;*             0 <= D(i) < D(j)  for  i < j .
;;*
;;*  We also assume RHO > 0 and that the Euclidean norm of the vector
;;*  Z is one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  I = 1 or I = 2.
;;*
;;*  D      (input) REAL array, dimension ( 2 )
;;*         The original eigenvalues.  We assume 0 <= D(1) < D(2).
;;*
;;*  Z      (input) REAL array, dimension ( 2 )
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) REAL array, dimension ( 2 )
;;*         Contains (D(j) - lambda_I) in its  j-th component.
;;*         The vector DELTA contains the information necessary
;;*         to construct the eigenvectors.
;;*
;;*  RHO    (input) REAL
;;*         The scalar in the symmetric updating formula.
;;*
;;*  DSIGMA (output) REAL
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  WORK   (workspace) REAL array, dimension ( 2 )
;;*         WORK contains (D(j) + sigma_I) in its  j-th component.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd5 (i  d  z  delta  rho  dsigma  work  )
	((-idx0- (-int-)) i )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) delta )
	((-idx0- (-float-)) rho )
	((-idx0- (-float-)) dsigma )
	((-idx1- (-float-)) work )
	#{ slasd5_(IDX_PTR($i,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($delta,float), IDX_PTR($rho,float), IDX_PTR($dsigma,float), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd6 <icompq>  <nl>  <nr>  <sqre>  <d>  <vf>  <vl>  <alpha>  <beta>  <idxq>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <poles>  <difl>  <difr>  <z>  <k>  <c>  <s>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD6 computes the SVD of an updated upper bidiagonal matrix B
;;*  obtained by merging two smaller ones by appending a row. This
;;*  routine is used only for the problem which requires all singular
;;*  values and optionally singular vector matrices in factored form.
;;*  B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
;;*  A related subroutine, SLASD1, handles the case in which all singular
;;*  values and singular vectors of the bidiagonal matrix are desired.
;;*
;;*  SLASD6 computes the SVD as follows:
;;*
;;*                ( D1(in)  0    0     0 )
;;*    B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
;;*                (   0     0   D2(in) 0 )
;;*
;;*      = U(out) * ( D(out) 0) * VT(out)
;;*
;;*  where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
;;*  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
;;*  elsewhere; and the entry b is empty if SQRE = 0.
;;*
;;*  The singular values of B can be computed using D1, D2, the first
;;*  components of all the right singular vectors of the lower block, and
;;*  the last components of all the right singular vectors of the upper
;;*  block. These components are stored and updated in VF and VL,
;;*  respectively, in SLASD6. Hence U and VT are not explicitly
;;*  referenced.
;;*
;;*  The singular values are stored in D. The algorithm consists of two
;;*  stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple singular values or if there is a zero
;;*        in the Z vector. For each such occurence the dimension of the
;;*        secular equation problem is reduced by one. This stage is
;;*        performed by the routine SLASD7.
;;*
;;*        The second stage consists of calculating the updated
;;*        singular values. This is done by finding the roots of the
;;*        secular equation via the routine SLASD4 (as called by SLASD8).
;;*        This routine also updates VF and VL and computes the distances
;;*        between the updated singular values and the old singular
;;*        values.
;;*
;;*  SLASD6 is called from SLASDA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed in
;;*         factored form:
;;*         = 0: Compute singular values only.
;;*         = 1: Compute singular vectors in factored form as well.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  D      (input/output) REAL array, dimension ( NL+NR+1 ).
;;*         On entry D(1:NL,1:NL) contains the singular values of the
;;*         upper block, and D(NL+2:N) contains the singular values
;;*         of the lower block. On exit D(1:N) contains the singular
;;*         values of the modified matrix.
;;*
;;*  VF     (input/output) REAL array, dimension ( M )
;;*         On entry, VF(1:NL+1) contains the first components of all
;;*         right singular vectors of the upper block; and VF(NL+2:M)
;;*         contains the first components of all right singular vectors
;;*         of the lower block. On exit, VF contains the first components
;;*         of all right singular vectors of the bidiagonal matrix.
;;*
;;*  VL     (input/output) REAL array, dimension ( M )
;;*         On entry, VL(1:NL+1) contains the  last components of all
;;*         right singular vectors of the upper block; and VL(NL+2:M)
;;*         contains the last components of all right singular vectors of
;;*         the lower block. On exit, VL contains the last components of
;;*         all right singular vectors of the bidiagonal matrix.
;;*
;;*  ALPHA  (input) REAL
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) REAL
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  IDXQ   (output) INTEGER array, dimension ( N )
;;*         This contains the permutation which will reintegrate the
;;*         subproblem just solved back into sorted order, i.e.
;;*         D( IDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  PERM   (output) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) to be applied
;;*         to each block. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVPTR (output) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVCOL (output) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGCOL (input) INTEGER
;;*         leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (output) REAL array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value to be used in the
;;*         corresponding Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of GIVNUM and POLES, must be at least N.
;;*
;;*  POLES  (output) REAL array, dimension ( LDGNUM, 2 )
;;*         On exit, POLES(1,*) is an array containing the new singular
;;*         values obtained from solving the secular equation, and
;;*         POLES(2,*) is an array containing the poles in the secular
;;*         equation. Not referenced if ICOMPQ = 0.
;;*
;;*  DIFL   (output) REAL array, dimension ( N )
;;*         On exit, DIFL(I) is the distance between I-th updated
;;*         (undeflated) singular value and the I-th (undeflated) old
;;*         singular value.
;;*
;;*  DIFR   (output) REAL array,
;;*                  dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
;;*                  dimension ( N ) if ICOMPQ = 0.
;;*         On exit, DIFR(I, 1) is the distance between I-th updated
;;*         (undeflated) singular value and the I+1-th (undeflated) old
;;*         singular value.
;;*
;;*         If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
;;*         normalizing factors for the right singular vector matrix.
;;*
;;*         See SLASD8 for details on DIFL and DIFR.
;;*
;;*  Z      (output) REAL array, dimension ( M )
;;*         The first elements of this array contain the components
;;*         of the deflation-adjusted updating row vector.
;;*
;;*  K      (output) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  C      (output) REAL
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (output) REAL
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  WORK   (workspace) REAL array, dimension ( 4 * M )
;;*
;;*  IWORK  (workspace) INTEGER array, dimension ( 3 * N )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd6 (icompq  nl  nr  sqre  d  vf  vl  alpha  beta  idxq  perm  givptr  givcol  ldgcol  givnum  ldgnum  poles  difl  difr  z  k  c  s  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) vf )
	((-idx1- (-float-)) vl )
	((-idx0- (-float-)) alpha )
	((-idx0- (-float-)) beta )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-float-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx2- (-float-)) poles )
	((-idx1- (-float-)) difl )
	((-idx1- (-float-)) difr )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) k )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) s )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slasd6_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($d,float), IDX_PTR($vf,float), IDX_PTR($vl,float), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($idxq,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,float), IDX_PTR($ldgnum,int), IDX_PTR($poles,float), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($z,float), IDX_PTR($k,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd7 <icompq>  <nl>  <nr>  <sqre>  <k>  <d>  <z>  <zw>  <vf>  <vfw>  <vl>  <vlw>  <alpha>  <beta>  <dsigma>  <idx>  <idxp>  <idxq>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <c>  <s>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD7 merges the two sets of singular values together into a single
;;*  sorted set. Then it tries to deflate the size of the problem. There
;;*  are two ways in which deflation can occur:  when two or more singular
;;*  values are close together or if there is a tiny entry in the Z
;;*  vector. For each such occurrence the order of the related
;;*  secular equation problem is reduced by one.
;;*
;;*  SLASD7 is called from SLASD6.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          Specifies whether singular vectors are to be computed
;;*          in compact form, as follows:
;;*          = 0: Compute singular values only.
;;*          = 1: Compute singular vectors of upper
;;*               bidiagonal matrix in compact form.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block. NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block. NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has
;;*         N = NL + NR + 1 rows and
;;*         M = N + SQRE >= N columns.
;;*
;;*  K      (output) INTEGER
;;*         Contains the dimension of the non-deflated matrix, this is
;;*         the order of the related secular equation. 1 <= K <=N.
;;*
;;*  D      (input/output) REAL array, dimension ( N )
;;*         On entry D contains the singular values of the two submatrices
;;*         to be combined. On exit D contains the trailing (N-K) updated
;;*         singular values (those which were deflated) sorted into
;;*         increasing order.
;;*
;;*  Z      (output) REAL array, dimension ( M )
;;*         On exit Z contains the updating row vector in the secular
;;*         equation.
;;*
;;*  ZW     (workspace) REAL array, dimension ( M )
;;*         Workspace for Z.
;;*
;;*  VF     (input/output) REAL array, dimension ( M )
;;*         On entry, VF(1:NL+1) contains the first components of all
;;*         right singular vectors of the upper block; and VF(NL+2:M)
;;*         contains the first components of all right singular vectors
;;*         of the lower block. On exit, VF contains the first components
;;*         of all right singular vectors of the bidiagonal matrix.
;;*
;;*  VFW    (workspace) REAL array, dimension ( M )
;;*         Workspace for VF.
;;*
;;*  VL     (input/output) REAL array, dimension ( M )
;;*         On entry, VL(1:NL+1) contains the  last components of all
;;*         right singular vectors of the upper block; and VL(NL+2:M)
;;*         contains the last components of all right singular vectors
;;*         of the lower block. On exit, VL contains the last components
;;*         of all right singular vectors of the bidiagonal matrix.
;;*
;;*  VLW    (workspace) REAL array, dimension ( M )
;;*         Workspace for VL.
;;*
;;*  ALPHA  (input) REAL
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) REAL
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  DSIGMA (output) REAL array, dimension ( N )
;;*         Contains a copy of the diagonal elements (K-1 singular values
;;*         and one zero) in the secular equation.
;;*
;;*  IDX    (workspace) INTEGER array, dimension ( N )
;;*         This will contain the permutation used to sort the contents of
;;*         D into ascending order.
;;*
;;*  IDXP   (workspace) INTEGER array, dimension ( N )
;;*         This will contain the permutation used to place deflated
;;*         values of D at the end of the array. On output IDXP(2:K)
;;*         points to the nondeflated D-values and IDXP(K+1:N)
;;*         points to the deflated singular values.
;;*
;;*  IDXQ   (input) INTEGER array, dimension ( N )
;;*         This contains the permutation which separately sorts the two
;;*         sub-problems in D into ascending order.  Note that entries in
;;*         the first half of this permutation must first be moved one
;;*         position backward; and entries in the second half
;;*         must first have NL+1 added to their values.
;;*
;;*  PERM   (output) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) to be applied
;;*         to each singular block. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVPTR (output) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVCOL (output) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGCOL (input) INTEGER
;;*         The leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (output) REAL array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value to be used in the
;;*         corresponding Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of GIVNUM, must be at least N.
;;*
;;*  C      (output) REAL
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (output) REAL
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd7 (icompq  nl  nr  sqre  k  d  z  zw  vf  vfw  vl  vlw  alpha  beta  dsigma  idx  idxp  idxq  perm  givptr  givcol  ldgcol  givnum  ldgnum  c  s  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) zw )
	((-idx1- (-float-)) vf )
	((-idx1- (-float-)) vfw )
	((-idx1- (-float-)) vl )
	((-idx1- (-float-)) vlw )
	((-idx0- (-float-)) alpha )
	((-idx0- (-float-)) beta )
	((-idx1- (-float-)) dsigma )
	((-idx1- (-int-)) idx )
	((-idx1- (-int-)) idxp )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-float-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx0- (-float-)) c )
	((-idx0- (-float-)) s )
	((-idx0- (-int-)) info )
	#{ slasd7_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($k,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($zw,float), IDX_PTR($vf,float), IDX_PTR($vfw,float), IDX_PTR($vl,float), IDX_PTR($vlw,float), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($dsigma,float), IDX_PTR($idx,int), IDX_PTR($idxp,int), IDX_PTR($idxq,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,float), IDX_PTR($ldgnum,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd8 <icompq>  <k>  <d>  <z>  <vf>  <vl>  <difl>  <difr>  <lddifr>  <dsigma>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD8 finds the square roots of the roots of the secular equation,
;;*  as defined by the values in DSIGMA and Z. It makes the appropriate
;;*  calls to SLASD4, and stores, for each  element in D, the distance
;;*  to its two nearest poles (elements in DSIGMA). It also updates
;;*  the arrays VF and VL, the first and last components of all the
;;*  right singular vectors of the original bidiagonal matrix.
;;*
;;*  SLASD8 is called from SLASD6.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          Specifies whether singular vectors are to be computed in
;;*          factored form in the calling routine:
;;*          = 0: Compute singular values only.
;;*          = 1: Compute singular vectors in factored form as well.
;;*
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved
;;*          by SLASD4.  K >= 1.
;;*
;;*  D       (output) REAL array, dimension ( K )
;;*          On output, D contains the updated singular values.
;;*
;;*  Z       (input) REAL array, dimension ( K )
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating row vector.
;;*
;;*  VF      (input/output) REAL array, dimension ( K )
;;*          On entry, VF contains  information passed through DBEDE8.
;;*          On exit, VF contains the first K components of the first
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  VL      (input/output) REAL array, dimension ( K )
;;*          On entry, VL contains  information passed through DBEDE8.
;;*          On exit, VL contains the first K components of the last
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  DIFL    (output) REAL array, dimension ( K )
;;*          On exit, DIFL(I) = D(I) - DSIGMA(I).
;;*
;;*  DIFR    (output) REAL array,
;;*                   dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
;;*                   dimension ( K ) if ICOMPQ = 0.
;;*          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
;;*          defined and will not be referenced.
;;*
;;*          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
;;*          normalizing factors for the right singular vector matrix.
;;*
;;*  LDDIFR  (input) INTEGER
;;*          The leading dimension of DIFR, must be at least K.
;;*
;;*  DSIGMA  (input) REAL array, dimension ( K )
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation.
;;*
;;*  WORK    (workspace) REAL array, dimension at least 3 * K
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd8 (icompq  k  d  z  vf  vl  difl  difr  lddifr  dsigma  work  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) vf )
	((-idx1- (-float-)) vl )
	((-idx1- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx0- (-int-)) lddifr )
	((-idx1- (-float-)) dsigma )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasd8_(IDX_PTR($icompq,int), IDX_PTR($k,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($vf,float), IDX_PTR($vl,float), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($lddifr,int), IDX_PTR($dsigma,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasd9 <icompq>  <ldu>  <k>  <d>  <z>  <vf>  <vl>  <difl>  <difr>  <dsigma>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASD9 finds the square roots of the roots of the secular equation,
;;*  as defined by the values in DSIGMA and Z.  It makes the
;;*  appropriate calls to SLASD4, and stores, for each  element in D,
;;*  the distance to its two nearest poles (elements in DSIGMA). It also
;;*  updates the arrays VF and VL, the first and last components of all
;;*  the right singular vectors of the original bidiagonal matrix.
;;*
;;*  SLASD9 is called from SLASD7.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          Specifies whether singular vectors are to be computed in
;;*          factored form in the calling routine:
;;*
;;*             ICOMPQ = 0             Compute singular values only.
;;*
;;*             ICOMPQ = 1             Compute singular vector matrices in
;;*                                    factored form also.
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved by
;;*          SLASD4.  K >= 1.
;;*
;;*  D       (output) REAL array, dimension(K)
;;*          D(I) contains the updated singular values.
;;*
;;*  DSIGMA  (input) REAL array, dimension(K)
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation.
;;*
;;*  Z       (input) REAL array, dimension (K)
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating row vector.
;;*
;;*  VF      (input/output) REAL array, dimension(K)
;;*          On entry, VF contains  information passed through SBEDE8.f
;;*          On exit, VF contains the first K components of the first
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  VL      (input/output) REAL array, dimension(K)
;;*          On entry, VL contains  information passed through SBEDE8.f
;;*          On exit, VL contains the first K components of the last
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  DIFL    (output) REAL array, dimension (K).
;;*          On exit, DIFL(I) = D(I) - DSIGMA(I).
;;*
;;*  DIFR    (output) REAL array,
;;*                              dimension (LDU, 2) if ICOMPQ =1 and
;;*                              dimension (K) if ICOMPQ = 0.
;;*          On exit, DIFR(I, 1) = D(I) - DSIGMA(I+1), DIFR(K, 1) is not
;;*          defined and will not be referenced.
;;*
;;*          If ICOMPQ = 1, DIFR(1:K, 2) is an array containing the
;;*          normalizing factors for the right singular vector matrix.
;;*
;;*  WORK    (workspace) REAL array,
;;*                                 dimension at least (3 * K)
;;*          Workspace.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasd9 (icompq  ldu  k  d  z  vf  vl  difl  difr  dsigma  work  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) ldu )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) z )
	((-idx1- (-float-)) vf )
	((-idx1- (-float-)) vl )
	((-idx1- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx1- (-float-)) dsigma )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasd9_(IDX_PTR($icompq,int), IDX_PTR($ldu,int), IDX_PTR($k,int), IDX_PTR($d,float), IDX_PTR($z,float), IDX_PTR($vf,float), IDX_PTR($vl,float), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($dsigma,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasda <icompq>  <smlsiz>  <n>  <sqre>  <d>  <e>  <u>  <ldu>  <vt>  <k>  <difl>  <difr>  <z>  <poles>  <givptr>  <givcol>  <ldgcol>  <perm>  <givnum>  <c>  <s>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Using a divide and conquer approach, SLASDA computes the singular
;;*  value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
;;*  B with diagonal D and offdiagonal E, where M = N + SQRE. The
;;*  algorithm computes the singular values in the SVD B = U * S * VT.
;;*  The orthogonal matrices U and VT are optionally computed in
;;*  compact form.
;;*
;;*  A related subroutine, SLASD0, computes the singular values and
;;*  the singular vectors in explicit form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed
;;*         in compact form, as follows
;;*         = 0: Compute singular values only.
;;*         = 1: Compute singular vectors of upper bidiagonal
;;*              matrix in compact form.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The row dimension of the upper bidiagonal matrix. This is
;;*         also the dimension of the main diagonal array D.
;;*
;;*  SQRE   (input) INTEGER
;;*         Specifies the column dimension of the bidiagonal matrix.
;;*         = 0: The bidiagonal matrix has column dimension M = N;
;;*         = 1: The bidiagonal matrix has column dimension M = N + 1.
;;*
;;*  D      (input/output) REAL array, dimension ( N )
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix. On exit D, if INFO = 0, contains its singular values.
;;*
;;*  E      (input) REAL array, dimension ( M-1 )
;;*         Contains the subdiagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  U      (output) REAL array,
;;*         dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
;;*         singular vector matrices of all subproblems at the bottom
;;*         level.
;;*
;;*  LDU    (input) INTEGER, LDU = > N.
;;*         The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
;;*         GIVNUM, and Z.
;;*
;;*  VT     (output) REAL array,
;;*         dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT' contains the right
;;*         singular vector matrices of all subproblems at the bottom
;;*         level.
;;*
;;*  K      (output) INTEGER array,
;;*         dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
;;*         If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
;;*         secular equation on the computation tree.
;;*
;;*  DIFL   (output) REAL array, dimension ( LDU, NLVL ),
;;*         where NLVL = floor(log_2 (N/SMLSIZ))).
;;*
;;*  DIFR   (output) REAL array,
;;*                  dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
;;*                  dimension ( N ) if ICOMPQ = 0.
;;*         If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
;;*         record distances between singular values on the I-th
;;*         level and singular values on the (I -1)-th level, and
;;*         DIFR(1:N, 2 * I ) contains the normalizing factors for
;;*         the right singular vector matrix. See SLASD8 for details.
;;*
;;*  Z      (output) REAL array,
;;*                  dimension ( LDU, NLVL ) if ICOMPQ = 1 and
;;*                  dimension ( N ) if ICOMPQ = 0.
;;*         The first K elements of Z(1, I) contain the components of
;;*         the deflation-adjusted updating row vector for subproblems
;;*         on the I-th level.
;;*
;;*  POLES  (output) REAL array,
;;*         dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
;;*         POLES(1, 2*I) contain  the new and old singular values
;;*         involved in the secular equations on the I-th level.
;;*
;;*  GIVPTR (output) INTEGER array,
;;*         dimension ( N ) if ICOMPQ = 1, and not referenced if
;;*         ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
;;*         the number of Givens rotations performed on the I-th
;;*         problem on the computation tree.
;;*
;;*  GIVCOL (output) INTEGER array,
;;*         dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
;;*         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
;;*         GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
;;*         of Givens rotations performed on the I-th level on the
;;*         computation tree.
;;*
;;*  LDGCOL (input) INTEGER, LDGCOL = > N.
;;*         The leading dimension of arrays GIVCOL and PERM.
;;*
;;*  PERM   (output) INTEGER array,
;;*         dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
;;*         permutations done on the I-th level of the computation tree.
;;*
;;*  GIVNUM (output) REAL array,
;;*         dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
;;*         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
;;*         GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
;;*         values of Givens rotations performed on the I-th level on
;;*         the computation tree.
;;*
;;*  C      (output) REAL array,
;;*         dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
;;*         If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
;;*         C( I ) contains the C-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  S      (output) REAL array, dimension ( N ) if
;;*         ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
;;*         and the I-th subproblem is not square, on exit, S( I )
;;*         contains the S-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  WORK   (workspace) REAL array, dimension
;;*         (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
;;*
;;*  IWORK  (workspace) INTEGER array.
;;*         Dimension must be at least (7 * N).
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasda (icompq  smlsiz  n  sqre  d  e  u  ldu  vt  k  difl  difr  z  poles  givptr  givcol  ldgcol  perm  givnum  c  s  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) sqre )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) vt )
	((-idx1- (-int-)) k )
	((-idx2- (-float-)) difl )
	((-idx2- (-float-)) difr )
	((-idx2- (-float-)) z )
	((-idx2- (-float-)) poles )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-int-)) perm )
	((-idx2- (-float-)) givnum )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ slasda_(IDX_PTR($icompq,int), IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($sqre,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($vt,float), IDX_PTR($k,int), IDX_PTR($difl,float), IDX_PTR($difr,float), IDX_PTR($z,float), IDX_PTR($poles,float), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($perm,int), IDX_PTR($givnum,float), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasdq <uplo>  <sqre>  <n>  <ncvt>  <nru>  <ncc>  <d>  <e>  <vt>  <ldvt>  <u>  <ldu>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASDQ computes the singular value decomposition (SVD) of a real
;;*  (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
;;*  E, accumulating the transformations if desired. Letting B denote
;;*  the input bidiagonal matrix, the algorithm computes orthogonal
;;*  matrices Q and P such that B = Q * S * P' (P' denotes the transpose
;;*  of P). The singular values S are overwritten on D.
;;*
;;*  The input matrix U  is changed to U  * Q  if desired.
;;*  The input matrix VT is changed to P' * VT if desired.
;;*  The input matrix C  is changed to Q' * C  if desired.
;;*
;;*  See "Computing  Small Singular Values of Bidiagonal Matrices With
;;*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
;;*  LAPACK Working Note #3, for a detailed description of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO  (input) CHARACTER*1
;;*        On entry, UPLO specifies whether the input bidiagonal matrix
;;*        is upper or lower bidiagonal, and wether it is square are
;;*        not.
;;*           UPLO = 'U' or 'u'   B is upper bidiagonal.
;;*           UPLO = 'L' or 'l'   B is lower bidiagonal.
;;*
;;*  SQRE  (input) INTEGER
;;*        = 0: then the input matrix is N-by-N.
;;*        = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
;;*             (N+1)-by-N if UPLU = 'L'.
;;*
;;*        The bidiagonal matrix has
;;*        N = NL + NR + 1 rows and
;;*        M = N + SQRE >= N columns.
;;*
;;*  N     (input) INTEGER
;;*        On entry, N specifies the number of rows and columns
;;*        in the matrix. N must be at least 0.
;;*
;;*  NCVT  (input) INTEGER
;;*        On entry, NCVT specifies the number of columns of
;;*        the matrix VT. NCVT must be at least 0.
;;*
;;*  NRU   (input) INTEGER
;;*        On entry, NRU specifies the number of rows of
;;*        the matrix U. NRU must be at least 0.
;;*
;;*  NCC   (input) INTEGER
;;*        On entry, NCC specifies the number of columns of
;;*        the matrix C. NCC must be at least 0.
;;*
;;*  D     (input/output) REAL array, dimension (N)
;;*        On entry, D contains the diagonal entries of the
;;*        bidiagonal matrix whose SVD is desired. On normal exit,
;;*        D contains the singular values in ascending order.
;;*
;;*  E     (input/output) REAL array.
;;*        dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
;;*        On entry, the entries of E contain the offdiagonal entries
;;*        of the bidiagonal matrix whose SVD is desired. On normal
;;*        exit, E will contain 0. If the algorithm does not converge,
;;*        D and E will contain the diagonal and superdiagonal entries
;;*        of a bidiagonal matrix orthogonally equivalent to the one
;;*        given as input.
;;*
;;*  VT    (input/output) REAL array, dimension (LDVT, NCVT)
;;*        On entry, contains a matrix which on exit has been
;;*        premultiplied by P', dimension N-by-NCVT if SQRE = 0
;;*        and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
;;*
;;*  LDVT  (input) INTEGER
;;*        On entry, LDVT specifies the leading dimension of VT as
;;*        declared in the calling (sub) program. LDVT must be at
;;*        least 1. If NCVT is nonzero LDVT must also be at least N.
;;*
;;*  U     (input/output) REAL array, dimension (LDU, N)
;;*        On entry, contains a  matrix which on exit has been
;;*        postmultiplied by Q, dimension NRU-by-N if SQRE = 0
;;*        and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
;;*
;;*  LDU   (input) INTEGER
;;*        On entry, LDU  specifies the leading dimension of U as
;;*        declared in the calling (sub) program. LDU must be at
;;*        least max( 1, NRU ) .
;;*
;;*  C     (input/output) REAL array, dimension (LDC, NCC)
;;*        On entry, contains an N-by-NCC matrix which on exit
;;*        has been premultiplied by Q'  dimension N-by-NCC if SQRE = 0
;;*        and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
;;*
;;*  LDC   (input) INTEGER
;;*        On entry, LDC  specifies the leading dimension of C as
;;*        declared in the calling (sub) program. LDC must be at
;;*        least 1. If NCC is nonzero, LDC must also be at least N.
;;*
;;*  WORK  (workspace) REAL array, dimension (4*N)
;;*        Workspace. Only referenced if one of NCVT, NRU, or NCC is
;;*        nonzero, and if N is at least 2.
;;*
;;*  INFO  (output) INTEGER
;;*        On exit, a value of 0 indicates a successful exit.
;;*        If INFO < 0, argument number -INFO is illegal.
;;*        If INFO > 0, the algorithm did not converge, and INFO
;;*        specifies how many superdiagonals did not converge.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasdq (uplo  sqre  n  ncvt  nru  ncc  d  e  vt  ldvt  u  ldu  c  ldc  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncvt )
	((-idx0- (-int-)) nru )
	((-idx0- (-int-)) ncc )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasdq_($uplo->data, IDX_PTR($sqre,int), IDX_PTR($n,int), IDX_PTR($ncvt,int), IDX_PTR($nru,int), IDX_PTR($ncc,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vt,float), IDX_PTR($ldvt,int), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasdt <n>  <lvl>  <nd>  <inode>  <ndiml>  <ndimr>  <msub>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASDT creates a tree of subproblems for bidiagonal divide and
;;*  conquer.
;;*
;;*  Arguments
;;*  =========
;;*
;;*   N      (input) INTEGER
;;*          On entry, the number of diagonal elements of the
;;*          bidiagonal matrix.
;;*
;;*   LVL    (output) INTEGER
;;*          On exit, the number of levels on the computation tree.
;;*
;;*   ND     (output) INTEGER
;;*          On exit, the number of nodes on the tree.
;;*
;;*   INODE  (output) INTEGER array, dimension ( N )
;;*          On exit, centers of subproblems.
;;*
;;*   NDIML  (output) INTEGER array, dimension ( N )
;;*          On exit, row dimensions of left children.
;;*
;;*   NDIMR  (output) INTEGER array, dimension ( N )
;;*          On exit, row dimensions of right children.
;;*
;;*   MSUB   (input) INTEGER.
;;*          On entry, the maximum row dimension each subproblem at the
;;*          bottom of the tree can be of.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasdt (n  lvl  nd  inode  ndiml  ndimr  msub  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) lvl )
	((-idx0- (-int-)) nd )
	((-idx1- (-int-)) inode )
	((-idx1- (-int-)) ndiml )
	((-idx1- (-int-)) ndimr )
	((-idx0- (-int-)) msub )
	#{ slasdt_(IDX_PTR($n,int), IDX_PTR($lvl,int), IDX_PTR($nd,int), IDX_PTR($inode,int), IDX_PTR($ndiml,int), IDX_PTR($ndimr,int), IDX_PTR($msub,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaset <uplo>  <m>  <n>  <alpha>  <beta>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASET initializes an m-by-n matrix A to BETA on the diagonal and
;;*  ALPHA on the offdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be set.
;;*          = 'U':      Upper triangular part is set; the strictly lower
;;*                      triangular part of A is not changed.
;;*          = 'L':      Lower triangular part is set; the strictly upper
;;*                      triangular part of A is not changed.
;;*          Otherwise:  All of the matrix A is set.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  ALPHA   (input) REAL
;;*          The constant to which the offdiagonal elements are to be set.
;;*
;;*  BETA    (input) REAL
;;*          The constant to which the diagonal elements are to be set.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On exit, the leading m-by-n submatrix of A is set as follows:
;;*
;;*          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
;;*          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
;;*          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
;;*
;;*          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slaset (uplo  m  n  alpha  beta  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) alpha )
	((-idx0- (-float-)) beta )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ slaset_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasq1 <n>  <d>  <e>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASQ1 computes the singular values of a real N-by-N bidiagonal
;;*  matrix with diagonal D and off-diagonal E. The singular values
;;*  are computed to high relative accuracy, in the absence of
;;*  denormalization, underflow and overflow. The algorithm was first
;;*  presented in
;;*
;;*  "Accurate singular values and differential qd algorithms" by K. V.
;;*  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
;;*  1994,
;;*
;;*  and the present implementation is described in "An implementation of
;;*  the dqds Algorithm (Positive Case)", LAPACK Working Note.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N     (input) INTEGER
;;*        The number of rows and columns in the matrix. N >= 0.
;;*
;;*  D     (input/output) REAL array, dimension (N)
;;*        On entry, D contains the diagonal elements of the
;;*        bidiagonal matrix whose SVD is desired. On normal exit,
;;*        D contains the singular values in decreasing order.
;;*
;;*  E     (input/output) REAL array, dimension (N)
;;*        On entry, elements E(1:N-1) contain the off-diagonal elements
;;*        of the bidiagonal matrix whose SVD is desired.
;;*        On exit, E is overwritten.
;;*
;;*  WORK  (workspace) REAL array, dimension (4*N)
;;*
;;*  INFO  (output) INTEGER
;;*        = 0: successful exit
;;*        < 0: if INFO = -i, the i-th argument had an illegal value
;;*        > 0: the algorithm failed
;;*             = 1, a split was marked by a positive value in E
;;*             = 2, current block of Z not diagonalized after 30*N
;;*                  iterations (in inner while loop)
;;*             = 3, termination criterion of outer while loop not met 
;;*                  (program created more than N unreduced blocks)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasq1 (n  d  e  work  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ slasq1_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasq2 <n>  <z>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASQ2 computes all the eigenvalues of the symmetric positive 
;;*  definite tridiagonal matrix associated with the qd array Z to high
;;*  relative accuracy are computed to high relative accuracy, in the
;;*  absence of denormalization, underflow and overflow.
;;*
;;*  To see the relation of Z to the tridiagonal matrix, let L be a
;;*  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
;;*  let U be an upper bidiagonal matrix with 1's above and diagonal
;;*  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
;;*  symmetric tridiagonal to which it is similar.
;;*
;;*  Note : SLASQ2 defines a logical variable, IEEE, which is true
;;*  on machines which follow ieee-754 floating-point standard in their
;;*  handling of infinities and NaNs, and false otherwise. This variable
;;*  is passed to SLASQ3.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N     (input) INTEGER
;;*        The number of rows and columns in the matrix. N >= 0.
;;*
;;*  Z     (workspace) REAL array, dimension ( 4*N )
;;*        On entry Z holds the qd array. On exit, entries 1 to N hold
;;*        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
;;*        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
;;*        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
;;*        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
;;*        shifts that failed.
;;*
;;*  INFO  (output) INTEGER
;;*        = 0: successful exit
;;*        < 0: if the i-th argument is a scalar and had an illegal
;;*             value, then INFO = -i, if the i-th argument is an
;;*             array and the j-entry had an illegal value, then
;;*             INFO = -(i*100+j)
;;*        > 0: the algorithm failed
;;*              = 1, a split was marked by a positive value in E
;;*              = 2, current block of Z not diagonalized after 30*N
;;*                   iterations (in inner while loop)
;;*              = 3, termination criterion of outer while loop not met 
;;*                   (program created more than N unreduced blocks)
;;*
;;*  Further Details
;;*  ===============
;;*  Local Variables: I0:N0 defines a current unreduced segment of Z.
;;*  The shifts are accumulated in SIGMA. Iteration count is in ITER.
;;*  Ping-pong is controlled by PP (alternates between 0 and 1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasq2 (n  z  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) info )
	#{ slasq2_(IDX_PTR($n,int), IDX_PTR($z,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasq3 <i0>  <n0>  <z>  <pp>  <dmin>  <sigma>  <desig>  <qmax>  <nfail>  <iter>  <ndiv>  <ieee>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
;;*  In case of failure it changes shifts, and tries again until output
;;*  is positive.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I0     (input) INTEGER
;;*         First index.
;;*
;;*  N0     (input) INTEGER
;;*         Last index.
;;*
;;*  Z      (input) REAL array, dimension ( 4*N )
;;*         Z holds the qd array.
;;*
;;*  PP     (input) INTEGER
;;*         PP=0 for ping, PP=1 for pong.
;;*
;;*  DMIN   (output) REAL
;;*         Minimum value of d.
;;*
;;*  SIGMA  (output) REAL
;;*         Sum of shifts used in current segment.
;;*
;;*  DESIG  (input/output) REAL
;;*         Lower order part of SIGMA
;;*
;;*  QMAX   (input) REAL
;;*         Maximum value of q.
;;*
;;*  NFAIL  (output) INTEGER
;;*         Number of times shift was too big.
;;*
;;*  ITER   (output) INTEGER
;;*         Number of iterations.
;;*
;;*  NDIV   (output) INTEGER
;;*         Number of divisions.
;;*
;;*  TTYPE  (output) INTEGER
;;*         Shift type.
;;*
;;*  IEEE   (input) LOGICAL
;;*         Flag for IEEE or non IEEE arithmetic (passed to SLASQ5).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasq3 (i0  n0  z  pp  dmin  sigma  desig  qmax  nfail  iter  ndiv  ieee  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-float-)) dmin )
	((-idx0- (-float-)) sigma )
	((-idx0- (-float-)) desig )
	((-idx0- (-float-)) qmax )
	((-idx0- (-int-)) nfail )
	((-idx0- (-int-)) iter )
	((-idx0- (-int-)) ndiv )
	((-idx0- (-int-)) ieee )
	#{ slasq3_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,float), IDX_PTR($pp,int), IDX_PTR($dmin,float), IDX_PTR($sigma,float), IDX_PTR($desig,float), IDX_PTR($qmax,float), IDX_PTR($nfail,int), IDX_PTR($iter,int), IDX_PTR($ndiv,int), IDX_PTR($ieee,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasq4 <i0>  <n0>  <z>  <pp>  <n0in>  <dmin>  <dmin1>  <dmin2>  <dn>  <dn1>  <dn2>  <tau>  <ttype>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASQ4 computes an approximation TAU to the smallest eigenvalue 
;;*  using values of d from the previous transform.
;;*
;;*  I0    (input) INTEGER
;;*        First index.
;;*
;;*  N0    (input) INTEGER
;;*        Last index.
;;*
;;*  Z     (input) REAL array, dimension ( 4*N )
;;*        Z holds the qd array.
;;*
;;*  PP    (input) INTEGER
;;*        PP=0 for ping, PP=1 for pong.
;;*
;;*  NOIN  (input) INTEGER
;;*        The value of N0 at start of EIGTEST.
;;*
;;*  DMIN  (input) REAL
;;*        Minimum value of d.
;;*
;;*  DMIN1 (input) REAL
;;*        Minimum value of d, excluding D( N0 ).
;;*
;;*  DMIN2 (input) REAL
;;*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
;;*
;;*  DN    (input) REAL
;;*        d(N)
;;*
;;*  DN1   (input) REAL
;;*        d(N-1)
;;*
;;*  DN2   (input) REAL
;;*        d(N-2)
;;*
;;*  TAU   (output) REAL
;;*        This is the shift.
;;*
;;*  TTYPE (output) INTEGER
;;*        Shift type.
;;*
;;*  Further Details
;;*  ===============
;;*  CNST1 = 9/16
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasq4 (i0  n0  z  pp  n0in  dmin  dmin1  dmin2  dn  dn1  dn2  tau  ttype  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-int-)) n0in )
	((-idx0- (-float-)) dmin )
	((-idx0- (-float-)) dmin1 )
	((-idx0- (-float-)) dmin2 )
	((-idx0- (-float-)) dn )
	((-idx0- (-float-)) dn1 )
	((-idx0- (-float-)) dn2 )
	((-idx0- (-float-)) tau )
	((-idx0- (-int-)) ttype )
	#{ slasq4_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,float), IDX_PTR($pp,int), IDX_PTR($n0in,int), IDX_PTR($dmin,float), IDX_PTR($dmin1,float), IDX_PTR($dmin2,float), IDX_PTR($dn,float), IDX_PTR($dn1,float), IDX_PTR($dn2,float), IDX_PTR($tau,float), IDX_PTR($ttype,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasq5 <i0>  <n0>  <z>  <pp>  <tau>  <dmin>  <dmin1>  <dmin2>  <dn>  <dnm1>  <dnm2>  <ieee>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASQ5 computes one dqds transform in ping-pong form, one
;;*  version for IEEE machines another for non IEEE machines.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I0    (input) INTEGER
;;*        First index.
;;*
;;*  N0    (input) INTEGER
;;*        Last index.
;;*
;;*  Z     (input) REAL array, dimension ( 4*N )
;;*        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
;;*        an extra argument.
;;*
;;*  PP    (input) INTEGER
;;*        PP=0 for ping, PP=1 for pong.
;;*
;;*  TAU   (input) REAL
;;*        This is the shift.
;;*
;;*  DMIN  (output) REAL
;;*        Minimum value of d.
;;*
;;*  DMIN1 (output) REAL
;;*        Minimum value of d, excluding D( N0 ).
;;*
;;*  DMIN2 (output) REAL
;;*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
;;*
;;*  DN    (output) REAL
;;*        d(N0), the last value of d.
;;*
;;*  DNM1  (output) REAL
;;*        d(N0-1).
;;*
;;*  DNM2  (output) REAL
;;*        d(N0-2).
;;*
;;*  IEEE  (input) LOGICAL
;;*        Flag for IEEE or non IEEE arithmetic.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameter ..
;;*  =====================================================================

(de slasq5 (i0  n0  z  pp  tau  dmin  dmin1  dmin2  dn  dnm1  dnm2  ieee  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-float-)) tau )
	((-idx0- (-float-)) dmin )
	((-idx0- (-float-)) dmin1 )
	((-idx0- (-float-)) dmin2 )
	((-idx0- (-float-)) dn )
	((-idx0- (-float-)) dnm1 )
	((-idx0- (-float-)) dnm2 )
	((-idx0- (-int-)) ieee )
	#{ slasq5_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,float), IDX_PTR($pp,int), IDX_PTR($tau,float), IDX_PTR($dmin,float), IDX_PTR($dmin1,float), IDX_PTR($dmin2,float), IDX_PTR($dn,float), IDX_PTR($dnm1,float), IDX_PTR($dnm2,float), IDX_PTR($ieee,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasq6 <i0>  <n0>  <z>  <pp>  <dmin>  <dmin1>  <dmin2>  <dn>  <dnm1>  <dnm2>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASQ6 computes one dqd (shift equal to zero) transform in
;;*  ping-pong form, with protection against underflow and overflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I0    (input) INTEGER
;;*        First index.
;;*
;;*  N0    (input) INTEGER
;;*        Last index.
;;*
;;*  Z     (input) REAL array, dimension ( 4*N )
;;*        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
;;*        an extra argument.
;;*
;;*  PP    (input) INTEGER
;;*        PP=0 for ping, PP=1 for pong.
;;*
;;*  DMIN  (output) REAL
;;*        Minimum value of d.
;;*
;;*  DMIN1 (output) REAL
;;*        Minimum value of d, excluding D( N0 ).
;;*
;;*  DMIN2 (output) REAL
;;*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
;;*
;;*  DN    (output) REAL
;;*        d(N0), the last value of d.
;;*
;;*  DNM1  (output) REAL
;;*        d(N0-1).
;;*
;;*  DNM2  (output) REAL
;;*        d(N0-2).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameter ..
;;*  =====================================================================

(de slasq6 (i0  n0  z  pp  dmin  dmin1  dmin2  dn  dnm1  dnm2  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-float-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-float-)) dmin )
	((-idx0- (-float-)) dmin1 )
	((-idx0- (-float-)) dmin2 )
	((-idx0- (-float-)) dn )
	((-idx0- (-float-)) dnm1 )
	((-idx0- (-float-)) dnm2 )
	#{ slasq6_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,float), IDX_PTR($pp,int), IDX_PTR($dmin,float), IDX_PTR($dmin1,float), IDX_PTR($dmin2,float), IDX_PTR($dn,float), IDX_PTR($dnm1,float), IDX_PTR($dnm2,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasr <side>  <pivot>  <direct>  <m>  <n>  <c>  <s>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASR   performs the transformation
;;*
;;*     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )
;;*
;;*     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )
;;*
;;*  where A is an m by n real matrix and P is an orthogonal matrix,
;;*  consisting of a sequence of plane rotations determined by the
;;*  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
;;*  and z = n when SIDE = 'R' or 'r' ):
;;*
;;*  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then
;;*
;;*     P = P( z - 1 )*...*P( 2 )*P( 1 ),
;;*
;;*  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then
;;*
;;*     P = P( 1 )*P( 2 )*...*P( z - 1 ),
;;*
;;*  where  P( k ) is a plane rotation matrix for the following planes:
;;*
;;*     when  PIVOT = 'V' or 'v'  ( Variable pivot ),
;;*        the plane ( k, k + 1 )
;;*
;;*     when  PIVOT = 'T' or 't'  ( Top pivot ),
;;*        the plane ( 1, k + 1 )
;;*
;;*     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),
;;*        the plane ( k, z )
;;*
;;*  c( k ) and s( k )  must contain the  cosine and sine that define the
;;*  matrix  P( k ).  The two by two plane rotation part of the matrix
;;*  P( k ), R( k ), is assumed to be of the form
;;*
;;*     R( k ) = (  c( k )  s( k ) ).
;;*              ( -s( k )  c( k ) )
;;*
;;*  This version vectorises across rows of the array A when SIDE = 'L'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          Specifies whether the plane rotation matrix P is applied to
;;*          A on the left or the right.
;;*          = 'L':  Left, compute A := P*A
;;*          = 'R':  Right, compute A:= A*P'
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies whether P is a forward or backward sequence of
;;*          plane rotations.
;;*          = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )
;;*          = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )
;;*
;;*  PIVOT   (input) CHARACTER*1
;;*          Specifies the plane for which P(k) is a plane rotation
;;*          matrix.
;;*          = 'V':  Variable pivot, the plane (k,k+1)
;;*          = 'T':  Top pivot, the plane (1,k+1)
;;*          = 'B':  Bottom pivot, the plane (k,z)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  If m <= 1, an immediate
;;*          return is effected.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  If n <= 1, an
;;*          immediate return is effected.
;;*
;;*  C, S    (input) REAL arrays, dimension
;;*                  (M-1) if SIDE = 'L'
;;*                  (N-1) if SIDE = 'R'
;;*          c(k) and s(k) contain the cosine and sine that define the
;;*          matrix P(k).  The two by two plane rotation part of the
;;*          matrix P(k), R(k), is assumed to be of the form
;;*          R( k ) = (  c( k )  s( k ) ).
;;*                   ( -s( k )  c( k ) )
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          The m by n matrix A.  On exit, A is overwritten by P*A if
;;*          SIDE = 'R' or by A*P' if SIDE = 'L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasr (side  pivot  direct  m  n  c  s  a  lda  )
	((-str-) side )
	((-str-) pivot )
	((-str-) direct )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) c )
	((-idx1- (-float-)) s )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ slasr_($side->data, $pivot->data, $direct->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($c,float), IDX_PTR($s,float), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasrt <id>  <n>  <d>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Sort the numbers in D in increasing order (if ID = 'I') or
;;*  in decreasing order (if ID = 'D' ).
;;*
;;*  Use Quick Sort, reverting to Insertion sort on arrays of
;;*  size <= 20. Dimension of STACK limits N to about 2**32.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ID      (input) CHARACTER*1
;;*          = 'I': sort D in increasing order;
;;*          = 'D': sort D in decreasing order.
;;*
;;*  N       (input) INTEGER
;;*          The length of the array D.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the array to be sorted.
;;*          On exit, D has been sorted into increasing order
;;*          (D(1) <= ... <= D(N) ) or into decreasing order
;;*          (D(1) >= ... >= D(N) ), depending on ID.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasrt (id  n  d  info  )
	((-str-) id )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx0- (-int-)) info )
	#{ slasrt_($id->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slassq <n>  <x>  <incx>  <scale>  <sumsq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASSQ  returns the values  scl  and  smsq  such that
;;*
;;*     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
;;*
;;*  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
;;*  assumed to be non-negative and  scl  returns the value
;;*
;;*     scl = max( scale, abs( x( i ) ) ).
;;*
;;*  scale and sumsq must be supplied in SCALE and SUMSQ and
;;*  scl and smsq are overwritten on SCALE and SUMSQ respectively.
;;*
;;*  The routine makes only one pass through the vector x.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements to be used from the vector X.
;;*
;;*  X       (input) REAL array, dimension (N)
;;*          The vector for which a scaled sum of squares is computed.
;;*             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector X.
;;*          INCX > 0.
;;*
;;*  SCALE   (input/output) REAL
;;*          On entry, the value  scale  in the equation above.
;;*          On exit, SCALE is overwritten with  scl , the scaling factor
;;*          for the sum of squares.
;;*
;;*  SUMSQ   (input/output) REAL
;;*          On entry, the value  sumsq  in the equation above.
;;*          On exit, SUMSQ is overwritten with  smsq , the basic sum of
;;*          squares from which  scl  has been factored out.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slassq (n  x  incx  scale  sumsq  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) sumsq )
	#{ slassq_(IDX_PTR($n,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($scale,float), IDX_PTR($sumsq,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasv2 <f>  <g>  <h>  <ssmin>  <ssmax>  <snr>  <csr>  <snl>  <csl>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASV2 computes the singular value decomposition of a 2-by-2
;;*  triangular matrix
;;*     [  F   G  ]
;;*     [  0   H  ].
;;*  On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
;;*  smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
;;*  right singular vectors for abs(SSMAX), giving the decomposition
;;*
;;*     [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
;;*     [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) REAL
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  G       (input) REAL
;;*          The (1,2) element of the 2-by-2 matrix.
;;*
;;*  H       (input) REAL
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  SSMIN   (output) REAL
;;*          abs(SSMIN) is the smaller singular value.
;;*
;;*  SSMAX   (output) REAL
;;*          abs(SSMAX) is the larger singular value.
;;*
;;*  SNL     (output) REAL
;;*  CSL     (output) REAL
;;*          The vector (CSL, SNL) is a unit left singular vector for the
;;*          singular value abs(SSMAX).
;;*
;;*  SNR     (output) REAL
;;*  CSR     (output) REAL
;;*          The vector (CSR, SNR) is a unit right singular vector for the
;;*          singular value abs(SSMAX).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Any input parameter may be aliased with any output parameter.
;;*
;;*  Barring over/underflow and assuming a guard digit in subtraction, all
;;*  output quantities are correct to within a few units in the last
;;*  place (ulps).
;;*
;;*  In IEEE arithmetic, the code works correctly if one matrix element is
;;*  infinite.
;;*
;;*  Overflow will not occur unless the largest singular value itself
;;*  overflows or is within a few ulps of overflow. (On machines with
;;*  partial overflow, like the Cray, overflow may occur if the largest
;;*  singular value is within a factor of 2 of overflow.)
;;*
;;*  Underflow is harmless if underflow is gradual. Otherwise, results
;;*  may correspond to a matrix modified by perturbations of size near
;;*  the underflow threshold.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasv2 (f  g  h  ssmin  ssmax  snr  csr  snl  csl  )
	((-idx0- (-float-)) f )
	((-idx0- (-float-)) g )
	((-idx0- (-float-)) h )
	((-idx0- (-float-)) ssmin )
	((-idx0- (-float-)) ssmax )
	((-idx0- (-float-)) snr )
	((-idx0- (-float-)) csr )
	((-idx0- (-float-)) snl )
	((-idx0- (-float-)) csl )
	#{ slasv2_(IDX_PTR($f,float), IDX_PTR($g,float), IDX_PTR($h,float), IDX_PTR($ssmin,float), IDX_PTR($ssmax,float), IDX_PTR($snr,float), IDX_PTR($csr,float), IDX_PTR($snl,float), IDX_PTR($csl,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slaswp <n>  <a>  <lda>  <k1>  <k2>  <ipiv>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASWP performs a series of row interchanges on the matrix A.
;;*  One row interchange is initiated for each of rows K1 through K2 of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the matrix of column dimension N to which the row
;;*          interchanges will be applied.
;;*          On exit, the permuted matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*
;;*  K1      (input) INTEGER
;;*          The first element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  K2      (input) INTEGER
;;*          The last element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
;;*          The vector of pivot indices.  Only the elements in positions
;;*          K1 through K2 of IPIV are accessed.
;;*          IPIV(K) = L implies rows K and L are to be interchanged.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of IPIV.  If IPIV
;;*          is negative, the pivots are applied in reverse order.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by
;;*   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de slaswp (n  a  lda  k1  k2  ipiv  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) k1 )
	((-idx0- (-int-)) k2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) incx )
	#{ slaswp_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($k1,int), IDX_PTR($k2,int), IDX_PTR($ipiv,int), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasy2 <ltranl>  <ltranr>  <isgn>  <n1>  <n2>  <tl>  <ldtl>  <tr>  <ldtr>  <b>  <ldb>  <scale>  <x>  <ldx>  <xnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
;;*
;;*         op(TL)*X + ISGN*X*op(TR) = SCALE*B,
;;*
;;*  where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
;;*  -1.  op(T) = T or T', where T' denotes the transpose of T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  LTRANL  (input) LOGICAL
;;*          On entry, LTRANL specifies the op(TL):
;;*             = .FALSE., op(TL) = TL,
;;*             = .TRUE., op(TL) = TL'.
;;*
;;*  LTRANR  (input) LOGICAL
;;*          On entry, LTRANR specifies the op(TR):
;;*            = .FALSE., op(TR) = TR,
;;*            = .TRUE., op(TR) = TR'.
;;*
;;*  ISGN    (input) INTEGER
;;*          On entry, ISGN specifies the sign of the equation
;;*          as described before. ISGN may only be 1 or -1.
;;*
;;*  N1      (input) INTEGER
;;*          On entry, N1 specifies the order of matrix TL.
;;*          N1 may only be 0, 1 or 2.
;;*
;;*  N2      (input) INTEGER
;;*          On entry, N2 specifies the order of matrix TR.
;;*          N2 may only be 0, 1 or 2.
;;*
;;*  TL      (input) REAL array, dimension (LDTL,2)
;;*          On entry, TL contains an N1 by N1 matrix.
;;*
;;*  LDTL    (input) INTEGER
;;*          The leading dimension of the matrix TL. LDTL >= max(1,N1).
;;*
;;*  TR      (input) REAL array, dimension (LDTR,2)
;;*          On entry, TR contains an N2 by N2 matrix.
;;*
;;*  LDTR    (input) INTEGER
;;*          The leading dimension of the matrix TR. LDTR >= max(1,N2).
;;*
;;*  B       (input) REAL array, dimension (LDB,2)
;;*          On entry, the N1 by N2 matrix B contains the right-hand
;;*          side of the equation.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the matrix B. LDB >= max(1,N1).
;;*
;;*  SCALE   (output) REAL
;;*          On exit, SCALE contains the scale factor. SCALE is chosen
;;*          less than or equal to 1 to prevent the solution overflowing.
;;*
;;*  X       (output) REAL array, dimension (LDX,2)
;;*          On exit, X contains the N1 by N2 solution.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the matrix X. LDX >= max(1,N1).
;;*
;;*  XNORM   (output) REAL
;;*          On exit, XNORM is the infinity-norm of the solution.
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, INFO is set to
;;*             0: successful exit.
;;*             1: TL and TR have too close eigenvalues, so TL or
;;*                TR is perturbed to get a nonsingular equation.
;;*          NOTE: In the interests of speed, this routine does not
;;*                check the inputs for errors.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasy2 (ltranl  ltranr  isgn  n1  n2  tl  ldtl  tr  ldtr  b  ldb  scale  x  ldx  xnorm  info  )
	((-idx0- (-int-)) ltranl )
	((-idx0- (-int-)) ltranr )
	((-idx0- (-int-)) isgn )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx2- (-float-)) tl )
	((-idx0- (-int-)) ldtl )
	((-idx2- (-float-)) tr )
	((-idx0- (-int-)) ldtr )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) scale )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) xnorm )
	((-idx0- (-int-)) info )
	#{ slasy2_(IDX_PTR($ltranl,int), IDX_PTR($ltranr,int), IDX_PTR($isgn,int), IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($tl,float), IDX_PTR($ldtl,int), IDX_PTR($tr,float), IDX_PTR($ldtr,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($scale,float), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($xnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slasyf <uplo>  <n>  <nb>  <kb>  <a>  <lda>  <ipiv>  <w>  <ldw>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLASYF computes a partial factorization of a real symmetric matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method. The partial
;;*  factorization has the form:
;;*
;;*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or:
;;*        ( 0  U22 ) (  0   D  ) ( U12' U22' )
;;*
;;*  A  =  ( L11  0 ) (  D   0  ) ( L11' L21' )  if UPLO = 'L'
;;*        ( L21  I ) (  0  A22 ) (  0    I   )
;;*
;;*  where the order of D is at most NB. The actual order is returned in
;;*  the argument KB, and is either NB or NB-1, or N if N <= NB.
;;*
;;*  SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code
;;*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
;;*  A22 (if UPLO = 'L').
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NB      (input) INTEGER
;;*          The maximum number of columns of the matrix A that should be
;;*          factored.  NB should be at least 2 to allow for 2-by-2 pivot
;;*          blocks.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns of A that were actually factored.
;;*          KB is either NB-1 or NB, or N if N <= NB.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, A contains details of the partial factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If UPLO = 'U', only the last KB elements of IPIV are set;
;;*          if UPLO = 'L', only the first KB elements are set.
;;*
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  W       (workspace) REAL array, dimension (LDW,NB)
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W.  LDW >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slasyf (uplo  n  nb  kb  a  lda  ipiv  w  ldw  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) w )
	((-idx0- (-int-)) ldw )
	((-idx0- (-int-)) info )
	#{ slasyf_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($w,float), IDX_PTR($ldw,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatbs <uplo>  <trans>  <diag>  <normin>  <n>  <kd>  <ab>  <ldab>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLATBS solves one of the triangular systems
;;*
;;*     A *x = s*b  or  A'*x = s*b
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular band matrix.  Here A' denotes the transpose of A, x and b
;;*  are n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine STBSV is called.  If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b  (No transpose)
;;*          = 'T':  Solve A'* x = s*b  (Transpose)
;;*          = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of subdiagonals or superdiagonals in the
;;*          triangular matrix A.  KD >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first KD+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  X       (input/output) REAL array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) REAL
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b  or  A'* x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) REAL array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, STBSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine STBSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A'*x = b.  The basic
;;*  algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call STBSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatbs (uplo  trans  diag  normin  n  kd  ab  ldab  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) x )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) cnorm )
	((-idx0- (-int-)) info )
	#{ slatbs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($x,float), IDX_PTR($scale,float), IDX_PTR($cnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatdf <ijob>  <n>  <z>  <ldz>  <rhs>  <rdsum>  <rdscal>  <ipiv>  <jpiv>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLATDF uses the LU factorization of the n-by-n matrix Z computed by
;;*  SGETC2 and computes a contribution to the reciprocal Dif-estimate
;;*  by solving Z * x = b for x, and choosing the r.h.s. b such that
;;*  the norm of x is as large as possible. On entry RHS = b holds the
;;*  contribution from earlier solved sub-systems, and on return RHS = x.
;;*
;;*  The factorization of Z returned by SGETC2 has the form Z = P*L*U*Q,
;;*  where P and Q are permutation matrices. L is lower triangular with
;;*  unit diagonal elements and U is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          IJOB = 2: First compute an approximative null-vector e
;;*              of Z using SGECON, e is normalized and solve for
;;*              Zx = +-e - f with the sign giving the greater value
;;*              of 2-norm(x). About 5 times as expensive as Default.
;;*          IJOB .ne. 2: Local look ahead strategy where all entries of
;;*              the r.h.s. b is choosen as either +1 or -1 (Default).
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Z.
;;*
;;*  Z       (input) REAL array, dimension (LDZ, N)
;;*          On entry, the LU part of the factorization of the n-by-n
;;*          matrix Z computed by SGETC2:  Z = P * L * U * Q
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) REAL array, dimension N.
;;*          On entry, RHS contains contributions from other subsystems.
;;*          On exit, RHS contains the solution of the subsystem with
;;*          entries acoording to the value of IJOB (see above).
;;*
;;*  RDSUM   (input/output) REAL
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by STGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when STGSY2 is called by STGSYL.
;;*
;;*  RDSCAL  (input/output) REAL
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when STGSY2 is called by
;;*                STGSYL.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  This routine is a further developed implementation of algorithm
;;*  BSOLVE in [1] using complete pivoting in the LU factorization.
;;*
;;*  [1] Bo Kagstrom and Lars Westin,
;;*      Generalized Schur Methods with Condition Estimators for
;;*      Solving the Generalized Sylvester Equation, IEEE Transactions
;;*      on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751.
;;*
;;*  [2] Peter Poromaa,
;;*      On Efficient and Robust Estimators for the Separation
;;*      between two Regular Matrix Pairs with Applications in
;;*      Condition Estimation. Report IMINF-95.05, Departement of
;;*      Computing Science, Umea University, S-901 87 Umea, Sweden, 1995.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatdf (ijob  n  z  ldz  rhs  rdsum  rdscal  ipiv  jpiv  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) rhs )
	((-idx0- (-float-)) rdsum )
	((-idx0- (-float-)) rdscal )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	#{ slatdf_(IDX_PTR($ijob,int), IDX_PTR($n,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($rhs,float), IDX_PTR($rdsum,float), IDX_PTR($rdscal,float), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatps <uplo>  <trans>  <diag>  <normin>  <n>  <ap>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLATPS solves one of the triangular systems
;;*
;;*     A *x = s*b  or  A'*x = s*b
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular matrix stored in packed form.  Here A' denotes the
;;*  transpose of A, x and b are n-element vectors, and s is a scaling
;;*  factor, usually less than or equal to 1, chosen so that the
;;*  components of x will be less than the overflow threshold.  If the
;;*  unscaled problem will not cause overflow, the Level 2 BLAS routine
;;*  STPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
;;*  then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b  (No transpose)
;;*          = 'T':  Solve A'* x = s*b  (Transpose)
;;*          = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  X       (input/output) REAL array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) REAL
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b  or  A'* x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) REAL array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, STPSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine STPSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A'*x = b.  The basic
;;*  algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call STPSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatps (uplo  trans  diag  normin  n  ap  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) x )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) cnorm )
	((-idx0- (-int-)) info )
	#{ slatps_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($x,float), IDX_PTR($scale,float), IDX_PTR($cnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatrd <uplo>  <n>  <nb>  <a>  <lda>  <e>  <tau>  <w>  <ldw>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLATRD reduces NB rows and columns of a real symmetric matrix A to
;;*  symmetric tridiagonal form by an orthogonal similarity
;;*  transformation Q' * A * Q, and returns the matrices V and W which are
;;*  needed to apply the transformation to the unreduced part of A.
;;*
;;*  If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
;;*  matrix, of which the upper triangle is supplied;
;;*  if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
;;*  matrix, of which the lower triangle is supplied.
;;*
;;*  This is an auxiliary routine called by SSYTRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U': Upper triangular
;;*          = 'L': Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of rows and columns to be reduced.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit:
;;*          if UPLO = 'U', the last NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements above the diagonal
;;*            with the array TAU, represent the orthogonal matrix Q as a
;;*            product of elementary reflectors;
;;*          if UPLO = 'L', the first NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements below the diagonal
;;*            with the array TAU, represent the  orthogonal matrix Q as a
;;*            product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= (1,N).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
;;*          elements of the last NB columns of the reduced matrix;
;;*          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
;;*          the first NB columns of the reduced matrix.
;;*
;;*  TAU     (output) REAL array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors, stored in
;;*          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
;;*          See Further Details.
;;*
;;*  W       (output) REAL array, dimension (LDW,NB)
;;*          The n-by-nb matrix W required to update the unreduced part
;;*          of A.
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W. LDW >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n) H(n-1) . . . H(n-nb+1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
;;*  and tau in TAU(i-1).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the n-by-nb matrix V
;;*  which is needed, with W, to apply the transformation to the unreduced
;;*  part of the matrix, using a symmetric rank-2k update of the form:
;;*  A := A - V*W' - W*V'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5 and nb = 2:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  a   a   a   v4  v5 )              (  d                  )
;;*    (      a   a   v4  v5 )              (  1   d              )
;;*    (          a   1   v5 )              (  v1  1   a          )
;;*    (              d   1  )              (  v1  v2  a   a      )
;;*    (                  d  )              (  v1  v2  a   a   a  )
;;*
;;*  where d denotes a diagonal element of the reduced matrix, a denotes
;;*  an element of the original matrix that is unchanged, and vi denotes
;;*  an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatrd (uplo  n  nb  a  lda  e  tau  w  ldw  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) w )
	((-idx0- (-int-)) ldw )
	#{ slatrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($w,float), IDX_PTR($ldw,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatrs <uplo>  <trans>  <diag>  <normin>  <n>  <a>  <lda>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLATRS solves one of the triangular systems
;;*
;;*     A *x = s*b  or  A'*x = s*b
;;*
;;*  with scaling to prevent overflow.  Here A is an upper or lower
;;*  triangular matrix, A' denotes the transpose of A, x and b are
;;*  n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine STRSV is called.  If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b  (No transpose)
;;*          = 'T':  Solve A'* x = s*b  (Transpose)
;;*          = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max (1,N).
;;*
;;*  X       (input/output) REAL array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) REAL
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b  or  A'* x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) REAL array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, STRSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine STRSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A'*x = b.  The basic
;;*  algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call STRSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatrs (uplo  trans  diag  normin  n  a  lda  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) x )
	((-idx0- (-float-)) scale )
	((-idx1- (-float-)) cnorm )
	((-idx0- (-int-)) info )
	#{ slatrs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($scale,float), IDX_PTR($cnorm,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatrz <m>  <n>  <l>  <a>  <lda>  <tau>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLATRZ factors the M-by-(M+L) real upper trapezoidal matrix
;;*  [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means
;;*  of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal
;;*  matrix and, R and A1 are M-by-M upper triangular matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing the
;;*          meaningful part of the Householder vectors. N-M >= L >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements N-L+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          orthogonal matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) REAL array, dimension (M)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an l element vector. tau and z( k )
;;*  are chosen to annihilate the elements of the kth row of A2.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A2, such that the elements of z( k ) are
;;*  in  a( k, l + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A1.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatrz (m  n  l  a  lda  tau  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	#{ slatrz_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slatzm <side>  <m>  <n>  <v>  <incv>  <tau>  <c1>  <c2>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine SORMRZ.
;;*
;;*  SLATZM applies a Householder matrix generated by STZRQF to a matrix.
;;*
;;*  Let P = I - tau*u*u',   u = ( 1 ),
;;*                              ( v )
;;*  where v is an (m-1) vector if SIDE = 'L', or a (n-1) vector if
;;*  SIDE = 'R'.
;;*
;;*  If SIDE equals 'L', let
;;*         C = [ C1 ] 1
;;*             [ C2 ] m-1
;;*               n
;;*  Then C is overwritten by P*C.
;;*
;;*  If SIDE equals 'R', let
;;*         C = [ C1, C2 ] m
;;*                1  n-1
;;*  Then C is overwritten by C*P.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form P * C
;;*          = 'R': form C * P
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) REAL array, dimension
;;*                  (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of P. V is not used
;;*          if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0
;;*
;;*  TAU     (input) REAL
;;*          The value tau in the representation of P.
;;*
;;*  C1      (input/output) REAL array, dimension
;;*                         (LDC,N) if SIDE = 'L'
;;*                         (M,1)   if SIDE = 'R'
;;*          On entry, the n-vector C1 if SIDE = 'L', or the m-vector C1
;;*          if SIDE = 'R'.
;;*
;;*          On exit, the first row of P*C if SIDE = 'L', or the first
;;*          column of C*P if SIDE = 'R'.
;;*
;;*  C2      (input/output) REAL array, dimension
;;*                         (LDC, N)   if SIDE = 'L'
;;*                         (LDC, N-1) if SIDE = 'R'
;;*          On entry, the (m - 1) x n matrix C2 if SIDE = 'L', or the
;;*          m x (n - 1) matrix C2 if SIDE = 'R'.
;;*
;;*          On exit, rows 2:m of P*C if SIDE = 'L', or columns 2:m of C*P
;;*          if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the arrays C1 and C2. LDC >= (1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                      (N) if SIDE = 'L'
;;*                      (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slatzm (side  m  n  v  incv  tau  c1  c2  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) v )
	((-idx0- (-int-)) incv )
	((-idx0- (-float-)) tau )
	((-idx2- (-float-)) c1 )
	((-idx2- (-float-)) c2 )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	#{ slatzm_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,float), IDX_PTR($incv,int), IDX_PTR($tau,float), IDX_PTR($c1,float), IDX_PTR($c2,float), IDX_PTR($ldc,int), IDX_PTR($work,float)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slauu2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAUU2 computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the unblocked form of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slauu2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ slauu2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (slauum <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SLAUUM computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the blocked form of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de slauum (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ slauum_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sopgtr <uplo>  <n>  <ap>  <tau>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SOPGTR generates a real orthogonal matrix Q which is defined as the
;;*  product of n-1 elementary reflectors H(i) of order n, as returned by
;;*  SSPTRD using packed storage:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to SSPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to SSPTRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The vectors which define the elementary reflectors, as
;;*          returned by SSPTRD.
;;*
;;*  TAU     (input) REAL array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SSPTRD.
;;*
;;*  Q       (output) REAL array, dimension (LDQ,N)
;;*          The N-by-N orthogonal matrix Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (N-1)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sopgtr (uplo  n  ap  tau  q  ldq  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sopgtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($tau,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sopmtr <side>  <uplo>  <trans>  <m>  <n>  <ap>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SOPMTR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by SSPTRD using packed
;;*  storage:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to SSPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to SSPTRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  AP      (input) REAL array, dimension
;;*                               (M*(M+1)/2) if SIDE = 'L'
;;*                               (N*(N+1)/2) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by SSPTRD.  AP is modified by the routine but
;;*          restored on exit.
;;*
;;*  TAU     (input) REAL array, dimension (M-1) if SIDE = 'L'
;;*                                     or (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SSPTRD.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                                   (N) if SIDE = 'L'
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sopmtr (side  uplo  trans  m  n  ap  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sopmtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorg2l <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORG2L generates an m by n real matrix Q with orthonormal columns,
;;*  which is defined as the last n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by SGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQLF.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorg2l (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorg2l_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorg2r <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORG2R generates an m by n real matrix Q with orthonormal columns,
;;*  which is defined as the first n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by SGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQRF.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorg2r (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorg2r_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgbr <vect>  <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGBR generates one of the real orthogonal matrices Q or P**T
;;*  determined by SGEBRD when reducing a real matrix A to bidiagonal
;;*  form: A = Q * B * P**T.  Q and P**T are defined as products of
;;*  elementary reflectors H(i) or G(i) respectively.
;;*
;;*  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
;;*  is of order M:
;;*  if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n
;;*  columns of Q, where m >= n >= k;
;;*  if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an
;;*  M-by-M matrix.
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
;;*  is of order N:
;;*  if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m
;;*  rows of P**T, where n >= m >= k;
;;*  if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as
;;*  an N-by-N matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether the matrix Q or the matrix P**T is
;;*          required, as defined in the transformation applied by SGEBRD:
;;*          = 'Q':  generate Q;
;;*          = 'P':  generate P**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q or P**T to be returned.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q or P**T to be returned.
;;*          N >= 0.
;;*          If VECT = 'Q', M >= N >= min(M,K);
;;*          if VECT = 'P', N >= M >= min(N,K).
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original M-by-K
;;*          matrix reduced by SGEBRD.
;;*          If VECT = 'P', the number of rows in the original K-by-N
;;*          matrix reduced by SGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by SGEBRD.
;;*          On exit, the M-by-N matrix Q or P**T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension
;;*                                (min(M,K)) if VECT = 'Q'
;;*                                (min(N,K)) if VECT = 'P'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i), which determines Q or P**T, as
;;*          returned by SGEBRD in its array argument TAUQ or TAUP.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,min(M,N)).
;;*          For optimum performance LWORK >= min(M,N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgbr (vect  m  n  k  a  lda  tau  work  lwork  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorgbr_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorghr <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGHR generates a real orthogonal matrix Q which is defined as the
;;*  product of IHI-ILO elementary reflectors of order N, as returned by
;;*  SGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of SGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by SGEHRD.
;;*          On exit, the N-by-N orthogonal matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAU     (input) REAL array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEHRD.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= IHI-ILO.
;;*          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorghr (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorghr_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgl2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGL2 generates an m by n real matrix Q with orthonormal rows,
;;*  which is defined as the first m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by SGELQF in the first k rows of its array argument A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGELQF.
;;*
;;*  WORK    (workspace) REAL array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgl2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorgl2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorglq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGLQ generates an M-by-N real matrix Q with orthonormal rows,
;;*  which is defined as the first M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by SGELQF in the first k rows of its array argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGELQF.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorglq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorglq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgql <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGQL generates an M-by-N real matrix Q with orthonormal columns,
;;*  which is defined as the last N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by SGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQLF.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgql (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorgql_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgqr <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGQR generates an M-by-N real matrix Q with orthonormal columns,
;;*  which is defined as the first N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by SGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQRF.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgqr (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorgqr_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgr2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGR2 generates an m by n real matrix Q with orthonormal rows,
;;*  which is defined as the last m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by SGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGERQF.
;;*
;;*  WORK    (workspace) REAL array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgr2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorgr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgrq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGRQ generates an M-by-N real matrix Q with orthonormal rows,
;;*  which is defined as the last M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by SGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGERQF.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgrq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorgrq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorgtr <uplo>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORGTR generates a real orthogonal matrix Q which is defined as the
;;*  product of n-1 elementary reflectors of order N, as returned by
;;*  SSYTRD:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from SSYTRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from SSYTRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by SSYTRD.
;;*          On exit, the N-by-N orthogonal matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAU     (input) REAL array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SSYTRD.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N-1).
;;*          For optimum performance LWORK >= (N-1)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorgtr (uplo  n  a  lda  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sorgtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorm2l <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORM2L overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQLF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorm2l (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorm2l_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorm2r <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORM2R overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGEQRF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQRF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorm2r (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorm2r_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormbr <vect>  <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      P * C          C * P
;;*  TRANS = 'T':      P**T * C       C * P**T
;;*
;;*  Here Q and P**T are the orthogonal matrices determined by SGEBRD when
;;*  reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
;;*  P**T are defined as products of elementary reflectors H(i) and G(i)
;;*  respectively.
;;*
;;*  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
;;*  order of the orthogonal matrix Q or P**T that is applied.
;;*
;;*  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
;;*  if nq >= k, Q = H(1) H(2) . . . H(k);
;;*  if nq < k, Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
;;*  if k < nq, P = G(1) G(2) . . . G(k);
;;*  if k >= nq, P = G(1) G(2) . . . G(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'Q': apply Q or Q**T;
;;*          = 'P': apply P or P**T.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q, Q**T, P or P**T from the Left;
;;*          = 'R': apply Q, Q**T, P or P**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q  or P;
;;*          = 'T':  Transpose, apply Q**T or P**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original
;;*          matrix reduced by SGEBRD.
;;*          If VECT = 'P', the number of rows in the original
;;*          matrix reduced by SGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                                (LDA,min(nq,K)) if VECT = 'Q'
;;*                                (LDA,nq)        if VECT = 'P'
;;*          The vectors which define the elementary reflectors H(i) and
;;*          G(i), whose products determine the matrices Q and P, as
;;*          returned by SGEBRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If VECT = 'Q', LDA >= max(1,nq);
;;*          if VECT = 'P', LDA >= max(1,min(nq,K)).
;;*
;;*  TAU     (input) REAL array, dimension (min(nq,K))
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i) which determines Q or P, as returned
;;*          by SGEBRD in the array argument TAUQ or TAUP.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
;;*          or P*C or P**T*C or C*P or C*P**T.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sormbr (vect  side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) vect )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormbr_($vect->data, $side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormhr <side>  <trans>  <m>  <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMHR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  IHI-ILO elementary reflectors, as returned by SGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of SGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
;;*          ILO = 1 and IHI = 0, if M = 0;
;;*          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
;;*          ILO = 1 and IHI = 0, if N = 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by SGEHRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) REAL array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEHRD.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sormhr (side  trans  m  n  ilo  ihi  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormhr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sorml2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORML2 overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGELQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGELQF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sorml2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sorml2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormlq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMLQ overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGELQF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sormlq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormlq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormql <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMQL overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQLF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sormql (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormql_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormqr <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMQR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGEQRF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sormqr (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormqr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormr2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMR2 overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGERQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGERQF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sormr2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sormr2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormr3 <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMR3 overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by STZRZF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          STZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by STZRZF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) REAL array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sormr3 (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sormr3_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormrq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMRQ overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          SGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SGERQF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sormrq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormrq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormrz <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMRZ overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          STZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) REAL array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by STZRZF.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sormrz (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormrz_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sormtr <side>  <uplo>  <trans>  <m>  <n>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SORMTR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by SSYTRD:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from SSYTRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from SSYTRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  A       (input) REAL array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by SSYTRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) REAL array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by SSYTRD.
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sormtr (side  uplo  trans  m  n  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ sormtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbcon <uplo>  <n>  <kd>  <ab>  <ldab>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite band matrix using the
;;*  Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm (or infinity-norm) of the symmetric band matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbcon (uplo  n  kd  ab  ldab  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ spbcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbequ <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBEQU computes row and column scalings intended to equilibrate a
;;*  symmetric positive definite band matrix A and reduce its condition
;;*  number (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular of A is stored;
;;*          = 'L':  Lower triangular of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB     (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) REAL
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbequ (uplo  n  kd  ab  ldab  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ spbequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbrfs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite
;;*  and banded, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  AFB     (input) REAL array, dimension (LDAFB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T of the band matrix A as computed by
;;*          SPBTRF, in the same storage format as A (see AB).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SPBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbrfs (uplo  n  kd  nrhs  ab  ldab  afb  ldafb  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ spbrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbstf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBSTF computes a split Cholesky factorization of a real
;;*  symmetric positive definite band matrix A.
;;*
;;*  This routine is designed to be used in conjunction with SSBGST.
;;*
;;*  The factorization has the form  A = S**T*S  where S is a band matrix
;;*  of the same bandwidth as A and the following structure:
;;*
;;*    S = ( U    )
;;*        ( M  L )
;;*
;;*  where U is upper triangular of order m = (n+kd)/2, and L is lower
;;*  triangular of order n-m.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first kd+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the factor S from the split Cholesky
;;*          factorization A = S**T*S. See Further Details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the factorization could not be completed,
;;*               because the updated element a(i,i) was negative; the
;;*               matrix A is not positive definite.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 7, KD = 2:
;;*
;;*  S = ( s11  s12  s13                     )
;;*      (      s22  s23  s24                )
;;*      (           s33  s34                )
;;*      (                s44                )
;;*      (           s53  s54  s55           )
;;*      (                s64  s65  s66      )
;;*      (                     s75  s76  s77 )
;;*
;;*  If UPLO = 'U', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*   *    *   a13  a24  a35  a46  a57   *    *   s13  s24  s53  s64  s75
;;*   *   a12  a23  a34  a45  a56  a67   *   s12  s23  s34  s54  s65  s76
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*
;;*  If UPLO = 'L', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*  a21  a32  a43  a54  a65  a76   *   s12  s23  s34  s54  s65  s76   *
;;*  a31  a42  a53  a64  a64   *    *   s13  s24  s53  s64  s75   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbstf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ spbstf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbsv <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular band matrix, and L is a lower
;;*  triangular band matrix, with the same number of superdiagonals or
;;*  subdiagonals as A.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**T*U or A = L*L**T of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de spbsv (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ spbsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbsvx <fact>  <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
;;*  compute the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**T * U,  if UPLO = 'U', or
;;*        A = L * L**T,  if UPLO = 'L',
;;*     where U is an upper triangular band matrix, and L is a lower
;;*     triangular band matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AB and AFB will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right-hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array, except
;;*          if FACT = 'F' and EQUED = 'Y', then A must contain the
;;*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A
;;*          is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  AFB     (input or output) REAL array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the band matrix
;;*          A, in the same storage format as A (see AB).  If EQUED = 'Y',
;;*          then AFB is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) REAL array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11  a12  a13
;;*          a22  a23  a24
;;*               a33  a34  a35
;;*                    a44  a45  a46
;;*                         a55  a56
;;*     (aij=conjg(aji))         a66
;;*
;;*  Band storage of the upper triangle of A:
;;*
;;*      *    *   a13  a24  a35  a46
;;*      *   a12  a23  a34  a45  a56
;;*     a11  a22  a33  a44  a55  a66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*     a11  a22  a33  a44  a55  a66
;;*     a21  a32  a43  a54  a65   *
;;*     a31  a42  a53  a64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbsvx (fact  uplo  n  kd  nrhs  ab  ldab  afb  ldafb  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) afb )
	((-idx0- (-int-)) ldafb )
	((-str-) equed )
	((-idx1- (-float-)) s )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ spbsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($afb,float), IDX_PTR($ldafb,int), $equed->data, IDX_PTR($s,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbtf2 <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBTF2 computes the Cholesky factorization of a real symmetric
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix, U' is the transpose of U, and
;;*  L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbtf2 (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ spbtf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbtrf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBTRF computes the Cholesky factorization of a real symmetric
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L  * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**T*U or A = L*L**T of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  Contributed by
;;*  Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spbtrf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ spbtrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spbtrs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPBTRS solves a system of linear equations A*X = B with a symmetric
;;*  positive definite band matrix A using the Cholesky factorization
;;*  A = U**T*U or A = L*L**T computed by SPBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de spbtrs (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ spbtrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spocon <uplo>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOCON estimates the reciprocal of the condition number (in the 
;;*  1-norm) of a real symmetric positive definite matrix using the
;;*  Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by SPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm (or infinity-norm) of the symmetric matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spocon (uplo  n  a  lda  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ spocon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spoequ <n>  <a>  <lda>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOEQU computes row and column scalings intended to equilibrate a
;;*  symmetric positive definite matrix A and reduce its condition number
;;*  (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The N-by-N symmetric positive definite matrix whose scaling
;;*          factors are to be computed.  Only the diagonal elements of A
;;*          are referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) REAL
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spoequ (n  a  lda  s  scond  amax  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ spoequ_(IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sporfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPORFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite,
;;*  and provides error bounds and backward error estimates for the
;;*  solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) REAL array, dimension (LDAF,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by SPOTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SPOTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sporfs (uplo  n  nrhs  a  lda  af  ldaf  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sporfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sposv <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**T* U,  if UPLO = 'U', or
;;*     A = L * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de sposv (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sposv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sposvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
;;*  compute the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**T* U,  if UPLO = 'U', or
;;*        A = L * L**T,  if UPLO = 'L',
;;*     where U is an upper triangular matrix and L is a lower triangular
;;*     matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  A and AF will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A, except if FACT = 'F' and
;;*          EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) REAL array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AF is the factored form
;;*          of the equilibrated matrix diag(S)*A*diag(S).
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the original
;;*          matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) REAL array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sposvx (fact  uplo  n  nrhs  a  lda  af  ldaf  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-str-) equed )
	((-idx1- (-float-)) s )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sposvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), $equed->data, IDX_PTR($s,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spotf2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOTF2 computes the Cholesky factorization of a real symmetric
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U'*U  or A = L*L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spotf2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ spotf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spotrf <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOTRF computes the Cholesky factorization of a real symmetric
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L  * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the block version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spotrf (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ spotrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spotri <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOTRI computes the inverse of a real symmetric positive definite
;;*  matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
;;*  computed by SPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, as computed by
;;*          SPOTRF.
;;*          On exit, the upper or lower triangle of the (symmetric)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de spotri (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ spotri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spotrs <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPOTRS solves a system of linear equations A*X = B with a symmetric
;;*  positive definite matrix A using the Cholesky factorization
;;*  A = U**T*U or A = L*L**T computed by SPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by SPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spotrs (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ spotrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sppcon <uplo>  <n>  <ap>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite packed matrix using
;;*  the Cholesky factorization A = U**T*U or A = L*L**T computed by
;;*  SPPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm (or infinity-norm) of the symmetric matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sppcon (uplo  n  ap  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sppcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sppequ <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPEQU computes row and column scalings intended to equilibrate a
;;*  symmetric positive definite matrix A in packed storage and reduce
;;*  its condition number (with respect to the two-norm).  S contains the
;;*  scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
;;*  B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
;;*  This choice of S puts the condition number of B within a factor N of
;;*  the smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  S       (output) REAL array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) REAL
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) REAL
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sppequ (uplo  n  ap  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) s )
	((-idx0- (-float-)) scond )
	((-idx0- (-float-)) amax )
	((-idx0- (-int-)) info )
	#{ sppequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($s,float), IDX_PTR($scond,float), IDX_PTR($amax,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) REAL array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by SPPTRF/CPPTRF,
;;*          packed columnwise in a linear array in the same format as A
;;*          (see AP).
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SPPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spprfs (uplo  n  nrhs  ap  afp  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) afp )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ spprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sppsv <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**T* U,  if UPLO = 'U', or
;;*     A = L * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.  
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, in the same storage
;;*          format as A.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de sppsv (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sppsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sppsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
;;*  compute the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**T* U,  if UPLO = 'U', or
;;*        A = L * L**T,  if UPLO = 'L',
;;*     where U is an upper triangular matrix and L is a lower triangular
;;*     matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFP contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AP and AFP will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array, except if FACT = 'F'
;;*          and EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  The j-th column of A is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  AFP     (input or output) REAL array, dimension
;;*                            (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U'*U or A = L*L', in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AFP is the factored
;;*          form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U'*U or A = L*L' of the original matrix A.
;;*
;;*          If FACT = 'E', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U'*U or A = L*L' of the equilibrated
;;*          matrix A (see the description of AP for the form of the
;;*          equilibrated matrix).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) REAL array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sppsvx (fact  uplo  n  nrhs  ap  afp  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) afp )
	((-str-) equed )
	((-idx1- (-float-)) s )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sppsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), $equed->data, IDX_PTR($s,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spptrf <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPTRF computes the Cholesky factorization of a real symmetric
;;*  positive definite matrix A stored in packed format.
;;*
;;*  The factorization has the form
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L  * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**T*U or A = L*L**T, in the same
;;*          storage format as A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spptrf (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx0- (-int-)) info )
	#{ spptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spptri <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPTRI computes the inverse of a real symmetric positive definite
;;*  matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
;;*  computed by SPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor is stored in AP;
;;*          = 'L':  Lower triangular factor is stored in AP.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, packed columnwise as
;;*          a linear array.  The j-th column of U or L is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*          On exit, the upper or lower triangle of the (symmetric)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spptri (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx0- (-int-)) info )
	#{ spptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spptrs <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPPTRS solves a system of linear equations A*X = B with a symmetric
;;*  positive definite matrix A in packed storage using the Cholesky
;;*  factorization A = U**T*U or A = L*L**T computed by SPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de spptrs (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ spptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sptcon <n>  <d>  <e>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTCON computes the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite tridiagonal matrix
;;*  using the factorization A = L*D*L**T or A = U**T*D*U computed by
;;*  SPTTRF.
;;*
;;*  Norm(inv(A)) is computed by a direct method, and the reciprocal of
;;*  the condition number is computed as
;;*               RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization of A, as computed by SPTTRF.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the unit bidiagonal factor
;;*          U or L from the factorization of A,  as computed by SPTTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the
;;*          1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The method used is described in Nicholas J. Higham, "Efficient
;;*  Algorithms for Computing the Condition Number of a Tridiagonal
;;*  Matrix", SIAM J. Sci. Stat. Comput., Vol. 7, No. 1, January 1986.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sptcon (n  d  e  anorm  rcond  work  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sptcon_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric positive definite tridiagonal matrix by first factoring the
;;*  matrix using SPTTRF, and then calling SBDSQR to compute the singular
;;*  values of the bidiagonal factor.
;;*
;;*  This routine computes the eigenvalues of the positive definite
;;*  tridiagonal matrix to high relative accuracy.  This means that if the
;;*  eigenvalues range over many orders of magnitude in size, then the
;;*  small eigenvalues and corresponding eigenvectors will be computed
;;*  more accurately than, for example, with the standard QR method.
;;*
;;*  The eigenvectors of a full or band symmetric positive definite matrix
;;*  can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to
;;*  reduce this matrix to tridiagonal form. (The reduction to tridiagonal
;;*  form, however, may preclude the possibility of obtaining high
;;*  relative accuracy in the small eigenvalues of the original matrix, if
;;*  these eigenvalues range over many orders of magnitude.)
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvectors of original symmetric
;;*                  matrix also.  Array Z contains the orthogonal
;;*                  matrix used to reduce the original matrix to
;;*                  tridiagonal form.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal
;;*          matrix.
;;*          On normal exit, D contains the eigenvalues, in descending
;;*          order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ, N)
;;*          On entry, if COMPZ = 'V', the orthogonal matrix used in the
;;*          reduction to tridiagonal form.
;;*          On exit, if COMPZ = 'V', the orthonormal eigenvectors of the
;;*          original symmetric matrix;
;;*          if COMPZ = 'I', the orthonormal eigenvectors of the
;;*          tridiagonal matrix.
;;*          If INFO > 0 on exit, Z contains the eigenvectors associated
;;*          with only the stored eigenvalues.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          COMPZ = 'V' or 'I', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, and i is:
;;*                <= N  the Cholesky factorization of the matrix could
;;*                      not be performed because the i-th principal minor
;;*                      was not positive definite.
;;*                > N   the SVD algorithm failed to converge;
;;*                      if INFO = N+i, i off-diagonal elements of the
;;*                      bidiagonal factor did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ spteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sptrfs <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite
;;*  and tridiagonal, and provides error bounds and backward error
;;*  estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix A.
;;*
;;*  DF      (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization computed by SPTTRF.
;;*
;;*  EF      (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal factor
;;*          L from the factorization computed by SPTTRF.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SPTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sptrfs (n  nrhs  d  e  df  ef  b  ldb  x  ldx  ferr  berr  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) df )
	((-idx1- (-float-)) ef )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sptrfs_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($df,float), IDX_PTR($ef,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sptsv <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTSV computes the solution to a real system of linear equations
;;*  A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
;;*  matrix, and X and B are N-by-NRHS matrices.
;;*
;;*  A is factored as A = L*D*L**T, and the factored form of A is then
;;*  used to solve the system of equations.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the factorization A = L*D*L**T.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L**T factorization of
;;*          A.  (E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U**T*D*U factorization of A.)
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the solution has not been
;;*                computed.  The factorization has not been completed
;;*                unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de sptsv (n  nrhs  d  e  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sptsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sptsvx <fact>  <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTSVX uses the factorization A = L*D*L**T to compute the solution
;;*  to a real system of linear equations A*X = B, where A is an N-by-N
;;*  symmetric positive definite tridiagonal matrix and X and B are
;;*  N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the matrix A is factored as A = L*D*L**T, where L
;;*     is a unit lower bidiagonal matrix and D is diagonal.  The
;;*     factorization can also be regarded as having the form
;;*     A = U**T*D*U.
;;*
;;*  2. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, DF and EF contain the factored form of A.
;;*                  D, E, DF, and EF will not be modified.
;;*          = 'N':  The matrix A will be copied to DF and EF and
;;*                  factored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix A.
;;*
;;*  DF      (input or output) REAL array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**T factorization of A.
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**T factorization of A.
;;*
;;*  EF      (input or output) REAL array, dimension (N-1)
;;*          If FACT = 'F', then EF is an input argument and on entry
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**T factorization of A.
;;*          If FACT = 'N', then EF is an output argument and on exit
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**T factorization of A.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal condition number of the matrix A.  If RCOND
;;*          is less than the machine precision (in particular, if
;;*          RCOND = 0), the matrix is singular to working precision.
;;*          This condition is indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in any
;;*          element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sptsvx (fact  n  nrhs  d  e  df  ef  b  ldb  x  ldx  rcond  ferr  berr  work  info  )
	((-str-) fact )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) df )
	((-idx1- (-float-)) ef )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sptsvx_($fact->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($df,float), IDX_PTR($ef,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spttrf <n>  <d>  <e>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTTRF computes the L*D*L' factorization of a real symmetric
;;*  positive definite tridiagonal matrix A.  The factorization may also
;;*  be regarded as having the form A = U'*D*U.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the L*D*L' factorization of A.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L' factorization of A.
;;*          E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U'*D*U factorization of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite; if k < N, the factorization could not
;;*               be completed, while if k = N, the factorization was
;;*               completed, but D(N) = 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de spttrf (n  d  e  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-int-)) info )
	#{ spttrf_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (spttrs <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTTRS solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the L*D*L' factorization of A computed by SPTTRF.  D is a
;;*  diagonal matrix specified in the vector D, L is a unit bidiagonal
;;*  matrix whose subdiagonal is specified in the vector E, and X and B
;;*  are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          L*D*L' factorization of A.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal factor
;;*          L from the L*D*L' factorization of A.  E can also be regarded
;;*          as the superdiagonal of the unit bidiagonal factor U from the
;;*          factorization A = U'*D*U.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de spttrs (n  nrhs  d  e  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ spttrs_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sptts2 <n>  <nrhs>  <d>  <e>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SPTTS2 solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the L*D*L' factorization of A computed by SPTTRF.  D is a
;;*  diagonal matrix specified in the vector D, L is a unit bidiagonal
;;*  matrix whose subdiagonal is specified in the vector E, and X and B
;;*  are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          L*D*L' factorization of A.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal factor
;;*          L from the L*D*L' factorization of A.  E can also be regarded
;;*          as the superdiagonal of the unit bidiagonal factor U from the
;;*          factorization A = U'*D*U.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sptts2 (n  nrhs  d  e  b  ldb  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ sptts2_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (srscl <n>  <sa>  <sx>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SRSCL multiplies an n-element real vector x by the real scalar 1/a.
;;*  This is done without overflow or underflow as long as
;;*  the final result x/a does not overflow or underflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of components of the vector x.
;;*
;;*  SA      (input) REAL
;;*          The scalar a which is used to divide each component of x.
;;*          SA must be >= 0, or the subroutine will divide by zero.
;;*
;;*  SX      (input/output) REAL array, dimension
;;*                         (1+(N-1)*abs(INCX))
;;*          The n-element vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector SX.
;;*          > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1< i<= n
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de srscl (n  sa  sx  incx  )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) sa )
	((-idx1- (-float-)) sx )
	((-idx0- (-int-)) incx )
	#{ srscl_(IDX_PTR($n,int), IDX_PTR($sa,float), IDX_PTR($sx,float), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbevd <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBEVD computes all the eigenvalues and, optionally, eigenvectors of
;;*  a real symmetric band matrix A. If eigenvectors are desired, it uses
;;*  a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          IF N <= 1,                LWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 2, LWORK must be at least 2*N.
;;*          If JOBZ  = 'V' and N > 2, LWORK must be at least
;;*                         ( 1 + 5*N + 2*N**2 ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array LIWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 2, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbevd (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ssbevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbev <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBEV computes all the eigenvalues and, optionally, eigenvectors of
;;*  a real symmetric band matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (max(1,3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbev (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssbev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbevx <jobz>  <range>  <uplo>  <n>  <kd>  <ab>  <ldab>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric band matrix A.  Eigenvalues and eigenvectors can
;;*  be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  Q       (output) REAL array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
;;*                         reduction to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'V', then
;;*          LDQ >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AB to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbevx (jobz  range  uplo  n  kd  ab  ldab  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ ssbevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbgst <vect>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <x>  <ldx>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBGST reduces a real symmetric-definite banded generalized
;;*  eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
;;*  such that C has the same bandwidth as A.
;;*
;;*  B must have been previously factorized as S**T*S by SPBSTF, using a
;;*  split Cholesky factorization. A is overwritten by C = X**T*A*X, where
;;*  X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
;;*  bandwidth of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form the transformation matrix X;
;;*          = 'V':  form X.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= KB >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the transformed matrix X**T*A*X, stored in the same
;;*          format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input) REAL array, dimension (LDBB,N)
;;*          The banded factor S from the split Cholesky factorization of
;;*          B, as returned by SPBSTF, stored in the first KB+1 rows of
;;*          the array.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  X       (output) REAL array, dimension (LDX,N)
;;*          If VECT = 'V', the n-by-n matrix X.
;;*          If VECT = 'N', the array X is not referenced.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.
;;*          LDX >= max(1,N) if VECT = 'V'; LDX >= 1 otherwise.
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbgst (vect  uplo  n  ka  kb  ab  ldab  bb  ldbb  x  ldx  work  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssbgst_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbgvd <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite banded eigenproblem, of the
;;*  form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
;;*  banded, and B is also positive definite.  If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KB >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) REAL array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**T*S, as returned by SPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i).  The eigenvectors are
;;*          normalized so Z**T*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= 3*N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if LIWORK > 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then SPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbgvd (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ssbgvd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbgv <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
;;*  and banded, and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) REAL array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**T*S, as returned by SPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**T*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then SPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ssbgv (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssbgv_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbgvx <jobz>  <range>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a real generalized symmetric-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
;;*  and banded, and B is also positive definite.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either all eigenvalues,
;;*  a range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KB >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) REAL array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**T*S, as returned by SPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  Q       (output) REAL array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the n-by-n matrix used in the reduction of
;;*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
;;*          and consequently C to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'N',
;;*          LDQ >= 1. If JOBZ = 'V', LDQ >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i).  The eigenvectors are
;;*          normalized so Z**T*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (7N)
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (5N)
;;*
;;*  IFAIL   (input) INTEGER array, dimension (M)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvalues that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0 : successful exit
;;*          < 0 : if INFO = -i, the i-th argument had an illegal value
;;*          <= N: if INFO = i, then i eigenvectors failed to converge.
;;*                  Their indices are stored in IFAIL.
;;*          > N : SPBSTF returned an error code; i.e.,
;;*                if INFO = N + i, for 1 <= i <= N, then the leading
;;*                minor of order i of B is not positive definite.
;;*                The factorization of B could not be completed and
;;*                no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbgvx (jobz  range  uplo  n  ka  kb  ab  ldab  bb  ldbb  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ ssbgvx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($bb,float), IDX_PTR($ldbb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssbtrd <vect>  <uplo>  <n>  <kd>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSBTRD reduces a real symmetric band matrix A to symmetric
;;*  tridiagonal form T by an orthogonal similarity transformation:
;;*  Q**T * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form Q;
;;*          = 'V':  form Q;
;;*          = 'U':  update a matrix X, by forming X*Q.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) REAL array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          On exit, the diagonal elements of AB are overwritten by the
;;*          diagonal elements of the tridiagonal matrix T; if KD > 0, the
;;*          elements on the first superdiagonal (if UPLO = 'U') or the
;;*          first subdiagonal (if UPLO = 'L') are overwritten by the
;;*          off-diagonal elements of T; the rest of AB is overwritten by
;;*          values generated during the reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ,N)
;;*          On entry, if VECT = 'U', then Q must contain an N-by-N
;;*          matrix X; if VECT = 'N' or 'V', then Q need not be set.
;;*
;;*          On exit:
;;*          if VECT = 'V', Q contains the N-by-N orthogonal matrix Q;
;;*          if VECT = 'U', Q contains the product X*Q;
;;*          if VECT = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1, and LDQ >= N if VECT = 'V' or 'U'.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by Linda Kaufman, Bell Labs.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssbtrd (vect  uplo  n  kd  ab  ldab  d  e  q  ldq  work  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssbtrd_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspcon <uplo>  <n>  <ap>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric packed matrix A using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by SSPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by SSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSPTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  IWORK    (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspcon (uplo  n  ap  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sspcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspevd <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPEVD computes all the eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix A in packed storage. If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least 2*N.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least
;;*                                                 1 + 6*N + N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspevd (jobz  uplo  n  ap  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ sspevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspev <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPEV computes all the eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric matrix A in packed storage.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspev (jobz  uplo  n  ap  w  z  ldz  work  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sspev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspevx <jobz>  <range>  <uplo>  <n>  <ap>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix A in packed storage.  Eigenvalues/vectors
;;*  can be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the selected eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (8*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspevx (jobz  range  uplo  n  ap  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ sspevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspgst <itype>  <uplo>  <n>  <ap>  <bp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPGST reduces a real symmetric-definite generalized eigenproblem
;;*  to standard form, using packed storage.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
;;*
;;*  B must have been previously factorized as U**T*U or L*L**T by SPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T);
;;*          = 2 or 3: compute U*A*U**T or L**T*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**T*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  BP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          stored in the same format as A, as returned by SPPTRF.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspgst (itype  uplo  n  ap  bp  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) bp )
	((-idx0- (-int-)) info )
	#{ sspgst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspgvd <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be symmetric, stored in packed format, and B is also
;;*  positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T, in the same storage
;;*          format as B.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= 2*N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 1 + 6*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  SPPTRF or SSPEVD returned an error code:
;;*             <= N:  if INFO = i, SSPEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspgvd (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) bp )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ sspgvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspgv <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPGV computes all the eigenvalues and, optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be symmetric, stored in packed format,
;;*  and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension
;;*                            (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T, in the same storage
;;*          format as B.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  SPPTRF or SSPEV returned an error code:
;;*             <= N:  if INFO = i, SSPEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero.
;;*             > N:   if INFO = n + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sspgv (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) bp )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sspgv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspgvx <itype>  <jobz>  <range>  <uplo>  <n>  <ap>  <bp>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
;;*  and B are assumed to be symmetric, stored in packed storage, and B
;;*  is also positive definite.  Eigenvalues and eigenvectors can be
;;*  selected by specifying either a range of values or a range of indices
;;*  for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A and B are stored;
;;*          = 'L':  Lower triangle of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix pencil (A,B).  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T, in the same storage
;;*          format as B.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (8*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  SPPTRF or SSPEVX returned an error code:
;;*             <= N:  if INFO = i, SSPEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de sspgvx (itype  jobz  range  uplo  n  ap  bp  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) bp )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ sspgvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($bp,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) REAL array, dimension (N*(N+1)/2)
;;*          The factored form of the matrix A.  AFP contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by SSPTRF, stored as a packed
;;*          triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSPTRF.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SSPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssprfs (uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ssprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspsv <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix stored in packed format and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, D is symmetric and block diagonal with 1-by-1
;;*  and 2-by-2 diagonal blocks.  The factored form of A is then used to
;;*  solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by SSPTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, so the solution could not be
;;*                computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de sspsv (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ sspsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sspsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
;;*  A = L*D*L**T to compute the solution to a real system of linear
;;*  equations A * X = B, where A is an N-by-N symmetric matrix stored
;;*  in packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A as
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AFP and IPIV contain the factored form of
;;*                  A.  AP, AFP and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*  AFP     (input or output) REAL array, dimension
;;*                            (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by SSPTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by SSPTRF.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sspsvx (fact  uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sspsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($afp,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssptrd <uplo>  <n>  <ap>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPTRD reduces a real symmetric matrix A stored in packed form to
;;*  symmetric tridiagonal form T by an orthogonal similarity
;;*  transformation: Q**T * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the orthogonal matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) REAL array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP,
;;*  overwriting A(1:i-1,i+1), and tau is stored in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP,
;;*  overwriting A(i+2:n,i), and tau is stored in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssptrd (uplo  n  ap  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ ssptrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssptrf <uplo>  <n>  <ap>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPTRF computes the factorization of a real symmetric matrix A stored
;;*  in packed format using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L, stored as a packed triangular
;;*          matrix overwriting A (see below for further details).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  5-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssptrf (uplo  n  ap  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ ssptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssptri <uplo>  <n>  <ap>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPTRI computes the inverse of a real symmetric indefinite matrix
;;*  A in packed storage using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by SSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by SSPTRF,
;;*          stored as a packed triangular matrix.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix, stored as a packed triangular matrix. The j-th column
;;*          of inv(A) is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
;;*          if UPLO = 'L',
;;*             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSPTRF.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssptri (uplo  n  ap  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssptrs <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSPTRS solves a system of linear equations A*X = B with a real
;;*  symmetric matrix A stored in packed format using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by SSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by SSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSPTRF.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssptrs (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ssptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstebz <range>  <order>  <n>  <vl>  <vu>  <il>  <iu>  <abstol>  <d>  <e>  <m>  <nsplit>  <w>  <iblock>  <isplit>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEBZ computes the eigenvalues of a symmetric tridiagonal
;;*  matrix T.  The user may ask for all eigenvalues, all eigenvalues
;;*  in the half-open interval (VL, VU], or the IL-th through IU-th
;;*  eigenvalues.
;;*
;;*  To avoid overflow, the matrix must be scaled so that its
;;*  largest element is no greater than overflow**(1/2) *
;;*  underflow**(1/4) in absolute value, and for greatest
;;*  accuracy, it should not be much smaller than that.
;;*
;;*  See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
;;*  Matrix", Report CS41, Computer Science Dept., Stanford
;;*  University, July 21, 1966.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  RANGE   (input) CHARACTER
;;*          = 'A': ("All")   all eigenvalues will be found.
;;*          = 'V': ("Value") all eigenvalues in the half-open interval
;;*                           (VL, VU] will be found.
;;*          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
;;*                           entire matrix) will be found.
;;*
;;*  ORDER   (input) CHARACTER
;;*          = 'B': ("By Block") the eigenvalues will be grouped by
;;*                              split-off block (see IBLOCK, ISPLIT) and
;;*                              ordered from smallest to largest within
;;*                              the block.
;;*          = 'E': ("Entire matrix")
;;*                              the eigenvalues for the entire matrix
;;*                              will be ordered from smallest to
;;*                              largest.
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix T.  N >= 0.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues.  Eigenvalues less than or equal
;;*          to VL, or greater than VU, will not be returned.  VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute tolerance for the eigenvalues.  An eigenvalue
;;*          (or cluster) is considered to be located if it has been
;;*          determined to lie in an interval whose width is ABSTOL or
;;*          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
;;*          will be used, where |T| means the 1-norm of T.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) REAL array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the tridiagonal matrix T.
;;*
;;*  M       (output) INTEGER
;;*          The actual number of eigenvalues found. 0 <= M <= N.
;;*          (See also the description of INFO=2,3.)
;;*
;;*  NSPLIT  (output) INTEGER
;;*          The number of diagonal blocks in the matrix T.
;;*          1 <= NSPLIT <= N.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          On exit, the first M elements of W will contain the
;;*          eigenvalues.  (SSTEBZ may use the remaining N-M elements as
;;*          workspace.)
;;*
;;*  IBLOCK  (output) INTEGER array, dimension (N)
;;*          At each row/column j where E(j) is zero or small, the
;;*          matrix T is considered to split into a block diagonal
;;*          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
;;*          block (from 1 to the number of blocks) the eigenvalue W(i)
;;*          belongs.  (SSTEBZ may use the remaining N-M elements as
;;*          workspace.)
;;*
;;*  ISPLIT  (output) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to ISPLIT(1),
;;*          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
;;*          etc., and the NSPLIT-th consists of rows/columns
;;*          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
;;*          (Only the first NSPLIT elements will actually be used, but
;;*          since the user cannot know a priori what value NSPLIT will
;;*          have, N words must be reserved for ISPLIT.)
;;*
;;*  WORK    (workspace) REAL array, dimension (4*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  some or all of the eigenvalues failed to converge or
;;*                were not computed:
;;*                =1 or 3: Bisection failed to converge for some
;;*                        eigenvalues; these eigenvalues are flagged by a
;;*                        negative block number.  The effect is that the
;;*                        eigenvalues may not be as accurate as the
;;*                        absolute and relative tolerances.  This is
;;*                        generally caused by unexpectedly inaccurate
;;*                        arithmetic.
;;*                =2 or 3: RANGE='I' only: Not all of the eigenvalues
;;*                        IL:IU were found.
;;*                        Effect: M < IU+1-IL
;;*                        Cause:  non-monotonic arithmetic, causing the
;;*                                Sturm sequence to be non-monotonic.
;;*                        Cure:   recalculate, using RANGE='A', and pick
;;*                                out eigenvalues IL:IU.  In some cases,
;;*                                increasing the PARAMETER "FUDGE" may
;;*                                make things work.
;;*                = 4:    RANGE='I', and the Gershgorin interval
;;*                        initially used was too small.  No eigenvalues
;;*                        were computed.
;;*                        Probable cause: your machine has sloppy
;;*                                        floating-point arithmetic.
;;*                        Cure: Increase the PARAMETER "FUDGE",
;;*                              recompile, and try again.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  RELFAC  REAL, default = 2.0e0
;;*          The relative tolerance.  An interval (a,b] lies within
;;*          "relative tolerance" if  b-a < RELFAC*ulp*max(|a|,|b|),
;;*          where "ulp" is the machine precision (distance from 1 to
;;*          the next larger floating point number.)
;;*
;;*  FUDGE   REAL, default = 2
;;*          A "fudge factor" to widen the Gershgorin intervals.  Ideally,
;;*          a value of 1 should work, but on machines with sloppy
;;*          arithmetic, this needs to be larger.  The default for
;;*          publicly released versions should be large enough to handle
;;*          the worst machine around.  Note that this has no effect
;;*          on accuracy of the solution.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstebz (range  order  n  vl  vu  il  iu  abstol  d  e  m  nsplit  w  iblock  isplit  work  iwork  info  )
	((-str-) range )
	((-str-) order )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) nsplit )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-int-)) isplit )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ sstebz_($range->data, $order->data, IDX_PTR($n,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($m,int), IDX_PTR($nsplit,int), IDX_PTR($w,float), IDX_PTR($iblock,int), IDX_PTR($isplit,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstedc <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the divide and conquer method.
;;*  The eigenvectors of a full or band real symmetric matrix can also be
;;*  found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
;;*  matrix to tridiagonal form.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.  See SLAED3 for details.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*          = 'V':  Compute eigenvectors of original dense symmetric
;;*                  matrix also.  On entry, Z contains the orthogonal
;;*                  matrix used to reduce the original matrix to
;;*                  tridiagonal form.
;;*
;;*  N       (input) INTEGER
;;*          The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the subdiagonal elements of the tridiagonal matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ,N)
;;*          On entry, if COMPZ = 'V', then Z contains the orthogonal
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original symmetric matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If eigenvectors are desired, then LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If COMPZ = 'N' or N <= 1 then LWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1 then LWORK must be at least
;;*                         ( 1 + 3*N + 2*N*lg N + 3*N**2 ),
;;*                         where lg( N ) = smallest integer k such
;;*                         that 2**k >= N.
;;*          If COMPZ = 'I' and N > 1 then LWORK must be at least
;;*                         ( 1 + 4*N + N**2 ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If COMPZ = 'N' or N <= 1 then LIWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1 then LIWORK must be at least
;;*                         ( 6 + 6*N + 5*N*lg N ).
;;*          If COMPZ = 'I' and N > 1 then LIWORK must be at least
;;*                         ( 3 + 5*N ).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstedc (compz  n  d  e  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ sstedc_($compz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstegr <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;* SSTEGR computes selected eigenvalues and, optionally, eigenvectors
;;* of a real symmetric tridiagonal matrix T.  Eigenvalues and
;;* eigenvectors can be selected by specifying either a range of values
;;* or a range of indices for the desired eigenvalues. The eigenvalues
;;* are computed by the dqds algorithm, while orthogonal eigenvectors are
;;* computed from various ``good'' L D L^T representations (also known as
;;* Relatively Robust Representations). Gram-Schmidt orthogonalization is
;;* avoided as far as possible. More specifically, the various steps of
;;* the algorithm are as follows. For the i-th unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*         is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB/CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*  Note 1 : Currently SSTEGR is only set up to find ALL the n
;;*  eigenvalues and eigenvectors of T in O(n^2) time
;;*  Note 2 : Currently the routine SSTEIN is called when an appropriate
;;*  sigma_i cannot be chosen in step (c) above. SSTEIN invokes modified
;;*  Gram-Schmidt when eigenvalues are close.
;;*  Note 3 : SSTEGR works only on machines which follow ieee-754
;;*  floating-point standard in their handling of infinities and NaNs.
;;*  Normal execution of SSTEGR may create NaNs and infinities and hence
;;*  may abort due to a floating point exception in environments which
;;*  do not conform to the ieee standard.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** Only RANGE = 'A' is currently supported *********************
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          T. On exit, D is overwritten.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix T in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E is overwritten.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors. IF JOBZ = 'V', the eigenvalues and
;;*          eigenvectors output have residual norms bounded by ABSTOL,
;;*          and the dot products between different eigenvectors are
;;*          bounded by ABSTOL. If ABSTOL is less than N*EPS*|T|, then
;;*          N*EPS*|T| will be used in its place, where EPS is the
;;*          machine precision and |T| is the 1-norm of the tridiagonal
;;*          matrix. The eigenvalues are computed to an accuracy of
;;*          EPS*|T| irrespective of ABSTOL. If high relative accuracy
;;*          is important, set ABSTOL to DLAMCH( 'Safe minimum' ).
;;*          See Barlow and Demmel "Computing Accurate Eigensystems of
;;*          Scaled Diagonally Dominant Matrices", LAPACK Working Note #7
;;*          for a discussion of which matrices define their eigenvalues
;;*          to high relative accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal
;;*          (and minimal) LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,18*N)
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= max(1,10*N)
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in SLARRE,
;;*                if INFO = 2, internal error in SLARRV.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstegr (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ sstegr_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstein <n>  <d>  <e>  <m>  <w>  <iblock>  <isplit>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEIN computes the eigenvectors of a real symmetric tridiagonal
;;*  matrix T corresponding to specified eigenvalues, using inverse
;;*  iteration.
;;*
;;*  The maximum number of iterations allowed for each eigenvector is
;;*  specified by an internal parameter MAXITS (currently set to 5).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input) REAL array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) REAL array, dimension (N)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix
;;*          T, in elements 1 to N-1.  E(N) need not be set.
;;*
;;*  M       (input) INTEGER
;;*          The number of eigenvectors to be found.  0 <= M <= N.
;;*
;;*  W       (input) REAL array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block.  ( The output array
;;*          W from SSTEBZ with ORDER = 'B' is expected here. )
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc.  ( The output array IBLOCK
;;*          from SSTEBZ is expected here. )
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*          ( The output array ISPLIT from SSTEBZ is expected here. )
;;*
;;*  Z       (output) REAL array, dimension (LDZ, M)
;;*          The computed eigenvectors.  The eigenvector associated
;;*          with the eigenvalue W(i) is stored in the i-th column of
;;*          Z.  Any vector which fails to converge is set to its current
;;*          iterate after MAXITS iterations.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (5*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (M)
;;*          On normal exit, all elements of IFAIL are zero.
;;*          If one or more eigenvectors fail to converge after
;;*          MAXITS iterations, then their indices are stored in
;;*          array IFAIL.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, then i eigenvectors failed to converge
;;*               in MAXITS iterations.  Their indices are stored in
;;*               array IFAIL.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXITS  INTEGER, default = 5
;;*          The maximum number of iterations performed.
;;*
;;*  EXTRA   INTEGER, default = 2
;;*          The number of iterations performed after norm growth
;;*          criterion is satisfied, should be at least 1.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstein (n  d  e  m  w  iblock  isplit  z  ldz  work  iwork  ifail  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-int-)) isplit )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ sstein_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($iblock,int), IDX_PTR($isplit,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the implicit QL or QR method.
;;*  The eigenvectors of a full or band symmetric matrix can also be found
;;*  if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
;;*  tridiagonal form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvalues and eigenvectors of the original
;;*                  symmetric matrix.  On entry, Z must contain the
;;*                  orthogonal matrix used to reduce the original matrix
;;*                  to tridiagonal form.
;;*          = 'I':  Compute eigenvalues and eigenvectors of the
;;*                  tridiagonal matrix.  Z is initialized to the identity
;;*                  matrix.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ, N)
;;*          On entry, if  COMPZ = 'V', then Z contains the orthogonal
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original symmetric matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          eigenvectors are desired, then  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (max(1,2*N-2))
;;*          If COMPZ = 'N', then WORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm has failed to find all the eigenvalues in
;;*                a total of 30*N iterations; if INFO = i, then i
;;*                elements of E have not converged to zero; on exit, D
;;*                and E contain the elements of a symmetric tridiagonal
;;*                matrix which is orthogonally similar to the original
;;*                matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssterf <n>  <d>  <e>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
;;*  using the Pal-Walker-Kahan variant of the QL or QR algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm failed to find all of the eigenvalues in
;;*                a total of 30*N iterations; if INFO = i, then i
;;*                elements of E have not converged to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssterf (n  d  e  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-int-)) info )
	#{ ssterf_(IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstevd <jobz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEVD computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric tridiagonal matrix. If eigenvectors are desired, it
;;*  uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A, stored in elements 1 to N-1 of E; E(N) need not
;;*          be set, but is used by the routine.
;;*          On exit, the contents of E are destroyed.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with D(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If JOBZ  = 'N' or N <= 1 then LWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1 then LWORK must be at least
;;*                         ( 1 + 4*N + N**2 ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1 then LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1 then LIWORK must be at least 3+5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of E did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstevd (jobz  n  d  e  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ sstevd_($jobz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstev <jobz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEV computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric tridiagonal matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A, stored in elements 1 to N-1 of E; E(N) need not
;;*          be set, but is used by the routine.
;;*          On exit, the contents of E are destroyed.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with D(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (max(1,2*N-2))
;;*          If JOBZ = 'N', WORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of E did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstev (jobz  n  d  e  z  ldz  work  info  )
	((-str-) jobz )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ sstev_($jobz->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstevr <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEVR computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric tridiagonal matrix T.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either a range of values
;;*  or a range of indices for the desired eigenvalues.
;;*
;;*  Whenever possible, SSTEVR calls SSTEGR to compute the
;;*  eigenspectrum using Relatively Robust Representations.  SSTEGR
;;*  computes eigenvalues by the dqds algorithm, while orthogonal
;;*  eigenvectors are computed from various "good" L D L^T representations
;;*  (also known as Relatively Robust Representations). Gram-Schmidt
;;*  orthogonalization is avoided as far as possible. More specifically,
;;*  the various steps of the algorithm are as follows. For the i-th
;;*  unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*          is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB//CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*
;;*  Note 1 : SSTEVR calls SSTEGR when the full spectrum is requested
;;*  on machines which conform to the ieee-754 floating point standard.
;;*  SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
;;*  when partial spectrum requests are made.
;;*
;;*  Normal execution of SSTEGR may create NaNs and infinities and
;;*  hence may abort due to a floating point exception in environments
;;*  which do not handle NaNs and infinities in the ieee standard default
;;*  manner.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
;;********** SSTEIN are called
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, D may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*          If high relative accuracy is important, set ABSTOL to
;;*          SLAMCH( 'Safe minimum' ).  Doing so will guarantee that
;;*          eigenvalues are computed to high relative accuracy when
;;*          possible in future releases.  The current code does not
;;*          make any guarantees about high relative accuracy, but
;;*          future releases will. See J. Barlow and J. Demmel,
;;*          "Computing Accurate Eigensystems of Scaled Diagonally
;;*          Dominant Matrices", LAPACK Working Note #7, for a discussion
;;*          of which matrices define their eigenvalues to high relative
;;*          accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;********** Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal (and
;;*          minimal) LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 20*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal (and
;;*          minimal) LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= 10*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  Internal error
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstevr (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ sstevr_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (sstevx <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSTEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric tridiagonal matrix A.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either a range of values
;;*  or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) REAL array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, D may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  E       (input/output) REAL array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less
;;*          than or equal to zero, then  EPS*|T|  will be used in
;;*          its place, where |T| is the 1-norm of the tridiagonal
;;*          matrix.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge (INFO > 0), then that
;;*          column of Z contains the latest approximation to the
;;*          eigenvector, and the index of the eigenvector is returned
;;*          in IFAIL.  If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) REAL array, dimension (5*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de sstevx (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ sstevx_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssycon <uplo>  <n>  <a>  <lda>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric matrix A using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by SSYTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by SSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSYTRF.
;;*
;;*  ANORM   (input) REAL
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  IWORK    (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssycon (uplo  n  a  lda  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-float-)) anorm )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ssycon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssyevd <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYEVD computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric matrix A. If eigenvectors are desired, it uses a
;;*  divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Because of large use of BLAS of level 3, SSYEVD needs N**2 more
;;*  workspace than SSYEVX.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) REAL array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least 
;;*                                                1 + 6*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssyevd (jobz  uplo  n  a  lda  w  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ssyevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssyev <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYEV computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,3*N-1).
;;*          For optimal efficiency, LWORK >= (NB+2)*N,
;;*          where NB is the blocksize for SSYTRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssyev (jobz  uplo  n  a  lda  w  work  lwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ssyev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssyevr <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYEVR computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix T.  Eigenvalues and eigenvectors can be
;;*  selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Whenever possible, SSYEVR calls SSTEGR to compute the
;;*  eigenspectrum using Relatively Robust Representations.  SSTEGR
;;*  computes eigenvalues by the dqds algorithm, while orthogonal
;;*  eigenvectors are computed from various "good" L D L^T representations
;;*  (also known as Relatively Robust Representations). Gram-Schmidt
;;*  orthogonalization is avoided as far as possible. More specifically,
;;*  the various steps of the algorithm are as follows. For the i-th
;;*  unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*          is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB//CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*
;;*  Note 1 : SSYEVR calls SSTEGR when the full spectrum is requested
;;*  on machines which conform to the ieee-754 floating point standard.
;;*  SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and
;;*  when partial spectrum requests are made.
;;*
;;*  Normal execution of SSTEGR may create NaNs and infinities and
;;*  hence may abort due to a floating point exception in environments
;;*  which do not handle NaNs and infinities in the ieee standard default
;;*  manner.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** For RANGE = 'V' or 'I' and IU - IL < N - 1, SSTEBZ and
;;********** SSTEIN are called
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*          If high relative accuracy is important, set ABSTOL to
;;*          SLAMCH( 'Safe minimum' ).  Doing so will guarantee that
;;*          eigenvalues are computed to high relative accuracy when
;;*          possible in future releases.  The current code does not
;;*          make any guarantees about high relative accuracy, but
;;*          furutre releases will. See J. Barlow and J. Demmel,
;;*          "Computing Accurate Eigensystems of Scaled Diagonally
;;*          Dominant Matrices", LAPACK Working Note #7, for a discussion
;;*          of which matrices define their eigenvalues to high relative
;;*          accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;********** Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,26*N).
;;*          For optimal efficiency, LWORK >= (NB+6)*N,
;;*          where NB is the max of the blocksize for SSYTRD and SORMTR
;;*          returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  Internal error
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssyevr (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ssyevr_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssyevx <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
;;*  selected by specifying either a range of values or a range of indices
;;*  for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,8*N).
;;*          For optimal efficiency, LWORK >= (NB+3)*N,
;;*          where NB is the max of the blocksize for SSYTRD and SORMTR
;;*          returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssyevx (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ ssyevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssygs2 <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYGS2 reduces a real symmetric-definite generalized eigenproblem
;;*  to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U` or L'*A*L.
;;*
;;*  B must have been previously factorized as U'*U or L*L' by SPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U')*A*inv(U) or inv(L)*A*inv(L');
;;*          = 2 or 3: compute U*A*U' or L'*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored, and how B has been factorized.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) REAL array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by SPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssygs2 (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ssygs2_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssygst <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYGST reduces a real symmetric-definite generalized eigenproblem
;;*  to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
;;*
;;*  B must have been previously factorized as U**T*U or L*L**T by SPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T);
;;*          = 2 or 3: compute U*A*U**T or L**T*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**T*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) REAL array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by SPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssygst (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ssygst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssygvd <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be symmetric and B is also positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the symmetric matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= 2*N+1.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 1 + 6*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  SPOTRF or SSYEVD returned an error code:
;;*             <= N:  if INFO = i, SSYEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssygvd (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ssygvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssygv <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be symmetric and B is also
;;*  positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB, N)
;;*          On entry, the symmetric positive definite matrix B.
;;*          If UPLO = 'U', the leading N-by-N upper triangular part of B
;;*          contains the upper triangular part of the matrix B.
;;*          If UPLO = 'L', the leading N-by-N lower triangular part of B
;;*          contains the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,3*N-1).
;;*          For optimal efficiency, LWORK >= (NB+2)*N,
;;*          where NB is the blocksize for SSYTRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  SPOTRF or SSYEV returned an error code:
;;*             <= N:  if INFO = i, SSYEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssygv (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) w )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ssygv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($w,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssygvx <itype>  <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
;;*  and B are assumed to be symmetric and B is also positive definite.
;;*  Eigenvalues and eigenvectors can be selected by specifying either a
;;*  range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A and B are stored;
;;*          = 'L':  Lower triangle of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix pencil (A,B).  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDA, N)
;;*          On entry, the symmetric matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  VL      (input) REAL
;;*  VU      (input) REAL
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) REAL
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*SLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) REAL array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) REAL array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,8*N).
;;*          For optimal efficiency, LWORK >= (NB+3)*N,
;;*          where NB is the blocksize for SSYTRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  SPOTRF or SSYEVX returned an error code:
;;*             <= N:  if INFO = i, SSYEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssygvx (itype  jobz  range  uplo  n  a  lda  b  ldb  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) vl )
	((-idx0- (-float-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-float-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) w )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ ssygvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($vl,float), IDX_PTR($vu,float), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,float), IDX_PTR($m,int), IDX_PTR($w,float), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssyrfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite, and
;;*  provides error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) REAL array, dimension (LDAF,N)
;;*          The factored form of the matrix A.  AF contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by SSYTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSYTRF.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) REAL array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by SSYTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssyrfs (uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ssyrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssysv <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with 
;;*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
;;*  used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the block diagonal matrix D and the
;;*          multipliers used to obtain the factor U or L from the
;;*          factorization A = U*D*U**T or A = L*D*L**T as computed by
;;*          SSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by SSYTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 1, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          SSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ssysv (uplo  n  nrhs  a  lda  ipiv  b  ldb  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ssysv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssysvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYSVX uses the diagonal pivoting factorization to compute the
;;*  solution to a real system of linear equations A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A.
;;*     The form of the factorization is
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices, and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AF and IPIV contain the factored form of
;;*                  A.  AF and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) REAL array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by SSYTRF.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by SSYTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by SSYTRF.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) REAL array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 3*N, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          SSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssysvx (fact  uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  lwork  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ssysvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($af,float), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($rcond,float), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssytd2 <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
;;*  form T by an orthogonal similarity transformation: Q' * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the orthogonal matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) REAL array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssytd2 (uplo  n  a  lda  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ ssytd2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssytf2 <uplo>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYTF2 computes the factorization of a real symmetric matrix A using
;;*  the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U'  or  A = L*D*L'
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, U' is the transpose of U, and D is symmetric and
;;*  block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  1-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssytf2 (uplo  n  a  lda  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ ssytf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssytrd <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYTRD reduces a real symmetric matrix A to real symmetric
;;*  tridiagonal form T by an orthogonal similarity transformation:
;;*  Q**T * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the orthogonal matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) REAL array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) REAL array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) REAL array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 1.
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssytrd (uplo  n  a  lda  d  e  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) d )
	((-idx1- (-float-)) e )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ssytrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($d,float), IDX_PTR($e,float), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssytrf <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYTRF computes the factorization of a real symmetric matrix A using
;;*  the Bunch-Kaufman diagonal pivoting method.  The form of the
;;*  factorization is
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with 
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >=1.  For best performance
;;*          LWORK >= N*NB, where NB is the block size returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, and division by zero will occur if it
;;*                is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ssytrf (uplo  n  a  lda  ipiv  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ssytrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssytri <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYTRI computes the inverse of a real symmetric indefinite matrix
;;*  A using the factorization A = U*D*U**T or A = L*D*L**T computed by
;;*  SSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by SSYTRF.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix.  If UPLO = 'U', the upper triangular part of the
;;*          inverse is formed and the part of A below the diagonal is not
;;*          referenced; if UPLO = 'L' the lower triangular part of the
;;*          inverse is formed and the part of A above the diagonal is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSYTRF.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssytri (uplo  n  a  lda  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ ssytri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ssytrs <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  SSYTRS solves a system of linear equations A*X = B with a real
;;*  symmetric matrix A using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by SSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by SSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by SSYTRF.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ssytrs (uplo  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ssytrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stbcon <norm>  <uplo>  <diag>  <n>  <kd>  <ab>  <ldab>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STBCON estimates the reciprocal of the condition number of a
;;*  triangular band matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stbcon (norm  uplo  diag  n  kd  ab  ldab  rcond  work  iwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ stbcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stbrfs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STBRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular band
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by STBTRS or some other
;;*  means before entering this routine.  STBRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) REAL array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stbrfs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ stbrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stbtrs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STBTRS solves a triangular system of the form
;;*
;;*     A * X = B  or  A**T * X = B,
;;*
;;*  where A is a triangular band matrix of order N, and B is an
;;*  N-by NRHS matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) REAL array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stbtrs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ stbtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,float), IDX_PTR($ldab,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgevc <side>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGEVC computes some or all of the right and/or left generalized
;;*  eigenvectors of a pair of real upper triangular matrices (A,B).
;;*
;;*  The right generalized eigenvector x and the left generalized 
;;*  eigenvector y of (A,B) corresponding to a generalized eigenvalue
;;*  w are defined by:
;;*
;;*          (A - wB) * x = 0  and  y**H * (A - wB) = 0
;;*
;;*  where y**H denotes the conjugate tranpose of y.
;;*
;;*  If an eigenvalue w is determined by zero diagonal elements of both A
;;*  and B, a unit vector is returned as the corresponding eigenvector.
;;*
;;*  If all eigenvectors are requested, the routine may either return
;;*  the matrices X and/or Y of right or left eigenvectors of (A,B), or
;;*  the products Z*X and/or Q*Y, where Z and Q are input orthogonal
;;*  matrices.  If (A,B) was obtained from the generalized real-Schur
;;*  factorization of an original pair of matrices
;;*     (A0,B0) = (Q*A*Z**H,Q*B*Z**H),
;;*  then Z*X and Q*Y are the matrices of right or left eigenvectors of
;;*  A.
;;*
;;*  A must be block upper triangular, with 1-by-1 and 2-by-2 diagonal
;;*  blocks.  Corresponding to each 2-by-2 diagonal block is a complex
;;*  conjugate pair of eigenvalues and eigenvectors; only one
;;*  eigenvector of the pair is computed, namely the one corresponding
;;*  to the eigenvalue with positive imaginary part.
;;* 
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute all right and/or left eigenvectors;
;;*          = 'B': compute all right and/or left eigenvectors, and
;;*                 backtransform them using the input matrices supplied
;;*                 in VR and/or VL; 
;;*          = 'S': compute selected right and/or left eigenvectors,
;;*                 specified by the logical array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY='S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY='A' or 'B', SELECT is not referenced.
;;*          To select the real eigenvector corresponding to the real
;;*          eigenvalue w(j), SELECT(j) must be set to .TRUE.  To select
;;*          the complex eigenvector corresponding to a complex conjugate
;;*          pair w(j) and w(j+1), either SELECT(j) or SELECT(j+1) must
;;*          be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The upper quasi-triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of array A.  LDA >= max(1, N).
;;*
;;*  B       (input) REAL array, dimension (LDB,N)
;;*          The upper triangular matrix B.  If A has a 2-by-2 diagonal
;;*          block, then the corresponding 2-by-2 block of B must be
;;*          diagonal with positive elements.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of array B.  LDB >= max(1,N).
;;*
;;*  VL      (input/output) REAL array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Q
;;*          of left Schur vectors returned by SHGEQZ).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VL, in the same order as their eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part, and the second the imaginary part.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) REAL array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Z
;;*          of right Schur vectors returned by SHGEQZ).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Z*X;
;;*          if HOWMNY = 'S', the right eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VR, in the same order as their eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part and the second the imaginary part.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
;;*          is set to N.  Each selected real eigenvector occupies one
;;*          column and each selected complex eigenvector occupies two
;;*          columns.
;;*
;;*  WORK    (workspace) REAL array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the 2-by-2 block (INFO:INFO+1) does not have a complex
;;*                eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Allocation of workspace:
;;*  ---------- -- ---------
;;*
;;*     WORK( j ) = 1-norm of j-th column of A, above the diagonal
;;*     WORK( N+j ) = 1-norm of j-th column of B, above the diagonal
;;*     WORK( 2*N+1:3*N ) = real part of eigenvector
;;*     WORK( 3*N+1:4*N ) = imaginary part of eigenvector
;;*     WORK( 4*N+1:5*N ) = real part of back-transformed eigenvector
;;*     WORK( 5*N+1:6*N ) = imaginary part of back-transformed eigenvector
;;*
;;*  Rowwise vs. columnwise solution methods:
;;*  ------- --  ---------- -------- -------
;;*
;;*  Finding a generalized eigenvector consists basically of solving the
;;*  singular triangular system
;;*
;;*   (A - w B) x = 0     (for right) or:   (A - w B)**H y = 0  (for left)
;;*
;;*  Consider finding the i-th right eigenvector (assume all eigenvalues
;;*  are real). The equation to be solved is:
;;*       n                   i
;;*  0 = sum  C(j,k) v(k)  = sum  C(j,k) v(k)     for j = i,. . .,1
;;*      k=j                 k=j
;;*
;;*  where  C = (A - w B)  (The components v(i+1:n) are 0.)
;;*
;;*  The "rowwise" method is:
;;*
;;*  (1)  v(i) := 1
;;*  for j = i-1,. . .,1:
;;*                          i
;;*      (2) compute  s = - sum C(j,k) v(k)   and
;;*                        k=j+1
;;*
;;*      (3) v(j) := s / C(j,j)
;;*
;;*  Step 2 is sometimes called the "dot product" step, since it is an
;;*  inner product between the j-th row and the portion of the eigenvector
;;*  that has been computed so far.
;;*
;;*  The "columnwise" method consists basically in doing the sums
;;*  for all the rows in parallel.  As each v(j) is computed, the
;;*  contribution of v(j) times the j-th column of C is added to the
;;*  partial sums.  Since FORTRAN arrays are stored columnwise, this has
;;*  the advantage that at each step, the elements of C that are accessed
;;*  are adjacent to one another, whereas with the rowwise method, the
;;*  elements accessed at a step are spaced LDA (and LDB) words apart.
;;*
;;*  When finding left eigenvectors, the matrix in question is the
;;*  transpose of the one in storage, so the rowwise method then
;;*  actually accesses columns of A and B at each step, and so is the
;;*  preferred method.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgevc (side  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  mm  m  work  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ stgevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgex2 <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <j1>  <n1>  <n2>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
;;*  of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
;;*  (A, B) by an orthogonal equivalence transformation.
;;*
;;*  (A, B) must be in generalized real Schur canonical form (as returned
;;*  by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
;;*  diagonal blocks. B is upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A      (input/output) REAL arrays, dimensions (LDA,N)
;;*          On entry, the matrix A in the pair (A, B).
;;*          On exit, the updated matrix A.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B      (input/output) REAL arrays, dimensions (LDB,N)
;;*          On entry, the matrix B in the pair (A, B).
;;*          On exit, the updated matrix B.
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) REAL array, dimension (LDZ,N)
;;*          On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
;;*          On exit, the updated matrix Q.
;;*          Not referenced if WANTQ = .FALSE..
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1.
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ,N)
;;*          On entry, if WANTZ =.TRUE., the orthogonal matrix Z.
;;*          On exit, the updated matrix Z.
;;*          Not referenced if WANTZ = .FALSE..
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1.
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  J1      (input) INTEGER
;;*          The index to the first block (A11, B11). 1 <= J1 <= N.
;;*
;;*  N1      (input) INTEGER
;;*          The order of the first block (A11, B11). N1 = 0, 1 or 2.
;;*
;;*  N2      (input) INTEGER
;;*          The order of the second block (A22, B22). N2 = 0, 1 or 2.
;;*
;;*  WORK    (workspace) REAL array, dimension (LWORK).
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          LWORK >=  MAX( N*(N2+N1), (N2+N1)*(N2+N1)*2 )
;;*
;;*  INFO    (output) INTEGER
;;*            =0: Successful exit
;;*            >0: If INFO = 1, the transformed matrix (A, B) would be
;;*                too far from generalized Schur form; the blocks are
;;*                not swapped and (A, B) and (Q, Z) are unchanged.
;;*                The problem of swapping is too ill-conditioned.
;;*            <0: If INFO = -16: LWORK is too small. Appropriate value
;;*                for LWORK is returned in WORK(1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  In the current code both weak and strong stability tests are
;;*  performed. The user can omit the strong stability test by changing
;;*  the internal logical parameter WANDS to .FALSE.. See ref. [2] for
;;*  details.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software,
;;*      Report UMINF - 94.04, Department of Computing Science, Umea
;;*      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
;;*      Note 87. To appear in Numerical Algorithms, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgex2 (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  j1  n1  n2  work  lwork  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) j1 )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ stgex2_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($j1,int), IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgexc <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <ifst>  <ilst>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGEXC reorders the generalized real Schur decomposition of a real
;;*  matrix pair (A,B) using an orthogonal equivalence transformation
;;*
;;*                 (A, B) = Q * (A, B) * Z',
;;*
;;*  so that the diagonal block of (A, B) with row index IFST is moved
;;*  to row ILST.
;;*
;;*  (A, B) must be in generalized real Schur canonical form (as returned
;;*  by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
;;*  diagonal blocks. B is upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the matrix A in generalized real Schur canonical
;;*          form.
;;*          On exit, the updated matrix A, again in generalized
;;*          real Schur canonical form.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the matrix B in generalized real Schur canonical
;;*          form (A,B).
;;*          On exit, the updated matrix B, again in generalized
;;*          real Schur canonical form (A,B).
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) REAL array, dimension (LDZ,N)
;;*          On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
;;*          On exit, the updated matrix Q.
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1.
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., the orthogonal matrix Z.
;;*          On exit, the updated matrix Z.
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1.
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  IFST    (input/output) INTEGER
;;*  ILST    (input/output) INTEGER
;;*          Specify the reordering of the diagonal blocks of (A, B).
;;*          The block with row index IFST is moved to row ILST, by a
;;*          sequence of swapping between adjacent blocks.
;;*          On exit, if IFST pointed on entry to the second row of
;;*          a 2-by-2 block, it is changed to point to the first row;
;;*          ILST always points to the first row of the block in its
;;*          final position (which may differ from its input value by
;;*          +1 or -1). 1 <= IFST, ILST <= N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 4*N + 16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*           =0:  successful exit.
;;*           <0:  if INFO = -i, the i-th argument had an illegal value.
;;*           =1:  The transformed matrix pair (A, B) would be too far
;;*                from generalized Schur form; the problem is ill-
;;*                conditioned. (A, B) may have been partially reordered,
;;*                and ILST points to the first row of the current
;;*                position of the block being moved.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgexc (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  ifst  ilst  work  lwork  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ stgexc_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgsen <ijob>  <wantq>  <wantz>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <q>  <ldq>  <z>  <ldz>  <m>  <pl>  <pr>  <dif>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGSEN reorders the generalized real Schur decomposition of a real
;;*  matrix pair (A, B) (in terms of an orthonormal equivalence trans-
;;*  formation Q' * (A, B) * Z), so that a selected cluster of eigenvalues
;;*  appears in the leading diagonal blocks of the upper quasi-triangular
;;*  matrix A and the upper triangular B. The leading columns of Q and
;;*  Z form orthonormal bases of the corresponding left and right eigen-
;;*  spaces (deflating subspaces). (A, B) must be in generalized real
;;*  Schur canonical form (as returned by SGGES), i.e. A is block upper
;;*  triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
;;*  triangular.
;;*
;;*  STGSEN also computes the generalized eigenvalues
;;*
;;*              w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
;;*
;;*  of the reordered matrix pair (A, B).
;;*
;;*  Optionally, STGSEN computes the estimates of reciprocal condition
;;*  numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
;;*  (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
;;*  between the matrix pairs (A11, B11) and (A22,B22) that correspond to
;;*  the selected cluster and the eigenvalues outside the cluster, resp.,
;;*  and norms of "projections" onto left and right eigenspaces w.r.t.
;;*  the selected cluster in the (1,1)-block.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (PL and PR) or the deflating subspaces
;;*          (Difu and Difl):
;;*           =0: Only reorder w.r.t. SELECT. No extras.
;;*           =1: Reciprocal of norms of "projections" onto left and right
;;*               eigenspaces w.r.t. the selected cluster (PL and PR).
;;*           =2: Upper bounds on Difu and Difl. F-norm-based estimate
;;*               (DIF(1:2)).
;;*           =3: Estimate of Difu and Difl. 1-norm-based estimate
;;*               (DIF(1:2)).
;;*               About 5 times as expensive as IJOB = 2.
;;*           =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
;;*               version to get it all.
;;*           =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster.
;;*          To select a real eigenvalue w(j), SELECT(j) must be set to
;;*          .TRUE.. To select a complex conjugate pair of eigenvalues
;;*          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
;;*          either SELECT(j) or SELECT(j+1) or both must be set to
;;*          .TRUE.; a complex conjugate pair of eigenvalues must be
;;*          either both included in the cluster or both excluded.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension(LDA,N)
;;*          On entry, the upper quasi-triangular matrix A, with (A, B) in
;;*          generalized real Schur canonical form.
;;*          On exit, A is overwritten by the reordered matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension(LDB,N)
;;*          On entry, the upper triangular matrix B, with (A, B) in
;;*          generalized real Schur canonical form.
;;*          On exit, B is overwritten by the reordered matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) REAL array, dimension (N)
;;*  ALPHAI  (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i
;;*          and BETA(j),j=1,...,N  are the diagonals of the complex Schur
;;*          form (S,T) that would result if the 2-by-2 diagonal blocks of
;;*          the real generalized Schur form of (A,B) were further reduced
;;*          to triangular form using complex unitary transformations.
;;*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
;;*          positive, then the j-th and (j+1)-st eigenvalues are a
;;*          complex conjugate pair, with ALPHAI(j+1) negative.
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ,N)
;;*          On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
;;*          On exit, Q has been postmultiplied by the left orthogonal
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Q form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= 1;
;;*          and if WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) REAL array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
;;*          On exit, Z has been postmultiplied by the left orthogonal
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Z form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1;
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified pair of left and right eigen-
;;*          spaces (deflating subspaces). 0 <= M <= N.
;;*
;;*  PL, PR  (output) REAL
;;*          If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
;;*          reciprocal of the norm of "projections" onto left and right
;;*          eigenspaces with respect to the selected cluster.
;;*          0 < PL, PR <= 1.
;;*          If M = 0 or M = N, PL = PR  = 1.
;;*          If IJOB = 0, 2 or 3, PL and PR are not referenced.
;;*
;;*  DIF     (output) REAL array, dimension (2).
;;*          If IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.
;;*          If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
;;*          Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
;;*          estimates of Difu and Difl.
;;*          If M = 0 or N, DIF(1:2) = F-norm([A, B]).
;;*          If IJOB = 0 or 1, DIF is not referenced.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          IF IJOB = 0, WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >=  4*N+16.
;;*          If IJOB = 1, 2 or 4, LWORK >= MAX(4*N+16, 2*M*(N-M)).
;;*          If IJOB = 3 or 5, LWORK >= MAX(4*N+16, 4*M*(N-M)).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          IF IJOB = 0, IWORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK. LIWORK >= 1.
;;*          If IJOB = 1, 2 or 4, LIWORK >=  N+6.
;;*          If IJOB = 3 or 5, LIWORK >= MAX(2*M*(N-M), N+6).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*            =0: Successful exit.
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            =1: Reordering of (A, B) failed because the transformed
;;*                matrix pair (A, B) would be too far from generalized
;;*                Schur form; the problem is very ill-conditioned.
;;*                (A, B) may have been partially reordered.
;;*                If requested, 0 is returned in DIF(*), PL and PR.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  STGSEN first collects the selected eigenvalues by computing
;;*  orthogonal U and W that move them to the top left corner of (A, B).
;;*  In other words, the selected eigenvalues are the eigenvalues of
;;*  (A11, B11) in:
;;*
;;*                U'*(A, B)*W = (A11 A12) (B11 B12) n1
;;*                              ( 0  A22),( 0  B22) n2
;;*                                n1  n2    n1  n2
;;*
;;*  where N = n1+n2 and U' means the transpose of U. The first n1 columns
;;*  of U and W span the specified pair of left and right eigenspaces
;;*  (deflating subspaces) of (A, B).
;;*
;;*  If (A, B) has been obtained from the generalized real Schur
;;*  decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the
;;*  reordered generalized real Schur form of (C, D) is given by
;;*
;;*           (C, D) = (Q*U)*(U'*(A, B)*W)*(Z*W)',
;;*
;;*  and the first n1 columns of Q*U and Z*W span the corresponding
;;*  deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).
;;*
;;*  Note that if the selected eigenvalue is sufficiently ill-conditioned,
;;*  then its value may differ significantly from its value before
;;*  reordering.
;;*
;;*  The reciprocal condition numbers of the left and right eigenspaces
;;*  spanned by the first n1 columns of U and W (or Q*U and Z*W) may
;;*  be returned in DIF(1:2), corresponding to Difu and Difl, resp.
;;*
;;*  The Difu and Difl are defined as:
;;*
;;*       Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
;;*  and
;;*       Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],
;;*
;;*  where sigma-min(Zu) is the smallest singular value of the
;;*  (2*n1*n2)-by-(2*n1*n2) matrix
;;*
;;*       Zu = [ kron(In2, A11)  -kron(A22', In1) ]
;;*            [ kron(In2, B11)  -kron(B22', In1) ].
;;*
;;*  Here, Inx is the identity matrix of size nx and A22' is the
;;*  transpose of A22. kron(X, Y) is the Kronecker product between
;;*  the matrices X and Y.
;;*
;;*  When DIF(2) is small, small changes in (A, B) can cause large changes
;;*  in the deflating subspace. An approximate (asymptotic) bound on the
;;*  maximum angular error in the computed deflating subspaces is
;;*
;;*       EPS * norm((A, B)) / DIF(2),
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal norm of the projectors on the left and right
;;*  eigenspaces associated with (A11, B11) may be returned in PL and PR.
;;*  They are computed as follows. First we compute L and R so that
;;*  P*(A, B)*Q is block diagonal, where
;;*
;;*       P = ( I -L ) n1           Q = ( I R ) n1
;;*           ( 0  I ) n2    and        ( 0 I ) n2
;;*             n1 n2                    n1 n2
;;*
;;*  and (L, R) is the solution to the generalized Sylvester equation
;;*
;;*       A11*R - L*A22 = -A12
;;*       B11*R - L*B22 = -B12
;;*
;;*  Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2).
;;*  An approximate (asymptotic) bound on the average absolute error of
;;*  the selected eigenvalues is
;;*
;;*       EPS * norm((A, B)) / PL.
;;*
;;*  There are also global error bounds which valid for perturbations up
;;*  to a certain restriction:  A lower bound (x) on the smallest
;;*  F-norm(E,F) for which an eigenvalue of (A11, B11) may move and
;;*  coalesce with an eigenvalue of (A22, B22) under perturbation (E,F),
;;*  (i.e. (A + E, B + F), is
;;*
;;*   x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).
;;*
;;*  An approximate bound on x can be computed from DIF(1:2), PL and PR.
;;*
;;*  If y = ( F-norm(E,F) / x) <= 1, the angles between the perturbed
;;*  (L', R') and unperturbed (L, R) left and right deflating subspaces
;;*  associated with the selected cluster in the (1,1)-blocks can be
;;*  bounded as
;;*
;;*   max-angle(L, L') <= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2))
;;*   max-angle(R, R') <= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))
;;*
;;*  See LAPACK User's Guide section 4.11 or the following references
;;*  for more information.
;;*
;;*  Note that if the default method for computing the Frobenius-norm-
;;*  based estimate DIF is not wanted (see SLATDF), then the parameter
;;*  IDIFJB (see below) should be changed from 3 to 4 (routine SLATDF
;;*  (IJOB = 2 will be used)). See STGSYL for more details.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software,
;;*      Report UMINF - 94.04, Department of Computing Science, Umea
;;*      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
;;*      Note 87. To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
;;*      1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgsen (ijob  wantq  wantz  select  n  a  lda  b  ldb  alphar  alphai  beta  q  ldq  z  ldz  m  pl  pr  dif  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) alphar )
	((-idx1- (-float-)) alphai )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-float-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) m )
	((-idx0- (-float-)) pl )
	((-idx0- (-float-)) pr )
	((-idx1- (-float-)) dif )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ stgsen_(IDX_PTR($ijob,int), IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($alphar,float), IDX_PTR($alphai,float), IDX_PTR($beta,float), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($z,float), IDX_PTR($ldz,int), IDX_PTR($m,int), IDX_PTR($pl,float), IDX_PTR($pr,float), IDX_PTR($dif,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgsja <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <ncycle>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGSJA computes the generalized singular value decomposition (GSVD)
;;*  of two real upper triangular (or trapezoidal) matrices A and B.
;;*
;;*  On entry, it is assumed that matrices A and B have the following
;;*  forms, which may be obtained by the preprocessing subroutine SGGSVP
;;*  from a general M-by-N matrix A and P-by-N matrix B:
;;*
;;*               N-K-L  K    L
;;*     A =    K ( 0    A12  A13 ) if M-K-L >= 0;
;;*            L ( 0     0   A23 )
;;*        M-K-L ( 0     0    0  )
;;*
;;*             N-K-L  K    L
;;*     A =  K ( 0    A12  A13 ) if M-K-L < 0;
;;*        M-K ( 0     0   A23 )
;;*
;;*             N-K-L  K    L
;;*     B =  L ( 0     0   B13 )
;;*        P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.
;;*
;;*  On exit,
;;*
;;*              U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
;;*
;;*  where U, V and Q are orthogonal matrices, Z' denotes the transpose
;;*  of Z, R is a nonsingular upper triangular matrix, and D1 and D2 are
;;*  ``diagonal'' matrices, which are of the following structures:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                    K  L
;;*         D2 = L   ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                 N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 ) K
;;*              L (  0    0   R22 ) L
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                 K M-K K+L-M
;;*      D1 =   K ( I  0    0   )
;;*           M-K ( 0  C    0   )
;;*
;;*                   K M-K K+L-M
;;*      D2 =   M-K ( 0  S    0   )
;;*           K+L-M ( 0  0    I   )
;;*             P-L ( 0  0    0   )
;;*
;;*                 N-K-L  K   M-K  K+L-M
;;* ( 0 R ) =    K ( 0    R11  R12  R13  )
;;*            M-K ( 0     0   R22  R23  )
;;*          K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*  C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*  S = diag( BETA(K+1),  ... , BETA(M) ),
;;*  C**2 + S**2 = I.
;;*
;;*  R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
;;*      (  0  R22 R23 )
;;*  in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The computation of the orthogonal transformation matrices U, V or Q
;;*  is optional.  These matrices may either be formed explicitly, or they
;;*  may be postmultiplied into input matrices U1, V1, or Q1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  U must contain an orthogonal matrix U1 on entry, and
;;*                  the product U1*U is returned;
;;*          = 'I':  U is initialized to the unit matrix, and the
;;*                  orthogonal matrix U is returned;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  V must contain an orthogonal matrix V1 on entry, and
;;*                  the product V1*V is returned;
;;*          = 'I':  V is initialized to the unit matrix, and the
;;*                  orthogonal matrix V is returned;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Q must contain an orthogonal matrix Q1 on entry, and
;;*                  the product Q1*Q is returned;
;;*          = 'I':  Q is initialized to the unit matrix, and the
;;*                  orthogonal matrix Q is returned;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  K       (input) INTEGER
;;*  L       (input) INTEGER
;;*          K and L specify the subblocks in the input matrices A and B:
;;*          A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)
;;*          of A and B, whose GSVD is going to be computed by STGSJA.
;;*          See Further details.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
;;*          matrix R or part of R.  See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
;;*          a part of R.  See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) REAL
;;*  TOLB    (input) REAL
;;*          TOLA and TOLB are the convergence criteria for the Jacobi-
;;*          Kogbetliantz iteration procedure. Generally, they are the
;;*          same as used in the preprocessing step, say
;;*              TOLA = max(M,N)*norm(A)*MACHEPS,
;;*              TOLB = max(P,N)*norm(B)*MACHEPS.
;;*
;;*  ALPHA   (output) REAL array, dimension (N)
;;*  BETA    (output) REAL array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = diag(C),
;;*            BETA(K+1:K+L)  = diag(S),
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
;;*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
;;*          Furthermore, if K+L < N,
;;*            ALPHA(K+L+1:N) = 0 and
;;*            BETA(K+L+1:N)  = 0.
;;*
;;*  U       (input/output) REAL array, dimension (LDU,M)
;;*          On entry, if JOBU = 'U', U must contain a matrix U1 (usually
;;*          the orthogonal matrix returned by SGGSVP).
;;*          On exit,
;;*          if JOBU = 'I', U contains the orthogonal matrix U;
;;*          if JOBU = 'U', U contains the product U1*U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (input/output) REAL array, dimension (LDV,P)
;;*          On entry, if JOBV = 'V', V must contain a matrix V1 (usually
;;*          the orthogonal matrix returned by SGGSVP).
;;*          On exit,
;;*          if JOBV = 'I', V contains the orthogonal matrix V;
;;*          if JOBV = 'V', V contains the product V1*V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ,N)
;;*          On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
;;*          the orthogonal matrix returned by SGGSVP).
;;*          On exit,
;;*          if JOBQ = 'I', Q contains the orthogonal matrix Q;
;;*          if JOBQ = 'Q', Q contains the product Q1*Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) REAL array, dimension (2*N)
;;*
;;*  NCYCLE  (output) INTEGER
;;*          The number of cycles required for convergence.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1:  the procedure does not converge after MAXIT cycles.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXIT   INTEGER
;;*          MAXIT specifies the total loops that the iterative procedure
;;*          may take. If after MAXIT cycles, the routine fails to
;;*          converge, we return INFO = 1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  STGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
;;*  min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
;;*  matrix B13 to the form:
;;*
;;*           U1'*A13*Q1 = C1*R1; V1'*B13*Q1 = S1*R1,
;;*
;;*  where U1, V1 and Q1 are orthogonal matrix, and Z' is the transpose
;;*  of Z.  C1 and S1 are diagonal matrices satisfying
;;*
;;*                C1**2 + S1**2 = I,
;;*
;;*  and R1 is an L-by-L nonsingular upper triangular matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgsja (jobu  jobv  jobq  m  p  n  k  l  a  lda  b  ldb  tola  tolb  alpha  beta  u  ldu  v  ldv  q  ldq  work  ncycle  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) tola )
	((-idx0- (-float-)) tolb )
	((-idx1- (-float-)) alpha )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-float-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) ncycle )
	((-idx0- (-int-)) info )
	#{ stgsja_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($tola,float), IDX_PTR($tolb,float), IDX_PTR($alpha,float), IDX_PTR($beta,float), IDX_PTR($u,float), IDX_PTR($ldu,int), IDX_PTR($v,float), IDX_PTR($ldv,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($work,float), IDX_PTR($ncycle,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgsna <job>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <dif>  <mm>  <m>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or eigenvectors of a matrix pair (A, B) in
;;*  generalized real Schur canonical form (or of any matrix pair
;;*  (Q*A*Z', Q*B*Z') with orthogonal matrices Q and Z, where
;;*  Z' denotes the transpose of Z.
;;*
;;*  (A, B) must be in generalized real Schur form (as returned by SGGES),
;;*  i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
;;*  blocks. B is upper triangular.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (DIF):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (DIF);
;;*          = 'B': for both eigenvalues and eigenvectors (S and DIF).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the eigenpair corresponding to a real eigenvalue w(j),
;;*          SELECT(j) must be set to .TRUE.. To select condition numbers
;;*          corresponding to a complex conjugate pair of eigenvalues w(j)
;;*          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
;;*          set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the square matrix pair (A, B). N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The upper quasi-triangular matrix A in the pair (A,B).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input) REAL array, dimension (LDB,N)
;;*          The upper triangular matrix B in the pair (A,B).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  VL      (input) REAL array, dimension (LDVL,M)
;;*          If JOB = 'E' or 'B', VL must contain left eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT. The eigenvectors must be stored in consecutive
;;*          columns of VL, as returned by STGEVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL. LDVL >= 1.
;;*          If JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) REAL array, dimension (LDVR,M)
;;*          If JOB = 'E' or 'B', VR must contain right eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT. The eigenvectors must be stored in consecutive
;;*          columns ov VR, as returned by STGEVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR. LDVR >= 1.
;;*          If JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) REAL array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array. For a complex conjugate pair of eigenvalues two
;;*          consecutive elements of S are set to the same value. Thus
;;*          S(j), DIF(j), and the j-th columns of VL and VR all
;;*          correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  DIF     (output) REAL array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. For a complex eigenvector two
;;*          consecutive elements of DIF are set to the same value. If
;;*          the eigenvalues cannot be reordered to compute DIF(j), DIF(j)
;;*          is set to 0; this can only occur when the true value would be
;;*          very small anyway.
;;*          If JOB = 'E', DIF is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S and DIF. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and DIF used to store
;;*          the specified condition numbers; for each selected real
;;*          eigenvalue one element is used, and for each selected complex
;;*          conjugate pair of eigenvalues, two elements are used.
;;*          If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          If JOB = 'E', WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= N.
;;*          If JOB = 'V' or 'B' LWORK >= 2*N*(N+2)+16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N + 6)
;;*          If JOB = 'E', IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          =0: Successful exit
;;*          <0: If INFO = -i, the i-th argument had an illegal value
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of a generalized eigenvalue
;;*  w = (a, b) is defined as
;;*
;;*       S(w) = (|u'Av|**2 + |u'Bv|**2)**(1/2) / (norm(u)*norm(v))
;;*
;;*  where u and v are the left and right eigenvectors of (A, B)
;;*  corresponding to w; |z| denotes the absolute value of the complex
;;*  number, and norm(u) denotes the 2-norm of the vector u.
;;*  The pair (a, b) corresponds to an eigenvalue w = a/b (= u'Av/u'Bv)
;;*  of the matrix pair (A, B). If both a and b equal zero, then (A B) is
;;*  singular and S(I) = -1 is returned.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*       chord(w, lambda) <= EPS * norm(A, B) / S(I)
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number DIF(i) of right eigenvector u
;;*  and left eigenvector v corresponding to the generalized eigenvalue w
;;*  is defined as follows:
;;*
;;*  a) If the i-th eigenvalue w = (a,b) is real
;;*
;;*     Suppose U and V are orthogonal transformations such that
;;*
;;*                U'*(A, B)*V  = (S, T) = ( a   *  ) ( b  *  )  1
;;*                                        ( 0  S22 ),( 0 T22 )  n-1
;;*                                          1  n-1     1 n-1
;;*
;;*     Then the reciprocal condition number DIF(i) is
;;*
;;*                Difl((a, b), (S22, T22)) = sigma-min( Zl ),
;;*
;;*     where sigma-min(Zl) denotes the smallest singular value of the
;;*     2(n-1)-by-2(n-1) matrix
;;*
;;*         Zl = [ kron(a, In-1)  -kron(1, S22) ]
;;*              [ kron(b, In-1)  -kron(1, T22) ] .
;;*
;;*     Here In-1 is the identity matrix of size n-1. kron(X, Y) is the
;;*     Kronecker product between the matrices X and Y.
;;*
;;*     Note that if the default method for computing DIF(i) is wanted
;;*     (see SLATDF), then the parameter DIFDRI (see below) should be
;;*     changed from 3 to 4 (routine SLATDF(IJOB = 2 will be used)).
;;*     See STGSYL for more details.
;;*
;;*  b) If the i-th and (i+1)-th eigenvalues are complex conjugate pair,
;;*
;;*     Suppose U and V are orthogonal transformations such that
;;*
;;*                U'*(A, B)*V = (S, T) = ( S11  *   ) ( T11  *  )  2
;;*                                       ( 0    S22 ),( 0    T22) n-2
;;*                                         2    n-2     2    n-2
;;*
;;*     and (S11, T11) corresponds to the complex conjugate eigenvalue
;;*     pair (w, conjg(w)). There exist unitary matrices U1 and V1 such
;;*     that
;;*
;;*         U1'*S11*V1 = ( s11 s12 )   and U1'*T11*V1 = ( t11 t12 )
;;*                      (  0  s22 )                    (  0  t22 )
;;*
;;*     where the generalized eigenvalues w = s11/t11 and
;;*     conjg(w) = s22/t22.
;;*
;;*     Then the reciprocal condition number DIF(i) is bounded by
;;*
;;*         min( d1, max( 1, |real(s11)/real(s22)| )*d2 )
;;*
;;*     where, d1 = Difl((s11, t11), (s22, t22)) = sigma-min(Z1), where
;;*     Z1 is the complex 2-by-2 matrix
;;*
;;*              Z1 =  [ s11  -s22 ]
;;*                    [ t11  -t22 ],
;;*
;;*     This is done by computing (using real arithmetic) the
;;*     roots of the characteristical polynomial det(Z1' * Z1 - lambda I),
;;*     where Z1' denotes the conjugate transpose of Z1 and det(X) denotes
;;*     the determinant of X.
;;*
;;*     and d2 is an upper bound on Difl((S11, T11), (S22, T22)), i.e. an
;;*     upper bound on sigma-min(Z2), where Z2 is (2n-2)-by-(2n-2)
;;*
;;*              Z2 = [ kron(S11', In-2)  -kron(I2, S22) ]
;;*                   [ kron(T11', In-2)  -kron(I2, T22) ]
;;*
;;*     Note that if the default method for computing DIF is wanted (see
;;*     SLATDF), then the parameter DIFDRI (see below) should be changed
;;*     from 3 to 4 (routine SLATDF(IJOB = 2 will be used)). See STGSYL
;;*     for more details.
;;*
;;*  For each eigenvalue/vector specified by SELECT, DIF stores a
;;*  Frobenius norm-based estimate of Difl.
;;*
;;*  An approximate error bound for the i-th computed eigenvector VL(i) or
;;*  VR(i) is given by
;;*
;;*             EPS * norm(A, B) / DIF(i).
;;*
;;*  See ref. [2-3] for more details and further references.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software,
;;*      Report UMINF - 94.04, Department of Computing Science, Umea
;;*      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
;;*      Note 87. To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
;;*      No 1, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgsna (job  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  s  dif  mm  m  work  lwork  iwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) dif )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ stgsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($s,float), IDX_PTR($dif,float), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgsy2 <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <rdsum>  <rdscal>  <iwork>  <pq>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGSY2 solves the generalized Sylvester equation:
;;*
;;*              A * R - L * B = scale * C                (1)
;;*              D * R - L * E = scale * F,
;;*
;;*  using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
;;*  (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
;;*  N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
;;*  must be in generalized Schur canonical form, i.e. A, B are upper
;;*  quasi triangular and D, E are upper triangular. The solution (R, L)
;;*  overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
;;*  chosen to avoid overflow.
;;*
;;*  In matrix notation solving equation (1) corresponds to solve
;;*  Z*x = scale*b, where Z is defined as
;;*
;;*         Z = [ kron(In, A)  -kron(B', Im) ]             (2)
;;*             [ kron(In, D)  -kron(E', Im) ],
;;*
;;*  Ik is the identity matrix of size k and X' is the transpose of X.
;;*  kron(X, Y) is the Kronecker product between the matrices X and Y.
;;*  In the process of solving (1), we solve a number of such systems
;;*  where Dim(In), Dim(In) = 1 or 2.
;;*
;;*  If TRANS = 'T', solve the transposed system Z'*y = scale*b for y,
;;*  which is equivalent to solve for R and L in
;;*
;;*              A' * R  + D' * L   = scale *  C           (3)
;;*              R  * B' + L  * E'  = scale * -F
;;*
;;*  This case is used to compute an estimate of Dif[(A, D), (B, E)] =
;;*  sigma_min(Z) using reverse communicaton with SLACON.
;;*
;;*  STGSY2 also (IJOB >= 1) contributes to the computation in STGSYL
;;*  of an upper bound on the separation between to matrix pairs. Then
;;*  the input (A, D), (B, E) are sub-pencils of the matrix pair in
;;*  STGSYL. See STGSYL for details.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N', solve the generalized Sylvester equation (1).
;;*          = 'T': solve the 'transposed' system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*          = 0: solve (1) only.
;;*          = 1: A contribution from this subsystem to a Frobenius
;;*               norm-based estimate of the separation between two matrix
;;*               pairs is computed. (look ahead strategy is used).
;;*          = 2: A contribution from this subsystem to a Frobenius
;;*               norm-based estimate of the separation between two matrix
;;*               pairs is computed. (SGECON on sub-systems is used.)
;;*          Not referenced if TRANS = 'T'.
;;*
;;*  M       (input) INTEGER
;;*          On entry, M specifies the order of A and D, and the row
;;*          dimension of C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the order of B and E, and the column
;;*          dimension of C, F, R and L.
;;*
;;*  A       (input) REAL array, dimension (LDA, M)
;;*          On entry, A contains an upper quasi triangular matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the matrix A. LDA >= max(1, M).
;;*
;;*  B       (input) REAL array, dimension (LDB, N)
;;*          On entry, B contains an upper quasi triangular matrix.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the matrix B. LDB >= max(1, N).
;;*
;;*  C       (input/ output) REAL array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, C has been overwritten by the
;;*          solution R.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the matrix C. LDC >= max(1, M).
;;*
;;*  D       (input) REAL array, dimension (LDD, M)
;;*          On entry, D contains an upper triangular matrix.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the matrix D. LDD >= max(1, M).
;;*
;;*  E       (input) REAL array, dimension (LDE, N)
;;*          On entry, E contains an upper triangular matrix.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the matrix E. LDE >= max(1, N).
;;*
;;*  F       (input/ output) REAL array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, F has been overwritten by the
;;*          solution L.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the matrix F. LDF >= max(1, M).
;;*
;;*  SCALE   (output) REAL
;;*          On exit, 0 <= SCALE <= 1. If 0 < SCALE < 1, the solutions
;;*          R and L (C and F on entry) will hold the solutions to a
;;*          slightly perturbed system but the input matrices A, B, D and
;;*          E have not been changed. If SCALE = 0, R and L will hold the
;;*          solutions to the homogeneous system with C = F = 0. Normally,
;;*          SCALE = 1.
;;*
;;*  RDSUM   (input/output) REAL
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by STGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when STGSY2 is called by STGSYL.
;;*
;;*  RDSCAL  (input/output) REAL
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when STGSY2 is called by
;;*                STGSYL.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (M+N+2)
;;*
;;*  PQ      (output) INTEGER
;;*          On exit, the number of subsystems (of size 2-by-2, 4-by-4 and
;;*          8-by-8) solved by this routine.
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, if INFO is set to
;;*            =0: Successful exit
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            >0: The matrix pairs (A, D) and (B, E) have common or very
;;*                close eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgsy2 (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  rdsum  rdscal  iwork  pq  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) d )
	((-idx0- (-int-)) ldd )
	((-idx2- (-float-)) e )
	((-idx0- (-int-)) lde )
	((-idx2- (-float-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) rdsum )
	((-idx0- (-float-)) rdscal )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) pq )
	((-idx0- (-int-)) info )
	#{ stgsy2_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($d,float), IDX_PTR($ldd,int), IDX_PTR($e,float), IDX_PTR($lde,int), IDX_PTR($f,float), IDX_PTR($ldf,int), IDX_PTR($scale,float), IDX_PTR($rdsum,float), IDX_PTR($rdscal,float), IDX_PTR($iwork,int), IDX_PTR($pq,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stgsyl <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <dif>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STGSYL solves the generalized Sylvester equation:
;;*
;;*              A * R - L * B = scale * C                 (1)
;;*              D * R - L * E = scale * F
;;*
;;*  where R and L are unknown m-by-n matrices, (A, D), (B, E) and
;;*  (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
;;*  respectively, with real entries. (A, D) and (B, E) must be in
;;*  generalized (real) Schur canonical form, i.e. A, B are upper quasi
;;*  triangular and D, E are upper triangular.
;;*
;;*  The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
;;*  scaling factor chosen to avoid overflow.
;;*
;;*  In matrix notation (1) is equivalent to solve  Zx = scale b, where
;;*  Z is defined as
;;*
;;*             Z = [ kron(In, A)  -kron(B', Im) ]         (2)
;;*                 [ kron(In, D)  -kron(E', Im) ].
;;*
;;*  Here Ik is the identity matrix of size k and X' is the transpose of
;;*  X. kron(X, Y) is the Kronecker product between the matrices X and Y.
;;*
;;*  If TRANS = 'T', STGSYL solves the transposed system Z'*y = scale*b,
;;*  which is equivalent to solve for R and L in
;;*
;;*              A' * R  + D' * L   = scale *  C           (3)
;;*              R  * B' + L  * E'  = scale * (-F)
;;*
;;*  This case (TRANS = 'T') is used to compute an one-norm-based estimate
;;*  of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
;;*  and (B,E), using SLACON.
;;*
;;*  If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
;;*  of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
;;*  reciprocal of the smallest singular value of Z. See [1-2] for more
;;*  information.
;;*
;;*  This is a level 3 BLAS algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N', solve the generalized Sylvester equation (1).
;;*          = 'T', solve the 'transposed' system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*           =0: solve (1) only.
;;*           =1: The functionality of 0 and 3.
;;*           =2: The functionality of 0 and 4.
;;*           =3: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*               (look ahead strategy IJOB  = 1 is used).
;;*           =4: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*               ( SGECON on sub-systems is used ).
;;*          Not referenced if TRANS = 'T'.
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrices A and D, and the row dimension of
;;*          the matrices C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices B and E, and the column dimension
;;*          of the matrices C, F, R and L.
;;*
;;*  A       (input) REAL array, dimension (LDA, M)
;;*          The upper quasi triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1, M).
;;*
;;*  B       (input) REAL array, dimension (LDB, N)
;;*          The upper quasi triangular matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1, N).
;;*
;;*  C       (input/output) REAL array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, C has been overwritten by
;;*          the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1, M).
;;*
;;*  D       (input) REAL array, dimension (LDD, M)
;;*          The upper triangular matrix D.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the array D. LDD >= max(1, M).
;;*
;;*  E       (input) REAL array, dimension (LDE, N)
;;*          The upper triangular matrix E.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the array E. LDE >= max(1, N).
;;*
;;*  F       (input/output) REAL array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, F has been overwritten by
;;*          the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1, M).
;;*
;;*  DIF     (output) REAL
;;*          On exit DIF is the reciprocal of a lower bound of the
;;*          reciprocal of the Dif-function, i.e. DIF is an upper bound of
;;*          Dif[(A,D), (B,E)] = sigma_min(Z), where Z as in (2).
;;*          IF IJOB = 0 or TRANS = 'T', DIF is not touched.
;;*
;;*  SCALE   (output) REAL
;;*          On exit SCALE is the scaling factor in (1) or (3).
;;*          If 0 < SCALE < 1, C and F hold the solutions R and L, resp.,
;;*          to a slightly perturbed system but the input matrices A, B, D
;;*          and E have not been changed. If SCALE = 0, C and F hold the
;;*          solutions R and L, respectively, to the homogeneous system
;;*          with C = F = 0. Normally, SCALE = 1.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          If IJOB = 0, WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK > = 1.
;;*          If IJOB = 1 or 2 and TRANS = 'N', LWORK >= 2*M*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (M+N+6)
;;*
;;*  INFO    (output) INTEGER
;;*            =0: successful exit
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            >0: (A, D) and (B, E) have common or close eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
;;*      No 1, 1996.
;;*
;;*  [2] B. Kagstrom, A Perturbation Analysis of the Generalized Sylvester
;;*      Equation (AR - LB, DR - LE ) = (C, F), SIAM J. Matrix Anal.
;;*      Appl., 15(4):1045-1060, 1994
;;*
;;*  [3] B. Kagstrom and L. Westin, Generalized Schur Methods with
;;*      Condition Estimators for Solving the Generalized Sylvester
;;*      Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7,
;;*      July 1989, pp 745-751.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stgsyl (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  dif  work  lwork  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-float-)) d )
	((-idx0- (-int-)) ldd )
	((-idx2- (-float-)) e )
	((-idx0- (-int-)) lde )
	((-idx2- (-float-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-float-)) scale )
	((-idx0- (-float-)) dif )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ stgsyl_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($d,float), IDX_PTR($ldd,int), IDX_PTR($e,float), IDX_PTR($lde,int), IDX_PTR($f,float), IDX_PTR($ldf,int), IDX_PTR($scale,float), IDX_PTR($dif,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stpcon <norm>  <uplo>  <diag>  <n>  <ap>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STPCON estimates the reciprocal of the condition number of a packed
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stpcon (norm  uplo  diag  n  ap  rcond  work  iwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ stpcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stprfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STPRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular packed
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by STPTRS or some other
;;*  means before entering this routine.  STPRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) REAL array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stprfs (uplo  trans  diag  n  nrhs  ap  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ stprfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stptri <uplo>  <diag>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STPTRI computes the inverse of a real upper or lower triangular
;;*  matrix A stored in packed format.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) REAL array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangular matrix A, stored
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same packed storage format.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular
;;*                matrix is singular and its inverse can not be computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  A triangular matrix A can be transferred to packed storage using one
;;*  of the following program segments:
;;*
;;*  UPLO = 'U':                      UPLO = 'L':
;;*
;;*        JC = 1                           JC = 1
;;*        DO 2 J = 1, N                    DO 2 J = 1, N
;;*           DO 1 I = 1, J                    DO 1 I = J, N
;;*              AP(JC+I-1) = A(I,J)              AP(JC+I-J) = A(I,J)
;;*      1    CONTINUE                    1    CONTINUE
;;*           JC = JC + J                      JC = JC + N - J + 1
;;*      2 CONTINUE                       2 CONTINUE
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stptri (uplo  diag  n  ap  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ap )
	((-idx0- (-int-)) info )
	#{ stptri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stptrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STPTRS solves a triangular system of the form
;;*
;;*     A * X = B  or  A**T * X = B,
;;*
;;*  where A is a triangular matrix of order N stored in packed format,
;;*  and B is an N-by-NRHS matrix.  A check is made to verify that A is
;;*  nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) REAL array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stptrs (uplo  trans  diag  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-float-)) ap )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ stptrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,float), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strcon <norm>  <uplo>  <diag>  <n>  <a>  <lda>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRCON estimates the reciprocal of the condition number of a
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  RCOND   (output) REAL
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strcon (norm  uplo  diag  n  a  lda  rcond  work  iwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) rcond )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ strcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($rcond,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strevc <side>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STREVC computes some or all of the right and/or left eigenvectors of
;;*  a real upper quasi-triangular matrix T.
;;*
;;*  The right eigenvector x and the left eigenvector y of T corresponding
;;*  to an eigenvalue w are defined by:
;;*
;;*               T*x = w*x,     y'*T = w*y'
;;*
;;*  where y' denotes the conjugate transpose of the vector y.
;;*
;;*  If all eigenvectors are requested, the routine may either return the
;;*  matrices X and/or Y of right or left eigenvectors of T, or the
;;*  products Q*X and/or Q*Y, where Q is an input orthogonal
;;*  matrix. If T was obtained from the real-Schur factorization of an
;;*  original matrix A = Q*T*Q', then Q*X and Q*Y are the matrices of
;;*  right or left eigenvectors of A.
;;*
;;*  T must be in Schur canonical form (as returned by SHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
;;*  diagonal block is a complex conjugate pair of eigenvalues and
;;*  eigenvectors; only one eigenvector of the pair is computed, namely
;;*  the one corresponding to the eigenvalue with positive imaginary part.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  compute right eigenvectors only;
;;*          = 'L':  compute left eigenvectors only;
;;*          = 'B':  compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A':  compute all right and/or left eigenvectors;
;;*          = 'B':  compute all right and/or left eigenvectors,
;;*                  and backtransform them using the input matrices
;;*                  supplied in VR and/or VL;
;;*          = 'S':  compute selected right and/or left eigenvectors,
;;*                  specified by the logical array SELECT.
;;*
;;*  SELECT  (input/output) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY = 'A' or 'B', SELECT is not referenced.
;;*          To select the real eigenvector corresponding to a real
;;*          eigenvalue w(j), SELECT(j) must be set to .TRUE..  To select
;;*          the complex eigenvector corresponding to a complex conjugate
;;*          pair w(j) and w(j+1), either SELECT(j) or SELECT(j+1) must be
;;*          set to .TRUE.; then on exit SELECT(j) is .TRUE. and
;;*          SELECT(j+1) is .FALSE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input) REAL array, dimension (LDT,N)
;;*          The upper quasi-triangular matrix T in Schur canonical form.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input/output) REAL array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Q
;;*          of Schur vectors returned by SHSEQR).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
;;*                           VL has the same quasi-lower triangular form
;;*                           as T'. If T(i,i) is a real eigenvalue, then
;;*                           the i-th column VL(i) of VL  is its
;;*                           corresponding eigenvector. If T(i:i+1,i:i+1)
;;*                           is a 2-by-2 block whose eigenvalues are
;;*                           complex-conjugate eigenvalues of T, then
;;*                           VL(i)+sqrt(-1)*VL(i+1) is the complex
;;*                           eigenvector corresponding to the eigenvalue
;;*                           with positive real part.
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VL, in the same order as their
;;*                           eigenvalues.
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part, and the second the imaginary part.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= max(1,N) if
;;*          SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) REAL array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Q
;;*          of Schur vectors returned by SHSEQR).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of T;
;;*                           VR has the same quasi-upper triangular form
;;*                           as T. If T(i,i) is a real eigenvalue, then
;;*                           the i-th column VR(i) of VR  is its
;;*                           corresponding eigenvector. If T(i:i+1,i:i+1)
;;*                           is a 2-by-2 block whose eigenvalues are
;;*                           complex-conjugate eigenvalues of T, then
;;*                           VR(i)+sqrt(-1)*VR(i+1) is the complex
;;*                           eigenvector corresponding to the eigenvalue
;;*                           with positive real part.
;;*          if HOWMNY = 'B', the matrix Q*X;
;;*          if HOWMNY = 'S', the right eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VR, in the same order as their
;;*                           eigenvalues.
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part and the second the imaginary part.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= max(1,N) if
;;*          SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.
;;*          If HOWMNY = 'A' or 'B', M is set to N.
;;*          Each selected real eigenvector occupies one column and each
;;*          selected complex eigenvector occupies two columns.
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The algorithm used in this program is basically backward (forward)
;;*  substitution, with scaling to make the the code robust against
;;*  possible overflow.
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x| + |y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strevc (side  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  mm  m  work  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ strevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strexc <compq>  <n>  <t_>  <ldt>  <q>  <ldq>  <ifst>  <ilst>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STREXC reorders the real Schur factorization of a real matrix
;;*  A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
;;*  moved to row ILST.
;;*
;;*  The real Schur form T is reordered by an orthogonal similarity
;;*  transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
;;*  is updated by postmultiplying it with Z.
;;*
;;*  T must be in Schur canonical form (as returned by SHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V':  update the matrix Q of Schur vectors;
;;*          = 'N':  do not update Q.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) REAL array, dimension (LDT,N)
;;*          On entry, the upper quasi-triangular matrix T, in Schur
;;*          Schur canonical form.
;;*          On exit, the reordered upper quasi-triangular matrix, again
;;*          in Schur canonical form.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          orthogonal transformation matrix Z which reorders T.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  IFST    (input/output) INTEGER
;;*  ILST    (input/output) INTEGER
;;*          Specify the reordering of the diagonal blocks of T.
;;*          The block with row index IFST is moved to row ILST, by a
;;*          sequence of transpositions between adjacent blocks.
;;*          On exit, if IFST pointed on entry to the second row of a
;;*          2-by-2 block, it is changed to point to the first row; ILST
;;*          always points to the first row of the block in its final
;;*          position (which may differ from its input value by +1 or -1).
;;*          1 <= IFST <= N; 1 <= ILST <= N.
;;*
;;*  WORK    (workspace) REAL array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          = 1:  two adjacent blocks were too close to swap (the problem
;;*                is very ill-conditioned); T may have been partially
;;*                reordered, and ILST points to the first row of the
;;*                current position of the block being moved.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strexc (compq  n  t_  ldt  q  ldq  ifst  ilst  work  info  )
	((-str-) compq )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) info )
	#{ strexc_($compq->data, IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($work,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strrfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by STRTRS or some other
;;*  means before entering this routine.  STRRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) REAL array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) REAL array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) REAL array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) REAL array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) REAL array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strrfs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-float-)) ferr )
	((-idx1- (-float-)) berr )
	((-idx1- (-float-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ strrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($x,float), IDX_PTR($ldx,int), IDX_PTR($ferr,float), IDX_PTR($berr,float), IDX_PTR($work,float), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strsen <job>  <compq>  <select>  <n>  <t_>  <ldt>  <q>  <ldq>  <wr>  <wi>  <m>  <s>  <sep>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRSEN reorders the real Schur factorization of a real matrix
;;*  A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
;;*  the leading diagonal blocks of the upper quasi-triangular matrix T,
;;*  and the leading columns of Q form an orthonormal basis of the
;;*  corresponding right invariant subspace.
;;*
;;*  Optionally the routine computes the reciprocal condition numbers of
;;*  the cluster of eigenvalues and/or the invariant subspace.
;;*
;;*  T must be in Schur canonical form (as returned by SHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elemnts equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (S) or the invariant subspace (SEP):
;;*          = 'N': none;
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for invariant subspace only (SEP);
;;*          = 'B': for both eigenvalues and invariant subspace (S and
;;*                 SEP).
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V': update the matrix Q of Schur vectors;
;;*          = 'N': do not update Q.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster. To
;;*          select a real eigenvalue w(j), SELECT(j) must be set to
;;*          .TRUE.. To select a complex conjugate pair of eigenvalues
;;*          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
;;*          either SELECT(j) or SELECT(j+1) or both must be set to
;;*          .TRUE.; a complex conjugate pair of eigenvalues must be
;;*          either both included in the cluster or both excluded.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) REAL array, dimension (LDT,N)
;;*          On entry, the upper quasi-triangular matrix T, in Schur
;;*          canonical form.
;;*          On exit, T is overwritten by the reordered matrix T, again in
;;*          Schur canonical form, with the selected eigenvalues in the
;;*          leading diagonal blocks.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) REAL array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          orthogonal transformation matrix which reorders T; the
;;*          leading M columns of Q form an orthonormal basis for the
;;*          specified invariant subspace.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1; and if COMPQ = 'V', LDQ >= N.
;;*
;;*  WR      (output) REAL array, dimension (N)
;;*  WI      (output) REAL array, dimension (N)
;;*          The real and imaginary parts, respectively, of the reordered
;;*          eigenvalues of T. The eigenvalues are stored in the same
;;*          order as on the diagonal of T, with WR(i) = T(i,i) and, if
;;*          T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) > 0 and
;;*          WI(i+1) = -WI(i). Note that if a complex eigenvalue is
;;*          sufficiently ill-conditioned, then its value may differ
;;*          significantly from its value before reordering.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified invariant subspace.
;;*          0 < = M <= N.
;;*
;;*  S       (output) REAL
;;*          If JOB = 'E' or 'B', S is a lower bound on the reciprocal
;;*          condition number for the selected cluster of eigenvalues.
;;*          S cannot underestimate the true reciprocal condition number
;;*          by more than a factor of sqrt(N). If M = 0 or N, S = 1.
;;*          If JOB = 'N' or 'V', S is not referenced.
;;*
;;*  SEP     (output) REAL
;;*          If JOB = 'V' or 'B', SEP is the estimated reciprocal
;;*          condition number of the specified invariant subspace. If
;;*          M = 0 or N, SEP = norm(T).
;;*          If JOB = 'N' or 'E', SEP is not referenced.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If JOB = 'N', LWORK >= max(1,N);
;;*          if JOB = 'E', LWORK >= M*(N-M);
;;*          if JOB = 'V' or 'B', LWORK >= 2*M*(N-M).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          IF JOB = 'N' or 'E', IWORK is not referenced.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOB = 'N' or 'E', LIWORK >= 1;
;;*          if JOB = 'V' or 'B', LIWORK >= M*(N-M).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1: reordering of T failed because some eigenvalues are too
;;*               close to separate (the problem is very ill-conditioned);
;;*               T may have been partially reordered, and WR and WI
;;*               contain the eigenvalues in the same order as in T; S and
;;*               SEP (if requested) are set to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  STRSEN first collects the selected eigenvalues by computing an
;;*  orthogonal transformation Z to move them to the top left corner of T.
;;*  In other words, the selected eigenvalues are the eigenvalues of T11
;;*  in:
;;*
;;*                Z'*T*Z = ( T11 T12 ) n1
;;*                         (  0  T22 ) n2
;;*                            n1  n2
;;*
;;*  where N = n1+n2 and Z' means the transpose of Z. The first n1 columns
;;*  of Z span the specified invariant subspace of T.
;;*
;;*  If T has been obtained from the real Schur factorization of a matrix
;;*  A = Q*T*Q', then the reordered real Schur factorization of A is given
;;*  by A = (Q*Z)*(Z'*T*Z)*(Q*Z)', and the first n1 columns of Q*Z span
;;*  the corresponding invariant subspace of A.
;;*
;;*  The reciprocal condition number of the average of the eigenvalues of
;;*  T11 may be returned in S. S lies between 0 (very badly conditioned)
;;*  and 1 (very well conditioned). It is computed as follows. First we
;;*  compute R so that
;;*
;;*                         P = ( I  R ) n1
;;*                             ( 0  0 ) n2
;;*                               n1 n2
;;*
;;*  is the projector on the invariant subspace associated with T11.
;;*  R is the solution of the Sylvester equation:
;;*
;;*                        T11*R - R*T22 = T12.
;;*
;;*  Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
;;*  the two-norm of M. Then S is computed as the lower bound
;;*
;;*                      (1 + F-norm(R)**2)**(-1/2)
;;*
;;*  on the reciprocal of 2-norm(P), the true reciprocal condition number.
;;*  S cannot underestimate 1 / 2-norm(P) by more than a factor of
;;*  sqrt(N).
;;*
;;*  An approximate error bound for the computed average of the
;;*  eigenvalues of T11 is
;;*
;;*                         EPS * norm(T) / S
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal condition number of the right invariant subspace
;;*  spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
;;*  SEP is defined as the separation of T11 and T22:
;;*
;;*                     sep( T11, T22 ) = sigma-min( C )
;;*
;;*  where sigma-min(C) is the smallest singular value of the
;;*  n1*n2-by-n1*n2 matrix
;;*
;;*     C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )
;;*
;;*  I(m) is an m by m identity matrix, and kprod denotes the Kronecker
;;*  product. We estimate sigma-min(C) by the reciprocal of an estimate of
;;*  the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
;;*  cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).
;;*
;;*  When SEP is small, small changes in T can cause large changes in
;;*  the invariant subspace. An approximate bound on the maximum angular
;;*  error in the computed right invariant subspace is
;;*
;;*                      EPS * norm(T) / SEP
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strsen (job  compq  select  n  t_  ldt  q  ldq  wr  wi  m  s  sep  work  lwork  iwork  liwork  info  )
	((-str-) job )
	((-str-) compq )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-float-)) wr )
	((-idx1- (-float-)) wi )
	((-idx0- (-int-)) m )
	((-idx0- (-float-)) s )
	((-idx0- (-float-)) sep )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ strsen_($job->data, $compq->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($q,float), IDX_PTR($ldq,int), IDX_PTR($wr,float), IDX_PTR($wi,float), IDX_PTR($m,int), IDX_PTR($s,float), IDX_PTR($sep,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strsna <job>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <sep>  <mm>  <m>  <work>  <ldwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or right eigenvectors of a real upper
;;*  quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
;;*  orthogonal).
;;*
;;*  T must be in Schur canonical form (as returned by SHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (SEP):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (SEP);
;;*          = 'B': for both eigenvalues and eigenvectors (S and SEP).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the eigenpair corresponding to a real eigenvalue w(j),
;;*          SELECT(j) must be set to .TRUE.. To select condition numbers
;;*          corresponding to a complex conjugate pair of eigenvalues w(j)
;;*          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
;;*          set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input) REAL array, dimension (LDT,N)
;;*          The upper quasi-triangular matrix T, in Schur canonical form.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input) REAL array, dimension (LDVL,M)
;;*          If JOB = 'E' or 'B', VL must contain left eigenvectors of T
;;*          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VL, as returned by
;;*          SHSEIN or STREVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) REAL array, dimension (LDVR,M)
;;*          If JOB = 'E' or 'B', VR must contain right eigenvectors of T
;;*          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VR, as returned by
;;*          SHSEIN or STREVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) REAL array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array. For a complex conjugate pair of eigenvalues two
;;*          consecutive elements of S are set to the same value. Thus
;;*          S(j), SEP(j), and the j-th columns of VL and VR all
;;*          correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  SEP     (output) REAL array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. For a complex eigenvector two
;;*          consecutive elements of SEP are set to the same value. If
;;*          the eigenvalues cannot be reordered to compute SEP(j), SEP(j)
;;*          is set to 0; this can only occur when the true value would be
;;*          very small anyway.
;;*          If JOB = 'E', SEP is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S (if JOB = 'E' or 'B')
;;*           and/or SEP (if JOB = 'V' or 'B'). MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and/or SEP actually
;;*          used to store the estimated condition numbers.
;;*          If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace) REAL array, dimension (LDWORK,N+1)
;;*          If JOB = 'E', WORK is not referenced.
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*          If JOB = 'E', IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of an eigenvalue lambda is
;;*  defined as
;;*
;;*          S(lambda) = |v'*u| / (norm(u)*norm(v))
;;*
;;*  where u and v are the right and left eigenvectors of T corresponding
;;*  to lambda; v' denotes the conjugate-transpose of v, and norm(u)
;;*  denotes the Euclidean norm. These reciprocal condition numbers always
;;*  lie between zero (very badly conditioned) and one (very well
;;*  conditioned). If n = 1, S(lambda) is defined to be 1.
;;*
;;*  An approximate error bound for a computed eigenvalue W(i) is given by
;;*
;;*                      EPS * norm(T) / S(i)
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number of the right eigenvector u
;;*  corresponding to lambda is defined as follows. Suppose
;;*
;;*              T = ( lambda  c  )
;;*                  (   0    T22 )
;;*
;;*  Then the reciprocal condition number is
;;*
;;*          SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )
;;*
;;*  where sigma-min denotes the smallest singular value. We approximate
;;*  the smallest singular value by the reciprocal of an estimate of the
;;*  one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is
;;*  defined to be abs(T(1,1)).
;;*
;;*  An approximate error bound for a computed right eigenvector VR(i)
;;*  is given by
;;*
;;*                      EPS * norm(T) / SEP(i)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strsna (job  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  s  sep  mm  m  work  ldwork  iwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-float-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-float-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-float-)) s )
	((-idx1- (-float-)) sep )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-float-)) work )
	((-idx0- (-int-)) ldwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ strsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,float), IDX_PTR($ldt,int), IDX_PTR($vl,float), IDX_PTR($ldvl,int), IDX_PTR($vr,float), IDX_PTR($ldvr,int), IDX_PTR($s,float), IDX_PTR($sep,float), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,float), IDX_PTR($ldwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strsyl <trana>  <tranb>  <isgn>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRSYL solves the real Sylvester matrix equation:
;;*
;;*     op(A)*X + X*op(B) = scale*C or
;;*     op(A)*X - X*op(B) = scale*C,
;;*
;;*  where op(A) = A or A**T, and  A and B are both upper quasi-
;;*  triangular. A is M-by-M and B is N-by-N; the right hand side C and
;;*  the solution X are M-by-N; and scale is an output scale factor, set
;;*  <= 1 to avoid overflow in X.
;;*
;;*  A and B must be in Schur canonical form (as returned by SHSEQR), that
;;*  is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
;;*  each 2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANA   (input) CHARACTER*1
;;*          Specifies the option op(A):
;;*          = 'N': op(A) = A    (No transpose)
;;*          = 'T': op(A) = A**T (Transpose)
;;*          = 'C': op(A) = A**H (Conjugate transpose = Transpose)
;;*
;;*  TRANB   (input) CHARACTER*1
;;*          Specifies the option op(B):
;;*          = 'N': op(B) = B    (No transpose)
;;*          = 'T': op(B) = B**T (Transpose)
;;*          = 'C': op(B) = B**H (Conjugate transpose = Transpose)
;;*
;;*  ISGN    (input) INTEGER
;;*          Specifies the sign in the equation:
;;*          = +1: solve op(A)*X + X*op(B) = scale*C
;;*          = -1: solve op(A)*X - X*op(B) = scale*C
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrix A, and the number of rows in the
;;*          matrices X and C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B, and the number of columns in the
;;*          matrices X and C. N >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,M)
;;*          The upper quasi-triangular matrix A, in Schur canonical form.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input) REAL array, dimension (LDB,N)
;;*          The upper quasi-triangular matrix B, in Schur canonical form.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  C       (input/output) REAL array, dimension (LDC,N)
;;*          On entry, the M-by-N right hand side matrix C.
;;*          On exit, C is overwritten by the solution matrix X.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M)
;;*
;;*  SCALE   (output) REAL
;;*          The scale factor, scale, set <= 1 to avoid overflow in X.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1: A and B have common or very close eigenvalues; perturbed
;;*               values were used to solve the equation (but the matrices
;;*               A and B are unchanged).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strsyl (trana  tranb  isgn  m  n  a  lda  b  ldb  c  ldc  scale  info  )
	((-str-) trana )
	((-str-) tranb )
	((-idx0- (-int-)) isgn )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-float-)) c )
	((-idx0- (-int-)) ldc )
	((-idx0- (-float-)) scale )
	((-idx0- (-int-)) info )
	#{ strsyl_($trana->data, $tranb->data, IDX_PTR($isgn,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($c,float), IDX_PTR($ldc,int), IDX_PTR($scale,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strti2 <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRTI2 computes the inverse of a real upper or lower triangular
;;*  matrix.
;;*
;;*  This is the Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading n by n upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strti2 (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ strti2_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strtri <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRTRI computes the inverse of a real upper or lower triangular
;;*  matrix A.
;;*
;;*  This is the Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
;;*               matrix is singular and its inverse can not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strtri (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ strtri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (strtrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STRTRS solves a triangular system of the form
;;*
;;*     A * X = B  or  A**T * X = B,
;;*
;;*  where A is a triangular matrix of order N, and B is an N-by-NRHS
;;*  matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) REAL array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) REAL array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the i-th diagonal element of A is zero,
;;*               indicating that the matrix is singular and the solutions
;;*               X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de strtrs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ strtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stzrqf <m>  <n>  <a>  <lda>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine STZRZF.
;;*
;;*  STZRQF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
;;*  to upper triangular form by means of orthogonal transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= M.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          orthogonal matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stzrqf (m  n  a  lda  tau  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx0- (-int-)) info )
	#{ stzrqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (stzrzf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  STZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
;;*  to upper triangular form by means of orthogonal transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) REAL array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          orthogonal matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) REAL array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) REAL array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de stzrzf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) tau )
	((-idx1- (-float-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ stzrzf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($tau,float), IDX_PTR($work,float), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar lapack-s-funclist
  '("sbdsdc" "sbdsqr" "scsum1" "sdisna"
    "second" "sgbbrd" "sgbcon" "sgbequ" "sgbrfs" "sgbsv" "sgbsvx" "sgbtf2"
    "sgbtrf" "sgbtrs" "sgebak" "sgebal" "sgebd2" "sgebrd" "sgecon"
    "sgeequ" "sgees" "sgeesx" "sgeev" "sgeevx" "sgegs" "sgegv" "sgehd2"
    "sgehrd" "sgelq2" "sgelqf" "sgelsd" "sgels" "sgelss" "sgelsx" "sgelsy"
    "sgeql2" "sgeqlf" "sgeqp3" "sgeqpf" "sgeqr2" "sgeqrf" "sgerfs"
    "sgerq2" "sgerqf" "sgesc2" "sgesdd" "sgesvd" "sgesv" "sgesvx" "sgetc2"
    "sgetf2" "sgetrf" "sgetri" "sgetrs" "sggbak" "sggbal" "sgges" "sggesx"
    "sggev" "sggevx" "sggglm" "sgghrd" "sgglse" "sggqrf" "sggrqf" "sggsvd"
    "sggsvp" "sgtcon" "sgtrfs" "sgtsv" "sgtsvx" "sgttrf" "sgttrs" "sgtts2"
    "shgeqz" "shsein" "shseqr" "slabad" "slabrd" "slacon" "slacpy"
    "sladiv" "slae2" "slaebz" "slaed0" "slaed1" "slaed2" "slaed3" "slaed4"
    "slaed5" "slaed6" "slaed7" "slaed8" "slaed9" "slaeda" "slaein"
    "slaev2" "slaexc" "slag2" "slags2" "slagtf" "slagtm" "slagts" "slagv2"
    "slahqr" "slahrd" "slaic1" "slaln2" "slals0" "slalsa" "slalsd"
    "slamch" "slamrg" "slangb" "slange" "slangt" "slanhs" "slansb"
    "slansp" "slanst" "slansy" "slantb" "slantp" "slantr" "slanv2"
    "slapll" "slapmt" "slapy2" "slapy3" "slaqgb" "slaqge" "slaqp2"
    "slaqps" "slaqsb" "slaqsp" "slaqsy" "slaqtr" "slar1v" "slar2v"
    "slarfb" "slarf" "slarfg" "slarft" "slarfx" "slargv" "slarnv" "slarrb"
    "slarre" "slarrf" "slarrv" "slartg" "slartv" "slaruv" "slarzb" "slarz"
    "slarzt" "slas2" "slascl" "slasd0" "slasd1" "slasd2" "slasd3" "slasd4"
    "slasd5" "slasd6" "slasd7" "slasd8"         "slasda" "slasdq"
    "slasdt" "slaset" "slasq1" "slasq2" "slasq3" "slasq4" "slasq5"
    "slasq6" "slasr" "slasrt" "slassq" "slasv2" "slaswp" "slasy2" "slasyf"
    "slatbs" "slatdf" "slatps" "slatrd" "slatrs" "slatrz" "slatzm"
    "slauu2" "slauum" "sopgtr" "sopmtr" "sorg2l" "sorg2r" "sorgbr"
    "sorghr" "sorgl2" "sorglq" "sorgql" "sorgqr" "sorgr2" "sorgrq"
    "sorgtr" "sorm2l" "sorm2r" "sormbr" "sormhr" "sorml2" "sormlq"
    "sormql" "sormqr" "sormr2" "sormr3" "sormrq" "sormrz" "sormtr"
    "spbcon" "spbequ" "spbrfs" "spbstf" "spbsv" "spbsvx" "spbtf2" "spbtrf"
    "spbtrs" "spocon" "spoequ" "sporfs" "sposv" "sposvx" "spotf2" "spotrf"
    "spotri" "spotrs" "sppcon" "sppequ" "spprfs" "sppsv" "sppsvx" "spptrf"
    "spptri" "spptrs" "sptcon" "spteqr" "sptrfs" "sptsv" "sptsvx" "spttrf"
    "spttrs" "sptts2" "srscl" "ssbevd" "ssbev" "ssbevx" "ssbgst" "ssbgvd"
    "ssbgv" "ssbgvx" "ssbtrd" "sspcon" "sspevd" "sspev" "sspevx" "sspgst"
    "sspgvd" "sspgv" "sspgvx" "ssprfs" "sspsv" "sspsvx" "ssptrd" "ssptrf"
    "ssptri" "ssptrs" "sstebz" "sstedc" "sstegr" "sstein" "ssteqr"
    "ssterf" "sstevd" "sstev" "sstevr" "sstevx" "ssycon" "ssyevd" "ssyev"
    "ssyevr" "ssyevx" "ssygs2" "ssygst" "ssygvd" "ssygv" "ssygvx" "ssyrfs"
    "ssysv" "ssysvx" "ssytd2" "ssytf2" "ssytrd" "ssytrf" "ssytri" "ssytrs"
    "stbcon" "stbrfs" "stbtrs" "stgevc" "stgex2" "stgexc" "stgsen"
    "stgsja" "stgsna" "stgsy2" "stgsyl" "stpcon" "stprfs" "stptri"
    "stptrs" "strcon" "strevc" "strexc" "strrfs" "strsen" "strsna"
    "strsyl" "strti2" "strtri" "strtrs" "stzrqf" "stzrzf" ))

(with-namespace lush1-
(let ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags)))
  (dhc-make-all 
   ()
   (all ((x (cons "lapack-s-dummy" lapack-s-funclist)))
     (named (downcase x)))
   (append lapack-liblapack lapack-libfortran)))
)
