#? * LAPACK: Double Precision Functions
;;.AUTHOR Fu Jie Huang, Yann LeCun
;; This provides a complete interface to the FORTRAN LAPACK
;; library of low-level linear algebra functions.

(libload "blas/blas-d")

(libload "lapack-config")
(libload "lapack-x")


;; Check if we can short-circuit by just mod-loading the object file
(let* ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags))
       (objfile (dhc-make-test ())) )
  (when objfile
    (mod-load objfile)
    (mapcar mod-load (append lapack-liblapack lapack-libfortran))
    (exit) ) )


(de lapack-d-dummy () (cheader "typedef int int_func();") ())


#? (dbdsdc <uplo>  <compq>  <n>  <d>  <e>  <u>  <ldu>  <vt>  <ldvt>  <q>  <iq>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DBDSDC computes the singular value decomposition (SVD) of a real
;;*  N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
;;*  using a divide and conquer method, where S is a diagonal matrix
;;*  with non-negative diagonal elements (the singular values of B), and
;;*  U and VT are orthogonal matrices of left and right singular vectors,
;;*  respectively. DBDSDC can be used to compute all singular values,
;;*  and optionally, singular vectors or singular vectors in compact form.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.  See DLASD3 for details.
;;*
;;*  The code currently call DLASDQ if singular values only are desired.
;;*  However, it can be slightly modified to compute singular values
;;*  using the divide and conquer method.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  B is upper bidiagonal.
;;*          = 'L':  B is lower bidiagonal.
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          Specifies whether singular vectors are to be computed
;;*          as follows:
;;*          = 'N':  Compute singular values only;
;;*          = 'P':  Compute singular values and compute singular
;;*                  vectors in compact form;
;;*          = 'I':  Compute singular values and singular vectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the bidiagonal matrix B.
;;*          On exit, if INFO=0, the singular values of B.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the elements of E contain the offdiagonal
;;*          elements of the bidiagonal matrix whose SVD is desired.
;;*          On exit, E has been destroyed.
;;*
;;*  U       (output) DOUBLE PRECISION array, dimension (LDU,N)
;;*          If  COMPQ = 'I', then:
;;*             On exit, if INFO = 0, U contains the left singular vectors
;;*             of the bidiagonal matrix.
;;*          For other values of COMPQ, U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1.
;;*          If singular vectors are desired, then LDU >= max( 1, N ).
;;*
;;*  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
;;*          If  COMPQ = 'I', then:
;;*             On exit, if INFO = 0, VT' contains the right singular
;;*             vectors of the bidiagonal matrix.
;;*          For other values of COMPQ, VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1.
;;*          If singular vectors are desired, then LDVT >= max( 1, N ).
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ)
;;*          If  COMPQ = 'P', then:
;;*             On exit, if INFO = 0, Q and IQ contain the left
;;*             and right singular vectors in a compact form,
;;*             requiring O(N log N) space instead of 2*N**2.
;;*             In particular, Q contains all the DOUBLE PRECISION data in
;;*             LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
;;*             words of memory, where SMLSIZ is returned by ILAENV and
;;*             is equal to the maximum size of the subproblems at the
;;*             bottom of the computation tree (usually about 25).
;;*          For other values of COMPQ, Q is not referenced.
;;*
;;*  IQ      (output) INTEGER array, dimension (LDIQ)
;;*          If  COMPQ = 'P', then:
;;*             On exit, if INFO = 0, Q and IQ contain the left
;;*             and right singular vectors in a compact form,
;;*             requiring O(N log N) space instead of 2*N**2.
;;*             In particular, IQ contains all INTEGER data in
;;*             LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
;;*             words of memory, where SMLSIZ is returned by ILAENV and
;;*             is equal to the maximum size of the subproblems at the
;;*             bottom of the computation tree (usually about 25).
;;*          For other values of COMPQ, IQ is not referenced.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
;;*          If COMPQ = 'N' then LWORK >= (4 * N).
;;*          If COMPQ = 'P' then LWORK >= (6 * N).
;;*          If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (8*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an singular value.
;;*                The update process of divide and conquer failed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dbdsdc (uplo  compq  n  d  e  u  ldu  vt  ldvt  q  iq  work  iwork  info  )
	((-str-) uplo )
	((-str-) compq )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-double-)) q )
	((-idx1- (-int-)) iq )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dbdsdc_($uplo->data, $compq->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($q,double), IDX_PTR($iq,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dbdsqr <uplo>  <n>  <ncvt>  <nru>  <ncc>  <d>  <e>  <vt>  <ldvt>  <u>  <ldu>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DBDSQR computes the singular value decomposition (SVD) of a real
;;*  N-by-N (upper or lower) bidiagonal matrix B:  B = Q * S * P' (P'
;;*  denotes the transpose of P), where S is a diagonal matrix with
;;*  non-negative diagonal elements (the singular values of B), and Q
;;*  and P are orthogonal matrices.
;;*
;;*  The routine computes S, and optionally computes U * Q, P' * VT,
;;*  or Q' * C, for given real input matrices U, VT, and C.
;;*
;;*  See "Computing  Small Singular Values of Bidiagonal Matrices With
;;*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
;;*  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
;;*  no. 5, pp. 873-912, Sept 1990) and
;;*  "Accurate singular values and differential qd algorithms," by
;;*  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
;;*  Department, University of California at Berkeley, July 1992
;;*  for a detailed description of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  B is upper bidiagonal;
;;*          = 'L':  B is lower bidiagonal.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B.  N >= 0.
;;*
;;*  NCVT    (input) INTEGER
;;*          The number of columns of the matrix VT. NCVT >= 0.
;;*
;;*  NRU     (input) INTEGER
;;*          The number of rows of the matrix U. NRU >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C. NCC >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the bidiagonal matrix B.
;;*          On exit, if INFO=0, the singular values of B in decreasing
;;*          order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the elements of E contain the
;;*          offdiagonal elements of the bidiagonal matrix whose SVD
;;*          is desired. On normal exit (INFO = 0), E is destroyed.
;;*          If the algorithm does not converge (INFO > 0), D and E
;;*          will contain the diagonal and superdiagonal elements of a
;;*          bidiagonal matrix orthogonally equivalent to the one given
;;*          as input. E(N) is used for workspace.
;;*
;;*  VT      (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
;;*          On entry, an N-by-NCVT matrix VT.
;;*          On exit, VT is overwritten by P' * VT.
;;*          VT is not referenced if NCVT = 0.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.
;;*          LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
;;*
;;*  U       (input/output) DOUBLE PRECISION array, dimension (LDU, N)
;;*          On entry, an NRU-by-N matrix U.
;;*          On exit, U is overwritten by U * Q.
;;*          U is not referenced if NRU = 0.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= max(1,NRU).
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
;;*          On entry, an N-by-NCC matrix C.
;;*          On exit, C is overwritten by Q' * C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  If INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm did not converge; D and E contain the
;;*                elements of a bidiagonal matrix which is orthogonally
;;*                similar to the input matrix B;  if INFO = i, i
;;*                elements of E have not converged to zero.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
;;*          TOLMUL controls the convergence criterion of the QR loop.
;;*          If it is positive, TOLMUL*EPS is the desired relative
;;*             precision in the computed singular values.
;;*          If it is negative, abs(TOLMUL*EPS*sigma_max) is the
;;*             desired absolute accuracy in the computed singular
;;*             values (corresponds to relative accuracy
;;*             abs(TOLMUL*EPS) in the largest singular value.
;;*          abs(TOLMUL) should be between 1 and 1/EPS, and preferably
;;*             between 10 (for fast convergence) and .1/EPS
;;*             (for there to be some accuracy in the results).
;;*          Default is to lose at either one eighth or 2 of the
;;*             available decimal digits in each computed singular value
;;*             (whichever is smaller).
;;*
;;*  MAXITR  INTEGER, default = 6
;;*          MAXITR controls the maximum number of passes of the
;;*          algorithm through its inner loop. The algorithms stops
;;*          (and so fails to converge) if the number of passes
;;*          through the inner loop exceeds MAXITR*N**2.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dbdsqr (uplo  n  ncvt  nru  ncc  d  e  vt  ldvt  u  ldu  c  ldc  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncvt )
	((-idx0- (-int-)) nru )
	((-idx0- (-int-)) ncc )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dbdsqr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ncvt,int), IDX_PTR($nru,int), IDX_PTR($ncc,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ddisna <job>  <m>  <n>  <d>  <sep>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DDISNA computes the reciprocal condition numbers for the eigenvectors
;;*  of a real symmetric or complex Hermitian matrix or for the left or
;;*  right singular vectors of a general m-by-n matrix. The reciprocal
;;*  condition number is the 'gap' between the corresponding eigenvalue or
;;*  singular value and the nearest other one.
;;*
;;*  The bound on the error, measured by angle in radians, in the I-th
;;*  computed vector is given by
;;*
;;*         DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
;;*
;;*  where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
;;*  to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
;;*  the error bound.
;;*
;;*  DDISNA may also be used to compute error bounds for eigenvectors of
;;*  the generalized symmetric definite eigenproblem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies for which problem the reciprocal condition numbers
;;*          should be computed:
;;*          = 'E':  the eigenvectors of a symmetric/Hermitian matrix;
;;*          = 'L':  the left singular vectors of a general matrix;
;;*          = 'R':  the right singular vectors of a general matrix.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          If JOB = 'L' or 'R', the number of columns of the matrix,
;;*          in which case N >= 0. Ignored if JOB = 'E'.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (M) if JOB = 'E'
;;*                              dimension (min(M,N)) if JOB = 'L' or 'R'
;;*          The eigenvalues (if JOB = 'E') or singular values (if JOB =
;;*          'L' or 'R') of the matrix, in either increasing or decreasing
;;*          order. If singular values, they must be non-negative.
;;*
;;*  SEP     (output) DOUBLE PRECISION array, dimension (M) if JOB = 'E'
;;*                               dimension (min(M,N)) if JOB = 'L' or 'R'
;;*          The reciprocal condition numbers of the vectors.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ddisna (job  m  n  d  sep  info  )
	((-str-) job )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) sep )
	((-idx0- (-int-)) info )
	#{ ddisna_($job->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($sep,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbbrd <vect>  <m>  <n>  <ncc>  <kl>  <ku>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <pt>  <ldpt>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBBRD reduces a real general m-by-n band matrix A to upper
;;*  bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
;;*
;;*  The routine computes B, and optionally forms Q or P', or computes
;;*  Q'*C for a given matrix C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether or not the matrices Q and P' are to be
;;*          formed.
;;*          = 'N': do not form Q or P';
;;*          = 'Q': form Q only;
;;*          = 'P': form P' only;
;;*          = 'B': form both.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C.  NCC >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals of the matrix A. KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals of the matrix A. KU >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the m-by-n band matrix A, stored in rows 1 to
;;*          KL+KU+1. The j-th column of A is stored in the j-th column of
;;*          the array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*          On exit, A is overwritten by values generated during the
;;*          reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A. LDAB >= KL+KU+1.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B.
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
;;*          The superdiagonal elements of the bidiagonal matrix B.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ,M)
;;*          If VECT = 'Q' or 'B', the m-by-m orthogonal matrix Q.
;;*          If VECT = 'N' or 'P', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= max(1,M) if VECT = 'Q' or 'B'; LDQ >= 1 otherwise.
;;*
;;*  PT      (output) DOUBLE PRECISION array, dimension (LDPT,N)
;;*          If VECT = 'P' or 'B', the n-by-n orthogonal matrix P'.
;;*          If VECT = 'N' or 'Q', the array PT is not referenced.
;;*
;;*  LDPT    (input) INTEGER
;;*          The leading dimension of the array PT.
;;*          LDPT >= max(1,N) if VECT = 'P' or 'B'; LDPT >= 1 otherwise.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,NCC)
;;*          On entry, an m-by-ncc matrix C.
;;*          On exit, C is overwritten by Q'*C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,M) if NCC > 0; LDC >= 1 if NCC = 0.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbbrd (vect  m  n  ncc  kl  ku  ab  ldab  d  e  q  ldq  pt  ldpt  c  ldc  work  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncc )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) pt )
	((-idx0- (-int-)) ldpt )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgbbrd_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ncc,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($pt,double), IDX_PTR($ldpt,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbcon <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBCON estimates the reciprocal of the condition number of a real
;;*  general band matrix A, in either the 1-norm or the infinity-norm,
;;*  using the LU factorization computed by DGBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by DGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbcon (norm  n  kl  ku  ab  ldab  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgbcon_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbequ <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N band matrix A and reduce its condition number.  R returns the
;;*  row scale factors and C the column scale factors, chosen to try to
;;*  make the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  R       (output) DOUBLE PRECISION array, dimension (M)
;;*          If INFO = 0, or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) DOUBLE PRECISION
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) DOUBLE PRECISION
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbequ (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ dgbequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbrfs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is banded, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The original band matrix A, stored in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input) DOUBLE PRECISION array, dimension (LDAFB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by DGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from DGBTRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DGBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbrfs (trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgbrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbsv <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBSV computes the solution to a real system of linear equations
;;*  A * X = B, where A is a band matrix of order N with KL subdiagonals
;;*  and KU superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as A = L * U, where L is a product of permutation
;;*  and unit lower triangular matrices with KL subdiagonals, and U is
;;*  upper triangular with KL+KU superdiagonals.  The factored form of A
;;*  is then used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de dgbsv (n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dgbsv_(IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbsvx <fact>  <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBSVX uses the LU factorization to compute the solution to a real
;;*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
;;*  where A is a band matrix of order N with KL subdiagonals and KU
;;*  superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed by this subroutine:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = L * U,
;;*     where L is a product of permutation and unit lower triangular
;;*     matrices with KL subdiagonals, and U is upper triangular with
;;*     KL+KU superdiagonals.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB and IPIV contain the factored form of
;;*                  A.  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  AB, AFB, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)
;;*
;;*          If FACT = 'F' and EQUED is not 'N', then A must have been
;;*          equilibrated by the scaling factors in R and/or C.  AB is not
;;*          modified if FACT = 'F' or 'N', or if FACT = 'E' and
;;*          EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input or output) DOUBLE PRECISION array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains details of the LU factorization of the band matrix
;;*          A, as computed by DGBTRF.  U is stored as an upper triangular
;;*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
;;*          and the multipliers used during the factorization are stored
;;*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. 'N', then AFB is
;;*          the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of A.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of the equilibrated
;;*          matrix A (see the description of AB for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = L*U
;;*          as computed by DGBTRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (3*N)
;;*          On exit, WORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If WORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          WORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbsvx (fact  trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgbsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbtf2 <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBTF2 computes an LU factorization of a real m-by-n band matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U, because of fill-in resulting from the row
;;*  interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbtf2 (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dgbtf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbtrf <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBTRF computes an LU factorization of a real m-by-n band matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbtrf (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dgbtrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgbtrs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGBTRS solves a system of linear equations
;;*     A * X = B  or  A' * X = B
;;*  with a general band matrix A using the LU factorization computed
;;*  by DGBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A'* X = B  (Transpose)
;;*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by DGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbtrs (trans  n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dgbtrs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgebak <job>  <side>  <n>  <ilo>  <ihi>  <scale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEBAK forms the right or left eigenvectors of a real general matrix
;;*  by backward transformation on the computed eigenvectors of the
;;*  balanced matrix output by DGEBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N', do nothing, return immediately;
;;*          = 'P', do backward transformation for permutation only;
;;*          = 'S', do backward transformation for scaling only;
;;*          = 'B', do backward transformations for both permutation and
;;*                 scaling.
;;*          JOB must be the same as the argument JOB supplied to DGEBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by DGEBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  SCALE   (input) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutation and scaling factors, as returned
;;*          by DGEBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) DOUBLE PRECISION array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by DHSEIN or DTREVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgebak (job  side  n  ilo  ihi  scale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) scale )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ dgebak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,double), IDX_PTR($m,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgebal <job>  <n>  <a>  <lda>  <ilo>  <ihi>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEBAL balances a general real matrix A.  This involves, first,
;;*  permuting A by a similarity transformation to isolate eigenvalues
;;*  in the first 1 to ILO-1 and last IHI+1 to N elements on the
;;*  diagonal; and second, applying a diagonal similarity transformation
;;*  to rows and columns ILO to IHI to make the rows and columns as
;;*  close in norm as possible.  Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrix, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
;;*                  for i = 1,...,N;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit,  A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  SCALE   (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied to
;;*          A.  If P(j) is the index of the row and column interchanged
;;*          with row and column j and D(j) is the scaling factor
;;*          applied to row and column j, then
;;*          SCALE(j) = P(j)    for j = 1,...,ILO-1
;;*                   = D(j)    for j = ILO,...,IHI
;;*                   = P(j)    for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The permutations consist of row and column interchanges which put
;;*  the matrix in the form
;;*
;;*             ( T1   X   Y  )
;;*     P A P = (  0   B   Z  )
;;*             (  0   0   T2 )
;;*
;;*  where T1 and T2 are upper triangular matrices whose eigenvalues lie
;;*  along the diagonal.  The column indices ILO and IHI mark the starting
;;*  and ending columns of the submatrix B. Balancing consists of applying
;;*  a diagonal similarity transformation inv(D) * B * D to make the
;;*  1-norms of each row of B and its corresponding column nearly equal.
;;*  The output matrix is
;;*
;;*     ( T1     X*D          Y    )
;;*     (  0  inv(D)*B*D  inv(D)*Z ).
;;*     (  0      0           T2   )
;;*
;;*  Information about the permutations P and the diagonal matrix D is
;;*  returned in the vector SCALE.
;;*
;;*  This subroutine is based on the EISPACK routine BALANC.
;;*
;;*  Modified by Tzu-Yi Chen, Computer Science Division, University of
;;*    California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgebal (job  n  a  lda  ilo  ihi  scale  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) scale )
	((-idx0- (-int-)) info )
	#{ dgebal_($job->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgebd2 <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEBD2 reduces a real general m by n matrix A to upper or lower
;;*  bidiagonal form B by an orthogonal transformation: Q' * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the orthogonal matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the orthogonal matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) DOUBLE PRECISION array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q. See Further Details.
;;*
;;*  TAUP    (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix P. See Further Details.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
;;*  u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
;;*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgebd2 (m  n  a  lda  d  e  tauq  taup  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tauq )
	((-idx1- (-double-)) taup )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgebd2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tauq,double), IDX_PTR($taup,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgebrd <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEBRD reduces a general real M-by-N matrix A to upper or lower
;;*  bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the orthogonal matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the orthogonal matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) DOUBLE PRECISION array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q. See Further Details.
;;*
;;*  TAUP    (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix P. See Further Details.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,M,N).
;;*          For optimum performance LWORK >= (M+N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
;;*  u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors;
;;*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
;;*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgebrd (m  n  a  lda  d  e  tauq  taup  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tauq )
	((-idx1- (-double-)) taup )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgebrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tauq,double), IDX_PTR($taup,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgecon <norm>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGECON estimates the reciprocal of the condition number of a general
;;*  real matrix A, in either the 1-norm or the infinity-norm, using
;;*  the LU factorization computed by DGETRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by DGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgecon (norm  n  a  lda  anorm  rcond  work  iwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgecon_($norm->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeequ <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N matrix A and reduce its condition number.  R returns the row
;;*  scale factors and C the column scale factors, chosen to try to make
;;*  the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The M-by-N matrix whose equilibration factors are
;;*          to be computed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  R       (output) DOUBLE PRECISION array, dimension (M)
;;*          If INFO = 0 or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0,  C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) DOUBLE PRECISION
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) DOUBLE PRECISION
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i,  and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeequ (m  n  a  lda  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ dgeequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgees <jobvs>  <sort>  <select>  <n>  <a>  <lda>  <sdim>  <wr>  <wi>  <vs>  <ldvs>  <work>  <lwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEES computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues, the real Schur form T, and, optionally, the matrix of
;;*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  real Schur form so that selected eigenvalues are at the top left.
;;*  The leading columns of Z then form an orthonormal basis for the
;;*  invariant subspace corresponding to the selected eigenvalues.
;;*
;;*  A matrix is in real Schur form if it is upper quasi-triangular with
;;*  1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
;;*  form
;;*          [  a  b  ]
;;*          [  c  a  ]
;;*
;;*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered;
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          If SORT = 'N', SELECT is not referenced.
;;*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
;;*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
;;*          conjugate pair of eigenvalues is selected, then both complex
;;*          eigenvalues are selected.
;;*          Note that a selected complex eigenvalue may no longer
;;*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned); in this
;;*          case INFO is set to N+2 (see INFO below).
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten by its real Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*                         for which SELECT is true. (Complex conjugate
;;*                         pairs for which SELECT is true for either
;;*                         eigenvalue count as 2.)
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          WR and WI contain the real and imaginary parts,
;;*          respectively, of the computed eigenvalues in the same order
;;*          that they appear on the diagonal of the output Schur form T.
;;*          Complex conjugate pairs of eigenvalues will appear
;;*          consecutively with the eigenvalue having the positive
;;*          imaginary part first.
;;*
;;*  VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1; if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) contains the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,3*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*             <= N: the QR algorithm failed to compute all the
;;*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
;;*                   contain those eigenvalues which have converged; if
;;*                   JOBVS = 'V', VS contains the matrix which reduces A
;;*                   to its partially converged Schur form.
;;*             = N+1: the eigenvalues could not be reordered because some
;;*                   eigenvalues were too close to separate (the problem
;;*                   is very ill-conditioned);
;;*             = N+2: after reordering, roundoff changed values of some
;;*                   complex eigenvalues so that leading eigenvalues in
;;*                   the Schur form no longer satisfy SELECT=.TRUE.  This
;;*                   could also be caused by underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgees (jobvs  sort  select  n  a  lda  sdim  wr  wi  vs  ldvs  work  lwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx2- (-double-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ dgees_($jobvs->data, $sort->data, $select, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($vs,double), IDX_PTR($ldvs,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeesx <jobvs>  <sort>  <select>  <sense>  <n>  <a>  <lda>  <sdim>  <wr>  <wi>  <vs>  <ldvs>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <liwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEESX computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues, the real Schur form T, and, optionally, the matrix of
;;*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  real Schur form so that selected eigenvalues are at the top left;
;;*  computes a reciprocal condition number for the average of the
;;*  selected eigenvalues (RCONDE); and computes a reciprocal condition
;;*  number for the right invariant subspace corresponding to the
;;*  selected eigenvalues (RCONDV).  The leading columns of Z form an
;;*  orthonormal basis for this invariant subspace.
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
;;*  these quantities are called s and sep respectively).
;;*
;;*  A real matrix is in real Schur form if it is upper quasi-triangular
;;*  with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
;;*  the form
;;*            [  a  b  ]
;;*            [  c  a  ]
;;*
;;*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered;
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          If SORT = 'N', SELECT is not referenced.
;;*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
;;*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a
;;*          complex conjugate pair of eigenvalues is selected, then both
;;*          are.  Note that a selected complex eigenvalue may no longer
;;*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned); in this
;;*          case INFO may be set to N+3 (see INFO below).
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for average of selected eigenvalues only;
;;*          = 'V': Computed for selected right invariant subspace only;
;;*          = 'B': Computed for both.
;;*          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A is overwritten by its real Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*                         for which SELECT is true. (Complex conjugate
;;*                         pairs for which SELECT is true for either
;;*                         eigenvalue count as 2.)
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          WR and WI contain the real and imaginary parts, respectively,
;;*          of the computed eigenvalues, in the same order that they
;;*          appear on the diagonal of the output Schur form T.  Complex
;;*          conjugate pairs of eigenvalues appear consecutively with the
;;*          eigenvalue having the positive imaginary part first.
;;*
;;*  VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1, and if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  RCONDE  (output) DOUBLE PRECISION
;;*          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
;;*          condition number for the average of the selected eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION
;;*          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
;;*          condition number for the selected right invariant subspace.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,3*N).
;;*          Also, if SENSE = 'E' or 'V' or 'B',
;;*          LWORK >= N+2*SDIM*(N-SDIM), where SDIM is the number of
;;*          selected eigenvalues computed by this routine.  Note that
;;*          N+2*SDIM*(N-SDIM) <= N+N*N/2.
;;*          For good performance, LWORK must generally be larger.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          LIWORK >= 1; if SENSE = 'V' or 'B', LIWORK >= SDIM*(N-SDIM).
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*             <= N: the QR algorithm failed to compute all the
;;*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
;;*                   contain those eigenvalues which have converged; if
;;*                   JOBVS = 'V', VS contains the transformation which
;;*                   reduces A to its partially converged Schur form.
;;*             = N+1: the eigenvalues could not be reordered because some
;;*                   eigenvalues were too close to separate (the problem
;;*                   is very ill-conditioned);
;;*             = N+2: after reordering, roundoff changed values of some
;;*                   complex eigenvalues so that leading eigenvalues in
;;*                   the Schur form no longer satisfy SELECT=.TRUE.  This
;;*                   could also be caused by underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeesx (jobvs  sort  select  sense  n  a  lda  sdim  wr  wi  vs  ldvs  rconde  rcondv  work  lwork  iwork  liwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx2- (-double-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx0- (-double-)) rconde )
	((-idx0- (-double-)) rcondv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ dgeesx_($jobvs->data, $sort->data, $select, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($vs,double), IDX_PTR($ldvs,int), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeev <jobvl>  <jobvr>  <n>  <a>  <lda>  <wr>  <wi>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEEV computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of A are computed.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          WR and WI contain the real and imaginary parts,
;;*          respectively, of the computed eigenvalues.  Complex
;;*          conjugate pairs of eigenvalues appear consecutively
;;*          with the eigenvalue having the positive imaginary part
;;*          first.
;;*
;;*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          If the j-th eigenvalue is real, then u(j) = VL(:,j),
;;*          the j-th column of VL.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
;;*          u(j+1) = VL(:,j) - i*VL(:,j+1).
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          If the j-th eigenvalue is real, then v(j) = VR(:,j),
;;*          the j-th column of VR.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
;;*          v(j+1) = VR(:,j) - i*VR(:,j+1).
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1; if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,3*N), and
;;*          if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
;;*          performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors have been computed;
;;*                elements i+1:N of WR and WI contain eigenvalues which
;;*                have converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeev (jobvl  jobvr  n  a  lda  wr  wi  vl  ldvl  vr  ldvr  work  lwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgeev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <wr>  <wi>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <scale>  <abnrm>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  Optionally also, it computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
;;*  (RCONDE), and reciprocal condition numbers for the right
;;*  eigenvectors (RCONDV).
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Balancing a matrix means permuting the rows and columns to make it
;;*  more nearly upper triangular, and applying a diagonal similarity
;;*  transformation D * A * D**(-1), where D is a diagonal matrix, to
;;*  make its rows and columns closer in norm and the condition numbers
;;*  of its eigenvalues and eigenvectors smaller.  The computed
;;*  reciprocal condition numbers correspond to the balanced matrix.
;;*  Permuting rows and columns will not change the condition numbers
;;*  (in exact arithmetic) but diagonal scaling will.  For further
;;*  explanation of balancing, see section 4.10.2 of the LAPACK
;;*  Users' Guide.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Indicates how the input matrix should be diagonally scaled
;;*          and/or permuted to improve the conditioning of its
;;*          eigenvalues.
;;*          = 'N': Do not diagonally scale or permute;
;;*          = 'P': Perform permutations to make the matrix more nearly
;;*                 upper triangular. Do not diagonally scale;
;;*          = 'S': Diagonally scale the matrix, i.e. replace A by
;;*                 D*A*D**(-1), where D is a diagonal matrix chosen
;;*                 to make the rows and columns of A more equal in
;;*                 norm. Do not permute;
;;*          = 'B': Both diagonally scale and permute A.
;;*
;;*          Computed reciprocal condition numbers will be for the matrix
;;*          after balancing and/or permuting. Permuting does not change
;;*          condition numbers (in exact arithmetic), but balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVL must = 'V'.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVR must = 'V'.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for eigenvalues only;
;;*          = 'V': Computed for right eigenvectors only;
;;*          = 'B': Computed for eigenvalues and right eigenvectors.
;;*
;;*          If SENSE = 'E' or 'B', both left and right eigenvectors
;;*          must also be computed (JOBVL = 'V' and JOBVR = 'V').
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.  If JOBVL = 'V' or
;;*          JOBVR = 'V', A contains the real Schur form of the balanced
;;*          version of the input matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          WR and WI contain the real and imaginary parts,
;;*          respectively, of the computed eigenvalues.  Complex
;;*          conjugate pairs of eigenvalues will appear consecutively
;;*          with the eigenvalue having the positive imaginary part
;;*          first.
;;*
;;*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          If the j-th eigenvalue is real, then u(j) = VL(:,j),
;;*          the j-th column of VL.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
;;*          u(j+1) = VL(:,j) - i*VL(:,j+1).
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          If the j-th eigenvalue is real, then v(j) = VR(:,j),
;;*          the j-th column of VR.
;;*          If the j-th and (j+1)-st eigenvalues form a complex
;;*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
;;*          v(j+1) = VR(:,j) - i*VR(:,j+1).
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1, and if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values determined when A was
;;*          balanced.  The balanced A(i,j) = 0 if I > J and
;;*          J = 1,...,ILO-1 or I = IHI+1,...,N.
;;*
;;*  SCALE   (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          when balancing A.  If P(j) is the index of the row and column
;;*          interchanged with row and column j, and D(j) is the scaling
;;*          factor applied to row and column j, then
;;*          SCALE(J) = P(J),    for J = 1,...,ILO-1
;;*                   = D(J),    for J = ILO,...,IHI
;;*                   = P(J)     for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) DOUBLE PRECISION
;;*          The one-norm of the balanced matrix (the maximum
;;*          of the sum of absolute values of elements of any column).
;;*
;;*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)
;;*          RCONDE(j) is the reciprocal condition number of the j-th
;;*          eigenvalue.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)
;;*          RCONDV(j) is the reciprocal condition number of the j-th
;;*          right eigenvector.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.   If SENSE = 'N' or 'E',
;;*          LWORK >= max(1,2*N), and if JOBVL = 'V' or JOBVR = 'V',
;;*          LWORK >= 3*N.  If SENSE = 'V' or 'B', LWORK >= N*(N+6).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (2*N-2)
;;*          If SENSE = 'N' or 'E', not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors or condition numbers
;;*                have been computed; elements 1:ILO-1 and i+1:N of WR
;;*                and WI contain eigenvalues which have converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeevx (balanc  jobvl  jobvr  sense  n  a  lda  wr  wi  vl  ldvl  vr  ldvr  ilo  ihi  scale  abnrm  rconde  rcondv  work  lwork  iwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) scale )
	((-idx0- (-double-)) abnrm )
	((-idx1- (-double-)) rconde )
	((-idx1- (-double-)) rcondv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgeevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,double), IDX_PTR($abnrm,double), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgegs <jobvsl>  <jobvsr>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine DGGES.
;;*
;;*  DGEGS computes for a pair of N-by-N real nonsymmetric matrices A, B:
;;*  the generalized eigenvalues (alphar +/- alphai*i, beta), the real
;;*  Schur form (A, B), and optionally left and/or right Schur vectors
;;*  (VSL and VSR).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver DGEGV
;;*  instead.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  The (generalized) Schur form of a pair of matrices is the result of
;;*  multiplying both matrices on the left by one orthogonal matrix and
;;*  both on the right by another orthogonal matrix, these two orthogonal
;;*  matrices being chosen so as to bring the pair of matrices into
;;*  (real) Schur form.
;;*
;;*  A pair of matrices A, B is in generalized real Schur form if B is
;;*  upper triangular with non-negative diagonal and A is block upper
;;*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
;;*  to real generalized eigenvalues, while 2-by-2 blocks of A will be
;;*  "standardized" by making the corresponding elements of B have the
;;*  form:
;;*          [  a  0  ]
;;*          [  0  b  ]
;;*
;;*  and the pair of corresponding 2-by-2 blocks in A and B will
;;*  have a complex conjugate pair of generalized eigenvalues.
;;*
;;*  The left and right Schur vectors are the columns of VSL and VSR,
;;*  respectively, where VSL and VSR are the orthogonal matrices
;;*  which reduce A and B to Schur form:
;;*
;;*  Schur form of (A,B) = ( (VSL)**T A (VSR), (VSL)**T B (VSR) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose generalized
;;*          eigenvalues and (optionally) Schur vectors are to be
;;*          computed.
;;*          On exit, the generalized Schur form of A.
;;*          Note: to avoid overflow, the Frobenius norm of the matrix
;;*          A should be less than the overflow threshold.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) Schur vectors are
;;*          to be computed.
;;*          On exit, the generalized Schur form of B.
;;*          Note: to avoid overflow, the Frobenius norm of the matrix
;;*          B should be less than the overflow threshold.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
;;*          j=1,...,N  and  BETA(j),j=1,...,N  are the diagonals of the
;;*          complex Schur form (A,B) that would result if the 2-by-2
;;*          diagonal blocks of the real Schur form of (A,B) were further
;;*          reduced to triangular form using 2-by-2 complex unitary
;;*          transformations.  If ALPHAI(j) is zero, then the j-th
;;*          eigenvalue is real; if positive, then the j-th and (j+1)-st
;;*          eigenvalues are a complex conjugate pair, with ALPHAI(j+1)
;;*          negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          alpha/beta.  However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VSL     (output) DOUBLE PRECISION array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) DOUBLE PRECISION array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,4*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR
;;*          The optimal LWORK is  2*N + N*(NB+1).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
;;*                be correct for j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from DGGBAL
;;*                =N+2: error return from DGEQRF
;;*                =N+3: error return from DORMQR
;;*                =N+4: error return from DORGQR
;;*                =N+5: error return from DGGHRD
;;*                =N+6: error return from DHGEQZ (other than failed
;;*                                                iteration)
;;*                =N+7: error return from DGGBAK (computing VSL)
;;*                =N+8: error return from DGGBAK (computing VSR)
;;*                =N+9: error return from DLASCL (various places)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgegs (jobvsl  jobvsr  n  a  lda  b  ldb  alphar  alphai  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx2- (-double-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgegs_($jobvsl->data, $jobvsr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($vsl,double), IDX_PTR($ldvsl,int), IDX_PTR($vsr,double), IDX_PTR($ldvsr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgegv <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine DGGEV.
;;*
;;*  DGEGV computes for a pair of n-by-n real nonsymmetric matrices A and
;;*  B, the generalized eigenvalues (alphar +/- alphai*i, beta), and
;;*  optionally, the left and/or right generalized eigenvectors (VL and
;;*  VR).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  A right generalized eigenvector corresponding to a generalized
;;*  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
;;*  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
;;*  l such that l**H * (A - w B) = 0, where l**H is the
;;*  conjugate-transpose of l.
;;*
;;*  Note: this routine performs "full balancing" on A and B -- see
;;*  "Further Details", below.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of A on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of B on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
;;*          the j-th eigenvalue is real; if positive, then the j-th and
;;*          (j+1)-st eigenvalues are a complex conjugate pair, with
;;*          ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          alpha/beta.  However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors.  (See
;;*          "Purpose", above.)  Real eigenvectors take one column,
;;*          complex take two columns, the first for the real part and
;;*          the second for the imaginary part.  Complex eigenvectors
;;*          correspond to an eigenvalue with positive imaginary part.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors.  (See
;;*          "Purpose", above.)  Real eigenvectors take one column,
;;*          complex take two columns, the first for the real part and
;;*          the second for the imaginary part.  Complex eigenvectors
;;*          correspond to an eigenvalue with positive imaginary part.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,8*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;
;;*          The optimal LWORK is:
;;*              2*N + MAX( 6*N, N*(NB+1) ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
;;*                should be correct for j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from DGGBAL
;;*                =N+2: error return from DGEQRF
;;*                =N+3: error return from DORMQR
;;*                =N+4: error return from DORGQR
;;*                =N+5: error return from DGGHRD
;;*                =N+6: error return from DHGEQZ (other than failed
;;*                                                iteration)
;;*                =N+7: error return from DTGEVC
;;*                =N+8: error return from DGGBAK (computing VL)
;;*                =N+9: error return from DGGBAK (computing VR)
;;*                =N+10: error return from DLASCL (various calls)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing
;;*  ---------
;;*
;;*  This driver calls DGGBAL to both permute and scale rows and columns
;;*  of A and B.  The permutations PL and PR are chosen so that PL*A*PR
;;*  and PL*B*R will be upper triangular except for the diagonal blocks
;;*  A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
;;*  possible.  The diagonal scaling matrices DL and DR are chosen so
;;*  that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
;;*  one (except for the elements that start out zero.)
;;*
;;*  After the eigenvalues and eigenvectors of the balanced matrices
;;*  have been computed, DGGBAK transforms the eigenvectors back to what
;;*  they would have been (in perfect arithmetic) if they had not been
;;*  balanced.
;;*
;;*  Contents of A and B on Exit
;;*  -------- -- - --- - -- ----
;;*
;;*  If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
;;*  both), then on exit the arrays A and B will contain the real Schur
;;*  form[*] of the "balanced" versions of A and B.  If no eigenvectors
;;*  are computed, then only the diagonal blocks will be correct.
;;*
;;*  [*] See DHGEQZ, DGEGS, or read the book "Matrix Computations",
;;*      by Golub & van Loan, pub. by Johns Hopkins U. Press.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgegv (jobvl  jobvr  n  a  lda  b  ldb  alphar  alphai  beta  vl  ldvl  vr  ldvr  work  lwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgegv_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgehd2 <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
;;*  an orthogonal similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to DGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= max(1,N).
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the n by n general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the orthogonal matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgehd2 (n  ilo  ihi  a  lda  tau  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgehd2_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgehrd <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEHRD reduces a real general matrix A to upper Hessenberg form H by
;;*  an orthogonal similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to DGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the orthogonal matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
;;*          zero.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgehrd (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgehrd_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgelq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGELQ2 computes an LQ factorization of a real m by n matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m by min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgelq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgelq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgelqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGELQF computes an LQ factorization of a real M-by-N matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dgelqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgelqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgelsd <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGELSD computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize 2-norm(| b - A*x |)
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The problem is solved in three steps:
;;*  (1) Reduce the coefficient matrix A to bidiagonal form with
;;*      Householder transformations, reducing the original problem
;;*      into a "bidiagonal least squares problem" (BLS)
;;*  (2) Solve the BLS using a divide and conquer approach.
;;*  (3) Apply back all the Householder tranformations to solve
;;*      the original least squares problem.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution
;;*          matrix X.  If m >= n and RANK = n, the residual
;;*          sum-of-squares for the solution in the i-th column is given
;;*          by the sum of squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,max(M,N)).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK must be at least 1.
;;*          The exact minimum amount of workspace needed depends on M,
;;*          N and NRHS. As long as LWORK is at least
;;*              12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,
;;*          if M is greater than or equal to N or
;;*              12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,
;;*          if M is less than N, the code will execute correctly.
;;*          SMLSIZ is returned by ILAENV and is equal to the maximum
;;*          size of the subproblems at the bottom of the computation
;;*          tree (usually about 25), and
;;*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          LIWORK >= 3 * MINMN * NLVL + 11 * MINMN,
;;*          where MINMN = MIN( M,N ).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgelsd (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  iwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgelsd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($s,double), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgels <trans>  <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGELS solves overdetermined or underdetermined real linear systems
;;*  involving an M-by-N matrix A, or its transpose, using a QR or LQ
;;*  factorization of A.  It is assumed that A has full rank.
;;*
;;*  The following options are provided:
;;*
;;*  1. If TRANS = 'N' and m >= n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A*X ||.
;;*
;;*  2. If TRANS = 'N' and m < n:  find the minimum norm solution of
;;*     an underdetermined system A * X = B.
;;*
;;*  3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
;;*     an undetermined system A**T * X = B.
;;*
;;*  4. If TRANS = 'T' and m < n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A**T * X ||.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N': the linear system involves A;
;;*          = 'T': the linear system involves A**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of the matrices B and X. NRHS >=0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*            if M >= N, A is overwritten by details of its QR
;;*                       factorization as returned by DGEQRF;
;;*            if M <  N, A is overwritten by details of its LQ
;;*                       factorization as returned by DGELQF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the matrix B of right hand side vectors, stored
;;*          columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
;;*          if TRANS = 'T'.
;;*          On exit, B is overwritten by the solution vectors, stored
;;*          columnwise:
;;*          if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
;;*          squares solution vectors; the residual sum of squares for the
;;*          solution in each column is given by the sum of squares of
;;*          elements N+1 to M in that column;
;;*          if TRANS = 'N' and m < n, rows 1 to N of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'T' and m >= n, rows 1 to M of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'T' and m < n, rows 1 to M of B contain the
;;*          least squares solution vectors; the residual sum of squares
;;*          for the solution in each column is given by the sum of
;;*          squares of elements M+1 to N in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= MAX(1,M,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          LWORK >= max( 1, MN + max( MN, NRHS ) ).
;;*          For optimal performance,
;;*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).
;;*          where MN = min(M,N) and NB is the optimum block size.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgels (trans  m  n  nrhs  a  lda  b  ldb  work  lwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgels_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgelss <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGELSS computes the minimum norm solution to a real linear least
;;*  squares problem:
;;*
;;*  Minimize 2-norm(| b - A*x |).
;;*
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
;;*  X.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the first min(m,n) rows of A are overwritten with
;;*          its right singular vectors, stored rowwise.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution
;;*          matrix X.  If m >= n and RANK = n, the residual
;;*          sum-of-squares for the solution in the i-th column is given
;;*          by the sum of squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,max(M,N)).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1, and also:
;;*          LWORK >= 3*min(M,N) + max( 2*min(M,N), max(M,N), NRHS )
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgelss (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgelss_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($s,double), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgelsx <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine DGELSY.
;;*
;;*  DGELSX computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by orthogonal transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements N+1:M in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is an
;;*          initial column, otherwise it is a free column.  Before
;;*          the QR factorization of A, all initial columns are
;;*          permuted to the leading positions; only the remaining
;;*          free columns are moved as a result of column pivoting
;;*          during the factorization.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                      (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgelsx (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgelsx_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgelsy <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGELSY computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by orthogonal transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  This routine is basically identical to the original xGELSX except
;;*  three differences:
;;*    o The call to the subroutine xGEQPF has been substituted by the
;;*      the call to the subroutine xGEQP3. This subroutine is a Blas-3
;;*      version of the QR factorization with column pivoting.
;;*    o Matrix B (the right hand side) is updated with Blas-3.
;;*    o The permutation of matrix B (the right hand side) is faster and
;;*      more simple.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of AP, otherwise column i is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of AP
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          The unblocked strategy requires that:
;;*             LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
;;*          where MN = min( M, N ).
;;*          The block algorithm requires that:
;;*             LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
;;*          where NB is an upper bound on the blocksize returned
;;*          by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
;;*          and DORMRZ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: If INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgelsy (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgelsy_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeql2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEQL2 computes a QL factorization of a real m by n matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the m by n lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          orthogonal matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeql2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgeql2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeqlf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEQLF computes a QL factorization of a real M-by-N matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the M-by-N lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          orthogonal matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dgeqlf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgeqlf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeqp3 <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEQP3 computes a QR factorization with column pivoting of a
;;*  matrix A:  A*P = Q*R  using Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper trapezoidal matrix R; the elements below
;;*          the diagonal, together with the array TAU, represent the
;;*          orthogonal matrix Q as a product of min(M,N) elementary
;;*          reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(J).ne.0, the J-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(J)=0,
;;*          the J-th column of A is a free column.
;;*          On exit, if JPVT(J)=K, then the J-th column of A*P was the
;;*          the K-th column of A.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 3*N+1.
;;*          For optimal performance LWORK >= 2*N+( N+1 )*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real/complex scalar, and v is a real/complex vector
;;*  with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
;;*  A(i+1:m,i), and tau in TAU(i).
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeqp3 (m  n  a  lda  jpvt  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgeqp3_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeqpf <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine DGEQP3.
;;*
;;*  DGEQPF computes a QR factorization with column pivoting of a
;;*  real M-by-N matrix A: A*P = Q*R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper triangular matrix R; the elements
;;*          below the diagonal, together with the array TAU,
;;*          represent the orthogonal matrix Q as a product of
;;*          min(m,n) elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n)
;;*
;;*  Each H(i) has the form
;;*
;;*     H = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
;;*
;;*  The matrix P is represented in jpvt as follows: If
;;*     jpvt(j) = i
;;*  then the jth column of P is the ith canonical unit vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeqpf (m  n  a  lda  jpvt  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgeqpf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeqr2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEQR2 computes a QR factorization of a real m by n matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(m,n) by n upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgeqr2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgeqr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgeqrf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGEQRF computes a QR factorization of a real M-by-N matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the orthogonal matrix Q as a
;;*          product of min(m,n) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dgeqrf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgeqrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgerfs <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGERFS improves the computed solution to a system of linear
;;*  equations and provides error bounds and backward error estimates for
;;*  the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The original N-by-N matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) DOUBLE PRECISION array, dimension (LDAF,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by DGETRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from DGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DGETRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgerfs (trans  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgerfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgerq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGERQ2 computes an RQ factorization of a real m by n matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the m by n upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAU, represent the orthogonal matrix
;;*          Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgerq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dgerq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgerqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGERQF computes an RQ factorization of a real M-by-N matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R;
;;*          the remaining elements, with the array TAU, represent the
;;*          orthogonal matrix Q as a product of min(m,n) elementary
;;*          reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dgerqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgerqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgesc2 <n>  <a>  <lda>  <rhs>  <ipiv>  <jpiv>  <scale>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGESC2 solves a system of linear equations
;;*
;;*            A * X = scale* RHS
;;*
;;*  with a general N-by-N matrix A using the LU factorization with
;;*  complete pivoting computed by DGETC2.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the  LU part of the factorization of the n-by-n
;;*          matrix A computed by DGETC2:  A = P * L * U * Q
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) DOUBLE PRECISION array, dimension (N).
;;*          On entry, the right hand side vector b.
;;*          On exit, the solution vector X.
;;*
;;*  IPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  SCALE    (output) DOUBLE PRECISION
;;*           On exit, SCALE contains the scale factor. SCALE is chosen
;;*           0 <= SCALE <= 1 to prevent owerflow in the solution.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgesc2 (n  a  lda  rhs  ipiv  jpiv  scale  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) rhs )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-double-)) scale )
	#{ dgesc2_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($rhs,double), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($scale,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgesdd <jobz>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGESDD computes the singular value decomposition (SVD) of a real
;;*  M-by-N matrix A, optionally computing the left and right singular
;;*  vectors.  If singular vectors are desired, it uses a
;;*  divide-and-conquer algorithm.
;;*
;;*  The SVD is written
;;*
;;*       A = U * SIGMA * transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
;;*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns VT = V**T, not V.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U and all N rows of V**T are
;;*                  returned in the arrays U and VT;
;;*          = 'S':  the first min(M,N) columns of U and the first
;;*                  min(M,N) rows of V**T are returned in the arrays U
;;*                  and VT;
;;*          = 'O':  If M >= N, the first N columns of U are overwritten
;;*                  on the array A and all rows of V**T are returned in
;;*                  the array VT;
;;*                  otherwise, all columns of U are returned in the
;;*                  array U and the first M rows of V**T are overwritten
;;*                  in the array VT;
;;*          = 'N':  no columns of U or rows of V**T are computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBZ = 'O',  A is overwritten with the first N columns
;;*                          of U (the left singular vectors, stored
;;*                          columnwise) if M >= N;
;;*                          A is overwritten with the first M rows
;;*                          of V**T (the right singular vectors, stored
;;*                          rowwise) otherwise.
;;*          if JOBZ .ne. 'O', the contents of A are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
;;*          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
;;*          UCOL = min(M,N) if JOBZ = 'S'.
;;*          If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
;;*          orthogonal matrix U;
;;*          if JOBZ = 'S', U contains the first min(M,N) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
;;*
;;*  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
;;*          If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
;;*          N-by-N orthogonal matrix V**T;
;;*          if JOBZ = 'S', VT contains the first min(M,N) rows of
;;*          V**T (the right singular vectors, stored rowwise);
;;*          if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
;;*          if JOBZ = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          If JOBZ = 'N',
;;*            LWORK >= 3*min(M,N) + max(max(M,N),6*min(M,N)).
;;*          If JOBZ = 'O',
;;*            LWORK >= 3*min(M,N)*min(M,N) + 
;;*                     max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
;;*          If JOBZ = 'S' or 'A'
;;*            LWORK >= 3*min(M,N)*min(M,N) +
;;*                     max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
;;*          For good performance, LWORK should generally be larger.
;;*          If LWORK < 0 but other input arguments are legal, WORK(1)
;;*          returns the optimal LWORK.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  DBDSDC did not converge, updating process failed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgesdd (jobz  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  iwork  info  )
	((-str-) jobz )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgesdd_($jobz->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgesvd <jobu>  <jobvt>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGESVD computes the singular value decomposition (SVD) of a real
;;*  M-by-N matrix A, optionally computing the left and/or right singular
;;*  vectors. The SVD is written
;;*
;;*       A = U * SIGMA * transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
;;*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns V**T, not V.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U are returned in array U:
;;*          = 'S':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are returned in the array U;
;;*          = 'O':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no columns of U (no left singular vectors) are
;;*                  computed.
;;*
;;*  JOBVT   (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix
;;*          V**T:
;;*          = 'A':  all N rows of V**T are returned in the array VT;
;;*          = 'S':  the first min(m,n) rows of V**T (the right singular
;;*                  vectors) are returned in the array VT;
;;*          = 'O':  the first min(m,n) rows of V**T (the right singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no rows of V**T (no right singular vectors) are
;;*                  computed.
;;*
;;*          JOBVT and JOBU cannot both be 'O'.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBU = 'O',  A is overwritten with the first min(m,n)
;;*                          columns of U (the left singular vectors,
;;*                          stored columnwise);
;;*          if JOBVT = 'O', A is overwritten with the first min(m,n)
;;*                          rows of V**T (the right singular vectors,
;;*                          stored rowwise);
;;*          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
;;*                          are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
;;*          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
;;*          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
;;*          if JOBU = 'S', U contains the first min(m,n) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBU = 'N' or 'O', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBU = 'S' or 'A', LDU >= M.
;;*
;;*  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
;;*          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
;;*          V**T;
;;*          if JOBVT = 'S', VT contains the first min(m,n) rows of
;;*          V**T (the right singular vectors, stored rowwise);
;;*          if JOBVT = 'N' or 'O', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
;;*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
;;*          superdiagonal elements of an upper bidiagonal matrix B
;;*          whose diagonal is in S (not necessarily sorted). B
;;*          satisfies A = U * B * VT, so it has the same singular values
;;*          as A, and singular vectors related by U and VT.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if DBDSQR did not converge, INFO specifies how many
;;*                superdiagonals of an intermediate bidiagonal form B
;;*                did not converge to zero. See the description of WORK
;;*                above for details.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgesvd (jobu  jobvt  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  info  )
	((-str-) jobu )
	((-str-) jobvt )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgesvd_($jobu->data, $jobvt->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgesv <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGESV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as
;;*     A = P * L * U,
;;*  where P is a permutation matrix, L is unit lower triangular, and U is
;;*  upper triangular.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the N-by-N coefficient matrix A.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS matrix of right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de dgesv (n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dgesv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgesvx <fact>  <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGESVX uses the LU factorization to compute the solution to a real
;;*  system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = P * L * U,
;;*     where P is a permutation matrix, L is a unit lower triangular
;;*     matrix, and U is upper triangular.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF and IPIV contain the factored form of A.
;;*                  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  A, AF, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
;;*          not 'N', then A must have been equilibrated by the scaling
;;*          factors in R and/or C.  A is not modified if FACT = 'F' or
;;*          'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the factors L and U from the factorization
;;*          A = P*L*U as computed by DGETRF.  If EQUED .ne. 'N', then
;;*          AF is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the equilibrated matrix A (see the description of A for
;;*          the form of the equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          as computed by DGETRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (4*N)
;;*          On exit, WORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If WORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          WORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization has
;;*                       been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgesvx (fact  trans  n  nrhs  a  lda  af  ldaf  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgesvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgetc2 <n>  <a>  <lda>  <ipiv>  <jpiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGETC2 computes an LU factorization with complete pivoting of the
;;*  n-by-n matrix A. The factorization has the form A = P * L * U * Q,
;;*  where P and Q are permutation matrices, L is lower triangular with
;;*  unit diagonal elements and U is upper triangular.
;;*
;;*  This is the Level 2 BLAS algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the n-by-n matrix A to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U*Q; the unit diagonal elements of L are not stored.
;;*          If U(k, k) appears to be less than SMIN, U(k, k) is given the
;;*          value of SMIN, i.e., giving a nonsingular perturbed system.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension(N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (output) INTEGER array, dimension(N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  INFO    (output) INTEGER
;;*           = 0: successful exit
;;*           > 0: if INFO = k, U(k, k) is likely to produce owerflow if
;;*                we try to solve for x in Ax = b. So U is perturbed to
;;*                avoid the overflow.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgetc2 (n  a  lda  ipiv  jpiv  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-int-)) info )
	#{ dgetc2_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgetf2 <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGETF2 computes an LU factorization of a general m-by-n matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgetf2 (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dgetf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgetrf <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGETRF computes an LU factorization of a general M-by-N matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgetrf (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dgetrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgetri <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGETRI computes the inverse of a matrix using the LU factorization
;;*  computed by DGETRF.
;;*
;;*  This method inverts U and then computes inv(A) by solving the system
;;*  inv(A)*L = inv(U) for inv(A).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the factors L and U from the factorization
;;*          A = P*L*U as computed by DGETRF.
;;*          On exit, if INFO = 0, the inverse of the original matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from DGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimal performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
;;*                singular and its inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgetri (n  a  lda  ipiv  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgetri_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgetrs <trans>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGETRS solves a system of linear equations
;;*     A * X = B  or  A' * X = B
;;*  with a general N-by-N matrix A using the LU factorization computed
;;*  by DGETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A'* X = B  (Transpose)
;;*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by DGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from DGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgetrs (trans  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dgetrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggbak <job>  <side>  <n>  <ilo>  <ihi>  <lscale>  <rscale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGBAK forms the right or left eigenvectors of a real generalized
;;*  eigenvalue problem A*x = lambda*B*x, by backward transformation on
;;*  the computed eigenvectors of the balanced pair of matrices output by
;;*  DGGBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N':  do nothing, return immediately;
;;*          = 'P':  do backward transformation for permutation only;
;;*          = 'S':  do backward transformation for scaling only;
;;*          = 'B':  do backward transformations for both permutation and
;;*                  scaling.
;;*          JOB must be the same as the argument JOB supplied to DGGBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by DGGBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  LSCALE  (input) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the left side of A and B, as returned by DGGBAL.
;;*
;;*  RSCALE  (input) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the right side of A and B, as returned by DGGBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) DOUBLE PRECISION array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by DTGEVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the matrix V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. Ward, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dggbak (job  side  n  ilo  ihi  lscale  rscale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) lscale )
	((-idx1- (-double-)) rscale )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ dggbak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,double), IDX_PTR($rscale,double), IDX_PTR($m,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggbal <job>  <n>  <a>  <lda>  <b>  <ldb>  <ilo>  <ihi>  <lscale>  <rscale>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGBAL balances a pair of general real matrices (A,B).  This
;;*  involves, first, permuting A and B by similarity transformations to
;;*  isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
;;*  elements on the diagonal; and second, applying a diagonal similarity
;;*  transformation to rows and columns ILO to IHI to make the rows
;;*  and columns as close in norm as possible. Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrices, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors in the
;;*  generalized eigenvalue problem A*x = lambda*B*x.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A and B:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
;;*                  and RSCALE(I) = 1.0 for i = 1,...,N.
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit,  A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the input matrix B.
;;*          On exit,  B is overwritten by the balanced matrix.
;;*          If JOB = 'N', B is not referenced.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If P(j) is the index of the
;;*          row interchanged with row j, and D(j)
;;*          is the scaling factor applied to row j, then
;;*            LSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If P(j) is the index of the
;;*          column interchanged with column j, and D(j)
;;*          is the scaling factor applied to column j, then
;;*            LSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. WARD, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dggbal (job  n  a  lda  b  ldb  ilo  ihi  lscale  rscale  work  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) lscale )
	((-idx1- (-double-)) rscale )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dggbal_($job->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,double), IDX_PTR($rscale,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgges <jobvsl>  <jobvsr>  <sort>  <delctg>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alphar>  <alphai>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
;;*  the generalized eigenvalues, the generalized real Schur form (S,T),
;;*  optionally, the left and/or right matrices of Schur vectors (VSL and
;;*  VSR). This gives the generalized Schur factorization
;;*
;;*           (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  quasi-triangular matrix S and the upper triangular matrix T.The
;;*  leading columns of VSL and VSR then form an orthonormal basis for the
;;*  corresponding left and right eigenspaces (deflating subspaces).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver
;;*  DGGEV instead, which is faster.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0 or both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized real Schur form if T is
;;*  upper triangular with non-negative diagonal and S is block upper
;;*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
;;*  to real generalized eigenvalues, while 2-by-2 blocks of S will be
;;*  "standardized" by making the corresponding elements of T have the
;;*  form:
;;*          [  a  0  ]
;;*          [  0  b  ]
;;*
;;*  and the pair of corresponding 2-by-2 blocks in S and T will have a
;;*  complex conjugate pair of generalized eigenvalues.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see DELZTG);
;;*
;;*  DELZTG  (input) LOGICAL FUNCTION of three DOUBLE PRECISION arguments
;;*          DELZTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', DELZTG is not referenced.
;;*          If SORT = 'S', DELZTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
;;*          DELZTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
;;*          one of a complex conjugate pair of eigenvalues is selected,
;;*          then both complex eigenvalues are selected.
;;*
;;*          Note that in the ill-conditioned case, a selected complex
;;*          eigenvalue may no longer satisfy DELZTG(ALPHAR(j),ALPHAI(j),
;;*          BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2
;;*          in this case.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which DELZTG is true.  (Complex conjugate pairs for which
;;*          DELZTG is true for either eigenvalue count as 2.)
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
;;*          and  BETA(j),j=1,...,N are the diagonals of the complex Schur
;;*          form (S,T) that would result if the 2-by-2 diagonal blocks of
;;*          the real Schur form of (A,B) were further reduced to
;;*          triangular form using 2-by-2 complex unitary transformations.
;;*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
;;*          positive, then the j-th and (j+1)-st eigenvalues are a
;;*          complex conjugate pair, with ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio.
;;*          However, ALPHAR and ALPHAI will be always less than and
;;*          usually comparable with norm(A) in magnitude, and BETA always
;;*          less than and usually comparable with norm(B).
;;*
;;*  VSL     (output) DOUBLE PRECISION array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) DOUBLE PRECISION array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 8*N+16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
;;*                be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in DHGEQZ.
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy DELZTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering failed in DTGSEN.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgges (jobvsl  jobvsr  sort  delctg  n  a  lda  b  ldb  sdim  alphar  alphai  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")delctg )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx2- (-double-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ dgges_($jobvsl->data, $jobvsr->data, $sort->data, $delctg, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($vsl,double), IDX_PTR($ldvsl,int), IDX_PTR($vsr,double), IDX_PTR($ldvsr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggesx <jobvsl>  <jobvsr>  <sort>  <delctg>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alphar>  <alphai>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <liwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGESX computes for a pair of N-by-N real nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
;;*  optionally, the left and/or right matrices of Schur vectors (VSL and
;;*  VSR).  This gives the generalized Schur factorization
;;*
;;*       (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  quasi-triangular matrix S and the upper triangular matrix T; computes
;;*  a reciprocal condition number for the average of the selected
;;*  eigenvalues (RCONDE); and computes a reciprocal condition number for
;;*  the right and left deflating subspaces corresponding to the selected
;;*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form
;;*  an orthonormal basis for the corresponding left and right eigenspaces
;;*  (deflating subspaces).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0 or for both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized real Schur form if T is
;;*  upper triangular with non-negative diagonal and S is block upper
;;*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
;;*  to real generalized eigenvalues, while 2-by-2 blocks of S will be
;;*  "standardized" by making the corresponding elements of T have the
;;*  form:
;;*          [  a  0  ]
;;*          [  0  b  ]
;;*
;;*  and the pair of corresponding 2-by-2 blocks in S and T will have a
;;*  complex conjugate pair of generalized eigenvalues.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see DELZTG).
;;*
;;*  DELZTG  (input) LOGICAL FUNCTION of three DOUBLE PRECISION arguments
;;*          DELZTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', DELZTG is not referenced.
;;*          If SORT = 'S', DELZTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if
;;*          DELZTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either
;;*          one of a complex conjugate pair of eigenvalues is selected,
;;*          then both complex eigenvalues are selected.
;;*          Note that a selected complex eigenvalue may no longer satisfy
;;*          DELZTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,
;;*          since ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned), in this
;;*          case INFO is set to N+3.
;;*
;;*  SENSE   (input) CHARACTER
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N' : None are computed;
;;*          = 'E' : Computed for average of selected eigenvalues only;
;;*          = 'V' : Computed for selected deflating subspaces only;
;;*          = 'B' : Computed for both.
;;*          If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which DELZTG is true.  (Complex conjugate pairs for which
;;*          DELZTG is true for either eigenvalue count as 2.)
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i
;;*          and BETA(j),j=1,...,N  are the diagonals of the complex Schur
;;*          form (S,T) that would result if the 2-by-2 diagonal blocks of
;;*          the real Schur form of (A,B) were further reduced to
;;*          triangular form using 2-by-2 complex unitary transformations.
;;*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
;;*          positive, then the j-th and (j+1)-st eigenvalues are a
;;*          complex conjugate pair, with ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio.
;;*          However, ALPHAR and ALPHAI will be always less than and
;;*          usually comparable with norm(A) in magnitude, and BETA always
;;*          less than and usually comparable with norm(B).
;;*
;;*  VSL     (output) DOUBLE PRECISION array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) DOUBLE PRECISION array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  RCONDE  (output) DOUBLE PRECISION array, dimension ( 2 )
;;*          If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
;;*          reciprocal condition numbers for the average of the selected
;;*          eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION array, dimension ( 2 )
;;*          If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
;;*          reciprocal condition numbers for the selected deflating
;;*          subspaces.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 8*(N+1)+16.
;;*          If SENSE = 'E', 'V', or 'B',
;;*          LWORK >= MAX( 8*(N+1)+16, 2*SDIM*(N-SDIM) ).
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          Not referenced if SENSE = 'N'.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array WORK.  LIWORK >= N+6.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
;;*                be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in DHGEQZ
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy DELZTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering failed in DTGSEN.
;;*
;;*  Further details
;;*  ===============
;;*
;;*  An approximate (asymptotic) bound on the average absolute error of
;;*  the selected eigenvalues is
;;*
;;*       EPS * norm((A, B)) / RCONDE( 1 ).
;;*
;;*  An approximate (asymptotic) bound on the maximum angular error in
;;*  the computed deflating subspaces is
;;*
;;*       EPS * norm((A, B)) / RCONDV( 2 ).
;;*
;;*  See LAPACK User's Guide, section 4.11 for more information.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dggesx (jobvsl  jobvsr  sort  delctg  sense  n  a  lda  b  ldb  sdim  alphar  alphai  beta  vsl  ldvsl  vsr  ldvsr  rconde  rcondv  work  lwork  iwork  liwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")delctg )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx2- (-double-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-double-)) rconde )
	((-idx1- (-double-)) rcondv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ dggesx_($jobvsl->data, $jobvsr->data, $sort->data, $delctg, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($vsl,double), IDX_PTR($ldvsl,int), IDX_PTR($vsr,double), IDX_PTR($ldvsr,int), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggev <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
;;*  the generalized eigenvalues, and optionally, the left and/or right
;;*  generalized eigenvectors.
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   A * v(j) = lambda(j) * B * v(j).
;;*
;;*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   u(j)**H * A  = lambda(j) * u(j)**H * B .
;;*
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
;;*          the j-th eigenvalue is real; if positive, then the j-th and
;;*          (j+1)-st eigenvalues are a complex conjugate pair, with
;;*          ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          alpha/beta.  However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          u(j) = VL(:,j), the j-th column of VL. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part)+abs(imag. part)=1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          v(j) = VR(:,j), the j-th column of VR. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part)+abs(imag. part)=1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,8*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
;;*                should be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in DHGEQZ.
;;*                =N+2: error return from DTGEVC.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dggev (jobvl  jobvr  n  a  lda  b  ldb  alphar  alphai  beta  vl  ldvl  vr  ldvr  work  lwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dggev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <lscale>  <rscale>  <abnrm>  <bbnrm>  <rconde>  <rcondv>  <work>  <lwork>  <iwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
;;*  the generalized eigenvalues, and optionally, the left and/or right
;;*  generalized eigenvectors.
;;*
;;*  Optionally also, it computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
;;*  the eigenvalues (RCONDE), and reciprocal condition numbers for the
;;*  right eigenvectors (RCONDV).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   A * v(j) = lambda(j) * B * v(j) .
;;*
;;*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*
;;*                   u(j)**H * A  = lambda(j) * u(j)**H * B.
;;*
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Specifies the balance option to be performed.
;;*          = 'N':  do not diagonally scale or permute;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*          Computed reciprocal condition numbers will be for the
;;*          matrices after permuting and/or balancing. Permuting does
;;*          not change condition numbers (in exact arithmetic), but
;;*          balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': none are computed;
;;*          = 'E': computed for eigenvalues only;
;;*          = 'V': computed for eigenvectors only;
;;*          = 'B': computed for eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then A contains the first part of the real Schur
;;*          form of the "balanced" versions of the input A and B.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then B contains the second part of the real Schur
;;*          form of the "balanced" versions of the input A and B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
;;*          the j-th eigenvalue is real; if positive, then the j-th and
;;*          (j+1)-st eigenvalues are a complex conjugate pair, with
;;*          ALPHAI(j+1) negative.
;;*
;;*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
;;*          may easily over- or underflow, and BETA(j) may even be zero.
;;*          Thus, the user should avoid naively computing the ratio
;;*          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
;;*          than and usually comparable with norm(A) in magnitude, and
;;*          BETA always less than and usually comparable with norm(B).
;;*
;;*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          u(j) = VL(:,j), the j-th column of VL. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order as
;;*          their eigenvalues. If the j-th eigenvalue is real, then
;;*          v(j) = VR(:,j), the j-th column of VR. If the j-th and
;;*          (j+1)-th eigenvalues form a complex conjugate pair, then
;;*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
;;*          Each eigenvector will be scaled so the largest component have
;;*          abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If BALANC = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If PL(j) is the index of the
;;*          row interchanged with row j, and DL(j) is the scaling
;;*          factor applied to row j, then
;;*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1
;;*                      = DL(j)  for j = ILO,...,IHI
;;*                      = PL(j)  for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If PR(j) is the index of the
;;*          column interchanged with column j, and DR(j) is the scaling
;;*          factor applied to column j, then
;;*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1
;;*                      = DR(j)  for j = ILO,...,IHI
;;*                      = PR(j)  for j = IHI+1,...,N
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) DOUBLE PRECISION
;;*          The one-norm of the balanced matrix A.
;;*
;;*  BBNRM   (output) DOUBLE PRECISION
;;*          The one-norm of the balanced matrix B.
;;*
;;*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)
;;*          If SENSE = 'E' or 'B', the reciprocal condition numbers of
;;*          the selected eigenvalues, stored in consecutive elements of
;;*          the array. For a complex conjugate pair of eigenvalues two
;;*          consecutive elements of RCONDE are set to the same value.
;;*          Thus RCONDE(j), RCONDV(j), and the j-th columns of VL and VR
;;*          all correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If SENSE = 'V', RCONDE is not referenced.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)
;;*          If SENSE = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. For a complex eigenvector two
;;*          consecutive elements of RCONDV are set to the same value. If
;;*          the eigenvalues cannot be reordered to compute RCONDV(j),
;;*          RCONDV(j) is set to 0; this can only occur when the true
;;*          value would be very small anyway.
;;*          If SENSE = 'E', RCONDV is not referenced.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,6*N).
;;*          If SENSE = 'E', LWORK >= 12*N.
;;*          If SENSE = 'V' or 'B', LWORK >= 2*N*N+12*N+16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N+6)
;;*          If SENSE = 'E', IWORK is not referenced.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          If SENSE = 'N', BWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
;;*                should be correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in DHGEQZ.
;;*                =N+2: error return from DTGEVC.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing a matrix pair (A,B) includes, first, permuting rows and
;;*  columns to isolate eigenvalues, second, applying diagonal similarity
;;*  transformation to the rows and columns to make the rows and columns
;;*  as close in norm as possible. The computed reciprocal condition
;;*  numbers correspond to the balanced matrix. Permuting rows and columns
;;*  will not change the condition numbers (in exact arithmetic) but
;;*  diagonal scaling will.  For further explanation of balancing, see
;;*  section 4.11.1.2 of LAPACK Users' Guide.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)
;;*
;;*  An approximate error bound for the angle between the i-th computed
;;*  eigenvector VL(i) or VR(i) is given by
;;*
;;*       EPS * norm(ABNRM, BBNRM) / DIF(i).
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see section 4.11 of LAPACK User's Guide.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dggevx (balanc  jobvl  jobvr  sense  n  a  lda  b  ldb  alphar  alphai  beta  vl  ldvl  vr  ldvr  ilo  ihi  lscale  rscale  abnrm  bbnrm  rconde  rcondv  work  lwork  iwork  bwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) lscale )
	((-idx1- (-double-)) rscale )
	((-idx0- (-double-)) abnrm )
	((-idx0- (-double-)) bbnrm )
	((-idx1- (-double-)) rconde )
	((-idx1- (-double-)) rcondv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ dggevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,double), IDX_PTR($rscale,double), IDX_PTR($abnrm,double), IDX_PTR($bbnrm,double), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggglm <n>  <m>  <p>  <a>  <lda>  <b>  <ldb>  <d>  <x>  <y>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGGLM solves a general Gauss-Markov linear model (GLM) problem:
;;*
;;*          minimize || y ||_2   subject to   d = A*x + B*y
;;*              x
;;*
;;*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
;;*  given N-vector. It is assumed that M <= N <= M+P, and
;;*
;;*             rank(A) = M    and    rank( A B ) = N.
;;*
;;*  Under these assumptions, the constrained equation is always
;;*  consistent, and there is a unique solution x and a minimal 2-norm
;;*  solution y, which is obtained using a generalized QR factorization
;;*  of A and B.
;;*
;;*  In particular, if matrix B is square nonsingular, then the problem
;;*  GLM is equivalent to the following weighted linear least squares
;;*  problem
;;*
;;*               minimize || inv(B)*(d-A*x) ||_2
;;*                   x
;;*
;;*  where inv(B) denotes the inverse of B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B.  N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  0 <= M <= N.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= N-M.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, D is the left hand side of the GLM equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (M)
;;*  Y       (output) DOUBLE PRECISION array, dimension (P)
;;*          On exit, X and Y are the solutions of the GLM problem.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N+M+P).
;;*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          DGEQRF, SGERQF, DORMQR and SORMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  ===================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dggglm (n  m  p  a  lda  b  ldb  d  x  y  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) x )
	((-idx1- (-double-)) y )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dggglm_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($d,double), IDX_PTR($x,double), IDX_PTR($y,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgghrd <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGHRD reduces a pair of real matrices (A,B) to generalized upper
;;*  Hessenberg form using orthogonal transformations, where A is a
;;*  general matrix and B is upper triangular:  Q' * A * Z = H and
;;*  Q' * B * Z = T, where H is upper Hessenberg, T is upper triangular,
;;*  and Q and Z are orthogonal, and ' means transpose.
;;*
;;*  The orthogonal matrices Q and Z are determined as products of Givens
;;*  rotations.  They may either be formed explicitly, or they may be
;;*  postmultiplied into input matrices Q1 and Z1, so that
;;*
;;*       Q1 * A * Z1' = (Q1*Q) * H * (Z1*Z)'
;;*       Q1 * B * Z1' = (Q1*Q) * T * (Z1*Z)'
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not compute Q;
;;*          = 'I': Q is initialized to the unit matrix, and the
;;*                 orthogonal matrix Q is returned;
;;*          = 'V': Q must contain an orthogonal matrix Q1 on entry,
;;*                 and the product Q1*Q is returned.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not compute Z;
;;*          = 'I': Z is initialized to the unit matrix, and the
;;*                 orthogonal matrix Z is returned;
;;*          = 'V': Z must contain an orthogonal matrix Z1 on entry,
;;*                 and the product Z1*Z is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.  ILO and IHI are normally set
;;*          by a previous call to DGGBAL; otherwise they should be set
;;*          to 1 and N respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          rest is set to zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.
;;*          On exit, the upper triangular matrix T = Q' B Z.  The
;;*          elements below the diagonal are set to zero.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*          If COMPQ='N':  Q is not referenced.
;;*          If COMPQ='I':  on entry, Q need not be set, and on exit it
;;*                         contains the orthogonal matrix Q, where Q'
;;*                         is the product of the Givens transformations
;;*                         which are applied to A and B on the left.
;;*          If COMPQ='V':  on entry, Q must contain an orthogonal matrix
;;*                         Q1, and on exit this is overwritten by Q1*Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If COMPZ='N':  Z is not referenced.
;;*          If COMPZ='I':  on entry, Z need not be set, and on exit it
;;*                         contains the orthogonal matrix Z, which is
;;*                         the product of the Givens transformations
;;*                         which are applied to A and B on the right.
;;*          If COMPZ='V':  on entry, Z must contain an orthogonal matrix
;;*                         Z1, and on exit this is overwritten by Z1*Z.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine reduces A to Hessenberg and B to triangular form by
;;*  an unblocked reduction, as described in _Matrix_Computations_,
;;*  by Golub and Van Loan (Johns Hopkins Press.)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgghrd (compq  compz  n  ilo  ihi  a  lda  b  ldb  q  ldq  z  ldz  info  )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ dgghrd_($compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgglse <m>  <n>  <p>  <a>  <lda>  <b>  <ldb>  <c>  <d>  <x>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGLSE solves the linear equality-constrained least squares (LSE)
;;*  problem:
;;*
;;*          minimize || c - A*x ||_2   subject to   B*x = d
;;*
;;*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
;;*  M-vector, and d is a given P-vector. It is assumed that
;;*  P <= N <= M+P, and
;;*
;;*           rank(B) = P and  rank( ( A ) ) = N.
;;*                                ( ( B ) )
;;*
;;*  These conditions ensure that the LSE problem has a unique solution,
;;*  which is obtained using a GRQ factorization of the matrices B and A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B. 0 <= P <= N <= M+P.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (M)
;;*          On entry, C contains the right hand side vector for the
;;*          least squares part of the LSE problem.
;;*          On exit, the residual sum of squares for the solution
;;*          is given by the sum of squares of elements N-P+1 to M of
;;*          vector C.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (P)
;;*          On entry, D contains the right hand side vector for the
;;*          constrained equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, X is the solution of the LSE problem.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M+N+P).
;;*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          DGEQRF, SGERQF, DORMQR and SORMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgglse (m  n  p  a  lda  b  ldb  c  d  x  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) x )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dgglse_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($d,double), IDX_PTR($x,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggqrf <n>  <m>  <p>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGQRF computes a generalized QR factorization of an N-by-M matrix A
;;*  and an N-by-P matrix B:
;;*
;;*              A = Q*R,        B = Q*T*Z,
;;*
;;*  where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
;;*  matrix, and R and T assume one of the forms:
;;*
;;*  if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
;;*                  (  0  ) N-M                         N   M-N
;;*                     M
;;*
;;*  where R11 is upper triangular, and
;;*
;;*  if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
;;*                   P-N  N                           ( T21 ) P
;;*                                                       P
;;*
;;*  where T12 or T21 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GQR factorization
;;*  of A and B implicitly gives the QR factorization of inv(B)*A:
;;*
;;*               inv(B)*A = Z'*(inv(T)*R)
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  transpose of the matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B. N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(N,M)-by-M upper trapezoidal matrix R (R is
;;*          upper triangular if N >= M); the elements below the diagonal,
;;*          with the array TAUA, represent the orthogonal matrix Q as a
;;*          product of min(N,M) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAUA    (output) DOUBLE PRECISION array, dimension (min(N,M))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q (see Further Details).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, if N <= P, the upper triangle of the subarray
;;*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
;;*          if N > P, the elements on and above the (N-P)-th subdiagonal
;;*          contain the N-by-P upper trapezoidal matrix T; the remaining
;;*          elements, with the array TAUB, represent the orthogonal
;;*          matrix Z as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  TAUB    (output) DOUBLE PRECISION array, dimension (min(N,P))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the QR factorization
;;*          of an N-by-M matrix, NB2 is the optimal blocksize for the
;;*          RQ factorization of an N-by-P matrix, and NB3 is the optimal
;;*          blocksize for a call of DORMQR.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(n,m).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine DORGQR.
;;*  To use Q to update another matrix, use LAPACK subroutine DORMQR.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(n,p).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a real scalar, and v is a real vector with
;;*  v(p-k+i+1:p) = 0 and v(p-k+i) = 1; v(1:p-k+i-1) is stored on exit in
;;*  B(n-k+i,1:p-k+i-1), and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine DORGRQ.
;;*  To use Z to update another matrix, use LAPACK subroutine DORMRQ.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dggqrf (n  m  p  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) taua )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) taub )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dggqrf_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($taua,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($taub,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggrqf <m>  <p>  <n>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGRQF computes a generalized RQ factorization of an M-by-N matrix A
;;*  and a P-by-N matrix B:
;;*
;;*              A = R*Q,        B = Z*T*Q,
;;*
;;*  where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal
;;*  matrix, and R and T assume one of the forms:
;;*
;;*  if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
;;*                   N-M  M                           ( R21 ) N
;;*                                                       N
;;*
;;*  where R12 or R21 is upper triangular, and
;;*
;;*  if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
;;*                  (  0  ) P-N                         P   N-P
;;*                     N
;;*
;;*  where T11 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GRQ factorization
;;*  of A and B implicitly gives the RQ factorization of A*inv(B):
;;*
;;*               A*inv(B) = (R*inv(T))*Z'
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  transpose of the matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, if M <= N, the upper triangle of the subarray
;;*          A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
;;*          if M > N, the elements on and above the (M-N)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAUA, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAUA    (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q (see Further Details).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(P,N)-by-N upper trapezoidal matrix T (T is
;;*          upper triangular if P >= N); the elements below the diagonal,
;;*          with the array TAUB, represent the orthogonal matrix Z as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TAUB    (output) DOUBLE PRECISION array, dimension (min(P,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the RQ factorization
;;*          of an M-by-N matrix, NB2 is the optimal blocksize for the
;;*          QR factorization of a P-by-N matrix, and NB3 is the optimal
;;*          blocksize for a call of DORMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INF0= -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a real scalar, and v is a real vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine DORGRQ.
;;*  To use Q to update another matrix, use LAPACK subroutine DORMRQ.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(p,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a real scalar, and v is a real vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i),
;;*  and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine DORGQR.
;;*  To use Z to update another matrix, use LAPACK subroutine DORMQR.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dggrqf (m  p  n  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) taua )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) taub )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dggrqf_(IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($taua,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($taub,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggsvd <jobu>  <jobv>  <jobq>  <m>  <n>  <p>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGSVD computes the generalized singular value decomposition (GSVD)
;;*  of an M-by-N real matrix A and P-by-N real matrix B:
;;*
;;*      U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
;;*
;;*  where U, V and Q are orthogonal matrices, and Z' is the transpose
;;*  of Z.  Let K+L = the effective numerical rank of the matrix (A',B')',
;;*  then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
;;*  D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
;;*  following structures, respectively:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                    K  L
;;*         D2 =   L ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                  N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 )
;;*              L (  0    0   R22 )
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                    K M-K K+L-M
;;*         D1 =   K ( I  0    0   )
;;*              M-K ( 0  C    0   )
;;*
;;*                      K M-K K+L-M
;;*         D2 =   M-K ( 0  S    0  )
;;*              K+L-M ( 0  0    I  )
;;*                P-L ( 0  0    0  )
;;*
;;*                     N-K-L  K   M-K  K+L-M
;;*    ( 0 R ) =     K ( 0    R11  R12  R13  )
;;*                M-K ( 0     0   R22  R23  )
;;*              K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*    S = diag( BETA(K+1),  ... , BETA(M) ),
;;*    C**2 + S**2 = I.
;;*
;;*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
;;*    ( 0  R22 R23 )
;;*    in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The routine computes C, S, R, and optionally the orthogonal
;;*  transformation matrices U, V and Q.
;;*
;;*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
;;*  A and B implicitly gives the SVD of A*inv(B):
;;*                       A*inv(B) = U*(D1*inv(D2))*V'.
;;*  If ( A',B')' has orthonormal columns, then the GSVD of A and B is
;;*  also equal to the CS decomposition of A and B. Furthermore, the GSVD
;;*  can be used to derive the solution of the eigenvalue problem:
;;*                       A'*A x = lambda* B'*B x.
;;*  In some literature, the GSVD of A and B is presented in the form
;;*                   U'*A*X = ( 0 D1 ),   V'*B*X = ( 0 D2 )
;;*  where U and V are orthogonal and X is nonsingular, D1 and D2 are
;;*  ``diagonal''.  The former GSVD form can be converted to the latter
;;*  form by taking the nonsingular matrix X as
;;*
;;*                       X = Q*( I   0    )
;;*                             ( 0 inv(R) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Orthogonal matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Orthogonal matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Orthogonal matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in the Purpose section.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular matrix R, or part of R.
;;*          See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains the triangular matrix R if M-K-L < 0.
;;*          See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDA >= max(1,P).
;;*
;;*  ALPHA   (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = C,
;;*            BETA(K+1:K+L)  = S,
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
;;*            BETA(K+1:M) =S, BETA(M+1:K+L) =1
;;*          and
;;*            ALPHA(K+L+1:N) = 0
;;*            BETA(K+L+1:N)  = 0
;;*
;;*  U       (output) DOUBLE PRECISION array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the M-by-M orthogonal matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) DOUBLE PRECISION array, dimension (LDV,P)
;;*          If JOBV = 'V', V contains the P-by-P orthogonal matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array,
;;*                      dimension (max(3*N,M,P)+N)
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (N)
;;*          On exit, IWORK stores the sorting information. More
;;*          precisely, the following loop will sort ALPHA
;;*             for I = K+1, min(M,K+L)
;;*                 swap ALPHA(I) and ALPHA(IWORK(I))
;;*             endfor
;;*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
;;*
;;*  INFO    (output)INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, the Jacobi-type procedure failed to
;;*                converge.  For further details, see subroutine DTGSJA.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLA    DOUBLE PRECISION
;;*  TOLB    DOUBLE PRECISION
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          rank of (A',B')'. Generally, they are set to
;;*                   TOLA = MAX(M,N)*norm(A)*MAZHEPS,
;;*                   TOLB = MAX(P,N)*norm(B)*MAZHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  2-96 Based on modifications by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dggsvd (jobu  jobv  jobq  m  n  p  k  l  a  lda  b  ldb  alpha  beta  u  ldu  v  ldv  q  ldq  work  iwork  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alpha )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dggsvd_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dggsvp <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <k>  <l>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <iwork>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGGSVP computes orthogonal matrices U, V and Q such that
;;*
;;*                   N-K-L  K    L
;;*   U'*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
;;*                L ( 0     0   A23 )
;;*            M-K-L ( 0     0    0  )
;;*
;;*                   N-K-L  K    L
;;*          =     K ( 0    A12  A13 )  if M-K-L < 0;
;;*              M-K ( 0     0   A23 )
;;*
;;*                 N-K-L  K    L
;;*   V'*B*Q =   L ( 0     0   B13 )
;;*            P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
;;*  numerical rank of the (M+P)-by-N matrix (A',B')'.  Z' denotes the
;;*  transpose of Z.
;;*
;;*  This decomposition is the preprocessing step for computing the
;;*  Generalized Singular Value Decomposition (GSVD), see subroutine
;;*  DGGSVD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Orthogonal matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Orthogonal matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Orthogonal matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular (or trapezoidal) matrix
;;*          described in the Purpose section.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains the triangular matrix described in
;;*          the Purpose section.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) DOUBLE PRECISION
;;*  TOLB    (input) DOUBLE PRECISION
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          numerical rank of matrix B and a subblock of A. Generally,
;;*          they are set to
;;*             TOLA = MAX(M,N)*norm(A)*MAZHEPS,
;;*             TOLB = MAX(P,N)*norm(B)*MAZHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in Purpose.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  U       (output) DOUBLE PRECISION array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the orthogonal matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) DOUBLE PRECISION array, dimension (LDV,M)
;;*          If JOBV = 'V', V contains the orthogonal matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the orthogonal matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  TAU     (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(3*N,M,P))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The subroutine uses LAPACK subroutine DGEQPF for the QR factorization
;;*  with column pivoting to detect the effective numerical rank of the
;;*  a matrix. It may be replaced by a better rank determination strategy.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dggsvp (jobu  jobv  jobq  m  p  n  a  lda  b  ldb  tola  tolb  k  l  u  ldu  v  ldv  q  ldq  iwork  tau  work  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) tola )
	((-idx0- (-double-)) tolb )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) iwork )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dggsvp_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($tola,double), IDX_PTR($tolb,double), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($iwork,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgtcon <norm>  <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTCON estimates the reciprocal of the condition number of a real
;;*  tridiagonal matrix A using the LU factorization as computed by
;;*  DGTTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by DGTTRF.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) DOUBLE PRECISION array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgtcon (norm  n  dl  d  du  du2  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx1- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgtcon_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgtrfs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is tridiagonal, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by DGTTRF.
;;*
;;*  DF      (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DUF     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) DOUBLE PRECISION array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DGTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgtrfs (trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx1- (-double-)) dlf )
	((-idx1- (-double-)) df )
	((-idx1- (-double-)) duf )
	((-idx1- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgtrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($dlf,double), IDX_PTR($df,double), IDX_PTR($duf,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgtsv <n>  <nrhs>  <dl>  <d>  <du>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTSV  solves the equation
;;*
;;*     A*X = B,
;;*
;;*  where A is an n by n tridiagonal matrix, by Gaussian elimination with
;;*  partial pivoting.
;;*
;;*  Note that the equation  A'*X = B  may be solved by interchanging the
;;*  order of the arguments DU and DL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) sub-diagonal elements of
;;*          A.
;;*
;;*          On exit, DL is overwritten by the (n-2) elements of the
;;*          second super-diagonal of the upper triangular matrix U from
;;*          the LU factorization of A, in DL(1), ..., DL(n-2).
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*
;;*          On exit, D is overwritten by the n diagonal elements of U.
;;*
;;*  DU      (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) super-diagonal elements
;;*          of A.
;;*
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          super-diagonal of U.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N by NRHS matrix of right hand side matrix B.
;;*          On exit, if INFO = 0, the N by NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, U(i,i) is exactly zero, and the solution
;;*               has not been computed.  The factorization has not been
;;*               completed unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgtsv (n  nrhs  dl  d  du  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dgtsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgtsvx <fact>  <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTSVX uses the LU factorization to compute the solution to a real
;;*  system of linear equations A * X = B or A**T * X = B,
;;*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the LU decomposition is used to factor the matrix A
;;*     as A = L * U, where L is a product of permutation and unit lower
;;*     bidiagonal matrices and U is upper triangular with nonzeros in
;;*     only the main diagonal and first two superdiagonals.
;;*
;;*  2. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  DLF, DF, DUF, DU2, and IPIV contain the factored
;;*                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV
;;*                  will not be modified.
;;*          = 'N':  The matrix will be copied to DLF, DF, and DUF
;;*                  and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of A.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input or output) DOUBLE PRECISION array, dimension (N-1)
;;*          If FACT = 'F', then DLF is an input argument and on entry
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A as computed by DGTTRF.
;;*
;;*          If FACT = 'N', then DLF is an output argument and on exit
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A.
;;*
;;*  DF      (input or output) DOUBLE PRECISION array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*  DUF     (input or output) DOUBLE PRECISION array, dimension (N-1)
;;*          If FACT = 'F', then DUF is an input argument and on entry
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*          If FACT = 'N', then DUF is an output argument and on exit
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input or output) DOUBLE PRECISION array, dimension (N-2)
;;*          If FACT = 'F', then DU2 is an input argument and on entry
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*          If FACT = 'N', then DU2 is an output argument and on exit
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the LU factorization of A as
;;*          computed by DGTTRF.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the LU factorization of A;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates
;;*          a row interchange was not required.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has not been completed unless i = N, but the
;;*                       factor U is exactly singular, so the solution
;;*                       and error bounds could not be computed.
;;*                       RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgtsvx (fact  trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx1- (-double-)) dlf )
	((-idx1- (-double-)) df )
	((-idx1- (-double-)) duf )
	((-idx1- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dgtsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($dlf,double), IDX_PTR($df,double), IDX_PTR($duf,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgttrf <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTTRF computes an LU factorization of a real tridiagonal matrix A
;;*  using elimination with partial pivoting and row interchanges.
;;*
;;*  The factorization has the form
;;*     A = L * U
;;*  where L is a product of permutation and unit lower bidiagonal
;;*  matrices and U is upper triangular with nonzeros in only the main
;;*  diagonal and first two superdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  DL      (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) sub-diagonal elements of
;;*          A.
;;*
;;*          On exit, DL is overwritten by the (n-1) multipliers that
;;*          define the matrix L from the LU factorization of A.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*
;;*          On exit, D is overwritten by the n diagonal elements of the
;;*          upper triangular matrix U from the LU factorization of A.
;;*
;;*  DU      (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) super-diagonal elements
;;*          of A.
;;*
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          super-diagonal of U.
;;*
;;*  DU2     (output) DOUBLE PRECISION array, dimension (N-2)
;;*          On exit, DU2 is overwritten by the (n-2) elements of the
;;*          second super-diagonal of U.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*          > 0:  if INFO = k, U(k,k) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgttrf (n  dl  d  du  du2  ipiv  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx1- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dgttrf_(IDX_PTR($n,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgttrs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTTRS solves one of the systems of equations
;;*     A*X = B  or  A'*X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by DGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A'* X = B  (Transpose)
;;*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) DOUBLE PRECISION array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dgttrs (trans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx1- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dgttrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dgtts2 <itrans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DGTTS2 solves one of the systems of equations
;;*     A*X = B  or  A'*X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by DGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITRANS  (input) INTEGER
;;*          Specifies the form of the system of equations.
;;*          = 0:  A * X = B  (No transpose)
;;*          = 1:  A'* X = B  (Transpose)
;;*          = 2:  A'* X = B  (Conjugate transpose = Transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) DOUBLE PRECISION array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dgtts2 (itrans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  )
	((-idx0- (-int-)) itrans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx1- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ dgtts2_(IDX_PTR($itrans,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dhgeqz <job>  <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <q>  <ldq>  <z>  <ldz>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DHGEQZ implements a single-/double-shift version of the QZ method for
;;*  finding the generalized eigenvalues
;;*
;;*  w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation
;;*
;;*       det( A - w(i) B ) = 0
;;*
;;*  In addition, the pair A,B may be reduced to generalized Schur form:
;;*  B is upper triangular, and A is block upper triangular, where the
;;*  diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having
;;*  complex generalized eigenvalues (see the description of the argument
;;*  JOB.)
;;*
;;*  If JOB='S', then the pair (A,B) is simultaneously reduced to Schur
;;*  form by applying one orthogonal tranformation (usually called Q) on
;;*  the left and another (usually called Z) on the right.  The 2-by-2
;;*  upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks
;;*  of A will be reduced to positive diagonal matrices.  (I.e.,
;;*  if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and
;;*  B(j+1,j+1) will be positive.)
;;*
;;*  If JOB='E', then at each iteration, the same transformations
;;*  are computed, but they are only applied to those parts of A and B
;;*  which are needed to compute ALPHAR, ALPHAI, and BETAR.
;;*
;;*  If JOB='S' and COMPQ and COMPZ are 'V' or 'I', then the orthogonal
;;*  transformations used to reduce (A,B) are accumulated into the arrays
;;*  Q and Z s.t.:
;;*
;;*       Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
;;*       Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*
;;*
;;*  Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
;;*       Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
;;*       pp. 241--256.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E': compute only ALPHAR, ALPHAI, and BETA.  A and B will
;;*                 not necessarily be put into generalized Schur form.
;;*          = 'S': put A and B into generalized Schur form, as well
;;*                 as computing ALPHAR, ALPHAI, and BETA.
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not modify Q.
;;*          = 'V': multiply the array Q on the right by the transpose of
;;*                 the orthogonal tranformation that is applied to the
;;*                 left side of A and B to reduce them to Schur form.
;;*          = 'I': like COMPQ='V', except that Q will be initialized to
;;*                 the identity first.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not modify Z.
;;*          = 'V': multiply the array Z on the right by the orthogonal
;;*                 tranformation that is applied to the right side of
;;*                 A and B to reduce them to Schur form.
;;*          = 'I': like COMPZ='V', except that Z will be initialized to
;;*                 the identity first.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, Q, and Z.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the N-by-N upper Hessenberg matrix A.  Elements
;;*          below the subdiagonal must be zero.
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to generalized Schur form.
;;*          If JOB='E', then on exit A will have been destroyed.
;;*             The diagonal blocks will be correct, but the off-diagonal
;;*             portion will be meaningless.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max( 1, N ).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.  Elements
;;*          below the diagonal must be zero.  2-by-2 blocks in B
;;*          corresponding to 2-by-2 blocks in A will be reduced to
;;*          positive diagonal form.  (I.e., if A(j+1,j) is non-zero,
;;*          then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be
;;*          positive.)
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to Schur form.
;;*          If JOB='E', then on exit B will have been destroyed.
;;*             Elements corresponding to diagonal blocks of A will be
;;*             correct, but the off-diagonal portion will be meaningless.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max( 1, N ).
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*          ALPHAR(1:N) will be set to real parts of the diagonal
;;*          elements of A that would result from reducing A and B to
;;*          Schur form and then further reducing them both to triangular
;;*          form using unitary transformations s.t. the diagonal of B
;;*          was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
;;*          (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).
;;*          Note that the (real or complex) values
;;*          (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
;;*          generalized eigenvalues of the matrix pencil A - wB.
;;*
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*          ALPHAI(1:N) will be set to imaginary parts of the diagonal
;;*          elements of A that would result from reducing A and B to
;;*          Schur form and then further reducing them both to triangular
;;*          form using unitary transformations s.t. the diagonal of B
;;*          was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
;;*          (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.
;;*          Note that the (real or complex) values
;;*          (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
;;*          generalized eigenvalues of the matrix pencil A - wB.
;;*
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          BETA(1:N) will be set to the (real) diagonal elements of B
;;*          that would result from reducing A and B to Schur form and
;;*          then further reducing them both to triangular form using
;;*          unitary transformations s.t. the diagonal of B was
;;*          non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
;;*          (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).
;;*          Note that the (real or complex) values
;;*          (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
;;*          generalized eigenvalues of the matrix pencil A - wB.
;;*          (Note that BETA(1:N) will always be non-negative, and no
;;*          BETAI is necessary.)
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*          If COMPQ='N', then Q will not be referenced.
;;*          If COMPQ='V' or 'I', then the transpose of the orthogonal
;;*             transformations which are applied to A and B on the left
;;*             will be applied to the array Q on the right.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= 1.
;;*          If COMPQ='V' or 'I', then LDQ >= N.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If COMPZ='N', then Z will not be referenced.
;;*          If COMPZ='V' or 'I', then the orthogonal transformations
;;*             which are applied to A and B on the right will be applied
;;*             to the array Z on the right.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If COMPZ='V' or 'I', then LDZ >= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1,...,N: the QZ iteration did not converge.  (A,B) is not
;;*                     in Schur form, but ALPHAR(i), ALPHAI(i), and
;;*                     BETA(i), i=INFO+1,...,N should be correct.
;;*          = N+1,...,2*N: the shift calculation failed.  (A,B) is not
;;*                     in Schur form, but ALPHAR(i), ALPHAI(i), and
;;*                     BETA(i), i=INFO-N+1,...,N should be correct.
;;*          > 2*N:     various "impossible" errors.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Iteration counters:
;;*
;;*  JITER  -- counts iterations.
;;*  IITER  -- counts iterations run since ILAST was last
;;*            changed.  This is therefore reset only when a 1-by-1 or
;;*            2-by-2 block deflates off the bottom.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*    $                     SAFETY = 1.0E+0 )
;;*  =====================================================================

(de dhgeqz (job  compq  compz  n  ilo  ihi  a  lda  b  ldb  alphar  alphai  beta  q  ldq  z  ldz  work  lwork  info  )
	((-str-) job )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dhgeqz_($job->data, $compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dhsein <side>  <eigsrc>  <initv>  <select>  <n>  <h>  <ldh>  <wr>  <wi>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <ifaill>  <ifailr>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DHSEIN uses inverse iteration to find specified right and/or left
;;*  eigenvectors of a real upper Hessenberg matrix H.
;;*
;;*  The right eigenvector x and the left eigenvector y of the matrix H
;;*  corresponding to an eigenvalue w are defined by:
;;*
;;*               H * x = w * x,     y**h * H = w * y**h
;;*
;;*  where y**h denotes the conjugate transpose of the vector y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  EIGSRC  (input) CHARACTER*1
;;*          Specifies the source of eigenvalues supplied in (WR,WI):
;;*          = 'Q': the eigenvalues were found using DHSEQR; thus, if
;;*                 H has zero subdiagonal elements, and so is
;;*                 block-triangular, then the j-th eigenvalue can be
;;*                 assumed to be an eigenvalue of the block containing
;;*                 the j-th row/column.  This property allows DHSEIN to
;;*                 perform inverse iteration on just one diagonal block.
;;*          = 'N': no assumptions are made on the correspondence
;;*                 between eigenvalues and diagonal blocks.  In this
;;*                 case, DHSEIN must always perform inverse iteration
;;*                 using the whole matrix H.
;;*
;;*  INITV   (input) CHARACTER*1
;;*          = 'N': no initial vectors are supplied;
;;*          = 'U': user-supplied initial vectors are stored in the arrays
;;*                 VL and/or VR.
;;*
;;*  SELECT  (input/output) LOGICAL array, dimension (N)
;;*          Specifies the eigenvectors to be computed. To select the
;;*          real eigenvector corresponding to a real eigenvalue WR(j),
;;*          SELECT(j) must be set to .TRUE.. To select the complex
;;*          eigenvector corresponding to a complex eigenvalue
;;*          (WR(j),WI(j)), with complex conjugate (WR(j+1),WI(j+1)),
;;*          either SELECT(j) or SELECT(j+1) or both must be set to
;;*          .TRUE.; then on exit SELECT(j) is .TRUE. and SELECT(j+1) is
;;*          .FALSE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) DOUBLE PRECISION array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  WR      (input/output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (input) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the real and imaginary parts of the eigenvalues of
;;*          H; a complex conjugate pair of eigenvalues must be stored in
;;*          consecutive elements of WR and WI.
;;*          On exit, WR may have been altered since close eigenvalues
;;*          are perturbed slightly in searching for independent
;;*          eigenvectors.
;;*
;;*  VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
;;*          contain starting vectors for the inverse iteration for the
;;*          left eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column(s) in which the eigenvector will
;;*          be stored.
;;*          On exit, if SIDE = 'L' or 'B', the left eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VL, in the same order as their eigenvalues. A
;;*          complex eigenvector corresponding to a complex eigenvalue is
;;*          stored in two consecutive columns, the first holding the real
;;*          part and the second the imaginary part.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
;;*          contain starting vectors for the inverse iteration for the
;;*          right eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column(s) in which the eigenvector will
;;*          be stored.
;;*          On exit, if SIDE = 'R' or 'B', the right eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VR, in the same order as their eigenvalues. A
;;*          complex eigenvector corresponding to a complex eigenvalue is
;;*          stored in two consecutive columns, the first holding the real
;;*          part and the second the imaginary part.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR required to
;;*          store the eigenvectors; each selected real eigenvector
;;*          occupies one column and each selected complex eigenvector
;;*          occupies two columns.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension ((N+2)*N)
;;*
;;*  IFAILL  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
;;*          eigenvector in the i-th column of VL (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
;;*          eigenvector converged satisfactorily. If the i-th and (i+1)th
;;*          columns of VL hold a complex eigenvector, then IFAILL(i) and
;;*          IFAILL(i+1) are set to the same value.
;;*          If SIDE = 'R', IFAILL is not referenced.
;;*
;;*  IFAILR  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
;;*          eigenvector in the i-th column of VR (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
;;*          eigenvector converged satisfactorily. If the i-th and (i+1)th
;;*          columns of VR hold a complex eigenvector, then IFAILR(i) and
;;*          IFAILR(i+1) are set to the same value.
;;*          If SIDE = 'L', IFAILR is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, i is the number of eigenvectors which
;;*                failed to converge; see IFAILL and IFAILR for further
;;*                details.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x|+|y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dhsein (side  eigsrc  initv  select  n  h  ldh  wr  wi  vl  ldvl  vr  ldvr  mm  m  work  ifaill  ifailr  info  )
	((-str-) side )
	((-str-) eigsrc )
	((-str-) initv )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) ifaill )
	((-idx1- (-int-)) ifailr )
	((-idx0- (-int-)) info )
	#{ dhsein_($side->data, $eigsrc->data, $initv->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($ifaill,int), IDX_PTR($ifailr,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dhseqr <job>  <compz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <wr>  <wi>  <z>  <ldz>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DHSEQR computes the eigenvalues of a real upper Hessenberg matrix H
;;*  and, optionally, the matrices T and Z from the Schur decomposition
;;*  H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur
;;*  form), and Z is the orthogonal matrix of Schur vectors.
;;*
;;*  Optionally Z may be postmultiplied into an input orthogonal matrix Q,
;;*  so that this routine can give the Schur factorization of a matrix A
;;*  which has been reduced to the Hessenberg form H by the orthogonal
;;*  matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E':  compute eigenvalues only;
;;*          = 'S':  compute eigenvalues and the Schur form T.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  no Schur vectors are computed;
;;*          = 'I':  Z is initialized to the unit matrix and the matrix Z
;;*                  of Schur vectors of H is returned;
;;*          = 'V':  Z must contain an orthogonal matrix Q on entry, and
;;*                  the product Q*Z is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to DGEBAL, and then passed to SGEHRD
;;*          when the matrix output by DGEBAL is reduced to Hessenberg
;;*          form. Otherwise ILO and IHI should be set to 1 and N
;;*          respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  H       (input/output) DOUBLE PRECISION array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if JOB = 'S', H contains the upper quasi-triangular
;;*          matrix T from the Schur decomposition (the Schur form);
;;*          2-by-2 diagonal blocks (corresponding to complex conjugate
;;*          pairs of eigenvalues) are returned in standard form, with
;;*          H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) < 0. If JOB = 'E',
;;*          the contents of H are unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          The real and imaginary parts, respectively, of the computed
;;*          eigenvalues. If two eigenvalues are computed as a complex
;;*          conjugate pair, they are stored in consecutive elements of
;;*          WR and WI, say the i-th and (i+1)th, with WI(i) > 0 and
;;*          WI(i+1) < 0. If JOB = 'S', the eigenvalues are stored in the
;;*          same order as on the diagonal of the Schur form returned in
;;*          H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
;;*          diagonal block, WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and
;;*          WI(i+1) = -WI(i).
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          If COMPZ = 'N': Z is not referenced.
;;*          If COMPZ = 'I': on entry, Z need not be set, and on exit, Z
;;*          contains the orthogonal matrix Z of the Schur vectors of H.
;;*          If COMPZ = 'V': on entry Z must contain an N-by-N matrix Q,
;;*          which is assumed to be equal to the unit matrix except for
;;*          the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
;;*          Normally Q is the orthogonal matrix generated by DORGHR after
;;*          the call to DGEHRD which formed the Hessenberg matrix H.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= max(1,N) if COMPZ = 'I' or 'V'; LDZ >= 1 otherwise.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, DHSEQR failed to compute all of the
;;*                eigenvalues in a total of 30*(IHI-ILO+1) iterations;
;;*                elements 1:ilo-1 and i+1:n of WR and WI contain those
;;*                eigenvalues which have been successfully computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dhseqr (job  compz  n  ilo  ihi  h  ldh  wr  wi  z  ldz  work  lwork  info  )
	((-str-) job )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dhseqr_($job->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlabad <small>  <large>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLABAD takes as input the values computed by DLAMCH for underflow and
;;*  overflow, and returns the square root of each of these values if the
;;*  log of LARGE is sufficiently large.  This subroutine is intended to
;;*  identify machines with a large exponent range, such as the Crays, and
;;*  redefine the underflow and overflow limits to be the square roots of
;;*  the values computed by DLAMCH.  This subroutine is needed because
;;*  DLAMCH does not compensate for poor arithmetic in the upper half of
;;*  the exponent range, as is found on a Cray.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SMALL   (input/output) DOUBLE PRECISION
;;*          On entry, the underflow threshold as computed by DLAMCH.
;;*          On exit, if LOG10(LARGE) is sufficiently large, the square
;;*          root of SMALL, otherwise unchanged.
;;*
;;*  LARGE   (input/output) DOUBLE PRECISION
;;*          On entry, the overflow threshold as computed by DLAMCH.
;;*          On exit, if LOG10(LARGE) is sufficiently large, the square
;;*          root of LARGE, otherwise unchanged.
;;*
;;*  =====================================================================
;;*
;;*     .. Intrinsic Functions ..
;;*  =====================================================================

(de dlabad (small  large  )
	((-idx0- (-double-)) small )
	((-idx0- (-double-)) large )
	#{ dlabad_(IDX_PTR($small,double), IDX_PTR($large,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlabrd <m>  <n>  <nb>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <x>  <ldx>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLABRD reduces the first NB rows and columns of a real general
;;*  m by n matrix A to upper or lower bidiagonal form by an orthogonal
;;*  transformation Q' * A * P, and returns the matrices X and Y which
;;*  are needed to apply the transformation to the unreduced part of A.
;;*
;;*  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
;;*  bidiagonal form.
;;*
;;*  This is an auxiliary routine called by DGEBRD
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of leading rows and columns of A to be reduced.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit, the first NB rows and columns of the matrix are
;;*          overwritten; the rest of the array is unchanged.
;;*          If m >= n, elements on and below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the orthogonal
;;*            matrix Q as a product of elementary reflectors; and
;;*            elements above the diagonal in the first NB rows, with the
;;*            array TAUP, represent the orthogonal matrix P as a product
;;*            of elementary reflectors.
;;*          If m < n, elements below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the orthogonal
;;*            matrix Q as a product of elementary reflectors, and
;;*            elements on and above the diagonal in the first NB rows,
;;*            with the array TAUP, represent the orthogonal matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (NB)
;;*          The diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.  D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (NB)
;;*          The off-diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.
;;*
;;*  TAUQ    (output) DOUBLE PRECISION array dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix Q. See Further Details.
;;*
;;*  TAUP    (output) DOUBLE PRECISION array, dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the orthogonal matrix P. See Further Details.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NB)
;;*          The m-by-nb matrix X required to update the unreduced part
;;*          of A.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X. LDX >= M.
;;*
;;*  Y       (output) DOUBLE PRECISION array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y required to update the unreduced part
;;*          of A.
;;*
;;*  LDY     (output) INTEGER
;;*          The leading dimension of the array Y. LDY >= N.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are real scalars, and v and u are real vectors.
;;*
;;*  If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
;;*  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The elements of the vectors v and u together form the m-by-nb matrix
;;*  V and the nb-by-n matrix U' which are needed, with X and Y, to apply
;;*  the transformation to the unreduced part of the matrix, using a block
;;*  update of the form:  A := A - V*Y' - X*U'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with nb = 2:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
;;*    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
;;*    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )
;;*
;;*  where a denotes an element of the original matrix which is unchanged,
;;*  vi denotes an element of the vector defining H(i), and ui an element
;;*  of the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlabrd (m  n  nb  a  lda  d  e  tauq  taup  x  ldx  y  ldy  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tauq )
	((-idx1- (-double-)) taup )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) ldy )
	#{ dlabrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tauq,double), IDX_PTR($taup,double), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($y,double), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlacon <n>  <v>  <x>  <isgn>  <est>  <kase>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLACON estimates the 1-norm of a square, real matrix A.
;;*  Reverse communication is used for evaluating matrix-vector products.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The order of the matrix.  N >= 1.
;;*
;;*  V      (workspace) DOUBLE PRECISION array, dimension (N)
;;*         On the final return, V = A*W,  where  EST = norm(V)/norm(W)
;;*         (W is not returned).
;;*
;;*  X      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On an intermediate return, X should be overwritten by
;;*               A * X,   if KASE=1,
;;*               A' * X,  if KASE=2,
;;*         and DLACON must be re-called with all the other parameters
;;*         unchanged.
;;*
;;*  ISGN   (workspace) INTEGER array, dimension (N)
;;*
;;*  EST    (output) DOUBLE PRECISION
;;*         An estimate (a lower bound) for norm(A).
;;*
;;*  KASE   (input/output) INTEGER
;;*         On the initial call to DLACON, KASE should be 0.
;;*         On an intermediate return, KASE will be 1 or 2, indicating
;;*         whether X should be overwritten by A * X  or A' * X.
;;*         On the final return from DLACON, KASE will again be 0.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  Contributed by Nick Higham, University of Manchester.
;;*  Originally named SONEST, dated March 16, 1988.
;;*
;;*  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of
;;*  a real or complex matrix, with applications to condition estimation",
;;*  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlacon (n  v  x  isgn  est  kase  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) v )
	((-idx1- (-double-)) x )
	((-idx1- (-int-)) isgn )
	((-idx0- (-double-)) est )
	((-idx0- (-int-)) kase )
	#{ dlacon_(IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($x,double), IDX_PTR($isgn,int), IDX_PTR($est,double), IDX_PTR($kase,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlacpy <uplo>  <m>  <n>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLACPY copies all or part of a two-dimensional matrix A to another
;;*  matrix B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be copied to B.
;;*          = 'U':      Upper triangular part
;;*          = 'L':      Lower triangular part
;;*          Otherwise:  All of the matrix A
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The m by n matrix A.  If UPLO = 'U', only the upper triangle
;;*          or trapezoid is accessed; if UPLO = 'L', only the lower
;;*          triangle or trapezoid is accessed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On exit, B = A in the locations specified by UPLO.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlacpy (uplo  m  n  a  lda  b  ldb  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ dlacpy_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dladiv <a>  <b>  <c>  <d>  <p>  <q>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLADIV performs complex division in  real arithmetic
;;*
;;*                        a + i*b
;;*             p + i*q = ---------
;;*                        c + i*d
;;*
;;*  The algorithm is due to Robert L. Smith and can be found
;;*  in D. Knuth, The art of Computer Programming, Vol.2, p.195
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) DOUBLE PRECISION
;;*  B       (input) DOUBLE PRECISION
;;*  C       (input) DOUBLE PRECISION
;;*  D       (input) DOUBLE PRECISION
;;*          The scalars a, b, c, and d in the above expression.
;;*
;;*  P       (output) DOUBLE PRECISION
;;*  Q       (output) DOUBLE PRECISION
;;*          The scalars p and q in the above expression.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dladiv (a  b  c  d  p  q  )
	((-idx0- (-double-)) a )
	((-idx0- (-double-)) b )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) d )
	((-idx0- (-double-)) p )
	((-idx0- (-double-)) q )
	#{ dladiv_(IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($d,double), IDX_PTR($p,double), IDX_PTR($q,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlae2 <a>  <b>  <c>  <rt1>  <rt2>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
;;*     [  A   B  ]
;;*     [  B   C  ].
;;*  On return, RT1 is the eigenvalue of larger absolute value, and RT2
;;*  is the eigenvalue of smaller absolute value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) DOUBLE PRECISION
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  B       (input) DOUBLE PRECISION
;;*          The (1,2) and (2,1) elements of the 2-by-2 matrix.
;;*
;;*  C       (input) DOUBLE PRECISION
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  RT1     (output) DOUBLE PRECISION
;;*          The eigenvalue of larger absolute value.
;;*
;;*  RT2     (output) DOUBLE PRECISION
;;*          The eigenvalue of smaller absolute value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  RT1 is accurate to a few ulps barring over/underflow.
;;*
;;*  RT2 may be inaccurate if there is massive cancellation in the
;;*  determinant A*C-B*B; higher precision or correctly rounded or
;;*  correctly truncated arithmetic would be needed to compute RT2
;;*  accurately in all cases.
;;*
;;*  Overflow is possible only if RT1 is within a factor of 5 of overflow.
;;*  Underflow is harmless if the input data is 0 or exceeds
;;*     underflow_threshold / macheps.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlae2 (a  b  c  rt1  rt2  )
	((-idx0- (-double-)) a )
	((-idx0- (-double-)) b )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) rt1 )
	((-idx0- (-double-)) rt2 )
	#{ dlae2_(IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($rt1,double), IDX_PTR($rt2,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaebz <ijob>  <nitmax>  <n>  <mmax>  <minp>  <nbmin>  <abstol>  <reltol>  <pivmin>  <d>  <e>  <e2>  <nval>  <ab>  <c>  <mout>  <nab>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAEBZ contains the iteration loops which compute and use the
;;*  function N(w), which is the count of eigenvalues of a symmetric
;;*  tridiagonal matrix T less than or equal to its argument  w.  It
;;*  performs a choice of two types of loops:
;;*
;;*  IJOB=1, followed by
;;*  IJOB=2: It takes as input a list of intervals and returns a list of
;;*          sufficiently small intervals whose union contains the same
;;*          eigenvalues as the union of the original intervals.
;;*          The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
;;*          The output interval (AB(j,1),AB(j,2)] will contain
;;*          eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
;;*
;;*  IJOB=3: It performs a binary search in each input interval
;;*          (AB(j,1),AB(j,2)] for a point  w(j)  such that
;;*          N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
;;*          the search.  If such a w(j) is found, then on output
;;*          AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
;;*          (AB(j,1),AB(j,2)] will be a small interval containing the
;;*          point where N(w) jumps through NVAL(j), unless that point
;;*          lies outside the initial interval.
;;*
;;*  Note that the intervals are in all cases half-open intervals,
;;*  i.e., of the form  (a,b] , which includes  b  but not  a .
;;*
;;*  To avoid underflow, the matrix should be scaled so that its largest
;;*  element is no greater than  overflow**(1/2) * underflow**(1/4)
;;*  in absolute value.  To assure the most accurate computation
;;*  of small eigenvalues, the matrix should be scaled to be
;;*  not much smaller than that, either.
;;*
;;*  See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
;;*  Matrix", Report CS41, Computer Science Dept., Stanford
;;*  University, July 21, 1966
;;*
;;*  Note: the arguments are, in general, *not* checked for unreasonable
;;*  values.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what is to be done:
;;*          = 1:  Compute NAB for the initial intervals.
;;*          = 2:  Perform bisection iteration to find eigenvalues of T.
;;*          = 3:  Perform bisection iteration to invert N(w), i.e.,
;;*                to find a point which has a specified number of
;;*                eigenvalues of T to its left.
;;*          Other values will cause DLAEBZ to return with INFO=-1.
;;*
;;*  NITMAX  (input) INTEGER
;;*          The maximum number of "levels" of bisection to be
;;*          performed, i.e., an interval of width W will not be made
;;*          smaller than 2^(-NITMAX) * W.  If not all intervals
;;*          have converged after NITMAX iterations, then INFO is set
;;*          to the number of non-converged intervals.
;;*
;;*  N       (input) INTEGER
;;*          The dimension n of the tridiagonal matrix T.  It must be at
;;*          least 1.
;;*
;;*  MMAX    (input) INTEGER
;;*          The maximum number of intervals.  If more than MMAX intervals
;;*          are generated, then DLAEBZ will quit with INFO=MMAX+1.
;;*
;;*  MINP    (input) INTEGER
;;*          The initial number of intervals.  It may not be greater than
;;*          MMAX.
;;*
;;*  NBMIN   (input) INTEGER
;;*          The smallest number of intervals that should be processed
;;*          using a vector loop.  If zero, then only the scalar loop
;;*          will be used.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The minimum (absolute) width of an interval.  When an
;;*          interval is narrower than ABSTOL, or than RELTOL times the
;;*          larger (in magnitude) endpoint, then it is considered to be
;;*          sufficiently small, i.e., converged.  This must be at least
;;*          zero.
;;*
;;*  RELTOL  (input) DOUBLE PRECISION
;;*          The minimum relative width of an interval.  When an interval
;;*          is narrower than ABSTOL, or than RELTOL times the larger (in
;;*          magnitude) endpoint, then it is considered to be
;;*          sufficiently small, i.e., converged.  Note: this should
;;*          always be at least radix*machine epsilon.
;;*
;;*  PIVMIN  (input) DOUBLE PRECISION
;;*          The minimum absolute value of a "pivot" in the Sturm
;;*          sequence loop.  This *must* be at least  max |e(j)**2| *
;;*          safe_min  and at least safe_min, where safe_min is at least
;;*          the smallest number that can divide one without overflow.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N)
;;*          The offdiagonal elements of the tridiagonal matrix T in
;;*          positions 1 through N-1.  E(N) is arbitrary.
;;*
;;*  E2      (input) DOUBLE PRECISION array, dimension (N)
;;*          The squares of the offdiagonal elements of the tridiagonal
;;*          matrix T.  E2(N) is ignored.
;;*
;;*  NVAL    (input/output) INTEGER array, dimension (MINP)
;;*          If IJOB=1 or 2, not referenced.
;;*          If IJOB=3, the desired values of N(w).  The elements of NVAL
;;*          will be reordered to correspond with the intervals in AB.
;;*          Thus, NVAL(j) on output will not, in general be the same as
;;*          NVAL(j) on input, but it will correspond with the interval
;;*          (AB(j,1),AB(j,2)] on output.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (MMAX,2)
;;*          The endpoints of the intervals.  AB(j,1) is  a(j), the left
;;*          endpoint of the j-th interval, and AB(j,2) is b(j), the
;;*          right endpoint of the j-th interval.  The input intervals
;;*          will, in general, be modified, split, and reordered by the
;;*          calculation.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (MMAX)
;;*          If IJOB=1, ignored.
;;*          If IJOB=2, workspace.
;;*          If IJOB=3, then on input C(j) should be initialized to the
;;*          first search point in the binary search.
;;*
;;*  MOUT    (output) INTEGER
;;*          If IJOB=1, the number of eigenvalues in the intervals.
;;*          If IJOB=2 or 3, the number of intervals output.
;;*          If IJOB=3, MOUT will equal MINP.
;;*
;;*  NAB     (input/output) INTEGER array, dimension (MMAX,2)
;;*          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j)).
;;*          If IJOB=2, then on input, NAB(i,j) should be set.  It must
;;*             satisfy the condition:
;;*             N(AB(i,1)) <= NAB(i,1) <= NAB(i,2) <= N(AB(i,2)),
;;*             which means that in interval i only eigenvalues
;;*             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,
;;*             NAB(i,j)=N(AB(i,j)), from a previous call to DLAEBZ with
;;*             IJOB=1.
;;*             On output, NAB(i,j) will contain
;;*             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
;;*             the input interval that the output interval
;;*             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the
;;*             the input values of NAB(k,1) and NAB(k,2).
;;*          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),
;;*             unless N(w) > NVAL(i) for all search points  w , in which
;;*             case NAB(i,1) will not be modified, i.e., the output
;;*             value will be the same as the input value (modulo
;;*             reorderings -- see NVAL and AB), or unless N(w) < NVAL(i)
;;*             for all search points  w , in which case NAB(i,2) will
;;*             not be modified.  Normally, NAB should be set to some
;;*             distinctive value(s) before DLAEBZ is called.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (MMAX)
;;*          Workspace.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (MMAX)
;;*          Workspace.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:       All intervals converged.
;;*          = 1--MMAX: The last INFO intervals did not converge.
;;*          = MMAX+1:  More than MMAX intervals were generated.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*      This routine is intended to be called only by other LAPACK
;;*  routines, thus the interface is less user-friendly.  It is intended
;;*  for two purposes:
;;*
;;*  (a) finding eigenvalues.  In this case, DLAEBZ should have one or
;;*      more initial intervals set up in AB, and DLAEBZ should be called
;;*      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
;;*      Intervals with no eigenvalues would usually be thrown out at
;;*      this point.  Also, if not all the eigenvalues in an interval i
;;*      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.
;;*      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest
;;*      eigenvalue.  DLAEBZ is then called with IJOB=2 and MMAX
;;*      no smaller than the value of MOUT returned by the call with
;;*      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1
;;*      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the
;;*      tolerance specified by ABSTOL and RELTOL.
;;*
;;*  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l).
;;*      In this case, start with a Gershgorin interval  (a,b).  Set up
;;*      AB to contain 2 search intervals, both initially (a,b).  One
;;*      NVAL element should contain  f-1  and the other should contain  l
;;*      , while C should contain a and b, resp.  NAB(i,1) should be -1
;;*      and NAB(i,2) should be N+1, to flag an error if the desired
;;*      interval does not lie in (a,b).  DLAEBZ is then called with
;;*      IJOB=3.  On exit, if w(f-1) < w(f), then one of the intervals --
;;*      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while
;;*      if, to the specified tolerance, w(f-k)=...=w(f+r), k > 0 and r
;;*      >= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and
;;*      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) < w(l+1) and
;;*      w(l-r)=...=w(l+k) are handled similarly.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaebz (ijob  nitmax  n  mmax  minp  nbmin  abstol  reltol  pivmin  d  e  e2  nval  ab  c  mout  nab  work  iwork  info  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) nitmax )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) mmax )
	((-idx0- (-int-)) minp )
	((-idx0- (-int-)) nbmin )
	((-idx0- (-double-)) abstol )
	((-idx0- (-double-)) reltol )
	((-idx0- (-double-)) pivmin )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) e2 )
	((-idx1- (-int-)) nval )
	((-idx2- (-double-)) ab )
	((-idx1- (-double-)) c )
	((-idx0- (-int-)) mout )
	((-idx2- (-int-)) nab )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlaebz_(IDX_PTR($ijob,int), IDX_PTR($nitmax,int), IDX_PTR($n,int), IDX_PTR($mmax,int), IDX_PTR($minp,int), IDX_PTR($nbmin,int), IDX_PTR($abstol,double), IDX_PTR($reltol,double), IDX_PTR($pivmin,double), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($e2,double), IDX_PTR($nval,int), IDX_PTR($ab,double), IDX_PTR($c,double), IDX_PTR($mout,int), IDX_PTR($nab,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed0 <icompq>  <qsiz>  <n>  <d>  <e>  <q>  <ldq>  <qstore>  <ldqs>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED0 computes all eigenvalues and corresponding eigenvectors of a
;;*  symmetric tridiagonal matrix using the divide and conquer method.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          = 0:  Compute eigenvalues only.
;;*          = 1:  Compute eigenvectors of original dense symmetric matrix
;;*                also.  On entry, Q contains the orthogonal matrix used
;;*                to reduce the original matrix to tridiagonal form.
;;*          = 2:  Compute eigenvalues and eigenvectors of tridiagonal
;;*                matrix.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the orthogonal matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, the main diagonal of the tridiagonal matrix.
;;*         On exit, its eigenvalues.
;;*
;;*  E      (input) DOUBLE PRECISION array, dimension (N-1)
;;*         The off-diagonal elements of the tridiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  Q      (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*         On entry, Q must contain an N-by-N orthogonal matrix.
;;*         If ICOMPQ = 0    Q is not referenced.
;;*         If ICOMPQ = 1    On entry, Q is a subset of the columns of the
;;*                          orthogonal matrix used to reduce the full
;;*                          matrix to tridiagonal form corresponding to
;;*                          the subset of the full matrix which is being
;;*                          decomposed at this time.
;;*         If ICOMPQ = 2    On entry, Q will be the identity matrix.
;;*                          On exit, Q contains the eigenvectors of the
;;*                          tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  If eigenvectors are
;;*         desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.
;;*
;;*  QSTORE (workspace) DOUBLE PRECISION array, dimension (LDQS, N)
;;*         Referenced only when ICOMPQ = 1.  Used to store parts of
;;*         the eigenvector matrix when the updating matrix multiplies
;;*         take place.
;;*
;;*  LDQS   (input) INTEGER
;;*         The leading dimension of the array QSTORE.  If ICOMPQ = 1,
;;*         then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array,
;;*         If ICOMPQ = 0 or 1, the dimension of WORK must be at least
;;*                     1 + 3*N + 2*N*lg N + 2*N**2
;;*                     ( lg( N ) = smallest integer k
;;*                                 such that 2^k >= N )
;;*         If ICOMPQ = 2, the dimension of WORK must be at least
;;*                     4*N + N**2.
;;*
;;*  IWORK  (workspace) INTEGER array,
;;*         If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
;;*                        6 + 6*N + 5*N*lg N.
;;*                        ( lg( N ) = smallest integer k
;;*                                    such that 2^k >= N )
;;*         If ICOMPQ = 2, the dimension of IWORK must be at least
;;*                        3 + 5*N.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed0 (icompq  qsiz  n  d  e  q  ldq  qstore  ldqs  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) qstore )
	((-idx0- (-int-)) ldqs )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlaed0_(IDX_PTR($icompq,int), IDX_PTR($qsiz,int), IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($qstore,double), IDX_PTR($ldqs,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed1 <n>  <d>  <q>  <ldq>  <indxq>  <rho>  <cutpnt>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED1 computes the updated eigensystem of a diagonal
;;*  matrix after modification by a rank-one symmetric matrix.  This
;;*  routine is used only for the eigenproblem which requires all
;;*  eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
;;*  the case in which eigenvalues only or eigenvalues and eigenvectors
;;*  of a full symmetric matrix (which was reduced to tridiagonal form)
;;*  are desired.
;;*
;;*    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
;;*
;;*     where Z = Q'u, u is a vector of length N with ones in the
;;*     CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
;;*
;;*     The eigenvectors of the original matrix are stored in Q, and the
;;*     eigenvalues are in D.  The algorithm consists of three stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple eigenvalues or if there is a zero in
;;*        the Z vector.  For each such occurence the dimension of the
;;*        secular equation problem is reduced by one.  This stage is
;;*        performed by the routine DLAED2.
;;*
;;*        The second stage consists of calculating the updated
;;*        eigenvalues. This is done by finding the roots of the secular
;;*        equation via the routine DLAED4 (as called by DLAED3).
;;*        This routine also calculates the eigenvectors of the current
;;*        problem.
;;*
;;*        The final stage consists of computing the updated eigenvectors
;;*        directly using the updated eigenvalues.  The eigenvectors for
;;*        the current problem are multiplied with the eigenvectors from
;;*        the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, the eigenvalues of the rank-1-perturbed matrix.
;;*         On exit, the eigenvalues of the repaired matrix.
;;*
;;*  Q      (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*         On entry, the eigenvectors of the rank-1-perturbed matrix.
;;*         On exit, the eigenvectors of the repaired tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (input/output) INTEGER array, dimension (N)
;;*         On entry, the permutation which separately sorts the two
;;*         subproblems in D into ascending order.
;;*         On exit, the permutation which will reintegrate the
;;*         subproblems back into sorted order,
;;*         i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         The subdiagonal entry used to create the rank-1 modification.
;;*
;;*  CUTPNT (input) INTEGER
;;*         The location of the last eigenvalue in the leading sub-matrix.
;;*         min(1,N) <= CUTPNT <= N/2.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension (4*N + N**2)
;;*
;;*  IWORK  (workspace) INTEGER array, dimension (4*N)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlaed1 (n  d  q  ldq  indxq  rho  cutpnt  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-double-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlaed1_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,double), IDX_PTR($cutpnt,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed2 <k>  <n>  <n1>  <d>  <q>  <ldq>  <indxq>  <rho>  <z>  <dlamda>  <w>  <q2>  <indx>  <indxc>  <indxp>  <coltyp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED2 merges the two sets of eigenvalues together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  eigenvalues are close together or if there is a tiny entry in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K      (output) INTEGER
;;*         The number of non-deflated eigenvalues, and the order of the
;;*         related secular equation. 0 <= K <=N.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  N1     (input) INTEGER
;;*         The location of the last eigenvalue in the leading sub-matrix.
;;*         min(1,N) <= N1 <= N/2.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, D contains the eigenvalues of the two submatrices to
;;*         be combined.
;;*         On exit, D contains the trailing (N-K) updated eigenvalues
;;*         (those which were deflated) sorted into increasing order.
;;*
;;*  Q      (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*         On entry, Q contains the eigenvectors of two submatrices in
;;*         the two square blocks with corners at (1,1), (N1,N1)
;;*         and (N1+1, N1+1), (N,N).
;;*         On exit, Q contains the trailing (N-K) updated eigenvectors
;;*         (those which were deflated) in its last N-K columns.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (input/output) INTEGER array, dimension (N)
;;*         The permutation which separately sorts the two sub-problems
;;*         in D into ascending order.  Note that elements in the second
;;*         half of this permutation must first have N1 added to their
;;*         values. Destroyed on exit.
;;*
;;*  RHO    (input/output) DOUBLE PRECISION
;;*         On entry, the off-diagonal element associated with the rank-1
;;*         cut which originally split the two submatrices which are now
;;*         being recombined.
;;*         On exit, RHO has been modified to the value required by
;;*         DLAED3.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension (N)
;;*         On entry, Z contains the updating vector (the last
;;*         row of the first sub-eigenvector matrix and the first row of
;;*         the second sub-eigenvector matrix).
;;*         On exit, the contents of Z have been destroyed by the updating
;;*         process.
;;*
;;*  DLAMDA (output) DOUBLE PRECISION array, dimension (N)
;;*         A copy of the first K eigenvalues which will be used by
;;*         DLAED3 to form the secular equation.
;;*
;;*  W      (output) DOUBLE PRECISION array, dimension (N)
;;*         The first k values of the final deflation-altered z-vector
;;*         which will be passed to DLAED3.
;;*
;;*  Q2     (output) DOUBLE PRECISION array, dimension (N1**2+(N-N1)**2)
;;*         A copy of the first K eigenvectors which will be used by
;;*         DLAED3 in a matrix multiply (DGEMM) to solve for the new
;;*         eigenvectors.
;;*
;;*  INDX   (workspace) INTEGER array, dimension (N)
;;*         The permutation used to sort the contents of DLAMDA into
;;*         ascending order.
;;*
;;*  INDXC  (output) INTEGER array, dimension (N)
;;*         The permutation used to arrange the columns of the deflated
;;*         Q matrix into three groups:  the first group contains non-zero
;;*         elements only at and above N1, the second contains
;;*         non-zero elements only below N1, and the third is dense.
;;*
;;*  INDXP  (workspace) INTEGER array, dimension (N)
;;*         The permutation used to place deflated values of D at the end
;;*         of the array.  INDXP(1:K) points to the nondeflated D-values
;;*         and INDXP(K+1:N) points to the deflated eigenvalues.
;;*
;;*  COLTYP (workspace/output) INTEGER array, dimension (N)
;;*         During execution, a label which will indicate which of the
;;*         following types a column in the Q2 matrix is:
;;*         1 : non-zero in the upper half only;
;;*         2 : dense;
;;*         3 : non-zero in the lower half only;
;;*         4 : deflated.
;;*         On exit, COLTYP(i) is the number of columns of type i,
;;*         for i=1 to 4 only.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed2 (k  n  n1  d  q  ldq  indxq  rho  z  dlamda  w  q2  indx  indxc  indxp  coltyp  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) n1 )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-double-)) rho )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) dlamda )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) q2 )
	((-idx1- (-int-)) indx )
	((-idx1- (-int-)) indxc )
	((-idx1- (-int-)) indxp )
	((-idx1- (-int-)) coltyp )
	((-idx0- (-int-)) info )
	#{ dlaed2_(IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($n1,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,double), IDX_PTR($z,double), IDX_PTR($dlamda,double), IDX_PTR($w,double), IDX_PTR($q2,double), IDX_PTR($indx,int), IDX_PTR($indxc,int), IDX_PTR($indxp,int), IDX_PTR($coltyp,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed3 <k>  <n>  <n1>  <d>  <q>  <ldq>  <rho>  <dlamda>  <q2>  <indx>  <ctot>  <w>  <s>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED3 finds the roots of the secular equation, as defined by the
;;*  values in D, W, and RHO, between 1 and K.  It makes the
;;*  appropriate calls to DLAED4 and then updates the eigenvectors by
;;*  multiplying the matrix of eigenvectors of the pair of eigensystems
;;*  being combined by the matrix of eigenvectors of the K-by-K system
;;*  which is solved here.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved by
;;*          DLAED4.  K >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows and columns in the Q matrix.
;;*          N >= K (deflation may result in N>K).
;;*
;;*  N1      (input) INTEGER
;;*          The location of the last eigenvalue in the leading submatrix.
;;*          min(1,N) <= N1 <= N/2.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          D(I) contains the updated eigenvalues for
;;*          1 <= I <= K.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          Initially the first K columns are used as workspace.
;;*          On output the columns 1 to K contain
;;*          the updated eigenvectors.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  RHO     (input) DOUBLE PRECISION
;;*          The value of the parameter in the rank one update equation.
;;*          RHO >= 0 required.
;;*
;;*  DLAMDA  (input/output) DOUBLE PRECISION array, dimension (K)
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation. May be changed on output by
;;*          having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
;;*          Cray-2, or Cray C-90, as described above.
;;*
;;*  Q2      (input) DOUBLE PRECISION array, dimension (LDQ2, N)
;;*          The first K columns of this matrix contain the non-deflated
;;*          eigenvectors for the split problem.
;;*
;;*  INDX    (input) INTEGER array, dimension (N)
;;*          The permutation used to arrange the columns of the deflated
;;*          Q matrix into three groups (see DLAED2).
;;*          The rows of the eigenvectors found by DLAED4 must be likewise
;;*          permuted before the matrix multiply can take place.
;;*
;;*  CTOT    (input) INTEGER array, dimension (4)
;;*          A count of the total number of the various types of columns
;;*          in Q, as described in INDX.  The fourth column type is any
;;*          column which has been deflated.
;;*
;;*  W       (input/output) DOUBLE PRECISION array, dimension (K)
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating vector. Destroyed on
;;*          output.
;;*
;;*  S       (workspace) DOUBLE PRECISION array, dimension (N1 + 1)*K
;;*          Will contain the eigenvectors of the repaired matrix which
;;*          will be multiplied by the previously accumulated eigenvectors
;;*          to update the system.
;;*
;;*  LDS     (input) INTEGER
;;*          The leading dimension of S.  LDS >= max(1,K).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed3 (k  n  n1  d  q  ldq  rho  dlamda  q2  indx  ctot  w  s  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) n1 )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) rho )
	((-idx1- (-double-)) dlamda )
	((-idx1- (-double-)) q2 )
	((-idx1- (-int-)) indx )
	((-idx1- (-int-)) ctot )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) s )
	((-idx0- (-int-)) info )
	#{ dlaed3_(IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($n1,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($rho,double), IDX_PTR($dlamda,double), IDX_PTR($q2,double), IDX_PTR($indx,int), IDX_PTR($ctot,int), IDX_PTR($w,double), IDX_PTR($s,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed4 <n>  <i>  <d>  <z>  <delta>  <rho>  <dlam>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the I-th updated eigenvalue of a symmetric
;;*  rank-one modification to a diagonal matrix whose elements are
;;*  given in the array d, and that
;;*
;;*             D(i) < D(j)  for  i < j
;;*
;;*  and that RHO > 0.  This is arranged by the calling routine, and is
;;*  no loss in generality.  The rank-one modified system is thus
;;*
;;*             diag( D )  +  RHO *  Z * Z_transpose.
;;*
;;*  where we assume the Euclidean norm of Z is 1.
;;*
;;*  The method consists of approximating the rational functions in the
;;*  secular equation by simpler interpolating rational functions.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The length of all arrays.
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  1 <= I <= N.
;;*
;;*  D      (input) DOUBLE PRECISION array, dimension (N)
;;*         The original eigenvalues.  It is assumed that they are in
;;*         order, D(I) < D(J)  for I < J.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension (N)
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) DOUBLE PRECISION array, dimension (N)
;;*         If N .ne. 1, DELTA contains (D(j) - lambda_I) in its  j-th
;;*         component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
;;*         contains the information necessary to construct the
;;*         eigenvectors.
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         The scalar in the symmetric updating formula.
;;*
;;*  DLAM   (output) DOUBLE PRECISION
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit
;;*         > 0:  if INFO = 1, the updating process failed.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  Logical variable ORGATI (origin-at-i?) is used for distinguishing
;;*  whether D(i) or D(i+1) is treated as the origin.
;;*
;;*            ORGATI = .true.    origin at i
;;*            ORGATI = .false.   origin at i+1
;;*
;;*   Logical variable SWTCH3 (switch-for-3-poles?) is for noting
;;*   if we are working with THREE poles!
;;*
;;*   MAXIT is the maximum number of iterations allowed for each
;;*   eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed4 (n  i  d  z  delta  rho  dlam  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) i )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) delta )
	((-idx0- (-double-)) rho )
	((-idx0- (-double-)) dlam )
	((-idx0- (-int-)) info )
	#{ dlaed4_(IDX_PTR($n,int), IDX_PTR($i,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($delta,double), IDX_PTR($rho,double), IDX_PTR($dlam,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed5 <i>  <d>  <z>  <delta>  <rho>  <dlam>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the I-th eigenvalue of a symmetric rank-one
;;*  modification of a 2-by-2 diagonal matrix
;;*
;;*             diag( D )  +  RHO *  Z * transpose(Z) .
;;*
;;*  The diagonal elements in the array D are assumed to satisfy
;;*
;;*             D(i) < D(j)  for  i < j .
;;*
;;*  We also assume RHO > 0 and that the Euclidean norm of the vector
;;*  Z is one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  I = 1 or I = 2.
;;*
;;*  D      (input) DOUBLE PRECISION array, dimension (2)
;;*         The original eigenvalues.  We assume D(1) < D(2).
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension (2)
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) DOUBLE PRECISION array, dimension (2)
;;*         The vector DELTA contains the information necessary
;;*         to construct the eigenvectors.
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         The scalar in the symmetric updating formula.
;;*
;;*  DLAM   (output) DOUBLE PRECISION
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed5 (i  d  z  delta  rho  dlam  )
	((-idx0- (-int-)) i )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) delta )
	((-idx0- (-double-)) rho )
	((-idx0- (-double-)) dlam )
	#{ dlaed5_(IDX_PTR($i,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($delta,double), IDX_PTR($rho,double), IDX_PTR($dlam,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed6 <kniter>  <orgati>  <rho>  <d>  <z>  <finit>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED6 computes the positive or negative root (closest to the origin)
;;*  of
;;*                   z(1)        z(2)        z(3)
;;*  f(x) =   rho + --------- + ---------- + ---------
;;*                  d(1)-x      d(2)-x      d(3)-x
;;*
;;*  It is assumed that
;;*
;;*        if ORGATI = .true. the root is between d(2) and d(3);
;;*        otherwise it is between d(1) and d(2)
;;*
;;*  This routine will be called by DLAED4 when necessary. In most cases,
;;*  the root sought is the smallest in magnitude, though it might not be
;;*  in some extremely rare situations.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  KNITER       (input) INTEGER
;;*               Refer to DLAED4 for its significance.
;;*
;;*  ORGATI       (input) LOGICAL
;;*               If ORGATI is true, the needed root is between d(2) and
;;*               d(3); otherwise it is between d(1) and d(2).  See
;;*               DLAED4 for further details.
;;*
;;*  RHO          (input) DOUBLE PRECISION
;;*               Refer to the equation f(x) above.
;;*
;;*  D            (input) DOUBLE PRECISION array, dimension (3)
;;*               D satisfies d(1) < d(2) < d(3).
;;*
;;*  Z            (input) DOUBLE PRECISION array, dimension (3)
;;*               Each of the elements in z must be positive.
;;*
;;*  FINIT        (input) DOUBLE PRECISION
;;*               The value of f at 0. It is more accurate than the one
;;*               evaluated inside this routine (if someone wants to do
;;*               so).
;;*
;;*  TAU          (output) DOUBLE PRECISION
;;*               The root of the equation f(x).
;;*
;;*  INFO         (output) INTEGER
;;*               = 0: successful exit
;;*               > 0: if INFO = 1, failure to converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed6 (kniter  orgati  rho  d  z  finit  tau  info  )
	((-idx0- (-int-)) kniter )
	((-idx0- (-int-)) orgati )
	((-idx0- (-double-)) rho )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx0- (-double-)) finit )
	((-idx0- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ dlaed6_(IDX_PTR($kniter,int), IDX_PTR($orgati,int), IDX_PTR($rho,double), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($finit,double), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed7 <icompq>  <n>  <qsiz>  <tlvls>  <curlvl>  <curpbm>  <d>  <q>  <ldq>  <indxq>  <rho>  <cutpnt>  <qstore>  <qptr>  <prmptr>  <perm>  <givptr>  <givcol>  <givnum>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED7 computes the updated eigensystem of a diagonal
;;*  matrix after modification by a rank-one symmetric matrix. This
;;*  routine is used only for the eigenproblem which requires all
;;*  eigenvalues and optionally eigenvectors of a dense symmetric matrix
;;*  that has been reduced to tridiagonal form.  DLAED1 handles
;;*  the case in which all eigenvalues and eigenvectors of a symmetric
;;*  tridiagonal matrix are desired.
;;*
;;*    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
;;*
;;*     where Z = Q'u, u is a vector of length N with ones in the
;;*     CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
;;*
;;*     The eigenvectors of the original matrix are stored in Q, and the
;;*     eigenvalues are in D.  The algorithm consists of three stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple eigenvalues or if there is a zero in
;;*        the Z vector.  For each such occurence the dimension of the
;;*        secular equation problem is reduced by one.  This stage is
;;*        performed by the routine DLAED8.
;;*
;;*        The second stage consists of calculating the updated
;;*        eigenvalues. This is done by finding the roots of the secular
;;*        equation via the routine DLAED4 (as called by DLAED9).
;;*        This routine also calculates the eigenvectors of the current
;;*        problem.
;;*
;;*        The final stage consists of computing the updated eigenvectors
;;*        directly using the updated eigenvalues.  The eigenvectors for
;;*        the current problem are multiplied with the eigenvectors from
;;*        the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          = 0:  Compute eigenvalues only.
;;*          = 1:  Compute eigenvectors of original dense symmetric matrix
;;*                also.  On entry, Q contains the orthogonal matrix used
;;*                to reduce the original matrix to tridiagonal form.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the orthogonal matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  TLVLS  (input) INTEGER
;;*         The total number of merging levels in the overall divide and
;;*         conquer tree.
;;*
;;*  CURLVL (input) INTEGER
;;*         The current level in the overall merge routine,
;;*         0 <= CURLVL <= TLVLS.
;;*
;;*  CURPBM (input) INTEGER
;;*         The current problem in the current level in the overall
;;*         merge routine (counting from upper left to lower right).
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, the eigenvalues of the rank-1-perturbed matrix.
;;*         On exit, the eigenvalues of the repaired matrix.
;;*
;;*  Q      (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*         On entry, the eigenvectors of the rank-1-perturbed matrix.
;;*         On exit, the eigenvectors of the repaired tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (output) INTEGER array, dimension (N)
;;*         The permutation which will reintegrate the subproblem just
;;*         solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
;;*         will be in ascending order.
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         The subdiagonal element used to create the rank-1
;;*         modification.
;;*
;;*  CUTPNT (input) INTEGER
;;*         Contains the location of the last eigenvalue in the leading
;;*         sub-matrix.  min(1,N) <= CUTPNT <= N.
;;*
;;*  QSTORE (input/output) DOUBLE PRECISION array, dimension (N**2+1)
;;*         Stores eigenvectors of submatrices encountered during
;;*         divide and conquer, packed together. QPTR points to
;;*         beginning of the submatrices.
;;*
;;*  QPTR   (input/output) INTEGER array, dimension (N+2)
;;*         List of indices pointing to beginning of submatrices stored
;;*         in QSTORE. The submatrices are numbered starting at the
;;*         bottom left of the divide and conquer tree, from left to
;;*         right and bottom to top.
;;*
;;*  PRMPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in PERM a
;;*         level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
;;*         indicates the size of the permutation and also the size of
;;*         the full, non-deflated problem.
;;*
;;*  PERM   (input) INTEGER array, dimension (N lg N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in GIVCOL a
;;*         level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
;;*         indicates the number of Givens rotations.
;;*
;;*  GIVCOL (input) INTEGER array, dimension (2, N lg N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension (2, N lg N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension (3*N+QSIZ*N)
;;*
;;*  IWORK  (workspace) INTEGER array, dimension (4*N)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed7 (icompq  n  qsiz  tlvls  curlvl  curpbm  d  q  ldq  indxq  rho  cutpnt  qstore  qptr  prmptr  perm  givptr  givcol  givnum  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) tlvls )
	((-idx0- (-int-)) curlvl )
	((-idx0- (-int-)) curpbm )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-double-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-double-)) qstore )
	((-idx1- (-int-)) qptr )
	((-idx1- (-int-)) prmptr )
	((-idx1- (-int-)) perm )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-double-)) givnum )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlaed7_(IDX_PTR($icompq,int), IDX_PTR($n,int), IDX_PTR($qsiz,int), IDX_PTR($tlvls,int), IDX_PTR($curlvl,int), IDX_PTR($curpbm,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,double), IDX_PTR($cutpnt,int), IDX_PTR($qstore,double), IDX_PTR($qptr,int), IDX_PTR($prmptr,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed8 <icompq>  <k>  <n>  <qsiz>  <d>  <q>  <ldq>  <indxq>  <rho>  <cutpnt>  <z>  <dlamda>  <q2>  <ldq2>  <w>  <perm>  <givptr>  <givcol>  <givnum>  <indxp>  <indx>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED8 merges the two sets of eigenvalues together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  eigenvalues are close together or if there is a tiny element in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          = 0:  Compute eigenvalues only.
;;*          = 1:  Compute eigenvectors of original dense symmetric matrix
;;*                also.  On entry, Q contains the orthogonal matrix used
;;*                to reduce the original matrix to tridiagonal form.
;;*
;;*  K      (output) INTEGER
;;*         The number of non-deflated eigenvalues, and the order of the
;;*         related secular equation.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the orthogonal matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, the eigenvalues of the two submatrices to be
;;*         combined.  On exit, the trailing (N-K) updated eigenvalues
;;*         (those which were deflated) sorted into increasing order.
;;*
;;*  Q      (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*         If ICOMPQ = 0, Q is not referenced.  Otherwise,
;;*         on entry, Q contains the eigenvectors of the partially solved
;;*         system which has been previously updated in matrix
;;*         multiplies with other partially solved eigensystems.
;;*         On exit, Q contains the trailing (N-K) updated eigenvectors
;;*         (those which were deflated) in its last N-K columns.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  INDXQ  (input) INTEGER array, dimension (N)
;;*         The permutation which separately sorts the two sub-problems
;;*         in D into ascending order.  Note that elements in the second
;;*         half of this permutation must first have CUTPNT added to
;;*         their values in order to be accurate.
;;*
;;*  RHO    (input/output) DOUBLE PRECISION
;;*         On entry, the off-diagonal element associated with the rank-1
;;*         cut which originally split the two submatrices which are now
;;*         being recombined.
;;*         On exit, RHO has been modified to the value required by
;;*         DLAED3.
;;*
;;*  CUTPNT (input) INTEGER
;;*         The location of the last eigenvalue in the leading
;;*         sub-matrix.  min(1,N) <= CUTPNT <= N.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension (N)
;;*         On entry, Z contains the updating vector (the last row of
;;*         the first sub-eigenvector matrix and the first row of the
;;*         second sub-eigenvector matrix).
;;*         On exit, the contents of Z are destroyed by the updating
;;*         process.
;;*
;;*  DLAMDA (output) DOUBLE PRECISION array, dimension (N)
;;*         A copy of the first K eigenvalues which will be used by
;;*         DLAED3 to form the secular equation.
;;*
;;*  Q2     (output) DOUBLE PRECISION array, dimension (LDQ2,N)
;;*         If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
;;*         a copy of the first K eigenvectors which will be used by
;;*         DLAED7 in a matrix multiply (DGEMM) to update the new
;;*         eigenvectors.
;;*
;;*  LDQ2   (input) INTEGER
;;*         The leading dimension of the array Q2.  LDQ2 >= max(1,N).
;;*
;;*  W      (output) DOUBLE PRECISION array, dimension (N)
;;*         The first k values of the final deflation-altered z-vector and
;;*         will be passed to DLAED3.
;;*
;;*  PERM   (output) INTEGER array, dimension (N)
;;*         The permutations (from deflation and sorting) to be applied
;;*         to each eigenblock.
;;*
;;*  GIVPTR (output) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem.
;;*
;;*  GIVCOL (output) INTEGER array, dimension (2, N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (output) DOUBLE PRECISION array, dimension (2, N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  INDXP  (workspace) INTEGER array, dimension (N)
;;*         The permutation used to place deflated values of D at the end
;;*         of the array.  INDXP(1:K) points to the nondeflated D-values
;;*         and INDXP(K+1:N) points to the deflated eigenvalues.
;;*
;;*  INDX   (workspace) INTEGER array, dimension (N)
;;*         The permutation used to sort the contents of D into ascending
;;*         order.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaed8 (icompq  k  n  qsiz  d  q  ldq  indxq  rho  cutpnt  z  dlamda  q2  ldq2  w  perm  givptr  givcol  givnum  indxp  indx  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) qsiz )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) indxq )
	((-idx0- (-double-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) dlamda )
	((-idx2- (-double-)) q2 )
	((-idx0- (-int-)) ldq2 )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-double-)) givnum )
	((-idx1- (-int-)) indxp )
	((-idx1- (-int-)) indx )
	((-idx0- (-int-)) info )
	#{ dlaed8_(IDX_PTR($icompq,int), IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($qsiz,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($indxq,int), IDX_PTR($rho,double), IDX_PTR($cutpnt,int), IDX_PTR($z,double), IDX_PTR($dlamda,double), IDX_PTR($q2,double), IDX_PTR($ldq2,int), IDX_PTR($w,double), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,double), IDX_PTR($indxp,int), IDX_PTR($indx,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaed9 <k>  <kstart>  <kstop>  <n>  <d>  <q>  <ldq>  <rho>  <dlamda>  <w>  <s>  <lds>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAED9 finds the roots of the secular equation, as defined by the
;;*  values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
;;*  appropriate calls to DLAED4 and then stores the new matrix of
;;*  eigenvectors for use in calculating the next level of Z vectors.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved by
;;*          DLAED4.  K >= 0.
;;*
;;*  KSTART  (input) INTEGER
;;*  KSTOP   (input) INTEGER
;;*          The updated eigenvalues Lambda(I), KSTART <= I <= KSTOP
;;*          are to be computed.  1 <= KSTART <= KSTOP <= K.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows and columns in the Q matrix.
;;*          N >= K (delation may result in N > K).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          D(I) contains the updated eigenvalues
;;*          for KSTART <= I <= KSTOP.
;;*
;;*  Q       (workspace) DOUBLE PRECISION array, dimension (LDQ,N)
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max( 1, N ).
;;*
;;*  RHO     (input) DOUBLE PRECISION
;;*          The value of the parameter in the rank one update equation.
;;*          RHO >= 0 required.
;;*
;;*  DLAMDA  (input) DOUBLE PRECISION array, dimension (K)
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation.
;;*
;;*  W       (input) DOUBLE PRECISION array, dimension (K)
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating vector.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (LDS, K)
;;*          Will contain the eigenvectors of the repaired matrix which
;;*          will be stored for subsequent Z vector calculation and
;;*          multiplied by the previously accumulated eigenvectors
;;*          to update the system.
;;*
;;*  LDS     (input) INTEGER
;;*          The leading dimension of S.  LDS >= max( 1, K ).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlaed9 (k  kstart  kstop  n  d  q  ldq  rho  dlamda  w  s  lds  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) kstart )
	((-idx0- (-int-)) kstop )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) rho )
	((-idx1- (-double-)) dlamda )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) s )
	((-idx0- (-int-)) lds )
	((-idx0- (-int-)) info )
	#{ dlaed9_(IDX_PTR($k,int), IDX_PTR($kstart,int), IDX_PTR($kstop,int), IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($rho,double), IDX_PTR($dlamda,double), IDX_PTR($w,double), IDX_PTR($s,double), IDX_PTR($lds,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaeda <n>  <tlvls>  <curlvl>  <curpbm>  <prmptr>  <perm>  <givptr>  <givcol>  <givnum>  <q>  <qptr>  <z>  <ztemp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAEDA computes the Z vector corresponding to the merge step in the
;;*  CURLVLth step of the merge process with TLVLS steps for the CURPBMth
;;*  problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  TLVLS  (input) INTEGER
;;*         The total number of merging levels in the overall divide and
;;*         conquer tree.
;;*
;;*  CURLVL (input) INTEGER
;;*         The current level in the overall merge routine,
;;*         0 <= curlvl <= tlvls.
;;*
;;*  CURPBM (input) INTEGER
;;*         The current problem in the current level in the overall
;;*         merge routine (counting from upper left to lower right).
;;*
;;*  PRMPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in PERM a
;;*         level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
;;*         indicates the size of the permutation and incidentally the
;;*         size of the full, non-deflated problem.
;;*
;;*  PERM   (input) INTEGER array, dimension (N lg N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in GIVCOL a
;;*         level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
;;*         indicates the number of Givens rotations.
;;*
;;*  GIVCOL (input) INTEGER array, dimension (2, N lg N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension (2, N lg N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  Q      (input) DOUBLE PRECISION array, dimension (N**2)
;;*         Contains the square eigenblocks from previous levels, the
;;*         starting positions for blocks are given by QPTR.
;;*
;;*  QPTR   (input) INTEGER array, dimension (N+2)
;;*         Contains a list of pointers which indicate where in Q an
;;*         eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
;;*         the size of the block.
;;*
;;*  Z      (output) DOUBLE PRECISION array, dimension (N)
;;*         On output this vector contains the updating vector (the last
;;*         row of the first sub-eigenvector matrix and the first row of
;;*         the second sub-eigenvector matrix).
;;*
;;*  ZTEMP  (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaeda (n  tlvls  curlvl  curpbm  prmptr  perm  givptr  givcol  givnum  q  qptr  z  ztemp  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) tlvls )
	((-idx0- (-int-)) curlvl )
	((-idx0- (-int-)) curpbm )
	((-idx1- (-int-)) prmptr )
	((-idx1- (-int-)) perm )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-double-)) givnum )
	((-idx1- (-double-)) q )
	((-idx1- (-int-)) qptr )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) ztemp )
	((-idx0- (-int-)) info )
	#{ dlaeda_(IDX_PTR($n,int), IDX_PTR($tlvls,int), IDX_PTR($curlvl,int), IDX_PTR($curpbm,int), IDX_PTR($prmptr,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,double), IDX_PTR($q,double), IDX_PTR($qptr,int), IDX_PTR($z,double), IDX_PTR($ztemp,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaein <rightv>  <noinit>  <n>  <h>  <ldh>  <wr>  <wi>  <vr>  <vi>  <b>  <ldb>  <work>  <eps3>  <smlnum>  <bignum>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAEIN uses inverse iteration to find a right or left eigenvector
;;*  corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
;;*  matrix H.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  RIGHTV   (input) LOGICAL
;;*          = .TRUE. : compute right eigenvector;
;;*          = .FALSE.: compute left eigenvector.
;;*
;;*  NOINIT   (input) LOGICAL
;;*          = .TRUE. : no initial vector supplied in (VR,VI).
;;*          = .FALSE.: initial vector supplied in (VR,VI).
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) DOUBLE PRECISION array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  WR      (input) DOUBLE PRECISION
;;*  WI      (input) DOUBLE PRECISION
;;*          The real and imaginary parts of the eigenvalue of H whose
;;*          corresponding right or left eigenvector is to be computed.
;;*
;;*  VR      (input/output) DOUBLE PRECISION array, dimension (N)
;;*  VI      (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, if NOINIT = .FALSE. and WI = 0.0, VR must contain
;;*          a real starting vector for inverse iteration using the real
;;*          eigenvalue WR; if NOINIT = .FALSE. and WI.ne.0.0, VR and VI
;;*          must contain the real and imaginary parts of a complex
;;*          starting vector for inverse iteration using the complex
;;*          eigenvalue (WR,WI); otherwise VR and VI need not be set.
;;*          On exit, if WI = 0.0 (real eigenvalue), VR contains the
;;*          computed real eigenvector; if WI.ne.0.0 (complex eigenvalue),
;;*          VR and VI contain the real and imaginary parts of the
;;*          computed complex eigenvector. The eigenvector is normalized
;;*          so that the component of largest magnitude has magnitude 1;
;;*          here the magnitude of a complex number (x,y) is taken to be
;;*          |x| + |y|.
;;*          VI is not referenced if WI = 0.0.
;;*
;;*  B       (workspace) DOUBLE PRECISION array, dimension (LDB,N)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= N+1.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  EPS3    (input) DOUBLE PRECISION
;;*          A small machine-dependent value which is used to perturb
;;*          close eigenvalues, and to replace zero pivots.
;;*
;;*  SMLNUM  (input) DOUBLE PRECISION
;;*          A machine-dependent value close to the underflow threshold.
;;*
;;*  BIGNUM  (input) DOUBLE PRECISION
;;*          A machine-dependent value close to the overflow threshold.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          = 1:  inverse iteration did not converge; VR is set to the
;;*                last iterate, and so is VI if WI.ne.0.0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaein (rightv  noinit  n  h  ldh  wr  wi  vr  vi  b  ldb  work  eps3  smlnum  bignum  info  )
	((-idx0- (-int-)) rightv )
	((-idx0- (-int-)) noinit )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx0- (-double-)) wr )
	((-idx0- (-double-)) wi )
	((-idx1- (-double-)) vr )
	((-idx1- (-double-)) vi )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) work )
	((-idx0- (-double-)) eps3 )
	((-idx0- (-double-)) smlnum )
	((-idx0- (-double-)) bignum )
	((-idx0- (-int-)) info )
	#{ dlaein_(IDX_PTR($rightv,int), IDX_PTR($noinit,int), IDX_PTR($n,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($vr,double), IDX_PTR($vi,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($work,double), IDX_PTR($eps3,double), IDX_PTR($smlnum,double), IDX_PTR($bignum,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaev2 <a>  <b>  <c>  <rt1>  <rt2>  <cs1>  <sn1>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
;;*     [  A   B  ]
;;*     [  B   C  ].
;;*  On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
;;*  eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
;;*  eigenvector for RT1, giving the decomposition
;;*
;;*     [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
;;*     [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) DOUBLE PRECISION
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  B       (input) DOUBLE PRECISION
;;*          The (1,2) element and the conjugate of the (2,1) element of
;;*          the 2-by-2 matrix.
;;*
;;*  C       (input) DOUBLE PRECISION
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  RT1     (output) DOUBLE PRECISION
;;*          The eigenvalue of larger absolute value.
;;*
;;*  RT2     (output) DOUBLE PRECISION
;;*          The eigenvalue of smaller absolute value.
;;*
;;*  CS1     (output) DOUBLE PRECISION
;;*  SN1     (output) DOUBLE PRECISION
;;*          The vector (CS1, SN1) is a unit right eigenvector for RT1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  RT1 is accurate to a few ulps barring over/underflow.
;;*
;;*  RT2 may be inaccurate if there is massive cancellation in the
;;*  determinant A*C-B*B; higher precision or correctly rounded or
;;*  correctly truncated arithmetic would be needed to compute RT2
;;*  accurately in all cases.
;;*
;;*  CS1 and SN1 are accurate to a few ulps barring over/underflow.
;;*
;;*  Overflow is possible only if RT1 is within a factor of 5 of overflow.
;;*  Underflow is harmless if the input data is 0 or exceeds
;;*     underflow_threshold / macheps.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaev2 (a  b  c  rt1  rt2  cs1  sn1  )
	((-idx0- (-double-)) a )
	((-idx0- (-double-)) b )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) rt1 )
	((-idx0- (-double-)) rt2 )
	((-idx0- (-double-)) cs1 )
	((-idx0- (-double-)) sn1 )
	#{ dlaev2_(IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($rt1,double), IDX_PTR($rt2,double), IDX_PTR($cs1,double), IDX_PTR($sn1,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaexc <wantq>  <n>  <t_>  <ldt>  <q>  <ldq>  <j1>  <n1>  <n2>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
;;*  an upper quasi-triangular matrix T by an orthogonal similarity
;;*  transformation.
;;*
;;*  T must be in Schur canonical form, that is, block upper triangular
;;*  with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
;;*  has its diagonal elemnts equal and its off-diagonal elements of
;;*  opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          = .TRUE. : accumulate the transformation in the matrix Q;
;;*          = .FALSE.: do not accumulate the transformation.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
;;*          On entry, the upper quasi-triangular matrix T, in Schur
;;*          canonical form.
;;*          On exit, the updated matrix T, again in Schur canonical form.
;;*
;;*  LDT     (input)  INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
;;*          On exit, if WANTQ is .TRUE., the updated matrix Q.
;;*          If WANTQ is .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.
;;*
;;*  J1      (input) INTEGER
;;*          The index of the first row of the first block T11.
;;*
;;*  N1      (input) INTEGER
;;*          The order of the first block T11. N1 = 0, 1 or 2.
;;*
;;*  N2      (input) INTEGER
;;*          The order of the second block T22. N2 = 0, 1 or 2.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          = 1: the transformed matrix T would be too far from Schur
;;*               form; the blocks are not swapped and T and Q are
;;*               unchanged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaexc (wantq  n  t_  ldt  q  ldq  j1  n1  n2  work  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-int-)) j1 )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlaexc_(IDX_PTR($wantq,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($j1,int), IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlag2 <a>  <lda>  <b>  <ldb>  <safmin>  <scale1>  <scale2>  <wr1>  <wr2>  <wi>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue
;;*  problem  A - w B, with scaling as necessary to avoid over-/underflow.
;;*
;;*  The scaling factor "s" results in a modified eigenvalue equation
;;*
;;*      s A - w B
;;*
;;*  where  s  is a non-negative scaling factor chosen so that  w,  w B,
;;*  and  s A  do not overflow and, if possible, do not underflow, either.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA, 2)
;;*          On entry, the 2 x 2 matrix A.  It is assumed that its 1-norm
;;*          is less than 1/SAFMIN.  Entries less than
;;*          sqrt(SAFMIN)*norm(A) are subject to being treated as zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= 2.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB, 2)
;;*          On entry, the 2 x 2 upper triangular matrix B.  It is
;;*          assumed that the one-norm of B is less than 1/SAFMIN.  The
;;*          diagonals should be at least sqrt(SAFMIN) times the largest
;;*          element of B (in absolute value); if a diagonal is smaller
;;*          than that, then  +/- sqrt(SAFMIN) will be used instead of
;;*          that diagonal.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= 2.
;;*
;;*  SAFMIN  (input) DOUBLE PRECISION
;;*          The smallest positive number s.t. 1/SAFMIN does not
;;*          overflow.  (This should always be DLAMCH('S') -- it is an
;;*          argument in order to avoid having to call DLAMCH frequently.)
;;*
;;*  SCALE1  (output) DOUBLE PRECISION
;;*          A scaling factor used to avoid over-/underflow in the
;;*          eigenvalue equation which defines the first eigenvalue.  If
;;*          the eigenvalues are complex, then the eigenvalues are
;;*          ( WR1  +/-  WI i ) / SCALE1  (which may lie outside the
;;*          exponent range of the machine), SCALE1=SCALE2, and SCALE1
;;*          will always be positive.  If the eigenvalues are real, then
;;*          the first (real) eigenvalue is  WR1 / SCALE1 , but this may
;;*          overflow or underflow, and in fact, SCALE1 may be zero or
;;*          less than the underflow threshhold if the exact eigenvalue
;;*          is sufficiently large.
;;*
;;*  SCALE2  (output) DOUBLE PRECISION
;;*          A scaling factor used to avoid over-/underflow in the
;;*          eigenvalue equation which defines the second eigenvalue.  If
;;*          the eigenvalues are complex, then SCALE2=SCALE1.  If the
;;*          eigenvalues are real, then the second (real) eigenvalue is
;;*          WR2 / SCALE2 , but this may overflow or underflow, and in
;;*          fact, SCALE2 may be zero or less than the underflow
;;*          threshhold if the exact eigenvalue is sufficiently large.
;;*
;;*  WR1     (output) DOUBLE PRECISION
;;*          If the eigenvalue is real, then WR1 is SCALE1 times the
;;*          eigenvalue closest to the (2,2) element of A B**(-1).  If the
;;*          eigenvalue is complex, then WR1=WR2 is SCALE1 times the real
;;*          part of the eigenvalues.
;;*
;;*  WR2     (output) DOUBLE PRECISION
;;*          If the eigenvalue is real, then WR2 is SCALE2 times the
;;*          other eigenvalue.  If the eigenvalue is complex, then
;;*          WR1=WR2 is SCALE1 times the real part of the eigenvalues.
;;*
;;*  WI      (output) DOUBLE PRECISION
;;*          If the eigenvalue is real, then WI is zero.  If the
;;*          eigenvalue is complex, then WI is SCALE1 times the imaginary
;;*          part of the eigenvalues.  WI will always be non-negative.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlag2 (a  lda  b  ldb  safmin  scale1  scale2  wr1  wr2  wi  )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) safmin )
	((-idx0- (-double-)) scale1 )
	((-idx0- (-double-)) scale2 )
	((-idx0- (-double-)) wr1 )
	((-idx0- (-double-)) wr2 )
	((-idx0- (-double-)) wi )
	#{ dlag2_(IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($safmin,double), IDX_PTR($scale1,double), IDX_PTR($scale2,double), IDX_PTR($wr1,double), IDX_PTR($wr2,double), IDX_PTR($wi,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlags2 <upper>  <a1>  <a2>  <a3>  <b1>  <b2>  <b3>  <csu>  <snu>  <csv>  <snv>  <csq>  <snq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
;;*  that if ( UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 A2 )*Q = ( x  0  )
;;*                        ( 0  A3 )     ( x  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 B2 )*Q = ( x  0  )
;;*                        ( 0  B3 )     ( x  x  )
;;*
;;*  or if ( .NOT.UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 0  )*Q = ( x  x  )
;;*                        ( A2 A3 )     ( 0  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 0  )*Q = ( x  x  )
;;*                        ( B2 B3 )     ( 0  x  )
;;*
;;*  The rows of the transformed A and B are parallel, where
;;*
;;*    U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
;;*        ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
;;*
;;*  Z' denotes the transpose of Z.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPPER   (input) LOGICAL
;;*          = .TRUE.: the input matrices A and B are upper triangular.
;;*          = .FALSE.: the input matrices A and B are lower triangular.
;;*
;;*  A1      (input) DOUBLE PRECISION
;;*  A2      (input) DOUBLE PRECISION
;;*  A3      (input) DOUBLE PRECISION
;;*          On entry, A1, A2 and A3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix A.
;;*
;;*  B1      (input) DOUBLE PRECISION
;;*  B2      (input) DOUBLE PRECISION
;;*  B3      (input) DOUBLE PRECISION
;;*          On entry, B1, B2 and B3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix B.
;;*
;;*  CSU     (output) DOUBLE PRECISION
;;*  SNU     (output) DOUBLE PRECISION
;;*          The desired orthogonal matrix U.
;;*
;;*  CSV     (output) DOUBLE PRECISION
;;*  SNV     (output) DOUBLE PRECISION
;;*          The desired orthogonal matrix V.
;;*
;;*  CSQ     (output) DOUBLE PRECISION
;;*  SNQ     (output) DOUBLE PRECISION
;;*          The desired orthogonal matrix Q.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlags2 (upper  a1  a2  a3  b1  b2  b3  csu  snu  csv  snv  csq  snq  )
	((-idx0- (-int-)) upper )
	((-idx0- (-double-)) a1 )
	((-idx0- (-double-)) a2 )
	((-idx0- (-double-)) a3 )
	((-idx0- (-double-)) b1 )
	((-idx0- (-double-)) b2 )
	((-idx0- (-double-)) b3 )
	((-idx0- (-double-)) csu )
	((-idx0- (-double-)) snu )
	((-idx0- (-double-)) csv )
	((-idx0- (-double-)) snv )
	((-idx0- (-double-)) csq )
	((-idx0- (-double-)) snq )
	#{ dlags2_(IDX_PTR($upper,int), IDX_PTR($a1,double), IDX_PTR($a2,double), IDX_PTR($a3,double), IDX_PTR($b1,double), IDX_PTR($b2,double), IDX_PTR($b3,double), IDX_PTR($csu,double), IDX_PTR($snu,double), IDX_PTR($csv,double), IDX_PTR($snv,double), IDX_PTR($csq,double), IDX_PTR($snq,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlagtf <n>  <a>  <lambda>  <b>  <c>  <tol>  <d>  <in>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
;;*  tridiagonal matrix and lambda is a scalar, as
;;*
;;*     T - lambda*I = PLU,
;;*
;;*  where P is a permutation matrix, L is a unit lower tridiagonal matrix
;;*  with at most one non-zero sub-diagonal elements per column and U is
;;*  an upper triangular matrix with at most two non-zero super-diagonal
;;*  elements per column.
;;*
;;*  The factorization is obtained by Gaussian elimination with partial
;;*  pivoting and implicit row scaling.
;;*
;;*  The parameter LAMBDA is included in the routine so that DLAGTF may
;;*  be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
;;*  inverse iteration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, A must contain the diagonal elements of T.
;;*
;;*          On exit, A is overwritten by the n diagonal elements of the
;;*          upper triangular matrix U of the factorization of T.
;;*
;;*  LAMBDA  (input) DOUBLE PRECISION
;;*          On entry, the scalar lambda.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, B must contain the (n-1) super-diagonal elements of
;;*          T.
;;*
;;*          On exit, B is overwritten by the (n-1) super-diagonal
;;*          elements of the matrix U of the factorization of T.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, C must contain the (n-1) sub-diagonal elements of
;;*          T.
;;*
;;*          On exit, C is overwritten by the (n-1) sub-diagonal elements
;;*          of the matrix L of the factorization of T.
;;*
;;*  TOL     (input) DOUBLE PRECISION
;;*          On entry, a relative tolerance used to indicate whether or
;;*          not the matrix (T - lambda*I) is nearly singular. TOL should
;;*          normally be chose as approximately the largest relative error
;;*          in the elements of T. For example, if the elements of T are
;;*          correct to about 4 significant figures, then TOL should be
;;*          set to about 5*10**(-4). If TOL is supplied as less than eps,
;;*          where eps is the relative machine precision, then the value
;;*          eps is used in place of TOL.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N-2)
;;*          On exit, D is overwritten by the (n-2) second super-diagonal
;;*          elements of the matrix U of the factorization of T.
;;*
;;*  IN      (output) INTEGER array, dimension (N)
;;*          On exit, IN contains details of the permutation matrix P. If
;;*          an interchange occurred at the kth step of the elimination,
;;*          then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)
;;*          returns the smallest positive integer j such that
;;*
;;*             abs( u(j,j) ).le. norm( (T - lambda*I)(j) )*TOL,
;;*
;;*          where norm( A(j) ) denotes the sum of the absolute values of
;;*          the jth row of the matrix A. If no such j exists then IN(n)
;;*          is returned as zero. If IN(n) is returned as positive, then a
;;*          diagonal element of U is small, indicating that
;;*          (T - lambda*I) is singular or nearly singular,
;;*
;;*  INFO    (output) INTEGER
;;*          = 0   : successful exit
;;*          .lt. 0: if INFO = -k, the kth argument had an illegal value
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlagtf (n  a  lambda  b  c  tol  d  in  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) a )
	((-idx0- (-double-)) lambda )
	((-idx1- (-double-)) b )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) tol )
	((-idx1- (-double-)) d )
	((-idx1- (-int-)) in )
	((-idx0- (-int-)) info )
	#{ dlagtf_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lambda,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($tol,double), IDX_PTR($d,double), IDX_PTR($in,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlagtm <trans>  <n>  <nrhs>  <alpha>  <dl>  <d>  <du>  <x>  <ldx>  <beta>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAGTM performs a matrix-vector product of the form
;;*
;;*     B := alpha * A * X + beta * B
;;*
;;*  where A is a tridiagonal matrix of order N, B and X are N by NRHS
;;*  matrices, and alpha and beta are real scalars, each of which may be
;;*  0., 1., or -1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the operation applied to A.
;;*          = 'N':  No transpose, B := alpha * A * X + beta * B
;;*          = 'T':  Transpose,    B := alpha * A'* X + beta * B
;;*          = 'C':  Conjugate transpose = Transpose
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices X and B.
;;*
;;*  ALPHA   (input) DOUBLE PRECISION
;;*          The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 0.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of T.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of T.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of T.
;;*
;;*  X       (input) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          The N by NRHS matrix X.
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(N,1).
;;*
;;*  BETA    (input) DOUBLE PRECISION
;;*          The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 1.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N by NRHS matrix B.
;;*          On exit, B is overwritten by the matrix expression
;;*          B := alpha * A * X + beta * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(N,1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlagtm (trans  n  nrhs  alpha  dl  d  du  x  ldx  beta  b  ldb  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ dlagtm_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($alpha,double), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($beta,double), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlagts <job>  <n>  <a>  <b>  <c>  <d>  <in>  <y>  <tol>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAGTS may be used to solve one of the systems of equations
;;*
;;*     (T - lambda*I)*x = y   or   (T - lambda*I)'*x = y,
;;*
;;*  where T is an n by n tridiagonal matrix, for x, following the
;;*  factorization of (T - lambda*I) as
;;*
;;*     (T - lambda*I) = P*L*U ,
;;*
;;*  by routine DLAGTF. The choice of equation to be solved is
;;*  controlled by the argument JOB, and in each case there is an option
;;*  to perturb zero or very small diagonal elements of U, this option
;;*  being intended for use in applications such as inverse iteration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) INTEGER
;;*          Specifies the job to be performed by DLAGTS as follows:
;;*          =  1: The equations  (T - lambda*I)x = y  are to be solved,
;;*                but diagonal elements of U are not to be perturbed.
;;*          = -1: The equations  (T - lambda*I)x = y  are to be solved
;;*                and, if overflow would otherwise occur, the diagonal
;;*                elements of U are to be perturbed. See argument TOL
;;*                below.
;;*          =  2: The equations  (T - lambda*I)'x = y  are to be solved,
;;*                but diagonal elements of U are not to be perturbed.
;;*          = -2: The equations  (T - lambda*I)'x = y  are to be solved
;;*                and, if overflow would otherwise occur, the diagonal
;;*                elements of U are to be perturbed. See argument TOL
;;*                below.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (N)
;;*          On entry, A must contain the diagonal elements of U as
;;*          returned from DLAGTF.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, B must contain the first super-diagonal elements of
;;*          U as returned from DLAGTF.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, C must contain the sub-diagonal elements of L as
;;*          returned from DLAGTF.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N-2)
;;*          On entry, D must contain the second super-diagonal elements
;;*          of U as returned from DLAGTF.
;;*
;;*  IN      (input) INTEGER array, dimension (N)
;;*          On entry, IN must contain details of the matrix P as returned
;;*          from DLAGTF.
;;*
;;*  Y       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the right hand side vector y.
;;*          On exit, Y is overwritten by the solution vector x.
;;*
;;*  TOL     (input/output) DOUBLE PRECISION
;;*          On entry, with  JOB .lt. 0, TOL should be the minimum
;;*          perturbation to be made to very small diagonal elements of U.
;;*          TOL should normally be chosen as about eps*norm(U), where eps
;;*          is the relative machine precision, but if TOL is supplied as
;;*          non-positive, then it is reset to eps*max( abs( u(i,j) ) ).
;;*          If  JOB .gt. 0  then TOL is not referenced.
;;*
;;*          On exit, TOL is changed as described above, only if TOL is
;;*          non-positive on entry. Otherwise TOL is unchanged.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0   : successful exit
;;*          .lt. 0: if INFO = -i, the i-th argument had an illegal value
;;*          .gt. 0: overflow would occur when computing the INFO(th)
;;*                  element of the solution vector x. This can only occur
;;*                  when JOB is supplied as positive and either means
;;*                  that a diagonal element of U is very small, or that
;;*                  the elements of the right-hand side vector y are very
;;*                  large.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlagts (job  n  a  b  c  d  in  y  tol  info  )
	((-idx0- (-int-)) job )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) a )
	((-idx1- (-double-)) b )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) d )
	((-idx1- (-int-)) in )
	((-idx1- (-double-)) y )
	((-idx0- (-double-)) tol )
	((-idx0- (-int-)) info )
	#{ dlagts_(IDX_PTR($job,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($d,double), IDX_PTR($in,int), IDX_PTR($y,double), IDX_PTR($tol,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlagv2 <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <csl>  <snl>  <csr>  <snr>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAGV2 computes the Generalized Schur factorization of a real 2-by-2
;;*  matrix pencil (A,B) where B is upper triangular. This routine
;;*  computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
;;*  SNR such that
;;*
;;*  1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
;;*     types), then
;;*
;;*     [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
;;*     [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
;;*
;;*     [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
;;*     [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
;;*
;;*  2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
;;*     then
;;*
;;*     [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
;;*     [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
;;*
;;*     [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
;;*     [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
;;*
;;*     where b11 >= b22 > 0.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, 2)
;;*          On entry, the 2 x 2 matrix A.
;;*          On exit, A is overwritten by the ``A-part'' of the
;;*          generalized Schur form.
;;*
;;*  LDA     (input) INTEGER
;;*          THe leading dimension of the array A.  LDA >= 2.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, 2)
;;*          On entry, the upper triangular 2 x 2 matrix B.
;;*          On exit, B is overwritten by the ``B-part'' of the
;;*          generalized Schur form.
;;*
;;*  LDB     (input) INTEGER
;;*          THe leading dimension of the array B.  LDB >= 2.
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (2)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (2)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (2)
;;*          (ALPHAR(k)+i*ALPHAI(k))/BETA(k) are the eigenvalues of the
;;*          pencil (A,B), k=1,2, i = sqrt(-1).  Note that BETA(k) may
;;*          be zero.
;;*
;;*  CSL     (output) DOUBLE PRECISION
;;*          The cosine of the left rotation matrix.
;;*
;;*  SNL     (output) DOUBLE PRECISION
;;*          The sine of the left rotation matrix.
;;*
;;*  CSR     (output) DOUBLE PRECISION
;;*          The cosine of the right rotation matrix.
;;*
;;*  SNR     (output) DOUBLE PRECISION
;;*          The sine of the right rotation matrix.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlagv2 (a  lda  b  ldb  alphar  alphai  beta  csl  snl  csr  snr  )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx0- (-double-)) csl )
	((-idx0- (-double-)) snl )
	((-idx0- (-double-)) csr )
	((-idx0- (-double-)) snr )
	#{ dlagv2_(IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($csl,double), IDX_PTR($snl,double), IDX_PTR($csr,double), IDX_PTR($snr,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlahqr <wantt>  <wantz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <wr>  <wi>  <iloz>  <ihiz>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAHQR is an auxiliary routine called by DHSEQR to update the
;;*  eigenvalues and Schur decomposition already computed by DHSEQR, by
;;*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTT   (input) LOGICAL
;;*          = .TRUE. : the full Schur form T is required;
;;*          = .FALSE.: only eigenvalues are required.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          = .TRUE. : the matrix of Schur vectors Z is required;
;;*          = .FALSE.: Schur vectors are not required.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper quasi-triangular in
;;*          rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
;;*          ILO = 1). DLAHQR works primarily with the Hessenberg
;;*          submatrix in rows and columns ILO to IHI, but applies
;;*          transformations to all of H if WANTT is .TRUE..
;;*          1 <= ILO <= max(1,IHI); IHI <= N.
;;*
;;*  H       (input/output) DOUBLE PRECISION array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if WANTT is .TRUE., H is upper quasi-triangular in
;;*          rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in
;;*          standard form. If WANTT is .FALSE., the contents of H are
;;*          unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          The real and imaginary parts, respectively, of the computed
;;*          eigenvalues ILO to IHI are stored in the corresponding
;;*          elements of WR and WI. If two eigenvalues are computed as a
;;*          complex conjugate pair, they are stored in consecutive
;;*          elements of WR and WI, say the i-th and (i+1)th, with
;;*          WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
;;*          eigenvalues are stored in the same order as on the diagonal
;;*          of the Schur form returned in H, with WR(i) = H(i,i), and, if
;;*          H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
;;*          WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
;;*
;;*  ILOZ    (input) INTEGER
;;*  IHIZ    (input) INTEGER
;;*          Specify the rows of Z to which transformations must be
;;*          applied if WANTZ is .TRUE..
;;*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          If WANTZ is .TRUE., on entry Z must contain the current
;;*          matrix Z of transformations accumulated by DHSEQR, and on
;;*          exit Z has been updated; transformations are applied only to
;;*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
;;*          If WANTZ is .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: DLAHQR failed to compute all the eigenvalues ILO to IHI
;;*               in a total of 30*(IHI-ILO+1) iterations; if INFO = i,
;;*               elements i+1:ihi of WR and WI contain those eigenvalues
;;*               which have been successfully computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  2-96 Based on modifications by
;;*     David Day, Sandia National Laboratory, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlahqr (wantt  wantz  n  ilo  ihi  h  ldh  wr  wi  iloz  ihiz  z  ldz  info  )
	((-idx0- (-int-)) wantt )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx0- (-int-)) iloz )
	((-idx0- (-int-)) ihiz )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ dlahqr_(IDX_PTR($wantt,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($iloz,int), IDX_PTR($ihiz,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlahrd <n>  <k>  <nb>  <a>  <lda>  <tau>  <t_>  <ldt>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAHRD reduces the first NB columns of a real general n-by-(n-k+1)
;;*  matrix A so that elements below the k-th subdiagonal are zero. The
;;*  reduction is performed by an orthogonal similarity transformation
;;*  Q' * A * Q. The routine returns the matrices V and T which determine
;;*  Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
;;*
;;*  This is an auxiliary routine called by DGEHRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  K       (input) INTEGER
;;*          The offset for the reduction. Elements below the k-th
;;*          subdiagonal in the first NB columns are reduced to zero.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to be reduced.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N-K+1)
;;*          On entry, the n-by-(n-k+1) general matrix A.
;;*          On exit, the elements on and above the k-th subdiagonal in
;;*          the first NB columns are overwritten with the corresponding
;;*          elements of the reduced matrix; the elements below the k-th
;;*          subdiagonal, with the array TAU, represent the matrix Q as a
;;*          product of elementary reflectors. The other columns of A are
;;*          unchanged. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (NB)
;;*          The scalar factors of the elementary reflectors. See Further
;;*          Details.
;;*
;;*  T       (output) DOUBLE PRECISION array, dimension (LDT,NB)
;;*          The upper triangular matrix T.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T.  LDT >= NB.
;;*
;;*  Y       (output) DOUBLE PRECISION array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y.
;;*
;;*  LDY     (input) INTEGER
;;*          The leading dimension of the array Y. LDY >= N.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of nb elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
;;*  A(i+k+1:n,i), and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the (n-k+1)-by-nb matrix
;;*  V which is needed, with T and Y, to apply the transformation to the
;;*  unreduced part of the matrix, using an update of the form:
;;*  A := (I - V*T*V') * (A - Y*V').
;;*
;;*  The contents of A on exit are illustrated by the following example
;;*  with n = 7, k = 3 and nb = 2:
;;*
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( h   h   a   a   a )
;;*     ( v1  h   a   a   a )
;;*     ( v1  v2  a   a   a )
;;*     ( v1  v2  a   a   a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlahrd (n  k  nb  a  lda  tau  t_  ldt  y  ldy  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) nb )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) ldy )
	#{ dlahrd_(IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($nb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($y,double), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaic1 <job>  <j>  <x>  <sest>  <w>  <gamma>  <sestpr>  <s>  <c>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAIC1 applies one step of incremental condition estimation in
;;*  its simplest version:
;;*
;;*  Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
;;*  lower triangular matrix L, such that
;;*           twonorm(L*x) = sest
;;*  Then DLAIC1 computes sestpr, s, c such that
;;*  the vector
;;*                  [ s*x ]
;;*           xhat = [  c  ]
;;*  is an approximate singular vector of
;;*                  [ L     0  ]
;;*           Lhat = [ w' gamma ]
;;*  in the sense that
;;*           twonorm(Lhat*xhat) = sestpr.
;;*
;;*  Depending on JOB, an estimate for the largest or smallest singular
;;*  value is computed.
;;*
;;*  Note that [s c]' and sestpr**2 is an eigenpair of the system
;;*
;;*      diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
;;*                                            [ gamma ]
;;*
;;*  where  alpha =  x'*w.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) INTEGER
;;*          = 1: an estimate for the largest singular value is computed.
;;*          = 2: an estimate for the smallest singular value is computed.
;;*
;;*  J       (input) INTEGER
;;*          Length of X and W
;;*
;;*  X       (input) DOUBLE PRECISION array, dimension (J)
;;*          The j-vector x.
;;*
;;*  SEST    (input) DOUBLE PRECISION
;;*          Estimated singular value of j by j matrix L
;;*
;;*  W       (input) DOUBLE PRECISION array, dimension (J)
;;*          The j-vector w.
;;*
;;*  GAMMA   (input) DOUBLE PRECISION
;;*          The diagonal element gamma.
;;*
;;*  SEDTPR  (output) DOUBLE PRECISION
;;*          Estimated singular value of (j+1) by (j+1) matrix Lhat.
;;*
;;*  S       (output) DOUBLE PRECISION
;;*          Sine needed in forming xhat.
;;*
;;*  C       (output) DOUBLE PRECISION
;;*          Cosine needed in forming xhat.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaic1 (job  j  x  sest  w  gamma  sestpr  s  c  )
	((-idx0- (-int-)) job )
	((-idx0- (-int-)) j )
	((-idx1- (-double-)) x )
	((-idx0- (-double-)) sest )
	((-idx1- (-double-)) w )
	((-idx0- (-double-)) gamma )
	((-idx0- (-double-)) sestpr )
	((-idx0- (-double-)) s )
	((-idx0- (-double-)) c )
	#{ dlaic1_(IDX_PTR($job,int), IDX_PTR($j,int), IDX_PTR($x,double), IDX_PTR($sest,double), IDX_PTR($w,double), IDX_PTR($gamma,double), IDX_PTR($sestpr,double), IDX_PTR($s,double), IDX_PTR($c,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaln2 <ltrans>  <na>  <nw>  <smin>  <ca>  <a>  <lda>  <d1>  <d2>  <b>  <ldb>  <wr>  <wi>  <x>  <ldx>  <scale>  <xnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLALN2 solves a system of the form  (ca A - w D ) X = s B
;;*  or (ca A' - w D) X = s B   with possible scaling ("s") and
;;*  perturbation of A.  (A' means A-transpose.)
;;*
;;*  A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
;;*  real diagonal matrix, w is a real or complex value, and X and B are
;;*  NA x 1 matrices -- real if w is real, complex if w is complex.  NA
;;*  may be 1 or 2.
;;*
;;*  If w is complex, X and B are represented as NA x 2 matrices,
;;*  the first column of each being the real part and the second
;;*  being the imaginary part.
;;*
;;*  "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
;;*  so chosen that X can be computed without overflow.  X is further
;;*  scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
;;*  than overflow.
;;*
;;*  If both singular values of (ca A - w D) are less than SMIN,
;;*  SMIN*identity will be used instead of (ca A - w D).  If only one
;;*  singular value is less than SMIN, one element of (ca A - w D) will be
;;*  perturbed enough to make the smallest singular value roughly SMIN.
;;*  If both singular values are at least SMIN, (ca A - w D) will not be
;;*  perturbed.  In any case, the perturbation will be at most some small
;;*  multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
;;*  are computed by infinity-norm approximations, and thus will only be
;;*  correct to a factor of 2 or so.
;;*
;;*  Note: all input quantities are assumed to be smaller than overflow
;;*  by a reasonable factor.  (See BIGNUM.)
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  LTRANS  (input) LOGICAL
;;*          =.TRUE.:  A-transpose will be used.
;;*          =.FALSE.: A will be used (not transposed.)
;;*
;;*  NA      (input) INTEGER
;;*          The size of the matrix A.  It may (only) be 1 or 2.
;;*
;;*  NW      (input) INTEGER
;;*          1 if "w" is real, 2 if "w" is complex.  It may only be 1
;;*          or 2.
;;*
;;*  SMIN    (input) DOUBLE PRECISION
;;*          The desired lower bound on the singular values of A.  This
;;*          should be a safe distance away from underflow or overflow,
;;*          say, between (underflow/machine precision) and  (machine
;;*          precision * overflow ).  (See BIGNUM and ULP.)
;;*
;;*  CA      (input) DOUBLE PRECISION
;;*          The coefficient c, which A is multiplied by.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,NA)
;;*          The NA x NA matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  It must be at least NA.
;;*
;;*  D1      (input) DOUBLE PRECISION
;;*          The 1,1 element in the diagonal matrix D.
;;*
;;*  D2      (input) DOUBLE PRECISION
;;*          The 2,2 element in the diagonal matrix D.  Not used if NW=1.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NW)
;;*          The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
;;*          complex), column 1 contains the real part of B and column 2
;;*          contains the imaginary part.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  It must be at least NA.
;;*
;;*  WR      (input) DOUBLE PRECISION
;;*          The real part of the scalar "w".
;;*
;;*  WI      (input) DOUBLE PRECISION
;;*          The imaginary part of the scalar "w".  Not used if NW=1.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NW)
;;*          The NA x NW matrix X (unknowns), as computed by DLALN2.
;;*          If NW=2 ("w" is complex), on exit, column 1 will contain
;;*          the real part of X and column 2 will contain the imaginary
;;*          part.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of X.  It must be at least NA.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scale factor that B must be multiplied by to insure
;;*          that overflow does not occur when computing X.  Thus,
;;*          (ca A - w D) X  will be SCALE*B, not B (ignoring
;;*          perturbations of A.)  It will be at most 1.
;;*
;;*  XNORM   (output) DOUBLE PRECISION
;;*          The infinity-norm of X, when X is regarded as an NA x NW
;;*          real matrix.
;;*
;;*  INFO    (output) INTEGER
;;*          An error flag.  It will be set to zero if no error occurs,
;;*          a negative number if an argument is in error, or a positive
;;*          number if  ca A - w D  had to be perturbed.
;;*          The possible values are:
;;*          = 0: No error occurred, and (ca A - w D) did not have to be
;;*                 perturbed.
;;*          = 1: (ca A - w D) had to be perturbed to make its smallest
;;*               (or only) singular value greater than SMIN.
;;*          NOTE: In the interests of speed, this routine does not
;;*                check the inputs for errors.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaln2 (ltrans  na  nw  smin  ca  a  lda  d1  d2  b  ldb  wr  wi  x  ldx  scale  xnorm  info  )
	((-idx0- (-int-)) ltrans )
	((-idx0- (-int-)) na )
	((-idx0- (-int-)) nw )
	((-idx0- (-double-)) smin )
	((-idx0- (-double-)) ca )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) d1 )
	((-idx0- (-double-)) d2 )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) wr )
	((-idx0- (-double-)) wi )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) xnorm )
	((-idx0- (-int-)) info )
	#{ dlaln2_(IDX_PTR($ltrans,int), IDX_PTR($na,int), IDX_PTR($nw,int), IDX_PTR($smin,double), IDX_PTR($ca,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d1,double), IDX_PTR($d2,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($scale,double), IDX_PTR($xnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlals0 <icompq>  <nl>  <nr>  <sqre>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <poles>  <difl>  <difr>  <z>  <k>  <c>  <s>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLALS0 applies back the multiplying factors of either the left or the
;;*  right singular vector matrix of a diagonal matrix appended by a row
;;*  to the right hand side matrix B in solving the least squares problem
;;*  using the divide-and-conquer SVD approach.
;;*
;;*  For the left singular vector matrix, three types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1L) Givens rotations: the number of such rotations is GIVPTR; the
;;*       pairs of columns/rows they were applied to are stored in GIVCOL;
;;*       and the C- and S-values of these rotations are stored in GIVNUM.
;;*
;;*  (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
;;*       row, and for J=2:N, PERM(J)-th row of B is to be moved to the
;;*       J-th row.
;;*
;;*  (3L) The left singular vector matrix of the remaining matrix.
;;*
;;*  For the right singular vector matrix, four types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1R) The right singular vector matrix of the remaining matrix.
;;*
;;*  (2R) If SQRE = 1, one extra Givens rotation to generate the right
;;*       null space.
;;*
;;*  (3R) The inverse transformation of (2L).
;;*
;;*  (4R) The inverse transformation of (1L).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed in
;;*         factored form:
;;*         = 0: Left singular vector matrix.
;;*         = 1: Right singular vector matrix.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block. NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block. NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input/output) DOUBLE PRECISION array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B. LDB must be at least
;;*         max(1,MAX( M, N ) ).
;;*
;;*  BX     (workspace) DOUBLE PRECISION array, dimension ( LDBX, NRHS )
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  PERM   (input) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) applied
;;*         to the two blocks.
;;*
;;*  GIVPTR (input) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of rows/columns
;;*         involved in a Givens rotation.
;;*
;;*  LDGCOL (input) INTEGER
;;*         The leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value used in the
;;*         corresponding Givens rotation.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of arrays DIFR, POLES and
;;*         GIVNUM, must be at least K.
;;*
;;*  POLES  (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         On entry, POLES(1:K, 1) contains the new singular
;;*         values obtained from solving the secular equation, and
;;*         POLES(1:K, 2) is an array containing the poles in the secular
;;*         equation.
;;*
;;*  DIFL   (input) DOUBLE PRECISION array, dimension ( K ).
;;*         On entry, DIFL(I) is the distance between I-th updated
;;*         (undeflated) singular value and the I-th (undeflated) old
;;*         singular value.
;;*
;;*  DIFR   (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 ).
;;*         On entry, DIFR(I, 1) contains the distances between I-th
;;*         updated (undeflated) singular value and the I+1-th
;;*         (undeflated) old singular value. And DIFR(I, 2) is the
;;*         normalizing factor for the I-th right singular vector.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( K )
;;*         Contain the components of the deflation-adjusted updating row
;;*         vector.
;;*
;;*  K      (input) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  C      (input) DOUBLE PRECISION
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (input) DOUBLE PRECISION
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension ( K )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlals0 (icompq  nl  nr  sqre  nrhs  b  ldb  bx  ldbx  perm  givptr  givcol  ldgcol  givnum  ldgnum  poles  difl  difr  z  k  c  s  work  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-double-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx2- (-double-)) poles )
	((-idx1- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) s )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlals0_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($nrhs,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($bx,double), IDX_PTR($ldbx,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,double), IDX_PTR($ldgnum,int), IDX_PTR($poles,double), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($z,double), IDX_PTR($k,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlalsa <icompq>  <smlsiz>  <n>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <u>  <ldu>  <vt>  <k>  <difl>  <difr>  <z>  <poles>  <givptr>  <givcol>  <ldgcol>  <perm>  <givnum>  <c>  <s>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLALSA is an itermediate step in solving the least squares problem
;;*  by computing the SVD of the coefficient matrix in compact form (The
;;*  singular vectors are computed as products of simple orthorgonal
;;*  matrices.).
;;*
;;*  If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector
;;*  matrix of an upper bidiagonal matrix to the right hand side; and if
;;*  ICOMPQ = 1, DLALSA applies the right singular vector matrix to the
;;*  right hand side. The singular vector matrices were generated in
;;*  compact form by DLALSA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether the left or the right singular vector
;;*         matrix is involved.
;;*         = 0: Left singular vector matrix
;;*         = 1: Right singular vector matrix
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The row and column dimensions of the upper bidiagonal matrix.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input) DOUBLE PRECISION array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,MAX( M, N ) ).
;;*
;;*  BX     (output) DOUBLE PRECISION array, dimension ( LDBX, NRHS )
;;*         On exit, the result of applying the left or right singular
;;*         vector matrix to B.
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  U      (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
;;*         On entry, U contains the left singular vector matrices of all
;;*         subproblems at the bottom level.
;;*
;;*  LDU    (input) INTEGER, LDU = > N.
;;*         The leading dimension of arrays U, VT, DIFL, DIFR,
;;*         POLES, GIVNUM, and Z.
;;*
;;*  VT     (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
;;*         On entry, VT' contains the right singular vector matrices of
;;*         all subproblems at the bottom level.
;;*
;;*  K      (input) INTEGER array, dimension ( N ).
;;*
;;*  DIFL   (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
;;*         where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.
;;*
;;*  DIFR   (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
;;*         distances between singular values on the I-th level and
;;*         singular values on the (I -1)-th level, and DIFR(*, 2 * I)
;;*         record the normalizing factors of the right singular vectors
;;*         matrices of subproblems on I-th level.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
;;*         On entry, Z(1, I) contains the components of the deflation-
;;*         adjusted updating row vector for subproblems on the I-th
;;*         level.
;;*
;;*  POLES  (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
;;*         singular values involved in the secular equations on the I-th
;;*         level.
;;*
;;*  GIVPTR (input) INTEGER array, dimension ( N ).
;;*         On entry, GIVPTR( I ) records the number of Givens
;;*         rotations performed on the I-th problem on the computation
;;*         tree.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
;;*         On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
;;*         locations of Givens rotations performed on the I-th level on
;;*         the computation tree.
;;*
;;*  LDGCOL (input) INTEGER, LDGCOL = > N.
;;*         The leading dimension of arrays GIVCOL and PERM.
;;*
;;*  PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
;;*         On entry, PERM(*, I) records permutations done on the I-th
;;*         level of the computation tree.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
;;*         values of Givens rotations performed on the I-th level on the
;;*         computation tree.
;;*
;;*  C      (input) DOUBLE PRECISION array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         C( I ) contains the C-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  S      (input) DOUBLE PRECISION array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         S( I ) contains the S-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array.
;;*         The dimension must be at least N.
;;*
;;*  IWORK  (workspace) INTEGER array.
;;*         The dimension must be at least 3 * N
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlalsa (icompq  smlsiz  n  nrhs  b  ldb  bx  ldbx  u  ldu  vt  k  difl  difr  z  poles  givptr  givcol  ldgcol  perm  givnum  c  s  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx1- (-int-)) k )
	((-idx2- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx2- (-double-)) z )
	((-idx2- (-double-)) poles )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-int-)) perm )
	((-idx2- (-double-)) givnum )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlalsa_(IDX_PTR($icompq,int), IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($bx,double), IDX_PTR($ldbx,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($k,int), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($z,double), IDX_PTR($poles,double), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($perm,int), IDX_PTR($givnum,double), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlalsd <uplo>  <smlsiz>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <rcond>  <rank>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLALSD uses the singular value decomposition of A to solve the least
;;*  squares problem of finding X to minimize the Euclidean norm of each
;;*  column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
;;*  are N-by-NRHS. The solution X overwrites B.
;;*
;;*  The singular values of A smaller than RCOND times the largest
;;*  singular value are treated as zero in solving the least squares
;;*  problem; in this case a minimum norm solution is returned.
;;*  The actual singular values are returned in D in ascending order.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO   (input) CHARACTER*1
;;*         = 'U': D and E define an upper bidiagonal matrix.
;;*         = 'L': D and E define a  lower bidiagonal matrix.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the  bidiagonal matrix.  N >= 0.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B. NRHS must be at least 1.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix. On exit, if INFO = 0, D contains its singular values.
;;*
;;*  E      (input) DOUBLE PRECISION array, dimension (N-1)
;;*         Contains the super-diagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  B      (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*         On input, B contains the right hand sides of the least
;;*         squares problem. On output, B contains the solution X.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,N).
;;*
;;*  RCOND  (input) DOUBLE PRECISION
;;*         The singular values of A less than or equal to RCOND times
;;*         the largest singular value are treated as zero in solving
;;*         the least squares problem. If RCOND is negative,
;;*         machine precision is used instead.
;;*         For example, if diag(S)*X=B were the least squares problem,
;;*         where diag(S) is a diagonal matrix of singular values, the
;;*         solution would be X(i) = B(i) / S(i) if S(i) is greater than
;;*         RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
;;*         RCOND*max(S).
;;*
;;*  RANK   (output) INTEGER
;;*         The number of singular values of A greater than RCOND times
;;*         the largest singular value.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension at least
;;*         (9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2),
;;*         where NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1).
;;*
;;*  IWORK  (workspace) INTEGER array, dimension at least
;;*         (3*N*NLVL + 11*N)
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*         > 0:  The algorithm failed to compute an singular value while
;;*               working on the submatrix lying in rows and columns
;;*               INFO/(N+1) through MOD(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlalsd (uplo  smlsiz  n  nrhs  d  e  b  ldb  rcond  rank  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlalsd_($uplo->data, IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlamch <cmach>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAMCH determines double precision machine parameters.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  CMACH   (input) CHARACTER*1
;;*          Specifies the value to be returned by DLAMCH:
;;*          = 'E' or 'e',   DLAMCH := eps
;;*          = 'S' or 's ,   DLAMCH := sfmin
;;*          = 'B' or 'b',   DLAMCH := base
;;*          = 'P' or 'p',   DLAMCH := eps*base
;;*          = 'N' or 'n',   DLAMCH := t
;;*          = 'R' or 'r',   DLAMCH := rnd
;;*          = 'M' or 'm',   DLAMCH := emin
;;*          = 'U' or 'u',   DLAMCH := rmin
;;*          = 'L' or 'l',   DLAMCH := emax
;;*          = 'O' or 'o',   DLAMCH := rmax
;;*
;;*          where
;;*
;;*          eps   = relative machine precision
;;*          sfmin = safe minimum, such that 1/sfmin does not overflow
;;*          base  = base of the machine
;;*          prec  = eps*base
;;*          t     = number of (base) digits in the mantissa
;;*          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
;;*          emin  = minimum exponent before (gradual) underflow
;;*          rmin  = underflow threshold - base**(emin-1)
;;*          emax  = largest exponent before overflow
;;*          rmax  = overflow threshold  - (base**emax)*(1-eps)
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlamch (cmach  )
	((-str-) cmach )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlamch_($cmach->data) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlamrg <n1>  <n2>  <a>  <dtrd1>  <dtrd2>  <index>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAMRG will create a permutation list which will merge the elements
;;*  of A (which is composed of two independently sorted sets) into a
;;*  single set which is sorted in ascending order.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N1     (input) INTEGER
;;*  N2     (input) INTEGER
;;*         These arguements contain the respective lengths of the two
;;*         sorted lists to be merged.
;;*
;;*  A      (input) DOUBLE PRECISION array, dimension (N1+N2)
;;*         The first N1 elements of A contain a list of numbers which
;;*         are sorted in either ascending or descending order.  Likewise
;;*         for the final N2 elements.
;;*
;;*  DTRD1  (input) INTEGER
;;*  DTRD2  (input) INTEGER
;;*         These are the strides to be taken through the array A.
;;*         Allowable strides are 1 and -1.  They indicate whether a
;;*         subset of A is sorted in ascending (DTRDx = 1) or descending
;;*         (DTRDx = -1) order.
;;*
;;*  INDEX  (output) INTEGER array, dimension (N1+N2)
;;*         On exit this array will contain a permutation such that
;;*         if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
;;*         sorted in ascending order.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlamrg (n1  n2  a  dtrd1  dtrd2  index  )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx1- (-double-)) a )
	((-idx0- (-int-)) dtrd1 )
	((-idx0- (-int-)) dtrd2 )
	((-idx1- (-int-)) index )
	#{ dlamrg_(IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($a,double), IDX_PTR($dtrd1,int), IDX_PTR($dtrd2,int), IDX_PTR($index,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlangb <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANGB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANGB returns the value
;;*
;;*     DLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANGB as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANGB is
;;*          set to zero.
;;*
;;*  KL      (input) INTEGER
;;*          The number of sub-diagonals of the matrix A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of super-diagonals of the matrix A.  KU >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlangb (norm  n  kl  ku  ab  ldab  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlangb_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlange <norm>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANGE  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANGE returns the value
;;*
;;*     DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANGE as described
;;*          above.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.  When M = 0,
;;*          DLANGE is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.  When N = 0,
;;*          DLANGE is set to zero.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The m by n matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlange (norm  m  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlange_($norm->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlangt <norm>  <n>  <dl>  <d>  <du>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANGT  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANGT returns the value
;;*
;;*     DLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANGT as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANGT is
;;*          set to zero.
;;*
;;*  DL      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of A.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlangt (norm  n  dl  d  du  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dl )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) du )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlangt_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlanhs <norm>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANHS  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  Hessenberg matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANHS returns the value
;;*
;;*     DLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANHS as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANHS is
;;*          set to zero.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The n by n upper Hessenberg matrix A; the part of A below the
;;*          first sub-diagonal is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlanhs (norm  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlanhs_($norm->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlansb <norm>  <uplo>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANSB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n symmetric band matrix A,  with k super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANSB returns the value
;;*
;;*     DLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANSB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          band matrix A is supplied.
;;*          = 'U':  Upper triangular part is supplied
;;*          = 'L':  Lower triangular part is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANSB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals or sub-diagonals of the
;;*          band matrix A.  K >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first K+1 rows of AB.  The j-th column of A is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlansb (norm  uplo  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlansb_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlansp <norm>  <uplo>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANSP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real symmetric matrix A,  supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANSP returns the value
;;*
;;*     DLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANSP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is supplied.
;;*          = 'U':  Upper triangular part of A is supplied
;;*          = 'L':  Lower triangular part of A is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANSP is
;;*          set to zero.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlansp (norm  uplo  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlansp_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlanst <norm>  <n>  <d>  <e>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANST  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real symmetric tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANST returns the value
;;*
;;*     DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANST as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANST is
;;*          set to zero.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) sub-diagonal or super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlanst (norm  n  d  e  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlanst_($norm->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlansy <norm>  <uplo>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANSY  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  real symmetric matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANSY returns the value
;;*
;;*     DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANSY as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is to be referenced.
;;*          = 'U':  Upper triangular part of A is referenced
;;*          = 'L':  Lower triangular part of A is referenced
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANSY is
;;*          set to zero.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlansy (norm  uplo  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlansy_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlantb <norm>  <uplo>  <diag>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANTB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n triangular band matrix A,  with ( k + 1 ) diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANTB returns the value
;;*
;;*     DLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANTB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANTB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals of the matrix A if UPLO = 'L'.
;;*          K >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first k+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*          Note that when DIAG = 'U', the elements of the array AB
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlantb (norm  uplo  diag  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlantb_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlantp <norm>  <uplo>  <diag>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANTP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  triangular matrix A, supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANTP returns the value
;;*
;;*     DLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANTP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, DLANTP is
;;*          set to zero.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          Note that when DIAG = 'U', the elements of the array AP
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlantp (norm  uplo  diag  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlantp_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlantr <norm>  <uplo>  <diag>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANTR  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  trapezoidal or triangular matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  DLANTR returns the value
;;*
;;*     DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in DLANTR as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower trapezoidal.
;;*          = 'U':  Upper trapezoidal
;;*          = 'L':  Lower trapezoidal
;;*          Note that A is triangular instead of trapezoidal if M = N.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A has unit diagonal.
;;*          = 'N':  Non-unit diagonal
;;*          = 'U':  Unit diagonal
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0, and if
;;*          UPLO = 'U', M <= N.  When M = 0, DLANTR is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0, and if
;;*          UPLO = 'L', N <= M.  When N = 0, DLANTR is set to zero.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The trapezoidal matrix A (A is triangular if M = N).
;;*          If UPLO = 'U', the leading m by n upper trapezoidal part of
;;*          the array A contains the upper trapezoidal matrix, and the
;;*          strictly lower triangular part of A is not referenced.
;;*          If UPLO = 'L', the leading m by n lower trapezoidal part of
;;*          the array A contains the lower trapezoidal matrix, and the
;;*          strictly upper triangular part of A is not referenced.  Note
;;*          that when DIAG = 'U', the diagonal elements of A are not
;;*          referenced and are assumed to be one.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlantr (norm  uplo  diag  m  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlantr_($norm->data, $uplo->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlanv2 <a>  <b>  <c>  <d>  <rt1r>  <rt1i>  <rt2r>  <rt2i>  <cs>  <sn>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
;;*  matrix in standard form:
;;*
;;*       [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
;;*       [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
;;*
;;*  where either
;;*  1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
;;*  2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
;;*  conjugate eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input/output) DOUBLE PRECISION
;;*  B       (input/output) DOUBLE PRECISION
;;*  C       (input/output) DOUBLE PRECISION
;;*  D       (input/output) DOUBLE PRECISION
;;*          On entry, the elements of the input matrix.
;;*          On exit, they are overwritten by the elements of the
;;*          standardised Schur form.
;;*
;;*  RT1R    (output) DOUBLE PRECISION
;;*  RT1I    (output) DOUBLE PRECISION
;;*  RT2R    (output) DOUBLE PRECISION
;;*  RT2I    (output) DOUBLE PRECISION
;;*          The real and imaginary parts of the eigenvalues. If the
;;*          eigenvalues are a complex conjugate pair, RT1I > 0.
;;*
;;*  CS      (output) DOUBLE PRECISION
;;*  SN      (output) DOUBLE PRECISION
;;*          Parameters of the rotation matrix.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by V. Sima, Research Institute for Informatics, Bucharest,
;;*  Romania, to reduce the risk of cancellation errors,
;;*  when computing real eigenvalues, and to ensure, if possible, that
;;*  abs(RT1R) >= abs(RT2R).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlanv2 (a  b  c  d  rt1r  rt1i  rt2r  rt2i  cs  sn  )
	((-idx0- (-double-)) a )
	((-idx0- (-double-)) b )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) d )
	((-idx0- (-double-)) rt1r )
	((-idx0- (-double-)) rt1i )
	((-idx0- (-double-)) rt2r )
	((-idx0- (-double-)) rt2i )
	((-idx0- (-double-)) cs )
	((-idx0- (-double-)) sn )
	#{ dlanv2_(IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($d,double), IDX_PTR($rt1r,double), IDX_PTR($rt1i,double), IDX_PTR($rt2r,double), IDX_PTR($rt2i,double), IDX_PTR($cs,double), IDX_PTR($sn,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlapll <n>  <x>  <incx>  <y>  <incy>  <ssmin>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given two column vectors X and Y, let
;;*
;;*                       A = ( X Y ).
;;*
;;*  The subroutine first computes the QR factorization of A = Q*R,
;;*  and then computes the SVD of the 2-by-2 upper triangular matrix R.
;;*  The smaller singular value of R is returned in SSMIN, which is used
;;*  as the measurement of the linear dependency of the vectors X and Y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The length of the vectors X and Y.
;;*
;;*  X       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCX)
;;*          On entry, X contains the N-vector X.
;;*          On exit, X is overwritten.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive elements of X. INCX > 0.
;;*
;;*  Y       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCY)
;;*          On entry, Y contains the N-vector Y.
;;*          On exit, Y is overwritten.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive elements of Y. INCY > 0.
;;*
;;*  SSMIN   (output) DOUBLE PRECISION
;;*          The smallest singular value of the N-by-2 matrix A = ( X Y ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlapll (n  x  incx  y  incy  ssmin  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx0- (-double-)) ssmin )
	#{ dlapll_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($ssmin,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlapmt <forwrd>  <m>  <n>  <x>  <ldx>  <k>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAPMT rearranges the columns of the M by N matrix X as specified
;;*  by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
;;*  If FORWRD = .TRUE.,  forward permutation:
;;*
;;*       X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
;;*
;;*  If FORWRD = .FALSE., backward permutation:
;;*
;;*       X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FORWRD  (input) LOGICAL
;;*          = .TRUE., forward permutation
;;*          = .FALSE., backward permutation
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix X. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix X. N >= 0.
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,N)
;;*          On entry, the M by N matrix X.
;;*          On exit, X contains the permuted matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X, LDX >= MAX(1,M).
;;*
;;*  K       (input) INTEGER array, dimension (N)
;;*          On entry, K contains the permutation vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlapmt (forwrd  m  n  x  ldx  k  )
	((-idx0- (-int-)) forwrd )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-int-)) k )
	#{ dlapmt_(IDX_PTR($forwrd,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($k,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlapy2 <x>  <y>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
;;*  overflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  X       (input) DOUBLE PRECISION
;;*  Y       (input) DOUBLE PRECISION
;;*          X and Y specify the values x and y.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlapy2 (x  y  )
	((-idx0- (-double-)) x )
	((-idx0- (-double-)) y )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlapy2_(IDX_PTR($x,double), IDX_PTR($y,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlapy3 <x>  <y>  <z>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
;;*  unnecessary overflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  X       (input) DOUBLE PRECISION
;;*  Y       (input) DOUBLE PRECISION
;;*  Z       (input) DOUBLE PRECISION
;;*          X, Y and Z specify the values x, y and z.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlapy3 (x  y  z  )
	((-idx0- (-double-)) x )
	((-idx0- (-double-)) y )
	((-idx0- (-double-)) z )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dlapy3_(IDX_PTR($x,double), IDX_PTR($y,double), IDX_PTR($z,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqgb <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQGB equilibrates a general M by N band matrix A with KL
;;*  subdiagonals and KU superdiagonals using the row and scaling factors
;;*  in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, the equilibrated matrix, in the same storage format
;;*          as A.  See EQUED for the form of the equilibrated matrix.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDA >= KL+KU+1.
;;*
;;*  R       (output) DOUBLE PRECISION array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (output) DOUBLE PRECISION
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (output) DOUBLE PRECISION
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqgb (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ dlaqgb_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqge <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQGE equilibrates a general M by N matrix A using the row and
;;*  scaling factors in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M by N matrix A.
;;*          On exit, the equilibrated matrix.  See EQUED for the form of
;;*          the equilibrated matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  R       (input) DOUBLE PRECISION array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (input) DOUBLE PRECISION
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (input) DOUBLE PRECISION
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqge (m  n  a  lda  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ dlaqge_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqp2 <m>  <n>  <offset>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQP2 computes a QR factorization with column pivoting of
;;*  the block A(OFFSET+1:M,1:N).
;;*  The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of the matrix A that must be pivoted
;;*          but no factorized. OFFSET >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
;;*          the triangular factor obtained; the elements in block
;;*          A(OFFSET+1:M,1:N) below the diagonal, together with the
;;*          array TAU, represent the orthogonal matrix Q as a product of
;;*          elementary reflectors. Block A(1:OFFSET,1:N) has been
;;*          accordingly pivoted, but no factorized.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqp2 (m  n  offset  a  lda  jpvt  tau  vn1  vn2  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) vn1 )
	((-idx1- (-double-)) vn2 )
	((-idx1- (-double-)) work )
	#{ dlaqp2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($vn1,double), IDX_PTR($vn2,double), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqps <m>  <n>  <offset>  <nb>  <kb>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <auxv>  <f>  <ldf>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQPS computes a step of QR factorization with column pivoting
;;*  of a real M-by-N matrix A by using Blas-3.  It tries to factorize
;;*  NB columns from A starting from the row OFFSET+1, and updates all
;;*  of the matrix with Blas-3 xGEMM.
;;*
;;*  In some cases, due to catastrophic cancellations, it cannot
;;*  factorize NB columns.  Hence, the actual number of factorized
;;*  columns is returned in KB.
;;*
;;*  Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of A that have been factorized in
;;*          previous steps.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to factorize.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns actually factorized.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, block A(OFFSET+1:M,1:KB) is the triangular
;;*          factor obtained and block A(1:OFFSET,1:N) has been
;;*          accordingly pivoted, but no factorized.
;;*          The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
;;*          been updated.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          JPVT(I) = K <==> Column K of the full matrix A has been
;;*          permuted into position I in AP.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (KB)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  AUXV    (input/output) DOUBLE PRECISION array, dimension (NB)
;;*          Auxiliar vector.
;;*
;;*  F       (input/output) DOUBLE PRECISION array, dimension (LDF,NB)
;;*          Matrix F' = L*Y'*A.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqps (m  n  offset  nb  kb  a  lda  jpvt  tau  vn1  vn2  auxv  f  ldf  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) vn1 )
	((-idx1- (-double-)) vn2 )
	((-idx1- (-double-)) auxv )
	((-idx2- (-double-)) f )
	((-idx0- (-int-)) ldf )
	#{ dlaqps_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($vn1,double), IDX_PTR($vn2,double), IDX_PTR($auxv,double), IDX_PTR($f,double), IDX_PTR($ldf,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqsb <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQSB equilibrates a symmetric band matrix A using the scaling
;;*  factors in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqsb (uplo  n  kd  ab  ldab  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ dlaqsb_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqsp <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQSP equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
;;*          the same storage format as A.
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqsp (uplo  n  ap  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ dlaqsp_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqsy <uplo>  <n>  <a>  <lda>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQSY equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if EQUED = 'Y', the equilibrated matrix:
;;*          diag(S) * A * diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqsy (uplo  n  a  lda  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ dlaqsy_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaqtr <ltran>  <lreal>  <n>  <t_>  <ldt>  <b>  <w>  <scale>  <x>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAQTR solves the real quasi-triangular system
;;*
;;*               op(T)*p = scale*c,               if LREAL = .TRUE.
;;*
;;*  or the complex quasi-triangular systems
;;*
;;*             op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
;;*
;;*  in real arithmetic, where T is upper quasi-triangular.
;;*  If LREAL = .FALSE., then the first diagonal block of T must be
;;*  1 by 1, B is the specially structured matrix
;;*
;;*                 B = [ b(1) b(2) ... b(n) ]
;;*                     [       w            ]
;;*                     [           w        ]
;;*                     [              .     ]
;;*                     [                 w  ]
;;*
;;*  op(A) = A or A', A' denotes the conjugate transpose of
;;*  matrix A.
;;*
;;*  On input, X = [ c ].  On output, X = [ p ].
;;*                [ d ]                  [ q ]
;;*
;;*  This subroutine is designed for the condition number estimation
;;*  in routine DTRSNA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  LTRAN   (input) LOGICAL
;;*          On entry, LTRAN specifies the option of conjugate transpose:
;;*             = .FALSE.,    op(T+i*B) = T+i*B,
;;*             = .TRUE.,     op(T+i*B) = (T+i*B)'.
;;*
;;*  LREAL   (input) LOGICAL
;;*          On entry, LREAL specifies the input matrix structure:
;;*             = .FALSE.,    the input is complex
;;*             = .TRUE.,     the input is real
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the order of T+i*B. N >= 0.
;;*
;;*  T       (input) DOUBLE PRECISION array, dimension (LDT,N)
;;*          On entry, T contains a matrix in Schur canonical form.
;;*          If LREAL = .FALSE., then the first diagonal block of T mu
;;*          be 1 by 1.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the matrix T. LDT >= max(1,N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (N)
;;*          On entry, B contains the elements to form the matrix
;;*          B as described above.
;;*          If LREAL = .TRUE., B is not referenced.
;;*
;;*  W       (input) DOUBLE PRECISION
;;*          On entry, W is the diagonal element of the matrix B.
;;*          If LREAL = .TRUE., W is not referenced.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          On exit, SCALE is the scale factor.
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (2*N)
;;*          On entry, X contains the right hand side of the system.
;;*          On exit, X is overwritten by the solution.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, INFO is set to
;;*             0: successful exit.
;;*               1: the some diagonal 1 by 1 block has been perturbed by
;;*                  a small number SMIN to keep nonsingularity.
;;*               2: the some diagonal 2 by 2 block has been perturbed by
;;*                  a small number in DLALN2 to keep nonsingularity.
;;*          NOTE: In the interests of speed, this routine does not
;;*                check the inputs for errors.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaqtr (ltran  lreal  n  t_  ldt  b  w  scale  x  work  info  )
	((-idx0- (-int-)) ltran )
	((-idx0- (-int-)) lreal )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx1- (-double-)) b )
	((-idx0- (-double-)) w )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) x )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlaqtr_(IDX_PTR($ltran,int), IDX_PTR($lreal,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($b,double), IDX_PTR($w,double), IDX_PTR($scale,double), IDX_PTR($x,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlar1v <n>  <b1>  <bn>  <sigma>  <d>  <l>  <ld>  <lld>  <gersch>  <z>  <ztz>  <mingma>  <r>  <isuppz>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAR1V computes the (scaled) r-th column of the inverse of
;;*  the sumbmatrix in rows B1 through BN of the tridiagonal matrix
;;*  L D L^T - sigma I. The following steps accomplish this computation :
;;*  (a) Stationary qd transform,  L D L^T - sigma I = L(+) D(+) L(+)^T,
;;*  (b) Progressive qd transform, L D L^T - sigma I = U(-) D(-) U(-)^T,
;;*  (c) Computation of the diagonal elements of the inverse of
;;*      L D L^T - sigma I by combining the above transforms, and choosing
;;*      r as the index where the diagonal of the inverse is (one of the)
;;*      largest in magnitude.
;;*  (d) Computation of the (scaled) r-th column of the inverse using the
;;*      twisted factorization obtained by combining the top part of the
;;*      the stationary and the bottom part of the progressive transform.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N        (input) INTEGER
;;*           The order of the matrix L D L^T.
;;*
;;*  B1       (input) INTEGER
;;*           First index of the submatrix of L D L^T.
;;*
;;*  BN       (input) INTEGER
;;*           Last index of the submatrix of L D L^T.
;;*
;;*  SIGMA    (input) DOUBLE PRECISION
;;*           The shift. Initially, when R = 0, SIGMA should be a good
;;*           approximation to an eigenvalue of L D L^T.
;;*
;;*  L        (input) DOUBLE PRECISION array, dimension (N-1)
;;*           The (n-1) subdiagonal elements of the unit bidiagonal matrix
;;*           L, in elements 1 to N-1.
;;*
;;*  D        (input) DOUBLE PRECISION array, dimension (N)
;;*           The n diagonal elements of the diagonal matrix D.
;;*
;;*  LD       (input) DOUBLE PRECISION array, dimension (N-1)
;;*           The n-1 elements L(i)*D(i).
;;*
;;*  LLD      (input) DOUBLE PRECISION array, dimension (N-1)
;;*           The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  GERSCH   (input) DOUBLE PRECISION array, dimension (2*N)
;;*           The n Gerschgorin intervals. These are used to restrict
;;*           the initial search for R, when R is input as 0.
;;*
;;*  Z        (output) DOUBLE PRECISION array, dimension (N)
;;*           The (scaled) r-th column of the inverse. Z(R) is returned
;;*           to be 1.
;;*
;;*  ZTZ      (output) DOUBLE PRECISION
;;*           The square of the norm of Z.
;;*
;;*  MINGMA   (output) DOUBLE PRECISION
;;*           The reciprocal of the largest (in magnitude) diagonal
;;*           element of the inverse of L D L^T - sigma I.
;;*
;;*  R        (input/output) INTEGER
;;*           Initially, R should be input to be 0 and is then output as
;;*           the index where the diagonal element of the inverse is
;;*           largest in magnitude. In later iterations, this same value
;;*           of R should be input.
;;*
;;*  ISUPPZ   (output) INTEGER array, dimension (2)
;;*           The support of the vector in Z, i.e., the vector Z is
;;*           nonzero only in elements ISUPPZ(1) through ISUPPZ( 2 ).
;;*
;;*  WORK     (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlar1v (n  b1  bn  sigma  d  l  ld  lld  gersch  z  ztz  mingma  r  isuppz  work  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) b1 )
	((-idx0- (-int-)) bn )
	((-idx0- (-double-)) sigma )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) l )
	((-idx1- (-double-)) ld )
	((-idx1- (-double-)) lld )
	((-idx1- (-double-)) gersch )
	((-idx1- (-double-)) z )
	((-idx0- (-double-)) ztz )
	((-idx0- (-double-)) mingma )
	((-idx0- (-int-)) r )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	#{ dlar1v_(IDX_PTR($n,int), IDX_PTR($b1,int), IDX_PTR($bn,int), IDX_PTR($sigma,double), IDX_PTR($d,double), IDX_PTR($l,double), IDX_PTR($ld,double), IDX_PTR($lld,double), IDX_PTR($gersch,double), IDX_PTR($z,double), IDX_PTR($ztz,double), IDX_PTR($mingma,double), IDX_PTR($r,int), IDX_PTR($isuppz,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlar2v <n>  <x>  <y>  <z>  <incx>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAR2V applies a vector of real plane rotations from both sides to
;;*  a sequence of 2-by-2 real symmetric matrices, defined by the elements
;;*  of the vectors x, y and z. For i = 1,2,...,n
;;*
;;*     ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
;;*     ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector x.
;;*
;;*  Y       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector y.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector z.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X, Y and Z. INCX > 0.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlar2v (n  x  y  z  incx  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	((-idx1- (-double-)) y )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx0- (-int-)) incc )
	#{ dlar2v_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($y,double), IDX_PTR($z,double), IDX_PTR($incx,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarfb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARFB applies a real block reflector H or its transpose H' to a
;;*  real m by n matrix C, from either the left or the right.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'T': apply H' (Transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  V       (input) DOUBLE PRECISION array, dimension
;;*                                (LDV,K) if STOREV = 'C'
;;*                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
;;*                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
;;*          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
;;*          if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) DOUBLE PRECISION array, dimension (LDT,K)
;;*          The triangular k by k matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDA >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarfb (side  trans  direct  storev  m  n  k  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) ldwork )
	#{ dlarfb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarfg <n>  <alpha>  <x>  <incx>  <tau>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARFG generates a real elementary reflector H of order n, such
;;*  that
;;*
;;*        H * ( alpha ) = ( beta ),   H' * H = I.
;;*            (   x   )   (   0  )
;;*
;;*  where alpha and beta are scalars, and x is an (n-1)-element real
;;*  vector. H is represented in the form
;;*
;;*        H = I - tau * ( 1 ) * ( 1 v' ) ,
;;*                      ( v )
;;*
;;*  where tau is a real scalar and v is a real (n-1)-element
;;*  vector.
;;*
;;*  If the elements of x are all zero, then tau = 0 and H is taken to be
;;*  the unit matrix.
;;*
;;*  Otherwise  1 <= tau <= 2.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the elementary reflector.
;;*
;;*  ALPHA   (input/output) DOUBLE PRECISION
;;*          On entry, the value alpha.
;;*          On exit, it is overwritten with the value beta.
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension
;;*                         (1+(N-2)*abs(INCX))
;;*          On entry, the vector x.
;;*          On exit, it is overwritten with the vector v.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  TAU     (output) DOUBLE PRECISION
;;*          The value tau.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarfg (n  alpha  x  incx  tau  )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) tau )
	#{ dlarfg_(IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($tau,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarf <side>  <m>  <n>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARF applies a real elementary reflector H to a real m by n matrix
;;*  C, from either the left or the right. H is represented in the form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a real scalar and v is a real vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) DOUBLE PRECISION array, dimension
;;*                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of H. V is not used if
;;*          TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) DOUBLE PRECISION
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarf (side  m  n  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) v )
	((-idx0- (-int-)) incv )
	((-idx0- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	#{ dlarf_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($incv,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarft <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARFT forms the triangular factor T of a real block reflector H
;;*  of order n, which is defined as a product of k elementary reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) DOUBLE PRECISION array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) DOUBLE PRECISION array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
;;*                   ( v1  1    )                     (     1 v2 v2 v2 )
;;*                   ( v1 v2  1 )                     (        1 v3 v3 )
;;*                   ( v1 v2 v3 )
;;*                   ( v1 v2 v3 )
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
;;*                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
;;*                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
;;*                   (     1 v3 )
;;*                   (        1 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarft (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ dlarft_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($tau,double), IDX_PTR($t_,double), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarfx <side>  <m>  <n>  <v>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARFX applies a real elementary reflector H to a real m by n
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a real scalar and v is a real vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix
;;*
;;*  This version uses inline code if H has order < 11.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) DOUBLE PRECISION array, dimension (M) if SIDE = 'L'
;;*                                     or (N) if SIDE = 'R'
;;*          The vector v in the representation of H.
;;*
;;*  TAU     (input) DOUBLE PRECISION
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDA >= (1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                      (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*          WORK is not referenced if H has order < 11.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarfx (side  m  n  v  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) v )
	((-idx0- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	#{ dlarfx_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlargv <n>  <x>  <incx>  <y>  <incy>  <c>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARGV generates a vector of real plane rotations, determined by
;;*  elements of the real vectors x and y. For i = 1,2,...,n
;;*
;;*     (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
;;*     ( -s(i)  c(i) ) ( y(i) ) = (   0  )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be generated.
;;*
;;*  X       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCX)
;;*          On entry, the vector x.
;;*          On exit, x(i) is overwritten by a(i), for i = 1,...,n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCY)
;;*          On entry, the vector y.
;;*          On exit, the sines of the plane rotations.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlargv (n  x  incx  y  incy  c  incc  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-double-)) c )
	((-idx0- (-int-)) incc )
	#{ dlargv_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarnv <idist>  <iseed>  <n>  <x>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARNV returns a vector of n random real numbers from a uniform or
;;*  normal distribution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IDIST   (input) INTEGER
;;*          Specifies the distribution of the random numbers:
;;*          = 1:  uniform (0,1)
;;*          = 2:  uniform (-1,1)
;;*          = 3:  normal (0,1)
;;*
;;*  ISEED   (input/output) INTEGER array, dimension (4)
;;*          On entry, the seed of the random number generator; the array
;;*          elements must be between 0 and 4095, and ISEED(4) must be
;;*          odd.
;;*          On exit, the seed is updated.
;;*
;;*  N       (input) INTEGER
;;*          The number of random numbers to be generated.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (N)
;;*          The generated random numbers.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine calls the auxiliary routine DLARUV to generate random
;;*  real numbers from a uniform (0,1) distribution, in batches of up to
;;*  128 using vectorisable code. The Box-Muller method is used to
;;*  transform numbers from a uniform to a normal distribution.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarnv (idist  iseed  n  x  )
	((-idx0- (-int-)) idist )
	((-idx1- (-int-)) iseed )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	#{ dlarnv_(IDX_PTR($idist,int), IDX_PTR($iseed,int), IDX_PTR($n,int), IDX_PTR($x,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarrb <n>  <d>  <l>  <ld>  <lld>  <ifirst>  <ilast>  <sigma>  <reltol>  <w>  <wgap>  <werr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given the relatively robust representation(RRR) L D L^T, DLARRB
;;*  does ``limited'' bisection to locate the eigenvalues of L D L^T,
;;*  W( IFIRST ) thru' W( ILAST ), to more accuracy. Intervals
;;*  [left, right] are maintained by storing their mid-points and
;;*  semi-widths in the arrays W and WERR respectively.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D.
;;*
;;*  L       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The n-1 subdiagonal elements of the unit bidiagonal matrix L.
;;*
;;*  LD      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The n-1 elements L(i)*D(i).
;;*
;;*  LLD     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  IFIRST  (input) INTEGER
;;*          The index of the first eigenvalue in the cluster.
;;*
;;*  ILAST   (input) INTEGER
;;*          The index of the last eigenvalue in the cluster.
;;*
;;*  SIGMA   (input) DOUBLE PRECISION
;;*          The shift used to form L D L^T (see DLARRF).
;;*
;;*  RELTOL  (input) DOUBLE PRECISION
;;*          The relative tolerance.
;;*
;;*  W       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On input, W( IFIRST ) thru' W( ILAST ) are estimates of the
;;*          corresponding eigenvalues of L D L^T.
;;*          On output, these estimates are ``refined''.
;;*
;;*  WGAP    (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The gaps between the eigenvalues of L D L^T. Very small
;;*          gaps are changed on output.
;;*
;;*  WERR    (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On input, WERR( IFIRST ) thru' WERR( ILAST ) are the errors
;;*          in the estimates W( IFIRST ) thru' W( ILAST ).
;;*          On output, these are the ``refined'' errors.
;;*
;;*****Reminder to Inder --- WORK is never used in this subroutine *****
;;*  WORK    (input) DOUBLE PRECISION array, dimension (???)
;;*          Workspace.
;;*
;;*  IWORK   (input) INTEGER array, dimension (2*N)
;;*          Workspace.
;;*
;;*****Reminder to Inder --- INFO is never set in this subroutine ******
;;*  INFO    (output) INTEGER
;;*          Error flag.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarrb (n  d  l  ld  lld  ifirst  ilast  sigma  reltol  w  wgap  werr  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) l )
	((-idx1- (-double-)) ld )
	((-idx1- (-double-)) lld )
	((-idx0- (-int-)) ifirst )
	((-idx0- (-int-)) ilast )
	((-idx0- (-double-)) sigma )
	((-idx0- (-double-)) reltol )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) wgap )
	((-idx1- (-double-)) werr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlarrb_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($l,double), IDX_PTR($ld,double), IDX_PTR($lld,double), IDX_PTR($ifirst,int), IDX_PTR($ilast,int), IDX_PTR($sigma,double), IDX_PTR($reltol,double), IDX_PTR($w,double), IDX_PTR($wgap,double), IDX_PTR($werr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarre <n>  <d>  <e>  <tol>  <nsplit>  <isplit>  <m>  <w>  <woff>  <gersch>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given the tridiagonal matrix T, DLARRE sets "small" off-diagonal
;;*  elements to zero, and for each unreduced block T_i, it finds
;;*  (i) the numbers sigma_i
;;*  (ii) the base T_i - sigma_i I = L_i D_i L_i^T representations and
;;*  (iii) eigenvalues of each L_i D_i L_i^T.
;;*  The representations and eigenvalues found are then used by
;;*  DSTEGR to compute the eigenvectors of a symmetric tridiagonal
;;*  matrix. Currently, the base representations are limited to being
;;*  positive or negative definite, and the eigenvalues of the definite
;;*  matrices are found by the dqds algorithm (subroutine DLASQ2). As
;;*  an added benefit, DLARRE also outputs the n Gerschgorin
;;*  intervals for each L_i D_i L_i^T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal
;;*          matrix T.
;;*          On exit, the n diagonal elements of the diagonal
;;*          matrices D_i.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix T; E(N) need not be set.
;;*          On exit, the subdiagonal elements of the unit bidiagonal
;;*          matrices L_i.
;;*
;;*  TOL     (input) DOUBLE PRECISION
;;*          The threshold for splitting. If on input |E(i)| < TOL, then
;;*          the matrix T is split into smaller blocks.
;;*
;;*  NSPLIT  (input) INTEGER
;;*          The number of blocks T splits into. 1 <= NSPLIT <= N.
;;*
;;*  ISPLIT  (output) INTEGER array, dimension (2*N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to ISPLIT(1),
;;*          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
;;*          etc., and the NSPLIT-th consists of rows/columns
;;*          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues (of all the L_i D_i L_i^T)
;;*          found.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the eigenvalues. The
;;*          eigenvalues of each of the blocks, L_i D_i L_i^T, are
;;*          sorted in ascending order.
;;*
;;*  WOFF    (output) DOUBLE PRECISION array, dimension (N)
;;*          The NSPLIT base points sigma_i.
;;*
;;*  GERSCH  (output) DOUBLE PRECISION array, dimension (2*N)
;;*          The n Gerschgorin intervals.
;;*
;;*  WORK    (input) DOUBLE PRECISION array, dimension (4*N???)
;;*          Workspace.
;;*
;;*  INFO    (output) INTEGER
;;*          Output error code from DLASQ2
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarre (n  d  e  tol  nsplit  isplit  m  w  woff  gersch  work  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-double-)) tol )
	((-idx0- (-int-)) nsplit )
	((-idx1- (-int-)) isplit )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) woff )
	((-idx1- (-double-)) gersch )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlarre_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tol,double), IDX_PTR($nsplit,int), IDX_PTR($isplit,int), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($woff,double), IDX_PTR($gersch,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarrf <n>  <d>  <l>  <ld>  <lld>  <ifirst>  <ilast>  <w>  <dplus>  <lplus>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given the initial representation L D L^T and its cluster of close
;;*  eigenvalues (in a relative measure), W( IFIRST ), W( IFIRST+1 ), ...
;;*  W( ILAST ), DLARRF finds a new relatively robust representation
;;*  L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
;;*  eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D.
;;*
;;*  L       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal
;;*          matrix L.
;;*
;;*  LD      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The n-1 elements L(i)*D(i).
;;*
;;*  LLD     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  IFIRST  (input) INTEGER
;;*          The index of the first eigenvalue in the cluster.
;;*
;;*  ILAST   (input) INTEGER
;;*          The index of the last eigenvalue in the cluster.
;;*
;;*  W       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On input, the eigenvalues of L D L^T in ascending order.
;;*          W( IFIRST ) through W( ILAST ) form the cluster of relatively
;;*          close eigenalues.
;;*          On output, W( IFIRST ) thru' W( ILAST ) are estimates of the
;;*          corresponding eigenvalues of L(+) D(+) L(+)^T.
;;*
;;*  SIGMA   (input) DOUBLE PRECISION
;;*          The shift used to form L(+) D(+) L(+)^T.
;;*
;;*  DPLUS   (output) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D(+).
;;*
;;*  LPLUS   (output) DOUBLE PRECISION array, dimension (N)
;;*          The first (n-1) elements of LPLUS contain the subdiagonal
;;*          elements of the unit bidiagonal matrix L(+). LPLUS( N ) is
;;*          set to SIGMA.
;;*
;;*  WORK    (input) DOUBLE PRECISION array, dimension (???)
;;*          Workspace.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarrf (n  d  l  ld  lld  ifirst  ilast  w  dplus  lplus  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) l )
	((-idx1- (-double-)) ld )
	((-idx1- (-double-)) lld )
	((-idx0- (-int-)) ifirst )
	((-idx0- (-int-)) ilast )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) dplus )
	((-idx1- (-double-)) lplus )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlarrf_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($l,double), IDX_PTR($ld,double), IDX_PTR($lld,double), IDX_PTR($ifirst,int), IDX_PTR($ilast,int), IDX_PTR($w,double), IDX_PTR($dplus,double), IDX_PTR($lplus,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarrv <n>  <d>  <l>  <isplit>  <m>  <w>  <iblock>  <gersch>  <tol>  <z>  <ldz>  <isuppz>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARRV computes the eigenvectors of the tridiagonal matrix
;;*  T = L D L^T given L, D and the eigenvalues of L D L^T.
;;*  The input eigenvalues should have high relative accuracy with
;;*  respect to the entries of L and D. The desired accuracy of the
;;*  output can be specified by the input parameter TOL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the diagonal matrix D.
;;*          On exit, D may be overwritten.
;;*
;;*  L       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the unit
;;*          bidiagonal matrix L in elements 1 to N-1 of L. L(N) need
;;*          not be set. On exit, L is overwritten.
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*
;;*  TOL     (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors.
;;*          Errors in the input eigenvalues must be bounded by TOL.
;;*          The eigenvectors output have residual norms
;;*          bounded by TOL, and the dot products between different
;;*          eigenvectors are bounded by TOL. TOL must be at least
;;*          N*EPS*|T|, where EPS is the machine precision and |T| is
;;*          the 1-norm of the tridiagonal matrix.
;;*
;;*  M       (input) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (input) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block ( The output array
;;*          W from DLARRE is expected here ).
;;*          Errors in W must be bounded by TOL (see above).
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (13*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in DLARRB
;;*                if INFO = 2, internal error in DSTEIN
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarrv (n  d  l  isplit  m  w  iblock  gersch  tol  z  ldz  isuppz  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) l )
	((-idx1- (-int-)) isplit )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-double-)) gersch )
	((-idx0- (-double-)) tol )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlarrv_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($l,double), IDX_PTR($isplit,int), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($iblock,int), IDX_PTR($gersch,double), IDX_PTR($tol,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlartg <f>  <g>  <cs>  <sn>  <r>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARTG generate a plane rotation so that
;;*
;;*     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
;;*     [ -SN  CS  ]     [ G ]     [ 0 ]
;;*
;;*  This is a slower, more accurate version of the BLAS1 routine DROTG,
;;*  with the following other differences:
;;*     F and G are unchanged on return.
;;*     If G=0, then CS=1 and SN=0.
;;*     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
;;*        floating point operations (saves work in DBDSQR when
;;*        there are zeros on the diagonal).
;;*
;;*  If F exceeds G in magnitude, CS will be positive.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) DOUBLE PRECISION
;;*          The first component of vector to be rotated.
;;*
;;*  G       (input) DOUBLE PRECISION
;;*          The second component of vector to be rotated.
;;*
;;*  CS      (output) DOUBLE PRECISION
;;*          The cosine of the rotation.
;;*
;;*  SN      (output) DOUBLE PRECISION
;;*          The sine of the rotation.
;;*
;;*  R       (output) DOUBLE PRECISION
;;*          The nonzero component of the rotated vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlartg (f  g  cs  sn  r  )
	((-idx0- (-double-)) f )
	((-idx0- (-double-)) g )
	((-idx0- (-double-)) cs )
	((-idx0- (-double-)) sn )
	((-idx0- (-double-)) r )
	#{ dlartg_(IDX_PTR($f,double), IDX_PTR($g,double), IDX_PTR($cs,double), IDX_PTR($sn,double), IDX_PTR($r,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlartv <n>  <x>  <incx>  <y>  <incy>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARTV applies a vector of real plane rotations to elements of the
;;*  real vectors x and y. For i = 1,2,...,n
;;*
;;*     ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
;;*     ( y(i) )    ( -s(i)  c(i) ) ( y(i) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCX)
;;*          The vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) DOUBLE PRECISION array,
;;*                         dimension (1+(N-1)*INCY)
;;*          The vector y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlartv (n  x  incx  y  incy  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx0- (-int-)) incc )
	#{ dlartv_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaruv <iseed>  <n>  <x>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARUV returns a vector of n random real numbers from a uniform (0,1)
;;*  distribution (n <= 128).
;;*
;;*  This is an auxiliary routine called by DLARNV and ZLARNV.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ISEED   (input/output) INTEGER array, dimension (4)
;;*          On entry, the seed of the random number generator; the array
;;*          elements must be between 0 and 4095, and ISEED(4) must be
;;*          odd.
;;*          On exit, the seed is updated.
;;*
;;*  N       (input) INTEGER
;;*          The number of random numbers to be generated. N <= 128.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (N)
;;*          The generated random numbers.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine uses a multiplicative congruential method with modulus
;;*  2**48 and multiplier 33952834046453 (see G.S.Fishman,
;;*  'Multiplicative congruential random number generators with modulus
;;*  2**b: an exhaustive analysis for b = 32 and a partial analysis for
;;*  b = 48', Math. Comp. 189, pp 331-344, 1990).
;;*
;;*  48-bit integers are stored in 4 integer array elements with 12 bits
;;*  per element. Hence the routine is portable across machines with
;;*  integers of 32 bits or more.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlaruv (iseed  n  x  )
	((-idx1- (-int-)) iseed )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	#{ dlaruv_(IDX_PTR($iseed,int), IDX_PTR($n,int), IDX_PTR($x,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarzb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <l>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARZB applies a real block reflector H or its transpose H**T to
;;*  a real distributed M-by-N  C from the left or the right.
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'C': apply H' (Transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise                        (not supported yet)
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix V containing the
;;*          meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) DOUBLE PRECISION array, dimension (LDV,NV).
;;*          If STOREV = 'C', NV = K; if STOREV = 'R', NV = L.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= L; if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) DOUBLE PRECISION array, dimension (LDT,K)
;;*          The triangular K-by-K matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarzb (side  trans  direct  storev  m  n  k  l  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) ldwork )
	#{ dlarzb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarz <side>  <m>  <n>  <l>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARZ applies a real elementary reflector H to a real M-by-N
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a real scalar and v is a real vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*
;;*  H is a product of k elementary reflectors as returned by DTZRZF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  L       (input) INTEGER
;;*          The number of entries of the vector V containing
;;*          the meaningful part of the Householder vectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) DOUBLE PRECISION array, dimension (1+(L-1)*abs(INCV))
;;*          The vector v in the representation of H as returned by
;;*          DTZRZF. V is not used if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) DOUBLE PRECISION
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarz (side  m  n  l  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx1- (-double-)) v )
	((-idx0- (-int-)) incv )
	((-idx0- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	#{ dlarz_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($v,double), IDX_PTR($incv,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlarzt <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLARZT forms the triangular factor T of a real block reflector
;;*  H of order > n, which is defined as a product of k elementary
;;*  reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise                        (not supported yet)
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) DOUBLE PRECISION array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) DOUBLE PRECISION array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*                                              ______V_____
;;*         ( v1 v2 v3 )                        /            \
;;*         ( v1 v2 v3 )                      ( v1 v1 v1 v1 v1 . . . . 1 )
;;*     V = ( v1 v2 v3 )                      ( v2 v2 v2 v2 v2 . . . 1   )
;;*         ( v1 v2 v3 )                      ( v3 v3 v3 v3 v3 . . 1     )
;;*         ( v1 v2 v3 )
;;*            .  .  .
;;*            .  .  .
;;*            1  .  .
;;*               1  .
;;*                  1
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*                                                        ______V_____
;;*            1                                          /            \
;;*            .  1                           ( 1 . . . . v1 v1 v1 v1 v1 )
;;*            .  .  1                        ( . 1 . . . v2 v2 v2 v2 v2 )
;;*            .  .  .                        ( . . 1 . . v3 v3 v3 v3 v3 )
;;*            .  .  .
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*     V = ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlarzt (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ dlarzt_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($tau,double), IDX_PTR($t_,double), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlas2 <f>  <g>  <h>  <ssmin>  <ssmax>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAS2  computes the singular values of the 2-by-2 matrix
;;*     [  F   G  ]
;;*     [  0   H  ].
;;*  On return, SSMIN is the smaller singular value and SSMAX is the
;;*  larger singular value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) DOUBLE PRECISION
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  G       (input) DOUBLE PRECISION
;;*          The (1,2) element of the 2-by-2 matrix.
;;*
;;*  H       (input) DOUBLE PRECISION
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  SSMIN   (output) DOUBLE PRECISION
;;*          The smaller singular value.
;;*
;;*  SSMAX   (output) DOUBLE PRECISION
;;*          The larger singular value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Barring over/underflow, all output quantities are correct to within
;;*  a few units in the last place (ulps), even in the absence of a guard
;;*  digit in addition/subtraction.
;;*
;;*  In IEEE arithmetic, the code works correctly if one matrix element is
;;*  infinite.
;;*
;;*  Overflow will not occur unless the largest singular value itself
;;*  overflows, or is within a few ulps of overflow. (On machines with
;;*  partial overflow, like the Cray, overflow may occur if the largest
;;*  singular value is within a factor of 2 of overflow.)
;;*
;;*  Underflow is harmless if underflow is gradual. Otherwise, results
;;*  may correspond to a matrix modified by perturbations of size near
;;*  the underflow threshold.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlas2 (f  g  h  ssmin  ssmax  )
	((-idx0- (-double-)) f )
	((-idx0- (-double-)) g )
	((-idx0- (-double-)) h )
	((-idx0- (-double-)) ssmin )
	((-idx0- (-double-)) ssmax )
	#{ dlas2_(IDX_PTR($f,double), IDX_PTR($g,double), IDX_PTR($h,double), IDX_PTR($ssmin,double), IDX_PTR($ssmax,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlascl <type>  <kl>  <ku>  <cfrom>  <cto>  <m>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASCL multiplies the M by N real matrix A by the real scalar
;;*  CTO/CFROM.  This is done without over/underflow as long as the final
;;*  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
;;*  A may be full, upper triangular, lower triangular, upper Hessenberg,
;;*  or banded.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TYPE    (input) CHARACTER*1
;;*          TYPE indices the storage type of the input matrix.
;;*          = 'G':  A is a full matrix.
;;*          = 'L':  A is a lower triangular matrix.
;;*          = 'U':  A is an upper triangular matrix.
;;*          = 'H':  A is an upper Hessenberg matrix.
;;*          = 'B':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the lower
;;*                  half stored.
;;*          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the upper
;;*                  half stored.
;;*          = 'Z':  A is a band matrix with lower bandwidth KL and upper
;;*                  bandwidth KU.
;;*
;;*  KL      (input) INTEGER
;;*          The lower bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  KU      (input) INTEGER
;;*          The upper bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  CFROM   (input) DOUBLE PRECISION
;;*  CTO     (input) DOUBLE PRECISION
;;*          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
;;*          without over/underflow if the final result CTO*A(I,J)/CFROM
;;*          can be represented without over/underflow.  CFROM must be
;;*          nonzero.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,M)
;;*          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
;;*          storage type.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  INFO    (output) INTEGER
;;*          0  - successful exit
;;*          <0 - if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlascl (type  kl  ku  cfrom  cto  m  n  a  lda  info  )
	((-str-) type )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-double-)) cfrom )
	((-idx0- (-double-)) cto )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dlascl_($type->data, IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($cfrom,double), IDX_PTR($cto,double), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd0 <n>  <sqre>  <d>  <e>  <u>  <ldu>  <vt>  <ldvt>  <smlsiz>  <iwork>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Using a divide and conquer approach, DLASD0 computes the singular
;;*  value decomposition (SVD) of a real upper bidiagonal N-by-M
;;*  matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
;;*  The algorithm computes orthogonal matrices U and VT such that
;;*  B = U * S * VT. The singular values S are overwritten on D.
;;*
;;*  A related subroutine, DLASDA, computes only the singular values,
;;*  and optionally, the singular vectors in compact form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         On entry, the row dimension of the upper bidiagonal matrix.
;;*         This is also the dimension of the main diagonal array D.
;;*
;;*  SQRE   (input) INTEGER
;;*         Specifies the column dimension of the bidiagonal matrix.
;;*         = 0: The bidiagonal matrix has column dimension M = N;
;;*         = 1: The bidiagonal matrix has column dimension M = N+1;
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix.
;;*         On exit D, if INFO = 0, contains its singular values.
;;*
;;*  E      (input) DOUBLE PRECISION array, dimension (M-1)
;;*         Contains the subdiagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  U      (output) DOUBLE PRECISION array, dimension at least (LDQ, N)
;;*         On exit, U contains the left singular vectors.
;;*
;;*  LDU    (input) INTEGER
;;*         On entry, leading dimension of U.
;;*
;;*  VT     (output) DOUBLE PRECISION array, dimension at least (LDVT, M)
;;*         On exit, VT' contains the right singular vectors.
;;*
;;*  LDVT   (input) INTEGER
;;*         On entry, leading dimension of VT.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         On entry, maximum size of the subproblems at the
;;*         bottom of the computation tree.
;;*
;;*  IWORK  INTEGER work array.
;;*         Dimension must be at least (8 * N)
;;*
;;*  WORK   DOUBLE PRECISION work array.
;;*         Dimension must be at least (3 * M**2 + 2 * M)
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlasd0 (n  sqre  d  e  u  ldu  vt  ldvt  smlsiz  iwork  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) sqre )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx0- (-int-)) smlsiz )
	((-idx1- (-int-)) iwork )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasd0_(IDX_PTR($n,int), IDX_PTR($sqre,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($smlsiz,int), IDX_PTR($iwork,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd1 <nl>  <nr>  <sqre>  <d>  <alpha>  <beta>  <u>  <ldu>  <vt>  <ldvt>  <idxq>  <iwork>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
;;*  where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.
;;*
;;*  A related subroutine DLASD7 handles the case in which the singular
;;*  values (and the singular vectors in factored form) are desired.
;;*
;;*  DLASD1 computes the SVD as follows:
;;*
;;*                ( D1(in)  0    0     0 )
;;*    B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
;;*                (   0     0   D2(in) 0 )
;;*
;;*      = U(out) * ( D(out) 0) * VT(out)
;;*
;;*  where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
;;*  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
;;*  elsewhere; and the entry b is empty if SQRE = 0.
;;*
;;*  The left singular vectors of the original matrix are stored in U, and
;;*  the transpose of the right singular vectors are stored in VT, and the
;;*  singular values are in D.  The algorithm consists of three stages:
;;*
;;*     The first stage consists of deflating the size of the problem
;;*     when there are multiple singular values or when there are zeros in
;;*     the Z vector.  For each such occurence the dimension of the
;;*     secular equation problem is reduced by one.  This stage is
;;*     performed by the routine DLASD2.
;;*
;;*     The second stage consists of calculating the updated
;;*     singular values. This is done by finding the square roots of the
;;*     roots of the secular equation via the routine DLASD4 (as called
;;*     by DLASD3). This routine also calculates the singular vectors of
;;*     the current problem.
;;*
;;*     The final stage consists of computing the updated singular vectors
;;*     directly using the updated singular values.  The singular vectors
;;*     for the current problem are multiplied with the singular vectors
;;*     from the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  D      (input/output) DOUBLE PRECISION array,
;;*                        dimension (N = NL+NR+1).
;;*         On entry D(1:NL,1:NL) contains the singular values of the
;;*         upper block; and D(NL+2:N) contains the singular values of
;;*         the lower block. On exit D(1:N) contains the singular values
;;*         of the modified matrix.
;;*
;;*  ALPHA  (input) DOUBLE PRECISION
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) DOUBLE PRECISION
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  U      (input/output) DOUBLE PRECISION array, dimension(LDU,N)
;;*         On entry U(1:NL, 1:NL) contains the left singular vectors of
;;*         the upper block; U(NL+2:N, NL+2:N) contains the left singular
;;*         vectors of the lower block. On exit U contains the left
;;*         singular vectors of the bidiagonal matrix.
;;*
;;*  LDU    (input) INTEGER
;;*         The leading dimension of the array U.  LDU >= max( 1, N ).
;;*
;;*  VT     (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
;;*         where M = N + SQRE.
;;*         On entry VT(1:NL+1, 1:NL+1)' contains the right singular
;;*         vectors of the upper block; VT(NL+2:M, NL+2:M)' contains
;;*         the right singular vectors of the lower block. On exit
;;*         VT' contains the right singular vectors of the
;;*         bidiagonal matrix.
;;*
;;*  LDVT   (input) INTEGER
;;*         The leading dimension of the array VT.  LDVT >= max( 1, M ).
;;*
;;*  IDXQ  (output) INTEGER array, dimension(N)
;;*         This contains the permutation which will reintegrate the
;;*         subproblem just solved back into sorted order, i.e.
;;*         D( IDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  IWORK  (workspace) INTEGER array, dimension( 4 * N )
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*
;;*  =====================================================================

(de dlasd1 (nl  nr  sqre  d  alpha  beta  u  ldu  vt  ldvt  idxq  iwork  work  info  )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx1- (-double-)) d )
	((-idx0- (-double-)) alpha )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) iwork )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasd1_(IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($d,double), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($idxq,int), IDX_PTR($iwork,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd2 <nl>  <nr>  <sqre>  <k>  <d>  <z>  <alpha>  <beta>  <u>  <ldu>  <vt>  <ldvt>  <dsigma>  <u2>  <ldu2>  <vt2>  <ldvt2>  <idxp>  <idx>  <idxc>  <idxq>  <coltyp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD2 merges the two sets of singular values together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  singular values are close together or if there is a tiny entry in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  DLASD2 is called from DLASD1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has N = NL + NR + 1 rows and
;;*         M = N + SQRE >= N columns.
;;*
;;*  K      (output) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension(N)
;;*         On entry D contains the singular values of the two submatrices
;;*         to be combined.  On exit D contains the trailing (N-K) updated
;;*         singular values (those which were deflated) sorted into
;;*         increasing order.
;;*
;;*  ALPHA  (input) DOUBLE PRECISION
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) DOUBLE PRECISION
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  U      (input/output) DOUBLE PRECISION array, dimension(LDU,N)
;;*         On entry U contains the left singular vectors of two
;;*         submatrices in the two square blocks with corners at (1,1),
;;*         (NL, NL), and (NL+2, NL+2), (N,N).
;;*         On exit U contains the trailing (N-K) updated left singular
;;*         vectors (those which were deflated) in its last N-K columns.
;;*
;;*  LDU    (input) INTEGER
;;*         The leading dimension of the array U.  LDU >= N.
;;*
;;*  Z      (output) DOUBLE PRECISION array, dimension(N)
;;*         On exit Z contains the updating row vector in the secular
;;*         equation.
;;*
;;*  DSIGMA (output) DOUBLE PRECISION array, dimension (N)
;;*         Contains a copy of the diagonal elements (K-1 singular values
;;*         and one zero) in the secular equation.
;;*
;;*  U2     (output) DOUBLE PRECISION array, dimension(LDU2,N)
;;*         Contains a copy of the first K-1 left singular vectors which
;;*         will be used by DLASD3 in a matrix multiply (DGEMM) to solve
;;*         for the new left singular vectors. U2 is arranged into four
;;*         blocks. The first block contains a column with 1 at NL+1 and
;;*         zero everywhere else; the second block contains non-zero
;;*         entries only at and above NL; the third contains non-zero
;;*         entries only below NL+1; and the fourth is dense.
;;*
;;*  LDU2   (input) INTEGER
;;*         The leading dimension of the array U2.  LDU2 >= N.
;;*
;;*  VT     (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
;;*         On entry VT' contains the right singular vectors of two
;;*         submatrices in the two square blocks with corners at (1,1),
;;*         (NL+1, NL+1), and (NL+2, NL+2), (M,M).
;;*         On exit VT' contains the trailing (N-K) updated right singular
;;*         vectors (those which were deflated) in its last N-K columns.
;;*         In case SQRE =1, the last row of VT spans the right null
;;*         space.
;;*
;;*  LDVT   (input) INTEGER
;;*         The leading dimension of the array VT.  LDVT >= M.
;;*
;;*  VT2    (output) DOUBLE PRECISION array, dimension(LDVT2,N)
;;*         VT2' contains a copy of the first K right singular vectors
;;*         which will be used by DLASD3 in a matrix multiply (DGEMM) to
;;*         solve for the new right singular vectors. VT2 is arranged into
;;*         three blocks. The first block contains a row that corresponds
;;*         to the special 0 diagonal element in SIGMA; the second block
;;*         contains non-zeros only at and before NL +1; the third block
;;*         contains non-zeros only at and after  NL +2.
;;*
;;*  LDVT2  (input) INTEGER
;;*         The leading dimension of the array VT2.  LDVT2 >= M.
;;*
;;*  IDXP   (workspace) INTEGER array, dimension(N)
;;*         This will contain the permutation used to place deflated
;;*         values of D at the end of the array. On output IDXP(2:K)
;;*         points to the nondeflated D-values and IDXP(K+1:N)
;;*         points to the deflated singular values.
;;*
;;*  IDX    (workspace) INTEGER array, dimension(N)
;;*         This will contain the permutation used to sort the contents of
;;*         D into ascending order.
;;*
;;*  IDXC   (output) INTEGER array, dimension(N)
;;*         This will contain the permutation used to arrange the columns
;;*         of the deflated U matrix into three groups:  the first group
;;*         contains non-zero entries only at and above NL, the second
;;*         contains non-zero entries only below NL+2, and the third is
;;*         dense.
;;*
;;*  COLTYP (workspace/output) INTEGER array, dimension(N)
;;*         As workspace, this will contain a label which will indicate
;;*         which of the following types a column in the U2 matrix or a
;;*         row in the VT2 matrix is:
;;*         1 : non-zero in the upper half only
;;*         2 : non-zero in the lower half only
;;*         3 : dense
;;*         4 : deflated
;;*
;;*         On exit, it is an array of dimension 4, with COLTYP(I) being
;;*         the dimension of the I-th type columns.
;;*
;;*  IDXQ   (input) INTEGER array, dimension(N)
;;*         This contains the permutation which separately sorts the two
;;*         sub-problems in D into ascending order.  Note that entries in
;;*         the first hlaf of this permutation must first be moved one
;;*         position backward; and entries in the second half
;;*         must first have NL+1 added to their values.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd2 (nl  nr  sqre  k  d  z  alpha  beta  u  ldu  vt  ldvt  dsigma  u2  ldu2  vt2  ldvt2  idxp  idx  idxc  idxq  coltyp  info  )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) k )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx0- (-double-)) alpha )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx1- (-double-)) dsigma )
	((-idx2- (-double-)) u2 )
	((-idx0- (-int-)) ldu2 )
	((-idx2- (-double-)) vt2 )
	((-idx0- (-int-)) ldvt2 )
	((-idx1- (-int-)) idxp )
	((-idx1- (-int-)) idx )
	((-idx1- (-int-)) idxc )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) coltyp )
	((-idx0- (-int-)) info )
	#{ dlasd2_(IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($k,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($dsigma,double), IDX_PTR($u2,double), IDX_PTR($ldu2,int), IDX_PTR($vt2,double), IDX_PTR($ldvt2,int), IDX_PTR($idxp,int), IDX_PTR($idx,int), IDX_PTR($idxc,int), IDX_PTR($idxq,int), IDX_PTR($coltyp,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd3 <nl>  <nr>  <sqre>  <k>  <d>  <q>  <ldq>  <dsigma>  <u>  <ldu>  <u2>  <ldu2>  <vt>  <ldvt>  <vt2>  <ldvt2>  <idxc>  <ctot>  <z>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD3 finds all the square roots of the roots of the secular
;;*  equation, as defined by the values in D and Z.  It makes the
;;*  appropriate calls to DLASD4 and then updates the singular
;;*  vectors by matrix multiplication.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  DLASD3 is called from DLASD1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has N = NL + NR + 1 rows and
;;*         M = N + SQRE >= N columns.
;;*
;;*  K      (input) INTEGER
;;*         The size of the secular equation, 1 =< K = < N.
;;*
;;*  D      (output) DOUBLE PRECISION array, dimension(K)
;;*         On exit the square roots of the roots of the secular equation,
;;*         in ascending order.
;;*
;;*  Q      (workspace) DOUBLE PRECISION array,
;;*                     dimension at least (LDQ,K).
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= K.
;;*
;;*  DSIGMA (input) DOUBLE PRECISION array, dimension(K)
;;*         The first K elements of this array contain the old roots
;;*         of the deflated updating problem.  These are the poles
;;*         of the secular equation.
;;*
;;*  U      (input) DOUBLE PRECISION array, dimension (LDU, N)
;;*         The last N - K columns of this matrix contain the deflated
;;*         left singular vectors.
;;*
;;*  LDU    (input) INTEGER
;;*         The leading dimension of the array U.  LDU >= N.
;;*
;;*  U2     (input) DOUBLE PRECISION array, dimension (LDU2, N)
;;*         The first K columns of this matrix contain the non-deflated
;;*         left singular vectors for the split problem.
;;*
;;*  LDU2   (input) INTEGER
;;*         The leading dimension of the array U2.  LDU2 >= N.
;;*
;;*  VT     (input) DOUBLE PRECISION array, dimension (LDVT, M)
;;*         The last M - K columns of VT' contain the deflated
;;*         right singular vectors.
;;*
;;*  LDVT   (input) INTEGER
;;*         The leading dimension of the array VT.  LDVT >= N.
;;*
;;*  VT2    (input) DOUBLE PRECISION array, dimension (LDVT2, N)
;;*         The first K columns of VT2' contain the non-deflated
;;*         right singular vectors for the split problem.
;;*
;;*  LDVT2  (input) INTEGER
;;*         The leading dimension of the array VT2.  LDVT2 >= N.
;;*
;;*  IDXC   (input) INTEGER array, dimension ( N )
;;*         The permutation used to arrange the columns of U (and rows of
;;*         VT) into three groups:  the first group contains non-zero
;;*         entries only at and above (or before) NL +1; the second
;;*         contains non-zero entries only at and below (or after) NL+2;
;;*         and the third is dense. The first column of U and the row of
;;*         VT are treated separately, however.
;;*
;;*         The rows of the singular vectors found by DLASD4
;;*         must be likewise permuted before the matrix multiplies can
;;*         take place.
;;*
;;*  CTOT   (input) INTEGER array, dimension ( 4 )
;;*         A count of the total number of the various types of columns
;;*         in U (or rows in VT), as described in IDXC. The fourth column
;;*         type is any column which has been deflated.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension (K)
;;*         The first K elements of this array contain the components
;;*         of the deflation-adjusted updating row vector.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*         > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd3 (nl  nr  sqre  k  d  q  ldq  dsigma  u  ldu  u2  ldu2  vt  ldvt  vt2  ldvt2  idxc  ctot  z  info  )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) k )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) dsigma )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) u2 )
	((-idx0- (-int-)) ldu2 )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-double-)) vt2 )
	((-idx0- (-int-)) ldvt2 )
	((-idx1- (-int-)) idxc )
	((-idx1- (-int-)) ctot )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) info )
	#{ dlasd3_(IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($k,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($dsigma,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($u2,double), IDX_PTR($ldu2,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($vt2,double), IDX_PTR($ldvt2,int), IDX_PTR($idxc,int), IDX_PTR($ctot,int), IDX_PTR($z,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd4 <n>  <i>  <d>  <z>  <delta>  <rho>  <sigma>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the square root of the I-th updated
;;*  eigenvalue of a positive symmetric rank-one modification to
;;*  a positive diagonal matrix whose entries are given as the squares
;;*  of the corresponding entries in the array d, and that
;;*
;;*         0 <= D(i) < D(j)  for  i < j
;;*
;;*  and that RHO > 0. This is arranged by the calling routine, and is
;;*  no loss in generality.  The rank-one modified system is thus
;;*
;;*         diag( D ) * diag( D ) +  RHO *  Z * Z_transpose.
;;*
;;*  where we assume the Euclidean norm of Z is 1.
;;*
;;*  The method consists of approximating the rational functions in the
;;*  secular equation by simpler interpolating rational functions.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The length of all arrays.
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  1 <= I <= N.
;;*
;;*  D      (input) DOUBLE PRECISION array, dimension ( N )
;;*         The original eigenvalues.  It is assumed that they are in
;;*         order, 0 <= D(I) < D(J)  for I < J.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( N )
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) DOUBLE PRECISION array, dimension ( N )
;;*         If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
;;*         component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
;;*         contains the information necessary to construct the
;;*         (singular) eigenvectors.
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         The scalar in the symmetric updating formula.
;;*
;;*  SIGMA  (output) DOUBLE PRECISION
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension ( N )
;;*         If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
;;*         component.  If N = 1, then WORK( 1 ) = 1.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit
;;*         > 0:  if INFO = 1, the updating process failed.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  Logical variable ORGATI (origin-at-i?) is used for distinguishing
;;*  whether D(i) or D(i+1) is treated as the origin.
;;*
;;*            ORGATI = .true.    origin at i
;;*            ORGATI = .false.   origin at i+1
;;*
;;*  Logical variable SWTCH3 (switch-for-3-poles?) is for noting
;;*  if we are working with THREE poles!
;;*
;;*  MAXIT is the maximum number of iterations allowed for each
;;*  eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd4 (n  i  d  z  delta  rho  sigma  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) i )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) delta )
	((-idx0- (-double-)) rho )
	((-idx0- (-double-)) sigma )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasd4_(IDX_PTR($n,int), IDX_PTR($i,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($delta,double), IDX_PTR($rho,double), IDX_PTR($sigma,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd5 <i>  <d>  <z>  <delta>  <rho>  <dsigma>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This subroutine computes the square root of the I-th eigenvalue
;;*  of a positive symmetric rank-one modification of a 2-by-2 diagonal
;;*  matrix
;;*
;;*             diag( D ) * diag( D ) +  RHO *  Z * transpose(Z) .
;;*
;;*  The diagonal entries in the array D are assumed to satisfy
;;*
;;*             0 <= D(i) < D(j)  for  i < j .
;;*
;;*  We also assume RHO > 0 and that the Euclidean norm of the vector
;;*  Z is one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I      (input) INTEGER
;;*         The index of the eigenvalue to be computed.  I = 1 or I = 2.
;;*
;;*  D      (input) DOUBLE PRECISION array, dimension ( 2 )
;;*         The original eigenvalues.  We assume 0 <= D(1) < D(2).
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( 2 )
;;*         The components of the updating vector.
;;*
;;*  DELTA  (output) DOUBLE PRECISION array, dimension ( 2 )
;;*         Contains (D(j) - lambda_I) in its  j-th component.
;;*         The vector DELTA contains the information necessary
;;*         to construct the eigenvectors.
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         The scalar in the symmetric updating formula.
;;*
;;*  DSIGMA (output) DOUBLE PRECISION
;;*         The computed lambda_I, the I-th updated eigenvalue.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension ( 2 )
;;*         WORK contains (D(j) + sigma_I) in its  j-th component.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ren-Cang Li, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd5 (i  d  z  delta  rho  dsigma  work  )
	((-idx0- (-int-)) i )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) delta )
	((-idx0- (-double-)) rho )
	((-idx0- (-double-)) dsigma )
	((-idx1- (-double-)) work )
	#{ dlasd5_(IDX_PTR($i,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($delta,double), IDX_PTR($rho,double), IDX_PTR($dsigma,double), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd6 <icompq>  <nl>  <nr>  <sqre>  <d>  <vf>  <vl>  <alpha>  <beta>  <idxq>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <poles>  <difl>  <difr>  <z>  <k>  <c>  <s>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD6 computes the SVD of an updated upper bidiagonal matrix B
;;*  obtained by merging two smaller ones by appending a row. This
;;*  routine is used only for the problem which requires all singular
;;*  values and optionally singular vector matrices in factored form.
;;*  B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
;;*  A related subroutine, DLASD1, handles the case in which all singular
;;*  values and singular vectors of the bidiagonal matrix are desired.
;;*
;;*  DLASD6 computes the SVD as follows:
;;*
;;*                ( D1(in)  0    0     0 )
;;*    B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
;;*                (   0     0   D2(in) 0 )
;;*
;;*      = U(out) * ( D(out) 0) * VT(out)
;;*
;;*  where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
;;*  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
;;*  elsewhere; and the entry b is empty if SQRE = 0.
;;*
;;*  The singular values of B can be computed using D1, D2, the first
;;*  components of all the right singular vectors of the lower block, and
;;*  the last components of all the right singular vectors of the upper
;;*  block. These components are stored and updated in VF and VL,
;;*  respectively, in DLASD6. Hence U and VT are not explicitly
;;*  referenced.
;;*
;;*  The singular values are stored in D. The algorithm consists of two
;;*  stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple singular values or if there is a zero
;;*        in the Z vector. For each such occurence the dimension of the
;;*        secular equation problem is reduced by one. This stage is
;;*        performed by the routine DLASD7.
;;*
;;*        The second stage consists of calculating the updated
;;*        singular values. This is done by finding the roots of the
;;*        secular equation via the routine DLASD4 (as called by DLASD8).
;;*        This routine also updates VF and VL and computes the distances
;;*        between the updated singular values and the old singular
;;*        values.
;;*
;;*  DLASD6 is called from DLASDA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed in
;;*         factored form:
;;*         = 0: Compute singular values only.
;;*         = 1: Compute singular vectors in factored form as well.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block.  NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block.  NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension ( NL+NR+1 ).
;;*         On entry D(1:NL,1:NL) contains the singular values of the
;;*         upper block, and D(NL+2:N) contains the singular values
;;*         of the lower block. On exit D(1:N) contains the singular
;;*         values of the modified matrix.
;;*
;;*  VF     (input/output) DOUBLE PRECISION array, dimension ( M )
;;*         On entry, VF(1:NL+1) contains the first components of all
;;*         right singular vectors of the upper block; and VF(NL+2:M)
;;*         contains the first components of all right singular vectors
;;*         of the lower block. On exit, VF contains the first components
;;*         of all right singular vectors of the bidiagonal matrix.
;;*
;;*  VL     (input/output) DOUBLE PRECISION array, dimension ( M )
;;*         On entry, VL(1:NL+1) contains the  last components of all
;;*         right singular vectors of the upper block; and VL(NL+2:M)
;;*         contains the last components of all right singular vectors of
;;*         the lower block. On exit, VL contains the last components of
;;*         all right singular vectors of the bidiagonal matrix.
;;*
;;*  ALPHA  (input) DOUBLE PRECISION
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) DOUBLE PRECISION
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  IDXQ   (output) INTEGER array, dimension ( N )
;;*         This contains the permutation which will reintegrate the
;;*         subproblem just solved back into sorted order, i.e.
;;*         D( IDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  PERM   (output) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) to be applied
;;*         to each block. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVPTR (output) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVCOL (output) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGCOL (input) INTEGER
;;*         leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value to be used in the
;;*         corresponding Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of GIVNUM and POLES, must be at least N.
;;*
;;*  POLES  (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         On exit, POLES(1,*) is an array containing the new singular
;;*         values obtained from solving the secular equation, and
;;*         POLES(2,*) is an array containing the poles in the secular
;;*         equation. Not referenced if ICOMPQ = 0.
;;*
;;*  DIFL   (output) DOUBLE PRECISION array, dimension ( N )
;;*         On exit, DIFL(I) is the distance between I-th updated
;;*         (undeflated) singular value and the I-th (undeflated) old
;;*         singular value.
;;*
;;*  DIFR   (output) DOUBLE PRECISION array,
;;*                  dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
;;*                  dimension ( N ) if ICOMPQ = 0.
;;*         On exit, DIFR(I, 1) is the distance between I-th updated
;;*         (undeflated) singular value and the I+1-th (undeflated) old
;;*         singular value.
;;*
;;*         If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
;;*         normalizing factors for the right singular vector matrix.
;;*
;;*         See DLASD8 for details on DIFL and DIFR.
;;*
;;*  Z      (output) DOUBLE PRECISION array, dimension ( M )
;;*         The first elements of this array contain the components
;;*         of the deflation-adjusted updating row vector.
;;*
;;*  K      (output) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  C      (output) DOUBLE PRECISION
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (output) DOUBLE PRECISION
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension ( 4 * M )
;;*
;;*  IWORK  (workspace) INTEGER array, dimension ( 3 * N )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd6 (icompq  nl  nr  sqre  d  vf  vl  alpha  beta  idxq  perm  givptr  givcol  ldgcol  givnum  ldgnum  poles  difl  difr  z  k  c  s  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) vf )
	((-idx1- (-double-)) vl )
	((-idx0- (-double-)) alpha )
	((-idx0- (-double-)) beta )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-double-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx2- (-double-)) poles )
	((-idx1- (-double-)) difl )
	((-idx1- (-double-)) difr )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) s )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlasd6_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($d,double), IDX_PTR($vf,double), IDX_PTR($vl,double), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($idxq,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,double), IDX_PTR($ldgnum,int), IDX_PTR($poles,double), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($z,double), IDX_PTR($k,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd7 <icompq>  <nl>  <nr>  <sqre>  <k>  <d>  <z>  <zw>  <vf>  <vfw>  <vl>  <vlw>  <alpha>  <beta>  <dsigma>  <idx>  <idxp>  <idxq>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <c>  <s>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD7 merges the two sets of singular values together into a single
;;*  sorted set. Then it tries to deflate the size of the problem. There
;;*  are two ways in which deflation can occur:  when two or more singular
;;*  values are close together or if there is a tiny entry in the Z
;;*  vector. For each such occurrence the order of the related
;;*  secular equation problem is reduced by one.
;;*
;;*  DLASD7 is called from DLASD6.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          Specifies whether singular vectors are to be computed
;;*          in compact form, as follows:
;;*          = 0: Compute singular values only.
;;*          = 1: Compute singular vectors of upper
;;*               bidiagonal matrix in compact form.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block. NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block. NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has
;;*         N = NL + NR + 1 rows and
;;*         M = N + SQRE >= N columns.
;;*
;;*  K      (output) INTEGER
;;*         Contains the dimension of the non-deflated matrix, this is
;;*         the order of the related secular equation. 1 <= K <=N.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension ( N )
;;*         On entry D contains the singular values of the two submatrices
;;*         to be combined. On exit D contains the trailing (N-K) updated
;;*         singular values (those which were deflated) sorted into
;;*         increasing order.
;;*
;;*  Z      (output) DOUBLE PRECISION array, dimension ( M )
;;*         On exit Z contains the updating row vector in the secular
;;*         equation.
;;*
;;*  ZW     (workspace) DOUBLE PRECISION array, dimension ( M )
;;*         Workspace for Z.
;;*
;;*  VF     (input/output) DOUBLE PRECISION array, dimension ( M )
;;*         On entry, VF(1:NL+1) contains the first components of all
;;*         right singular vectors of the upper block; and VF(NL+2:M)
;;*         contains the first components of all right singular vectors
;;*         of the lower block. On exit, VF contains the first components
;;*         of all right singular vectors of the bidiagonal matrix.
;;*
;;*  VFW    (workspace) DOUBLE PRECISION array, dimension ( M )
;;*         Workspace for VF.
;;*
;;*  VL     (input/output) DOUBLE PRECISION array, dimension ( M )
;;*         On entry, VL(1:NL+1) contains the  last components of all
;;*         right singular vectors of the upper block; and VL(NL+2:M)
;;*         contains the last components of all right singular vectors
;;*         of the lower block. On exit, VL contains the last components
;;*         of all right singular vectors of the bidiagonal matrix.
;;*
;;*  VLW    (workspace) DOUBLE PRECISION array, dimension ( M )
;;*         Workspace for VL.
;;*
;;*  ALPHA  (input) DOUBLE PRECISION
;;*         Contains the diagonal element associated with the added row.
;;*
;;*  BETA   (input) DOUBLE PRECISION
;;*         Contains the off-diagonal element associated with the added
;;*         row.
;;*
;;*  DSIGMA (output) DOUBLE PRECISION array, dimension ( N )
;;*         Contains a copy of the diagonal elements (K-1 singular values
;;*         and one zero) in the secular equation.
;;*
;;*  IDX    (workspace) INTEGER array, dimension ( N )
;;*         This will contain the permutation used to sort the contents of
;;*         D into ascending order.
;;*
;;*  IDXP   (workspace) INTEGER array, dimension ( N )
;;*         This will contain the permutation used to place deflated
;;*         values of D at the end of the array. On output IDXP(2:K)
;;*         points to the nondeflated D-values and IDXP(K+1:N)
;;*         points to the deflated singular values.
;;*
;;*  IDXQ   (input) INTEGER array, dimension ( N )
;;*         This contains the permutation which separately sorts the two
;;*         sub-problems in D into ascending order.  Note that entries in
;;*         the first half of this permutation must first be moved one
;;*         position backward; and entries in the second half
;;*         must first have NL+1 added to their values.
;;*
;;*  PERM   (output) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) to be applied
;;*         to each singular block. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVPTR (output) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem. Not referenced if ICOMPQ = 0.
;;*
;;*  GIVCOL (output) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGCOL (input) INTEGER
;;*         The leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value to be used in the
;;*         corresponding Givens rotation. Not referenced if ICOMPQ = 0.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of GIVNUM, must be at least N.
;;*
;;*  C      (output) DOUBLE PRECISION
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (output) DOUBLE PRECISION
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd7 (icompq  nl  nr  sqre  k  d  z  zw  vf  vfw  vl  vlw  alpha  beta  dsigma  idx  idxp  idxq  perm  givptr  givcol  ldgcol  givnum  ldgnum  c  s  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) k )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) zw )
	((-idx1- (-double-)) vf )
	((-idx1- (-double-)) vfw )
	((-idx1- (-double-)) vl )
	((-idx1- (-double-)) vlw )
	((-idx0- (-double-)) alpha )
	((-idx0- (-double-)) beta )
	((-idx1- (-double-)) dsigma )
	((-idx1- (-int-)) idx )
	((-idx1- (-int-)) idxp )
	((-idx1- (-int-)) idxq )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-double-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) s )
	((-idx0- (-int-)) info )
	#{ dlasd7_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($k,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($zw,double), IDX_PTR($vf,double), IDX_PTR($vfw,double), IDX_PTR($vl,double), IDX_PTR($vlw,double), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($dsigma,double), IDX_PTR($idx,int), IDX_PTR($idxp,int), IDX_PTR($idxq,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,double), IDX_PTR($ldgnum,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd8 <icompq>  <k>  <d>  <z>  <vf>  <vl>  <difl>  <difr>  <lddifr>  <dsigma>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD8 finds the square roots of the roots of the secular equation,
;;*  as defined by the values in DSIGMA and Z. It makes the appropriate
;;*  calls to DLASD4, and stores, for each  element in D, the distance
;;*  to its two nearest poles (elements in DSIGMA). It also updates
;;*  the arrays VF and VL, the first and last components of all the
;;*  right singular vectors of the original bidiagonal matrix.
;;*
;;*  DLASD8 is called from DLASD6.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          Specifies whether singular vectors are to be computed in
;;*          factored form in the calling routine:
;;*          = 0: Compute singular values only.
;;*          = 1: Compute singular vectors in factored form as well.
;;*
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved
;;*          by DLASD4.  K >= 1.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension ( K )
;;*          On output, D contains the updated singular values.
;;*
;;*  Z       (input) DOUBLE PRECISION array, dimension ( K )
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating row vector.
;;*
;;*  VF      (input/output) DOUBLE PRECISION array, dimension ( K )
;;*          On entry, VF contains  information passed through DBEDE8.
;;*          On exit, VF contains the first K components of the first
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  VL      (input/output) DOUBLE PRECISION array, dimension ( K )
;;*          On entry, VL contains  information passed through DBEDE8.
;;*          On exit, VL contains the first K components of the last
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  DIFL    (output) DOUBLE PRECISION array, dimension ( K )
;;*          On exit, DIFL(I) = D(I) - DSIGMA(I).
;;*
;;*  DIFR    (output) DOUBLE PRECISION array,
;;*                   dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
;;*                   dimension ( K ) if ICOMPQ = 0.
;;*          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
;;*          defined and will not be referenced.
;;*
;;*          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
;;*          normalizing factors for the right singular vector matrix.
;;*
;;*  LDDIFR  (input) INTEGER
;;*          The leading dimension of DIFR, must be at least K.
;;*
;;*  DSIGMA  (input) DOUBLE PRECISION array, dimension ( K )
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension at least 3 * K
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd8 (icompq  k  d  z  vf  vl  difl  difr  lddifr  dsigma  work  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) k )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) vf )
	((-idx1- (-double-)) vl )
	((-idx1- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx0- (-int-)) lddifr )
	((-idx1- (-double-)) dsigma )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasd8_(IDX_PTR($icompq,int), IDX_PTR($k,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($vf,double), IDX_PTR($vl,double), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($lddifr,int), IDX_PTR($dsigma,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasd9 <icompq>  <ldu>  <k>  <d>  <z>  <vf>  <vl>  <difl>  <difr>  <dsigma>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASD9 finds the square roots of the roots of the secular equation,
;;*  as defined by the values in DSIGMA and Z.  It makes the
;;*  appropriate calls to DLASD4, and stores, for each  element in D,
;;*  the distance to its two nearest poles (elements in DSIGMA). It also
;;*  updates the arrays VF and VL, the first and last components of all
;;*  the right singular vectors of the original bidiagonal matrix.
;;*
;;*  DLASD9 is called from DLASD7.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ  (input) INTEGER
;;*          Specifies whether singular vectors are to be computed in
;;*          factored form in the calling routine:
;;*
;;*             ICOMPQ = 0             Compute singular values only.
;;*
;;*             ICOMPQ = 1             Compute singular vector matrices in
;;*                                    factored form also.
;;*  K       (input) INTEGER
;;*          The number of terms in the rational function to be solved by
;;*          DLASD4.  K >= 1.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension(K)
;;*          D(I) contains the updated singular values.
;;*
;;*  DSIGMA  (input) DOUBLE PRECISION array, dimension(K)
;;*          The first K elements of this array contain the old roots
;;*          of the deflated updating problem.  These are the poles
;;*          of the secular equation.
;;*
;;*  Z       (input) DOUBLE PRECISION array, dimension (K)
;;*          The first K elements of this array contain the components
;;*          of the deflation-adjusted updating row vector.
;;*
;;*  VF      (input/output) DOUBLE PRECISION array, dimension(K)
;;*          On entry, VF contains  information passed through SBEDE8.f
;;*          On exit, VF contains the first K components of the first
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  VL      (input/output) DOUBLE PRECISION array, dimension(K)
;;*          On entry, VL contains  information passed through SBEDE8.f
;;*          On exit, VL contains the first K components of the last
;;*          components of all right singular vectors of the bidiagonal
;;*          matrix.
;;*
;;*  DIFL    (output) DOUBLE PRECISION array, dimension (K).
;;*          On exit, DIFL(I) = D(I) - DSIGMA(I).
;;*
;;*  DIFR    (output) DOUBLE PRECISION array,
;;*                              dimension (LDU, 2) if ICOMPQ =1 and
;;*                              dimension (K) if ICOMPQ = 0.
;;*          On exit, DIFR(I, 1) = D(I) - DSIGMA(I+1), DIFR(K, 1) is not
;;*          defined and will not be referenced.
;;*
;;*          If ICOMPQ = 1, DIFR(1:K, 2) is an array containing the
;;*          normalizing factors for the right singular vector matrix.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array,
;;*                                 dimension at least (3 * K)
;;*          Workspace.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasd9 (icompq  ldu  k  d  z  vf  vl  difl  difr  dsigma  work  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) ldu )
	((-idx0- (-int-)) k )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) vf )
	((-idx1- (-double-)) vl )
	((-idx1- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx1- (-double-)) dsigma )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasd9_(IDX_PTR($icompq,int), IDX_PTR($ldu,int), IDX_PTR($k,int), IDX_PTR($d,double), IDX_PTR($z,double), IDX_PTR($vf,double), IDX_PTR($vl,double), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($dsigma,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasda <icompq>  <smlsiz>  <n>  <sqre>  <d>  <e>  <u>  <ldu>  <vt>  <k>  <difl>  <difr>  <z>  <poles>  <givptr>  <givcol>  <ldgcol>  <perm>  <givnum>  <c>  <s>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Using a divide and conquer approach, DLASDA computes the singular
;;*  value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
;;*  B with diagonal D and offdiagonal E, where M = N + SQRE. The
;;*  algorithm computes the singular values in the SVD B = U * S * VT.
;;*  The orthogonal matrices U and VT are optionally computed in
;;*  compact form.
;;*
;;*  A related subroutine, DLASD0, computes the singular values and
;;*  the singular vectors in explicit form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed
;;*         in compact form, as follows
;;*         = 0: Compute singular values only.
;;*         = 1: Compute singular vectors of upper bidiagonal
;;*              matrix in compact form.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The row dimension of the upper bidiagonal matrix. This is
;;*         also the dimension of the main diagonal array D.
;;*
;;*  SQRE   (input) INTEGER
;;*         Specifies the column dimension of the bidiagonal matrix.
;;*         = 0: The bidiagonal matrix has column dimension M = N;
;;*         = 1: The bidiagonal matrix has column dimension M = N + 1.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension ( N )
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix. On exit D, if INFO = 0, contains its singular values.
;;*
;;*  E      (input) DOUBLE PRECISION array, dimension ( M-1 )
;;*         Contains the subdiagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  U      (output) DOUBLE PRECISION array,
;;*         dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
;;*         singular vector matrices of all subproblems at the bottom
;;*         level.
;;*
;;*  LDU    (input) INTEGER, LDU = > N.
;;*         The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
;;*         GIVNUM, and Z.
;;*
;;*  VT     (output) DOUBLE PRECISION array,
;;*         dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT' contains the right
;;*         singular vector matrices of all subproblems at the bottom
;;*         level.
;;*
;;*  K      (output) INTEGER array,
;;*         dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
;;*         If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
;;*         secular equation on the computation tree.
;;*
;;*  DIFL   (output) DOUBLE PRECISION array, dimension ( LDU, NLVL ),
;;*         where NLVL = floor(log_2 (N/SMLSIZ))).
;;*
;;*  DIFR   (output) DOUBLE PRECISION array,
;;*                  dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
;;*                  dimension ( N ) if ICOMPQ = 0.
;;*         If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
;;*         record distances between singular values on the I-th
;;*         level and singular values on the (I -1)-th level, and
;;*         DIFR(1:N, 2 * I ) contains the normalizing factors for
;;*         the right singular vector matrix. See DLASD8 for details.
;;*
;;*  Z      (output) DOUBLE PRECISION array,
;;*                  dimension ( LDU, NLVL ) if ICOMPQ = 1 and
;;*                  dimension ( N ) if ICOMPQ = 0.
;;*         The first K elements of Z(1, I) contain the components of
;;*         the deflation-adjusted updating row vector for subproblems
;;*         on the I-th level.
;;*
;;*  POLES  (output) DOUBLE PRECISION array,
;;*         dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
;;*         POLES(1, 2*I) contain  the new and old singular values
;;*         involved in the secular equations on the I-th level.
;;*
;;*  GIVPTR (output) INTEGER array,
;;*         dimension ( N ) if ICOMPQ = 1, and not referenced if
;;*         ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
;;*         the number of Givens rotations performed on the I-th
;;*         problem on the computation tree.
;;*
;;*  GIVCOL (output) INTEGER array,
;;*         dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
;;*         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
;;*         GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
;;*         of Givens rotations performed on the I-th level on the
;;*         computation tree.
;;*
;;*  LDGCOL (input) INTEGER, LDGCOL = > N.
;;*         The leading dimension of arrays GIVCOL and PERM.
;;*
;;*  PERM   (output) INTEGER array,
;;*         dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
;;*         if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
;;*         permutations done on the I-th level of the computation tree.
;;*
;;*  GIVNUM (output) DOUBLE PRECISION array,
;;*         dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
;;*         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
;;*         GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
;;*         values of Givens rotations performed on the I-th level on
;;*         the computation tree.
;;*
;;*  C      (output) DOUBLE PRECISION array,
;;*         dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
;;*         If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
;;*         C( I ) contains the C-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  S      (output) DOUBLE PRECISION array, dimension ( N ) if
;;*         ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
;;*         and the I-th subproblem is not square, on exit, S( I )
;;*         contains the S-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  WORK   (workspace) DOUBLE PRECISION array, dimension
;;*         (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
;;*
;;*  IWORK  (workspace) INTEGER array.
;;*         Dimension must be at least (7 * N).
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an singular value did not converge
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasda (icompq  smlsiz  n  sqre  d  e  u  ldu  vt  k  difl  difr  z  poles  givptr  givcol  ldgcol  perm  givnum  c  s  work  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) sqre )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx1- (-int-)) k )
	((-idx2- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx2- (-double-)) z )
	((-idx2- (-double-)) poles )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-int-)) perm )
	((-idx2- (-double-)) givnum )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dlasda_(IDX_PTR($icompq,int), IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($sqre,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($k,int), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($z,double), IDX_PTR($poles,double), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($perm,int), IDX_PTR($givnum,double), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasdq <uplo>  <sqre>  <n>  <ncvt>  <nru>  <ncc>  <d>  <e>  <vt>  <ldvt>  <u>  <ldu>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASDQ computes the singular value decomposition (SVD) of a real
;;*  (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
;;*  E, accumulating the transformations if desired. Letting B denote
;;*  the input bidiagonal matrix, the algorithm computes orthogonal
;;*  matrices Q and P such that B = Q * S * P' (P' denotes the transpose
;;*  of P). The singular values S are overwritten on D.
;;*
;;*  The input matrix U  is changed to U  * Q  if desired.
;;*  The input matrix VT is changed to P' * VT if desired.
;;*  The input matrix C  is changed to Q' * C  if desired.
;;*
;;*  See "Computing  Small Singular Values of Bidiagonal Matrices With
;;*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
;;*  LAPACK Working Note #3, for a detailed description of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO  (input) CHARACTER*1
;;*        On entry, UPLO specifies whether the input bidiagonal matrix
;;*        is upper or lower bidiagonal, and wether it is square are
;;*        not.
;;*           UPLO = 'U' or 'u'   B is upper bidiagonal.
;;*           UPLO = 'L' or 'l'   B is lower bidiagonal.
;;*
;;*  SQRE  (input) INTEGER
;;*        = 0: then the input matrix is N-by-N.
;;*        = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
;;*             (N+1)-by-N if UPLU = 'L'.
;;*
;;*        The bidiagonal matrix has
;;*        N = NL + NR + 1 rows and
;;*        M = N + SQRE >= N columns.
;;*
;;*  N     (input) INTEGER
;;*        On entry, N specifies the number of rows and columns
;;*        in the matrix. N must be at least 0.
;;*
;;*  NCVT  (input) INTEGER
;;*        On entry, NCVT specifies the number of columns of
;;*        the matrix VT. NCVT must be at least 0.
;;*
;;*  NRU   (input) INTEGER
;;*        On entry, NRU specifies the number of rows of
;;*        the matrix U. NRU must be at least 0.
;;*
;;*  NCC   (input) INTEGER
;;*        On entry, NCC specifies the number of columns of
;;*        the matrix C. NCC must be at least 0.
;;*
;;*  D     (input/output) DOUBLE PRECISION array, dimension (N)
;;*        On entry, D contains the diagonal entries of the
;;*        bidiagonal matrix whose SVD is desired. On normal exit,
;;*        D contains the singular values in ascending order.
;;*
;;*  E     (input/output) DOUBLE PRECISION array.
;;*        dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
;;*        On entry, the entries of E contain the offdiagonal entries
;;*        of the bidiagonal matrix whose SVD is desired. On normal
;;*        exit, E will contain 0. If the algorithm does not converge,
;;*        D and E will contain the diagonal and superdiagonal entries
;;*        of a bidiagonal matrix orthogonally equivalent to the one
;;*        given as input.
;;*
;;*  VT    (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
;;*        On entry, contains a matrix which on exit has been
;;*        premultiplied by P', dimension N-by-NCVT if SQRE = 0
;;*        and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
;;*
;;*  LDVT  (input) INTEGER
;;*        On entry, LDVT specifies the leading dimension of VT as
;;*        declared in the calling (sub) program. LDVT must be at
;;*        least 1. If NCVT is nonzero LDVT must also be at least N.
;;*
;;*  U     (input/output) DOUBLE PRECISION array, dimension (LDU, N)
;;*        On entry, contains a  matrix which on exit has been
;;*        postmultiplied by Q, dimension NRU-by-N if SQRE = 0
;;*        and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
;;*
;;*  LDU   (input) INTEGER
;;*        On entry, LDU  specifies the leading dimension of U as
;;*        declared in the calling (sub) program. LDU must be at
;;*        least max( 1, NRU ) .
;;*
;;*  C     (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
;;*        On entry, contains an N-by-NCC matrix which on exit
;;*        has been premultiplied by Q'  dimension N-by-NCC if SQRE = 0
;;*        and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
;;*
;;*  LDC   (input) INTEGER
;;*        On entry, LDC  specifies the leading dimension of C as
;;*        declared in the calling (sub) program. LDC must be at
;;*        least 1. If NCC is nonzero, LDC must also be at least N.
;;*
;;*  WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*        Workspace. Only referenced if one of NCVT, NRU, or NCC is
;;*        nonzero, and if N is at least 2.
;;*
;;*  INFO  (output) INTEGER
;;*        On exit, a value of 0 indicates a successful exit.
;;*        If INFO < 0, argument number -INFO is illegal.
;;*        If INFO > 0, the algorithm did not converge, and INFO
;;*        specifies how many superdiagonals did not converge.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasdq (uplo  sqre  n  ncvt  nru  ncc  d  e  vt  ldvt  u  ldu  c  ldc  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncvt )
	((-idx0- (-int-)) nru )
	((-idx0- (-int-)) ncc )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasdq_($uplo->data, IDX_PTR($sqre,int), IDX_PTR($n,int), IDX_PTR($ncvt,int), IDX_PTR($nru,int), IDX_PTR($ncc,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasdt <n>  <lvl>  <nd>  <inode>  <ndiml>  <ndimr>  <msub>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASDT creates a tree of subproblems for bidiagonal divide and
;;*  conquer.
;;*
;;*  Arguments
;;*  =========
;;*
;;*   N      (input) INTEGER
;;*          On entry, the number of diagonal elements of the
;;*          bidiagonal matrix.
;;*
;;*   LVL    (output) INTEGER
;;*          On exit, the number of levels on the computation tree.
;;*
;;*   ND     (output) INTEGER
;;*          On exit, the number of nodes on the tree.
;;*
;;*   INODE  (output) INTEGER array, dimension ( N )
;;*          On exit, centers of subproblems.
;;*
;;*   NDIML  (output) INTEGER array, dimension ( N )
;;*          On exit, row dimensions of left children.
;;*
;;*   NDIMR  (output) INTEGER array, dimension ( N )
;;*          On exit, row dimensions of right children.
;;*
;;*   MSUB   (input) INTEGER.
;;*          On entry, the maximum row dimension each subproblem at the
;;*          bottom of the tree can be of.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasdt (n  lvl  nd  inode  ndiml  ndimr  msub  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) lvl )
	((-idx0- (-int-)) nd )
	((-idx1- (-int-)) inode )
	((-idx1- (-int-)) ndiml )
	((-idx1- (-int-)) ndimr )
	((-idx0- (-int-)) msub )
	#{ dlasdt_(IDX_PTR($n,int), IDX_PTR($lvl,int), IDX_PTR($nd,int), IDX_PTR($inode,int), IDX_PTR($ndiml,int), IDX_PTR($ndimr,int), IDX_PTR($msub,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaset <uplo>  <m>  <n>  <alpha>  <beta>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASET initializes an m-by-n matrix A to BETA on the diagonal and
;;*  ALPHA on the offdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be set.
;;*          = 'U':      Upper triangular part is set; the strictly lower
;;*                      triangular part of A is not changed.
;;*          = 'L':      Lower triangular part is set; the strictly upper
;;*                      triangular part of A is not changed.
;;*          Otherwise:  All of the matrix A is set.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  ALPHA   (input) DOUBLE PRECISION
;;*          The constant to which the offdiagonal elements are to be set.
;;*
;;*  BETA    (input) DOUBLE PRECISION
;;*          The constant to which the diagonal elements are to be set.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On exit, the leading m-by-n submatrix of A is set as follows:
;;*
;;*          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
;;*          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
;;*          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
;;*
;;*          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlaset (uplo  m  n  alpha  beta  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ dlaset_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasq1 <n>  <d>  <e>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASQ1 computes the singular values of a real N-by-N bidiagonal
;;*  matrix with diagonal D and off-diagonal E. The singular values
;;*  are computed to high relative accuracy, in the absence of
;;*  denormalization, underflow and overflow. The algorithm was first
;;*  presented in
;;*
;;*  "Accurate singular values and differential qd algorithms" by K. V.
;;*  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
;;*  1994,
;;*
;;*  and the present implementation is described in "An implementation of
;;*  the dqds Algorithm (Positive Case)", LAPACK Working Note.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N     (input) INTEGER
;;*        The number of rows and columns in the matrix. N >= 0.
;;*
;;*  D     (input/output) DOUBLE PRECISION array, dimension (N)
;;*        On entry, D contains the diagonal elements of the
;;*        bidiagonal matrix whose SVD is desired. On normal exit,
;;*        D contains the singular values in decreasing order.
;;*
;;*  E     (input/output) DOUBLE PRECISION array, dimension (N)
;;*        On entry, elements E(1:N-1) contain the off-diagonal elements
;;*        of the bidiagonal matrix whose SVD is desired.
;;*        On exit, E is overwritten.
;;*
;;*  WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  INFO  (output) INTEGER
;;*        = 0: successful exit
;;*        < 0: if INFO = -i, the i-th argument had an illegal value
;;*        > 0: the algorithm failed
;;*             = 1, a split was marked by a positive value in E
;;*             = 2, current block of Z not diagonalized after 30*N
;;*                  iterations (in inner while loop)
;;*             = 3, termination criterion of outer while loop not met 
;;*                  (program created more than N unreduced blocks)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasq1 (n  d  e  work  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dlasq1_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasq2 <n>  <z>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASQ2 computes all the eigenvalues of the symmetric positive 
;;*  definite tridiagonal matrix associated with the qd array Z to high
;;*  relative accuracy are computed to high relative accuracy, in the
;;*  absence of denormalization, underflow and overflow.
;;*
;;*  To see the relation of Z to the tridiagonal matrix, let L be a
;;*  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
;;*  let U be an upper bidiagonal matrix with 1's above and diagonal
;;*  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
;;*  symmetric tridiagonal to which it is similar.
;;*
;;*  Note : DLASQ2 defines a logical variable, IEEE, which is true
;;*  on machines which follow ieee-754 floating-point standard in their
;;*  handling of infinities and NaNs, and false otherwise. This variable
;;*  is passed to DLASQ3.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N     (input) INTEGER
;;*        The number of rows and columns in the matrix. N >= 0.
;;*
;;*  Z     (workspace) DOUBLE PRECISION array, dimension ( 4*N )
;;*        On entry Z holds the qd array. On exit, entries 1 to N hold
;;*        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
;;*        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
;;*        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
;;*        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
;;*        shifts that failed.
;;*
;;*  INFO  (output) INTEGER
;;*        = 0: successful exit
;;*        < 0: if the i-th argument is a scalar and had an illegal
;;*             value, then INFO = -i, if the i-th argument is an
;;*             array and the j-entry had an illegal value, then
;;*             INFO = -(i*100+j)
;;*        > 0: the algorithm failed
;;*              = 1, a split was marked by a positive value in E
;;*              = 2, current block of Z not diagonalized after 30*N
;;*                   iterations (in inner while loop)
;;*              = 3, termination criterion of outer while loop not met 
;;*                   (program created more than N unreduced blocks)
;;*
;;*  Further Details
;;*  ===============
;;*  Local Variables: I0:N0 defines a current unreduced segment of Z.
;;*  The shifts are accumulated in SIGMA. Iteration count is in ITER.
;;*  Ping-pong is controlled by PP (alternates between 0 and 1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasq2 (n  z  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) info )
	#{ dlasq2_(IDX_PTR($n,int), IDX_PTR($z,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasq3 <i0>  <n0>  <z>  <pp>  <dmin>  <sigma>  <desig>  <qmax>  <nfail>  <iter>  <ndiv>  <ieee>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
;;*  In case of failure it changes shifts, and tries again until output
;;*  is positive.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I0     (input) INTEGER
;;*         First index.
;;*
;;*  N0     (input) INTEGER
;;*         Last index.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( 4*N )
;;*         Z holds the qd array.
;;*
;;*  PP     (input) INTEGER
;;*         PP=0 for ping, PP=1 for pong.
;;*
;;*  DMIN   (output) DOUBLE PRECISION
;;*         Minimum value of d.
;;*
;;*  SIGMA  (output) DOUBLE PRECISION
;;*         Sum of shifts used in current segment.
;;*
;;*  DESIG  (input/output) DOUBLE PRECISION
;;*         Lower order part of SIGMA
;;*
;;*  QMAX   (input) DOUBLE PRECISION
;;*         Maximum value of q.
;;*
;;*  NFAIL  (output) INTEGER
;;*         Number of times shift was too big.
;;*
;;*  ITER   (output) INTEGER
;;*         Number of iterations.
;;*
;;*  NDIV   (output) INTEGER
;;*         Number of divisions.
;;*
;;*  TTYPE  (output) INTEGER
;;*         Shift type.
;;*
;;*  IEEE   (input) LOGICAL
;;*         Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasq3 (i0  n0  z  pp  dmin  sigma  desig  qmax  nfail  iter  ndiv  ieee  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-double-)) dmin )
	((-idx0- (-double-)) sigma )
	((-idx0- (-double-)) desig )
	((-idx0- (-double-)) qmax )
	((-idx0- (-int-)) nfail )
	((-idx0- (-int-)) iter )
	((-idx0- (-int-)) ndiv )
	((-idx0- (-int-)) ieee )
	#{ dlasq3_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,double), IDX_PTR($pp,int), IDX_PTR($dmin,double), IDX_PTR($sigma,double), IDX_PTR($desig,double), IDX_PTR($qmax,double), IDX_PTR($nfail,int), IDX_PTR($iter,int), IDX_PTR($ndiv,int), IDX_PTR($ieee,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasq4 <i0>  <n0>  <z>  <pp>  <n0in>  <dmin>  <dmin1>  <dmin2>  <dn>  <dn1>  <dn2>  <tau>  <ttype>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASQ4 computes an approximation TAU to the smallest eigenvalue 
;;*  using values of d from the previous transform.
;;*
;;*  I0    (input) INTEGER
;;*        First index.
;;*
;;*  N0    (input) INTEGER
;;*        Last index.
;;*
;;*  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
;;*        Z holds the qd array.
;;*
;;*  PP    (input) INTEGER
;;*        PP=0 for ping, PP=1 for pong.
;;*
;;*  NOIN  (input) INTEGER
;;*        The value of N0 at start of EIGTEST.
;;*
;;*  DMIN  (input) DOUBLE PRECISION
;;*        Minimum value of d.
;;*
;;*  DMIN1 (input) DOUBLE PRECISION
;;*        Minimum value of d, excluding D( N0 ).
;;*
;;*  DMIN2 (input) DOUBLE PRECISION
;;*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
;;*
;;*  DN    (input) DOUBLE PRECISION
;;*        d(N)
;;*
;;*  DN1   (input) DOUBLE PRECISION
;;*        d(N-1)
;;*
;;*  DN2   (input) DOUBLE PRECISION
;;*        d(N-2)
;;*
;;*  TAU   (output) DOUBLE PRECISION
;;*        This is the shift.
;;*
;;*  TTYPE (output) INTEGER
;;*        Shift type.
;;*
;;*  Further Details
;;*  ===============
;;*  CNST1 = 9/16
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasq4 (i0  n0  z  pp  n0in  dmin  dmin1  dmin2  dn  dn1  dn2  tau  ttype  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-int-)) n0in )
	((-idx0- (-double-)) dmin )
	((-idx0- (-double-)) dmin1 )
	((-idx0- (-double-)) dmin2 )
	((-idx0- (-double-)) dn )
	((-idx0- (-double-)) dn1 )
	((-idx0- (-double-)) dn2 )
	((-idx0- (-double-)) tau )
	((-idx0- (-int-)) ttype )
	#{ dlasq4_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,double), IDX_PTR($pp,int), IDX_PTR($n0in,int), IDX_PTR($dmin,double), IDX_PTR($dmin1,double), IDX_PTR($dmin2,double), IDX_PTR($dn,double), IDX_PTR($dn1,double), IDX_PTR($dn2,double), IDX_PTR($tau,double), IDX_PTR($ttype,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasq5 <i0>  <n0>  <z>  <pp>  <tau>  <dmin>  <dmin1>  <dmin2>  <dn>  <dnm1>  <dnm2>  <ieee>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASQ5 computes one dqds transform in ping-pong form, one
;;*  version for IEEE machines another for non IEEE machines.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I0    (input) INTEGER
;;*        First index.
;;*
;;*  N0    (input) INTEGER
;;*        Last index.
;;*
;;*  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
;;*        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
;;*        an extra argument.
;;*
;;*  PP    (input) INTEGER
;;*        PP=0 for ping, PP=1 for pong.
;;*
;;*  TAU   (input) DOUBLE PRECISION
;;*        This is the shift.
;;*
;;*  DMIN  (output) DOUBLE PRECISION
;;*        Minimum value of d.
;;*
;;*  DMIN1 (output) DOUBLE PRECISION
;;*        Minimum value of d, excluding D( N0 ).
;;*
;;*  DMIN2 (output) DOUBLE PRECISION
;;*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
;;*
;;*  DN    (output) DOUBLE PRECISION
;;*        d(N0), the last value of d.
;;*
;;*  DNM1  (output) DOUBLE PRECISION
;;*        d(N0-1).
;;*
;;*  DNM2  (output) DOUBLE PRECISION
;;*        d(N0-2).
;;*
;;*  IEEE  (input) LOGICAL
;;*        Flag for IEEE or non IEEE arithmetic.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameter ..
;;*  =====================================================================

(de dlasq5 (i0  n0  z  pp  tau  dmin  dmin1  dmin2  dn  dnm1  dnm2  ieee  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-double-)) tau )
	((-idx0- (-double-)) dmin )
	((-idx0- (-double-)) dmin1 )
	((-idx0- (-double-)) dmin2 )
	((-idx0- (-double-)) dn )
	((-idx0- (-double-)) dnm1 )
	((-idx0- (-double-)) dnm2 )
	((-idx0- (-int-)) ieee )
	#{ dlasq5_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,double), IDX_PTR($pp,int), IDX_PTR($tau,double), IDX_PTR($dmin,double), IDX_PTR($dmin1,double), IDX_PTR($dmin2,double), IDX_PTR($dn,double), IDX_PTR($dnm1,double), IDX_PTR($dnm2,double), IDX_PTR($ieee,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasq6 <i0>  <n0>  <z>  <pp>  <dmin>  <dmin1>  <dmin2>  <dn>  <dnm1>  <dnm2>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASQ6 computes one dqd (shift equal to zero) transform in
;;*  ping-pong form, with protection against underflow and overflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  I0    (input) INTEGER
;;*        First index.
;;*
;;*  N0    (input) INTEGER
;;*        Last index.
;;*
;;*  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
;;*        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
;;*        an extra argument.
;;*
;;*  PP    (input) INTEGER
;;*        PP=0 for ping, PP=1 for pong.
;;*
;;*  DMIN  (output) DOUBLE PRECISION
;;*        Minimum value of d.
;;*
;;*  DMIN1 (output) DOUBLE PRECISION
;;*        Minimum value of d, excluding D( N0 ).
;;*
;;*  DMIN2 (output) DOUBLE PRECISION
;;*        Minimum value of d, excluding D( N0 ) and D( N0-1 ).
;;*
;;*  DN    (output) DOUBLE PRECISION
;;*        d(N0), the last value of d.
;;*
;;*  DNM1  (output) DOUBLE PRECISION
;;*        d(N0-1).
;;*
;;*  DNM2  (output) DOUBLE PRECISION
;;*        d(N0-2).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameter ..
;;*  =====================================================================

(de dlasq6 (i0  n0  z  pp  dmin  dmin1  dmin2  dn  dnm1  dnm2  )
	((-idx0- (-int-)) i0 )
	((-idx0- (-int-)) n0 )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) pp )
	((-idx0- (-double-)) dmin )
	((-idx0- (-double-)) dmin1 )
	((-idx0- (-double-)) dmin2 )
	((-idx0- (-double-)) dn )
	((-idx0- (-double-)) dnm1 )
	((-idx0- (-double-)) dnm2 )
	#{ dlasq6_(IDX_PTR($i0,int), IDX_PTR($n0,int), IDX_PTR($z,double), IDX_PTR($pp,int), IDX_PTR($dmin,double), IDX_PTR($dmin1,double), IDX_PTR($dmin2,double), IDX_PTR($dn,double), IDX_PTR($dnm1,double), IDX_PTR($dnm2,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasr <side>  <pivot>  <direct>  <m>  <n>  <c>  <s>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASR   performs the transformation
;;*
;;*     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )
;;*
;;*     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )
;;*
;;*  where A is an m by n real matrix and P is an orthogonal matrix,
;;*  consisting of a sequence of plane rotations determined by the
;;*  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
;;*  and z = n when SIDE = 'R' or 'r' ):
;;*
;;*  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then
;;*
;;*     P = P( z - 1 )*...*P( 2 )*P( 1 ),
;;*
;;*  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then
;;*
;;*     P = P( 1 )*P( 2 )*...*P( z - 1 ),
;;*
;;*  where  P( k ) is a plane rotation matrix for the following planes:
;;*
;;*     when  PIVOT = 'V' or 'v'  ( Variable pivot ),
;;*        the plane ( k, k + 1 )
;;*
;;*     when  PIVOT = 'T' or 't'  ( Top pivot ),
;;*        the plane ( 1, k + 1 )
;;*
;;*     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),
;;*        the plane ( k, z )
;;*
;;*  c( k ) and s( k )  must contain the  cosine and sine that define the
;;*  matrix  P( k ).  The two by two plane rotation part of the matrix
;;*  P( k ), R( k ), is assumed to be of the form
;;*
;;*     R( k ) = (  c( k )  s( k ) ).
;;*              ( -s( k )  c( k ) )
;;*
;;*  This version vectorises across rows of the array A when SIDE = 'L'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          Specifies whether the plane rotation matrix P is applied to
;;*          A on the left or the right.
;;*          = 'L':  Left, compute A := P*A
;;*          = 'R':  Right, compute A:= A*P'
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies whether P is a forward or backward sequence of
;;*          plane rotations.
;;*          = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )
;;*          = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )
;;*
;;*  PIVOT   (input) CHARACTER*1
;;*          Specifies the plane for which P(k) is a plane rotation
;;*          matrix.
;;*          = 'V':  Variable pivot, the plane (k,k+1)
;;*          = 'T':  Top pivot, the plane (1,k+1)
;;*          = 'B':  Bottom pivot, the plane (k,z)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  If m <= 1, an immediate
;;*          return is effected.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  If n <= 1, an
;;*          immediate return is effected.
;;*
;;*  C, S    (input) DOUBLE PRECISION arrays, dimension
;;*                  (M-1) if SIDE = 'L'
;;*                  (N-1) if SIDE = 'R'
;;*          c(k) and s(k) contain the cosine and sine that define the
;;*          matrix P(k).  The two by two plane rotation part of the
;;*          matrix P(k), R(k), is assumed to be of the form
;;*          R( k ) = (  c( k )  s( k ) ).
;;*                   ( -s( k )  c( k ) )
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The m by n matrix A.  On exit, A is overwritten by P*A if
;;*          SIDE = 'R' or by A*P' if SIDE = 'L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasr (side  pivot  direct  m  n  c  s  a  lda  )
	((-str-) side )
	((-str-) pivot )
	((-str-) direct )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ dlasr_($side->data, $pivot->data, $direct->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasrt <id>  <n>  <d>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Sort the numbers in D in increasing order (if ID = 'I') or
;;*  in decreasing order (if ID = 'D' ).
;;*
;;*  Use Quick Sort, reverting to Insertion sort on arrays of
;;*  size <= 20. Dimension of STACK limits N to about 2**32.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ID      (input) CHARACTER*1
;;*          = 'I': sort D in increasing order;
;;*          = 'D': sort D in decreasing order.
;;*
;;*  N       (input) INTEGER
;;*          The length of the array D.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the array to be sorted.
;;*          On exit, D has been sorted into increasing order
;;*          (D(1) <= ... <= D(N) ) or into decreasing order
;;*          (D(1) >= ... >= D(N) ), depending on ID.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasrt (id  n  d  info  )
	((-str-) id )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx0- (-int-)) info )
	#{ dlasrt_($id->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlassq <n>  <x>  <incx>  <scale>  <sumsq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASSQ  returns the values  scl  and  smsq  such that
;;*
;;*     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
;;*
;;*  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
;;*  assumed to be non-negative and  scl  returns the value
;;*
;;*     scl = max( scale, abs( x( i ) ) ).
;;*
;;*  scale and sumsq must be supplied in SCALE and SUMSQ and
;;*  scl and smsq are overwritten on SCALE and SUMSQ respectively.
;;*
;;*  The routine makes only one pass through the vector x.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements to be used from the vector X.
;;*
;;*  X       (input) DOUBLE PRECISION array, dimension (N)
;;*          The vector for which a scaled sum of squares is computed.
;;*             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector X.
;;*          INCX > 0.
;;*
;;*  SCALE   (input/output) DOUBLE PRECISION
;;*          On entry, the value  scale  in the equation above.
;;*          On exit, SCALE is overwritten with  scl , the scaling factor
;;*          for the sum of squares.
;;*
;;*  SUMSQ   (input/output) DOUBLE PRECISION
;;*          On entry, the value  sumsq  in the equation above.
;;*          On exit, SUMSQ is overwritten with  smsq , the basic sum of
;;*          squares from which  scl  has been factored out.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlassq (n  x  incx  scale  sumsq  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) sumsq )
	#{ dlassq_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($scale,double), IDX_PTR($sumsq,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasv2 <f>  <g>  <h>  <ssmin>  <ssmax>  <snr>  <csr>  <snl>  <csl>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASV2 computes the singular value decomposition of a 2-by-2
;;*  triangular matrix
;;*     [  F   G  ]
;;*     [  0   H  ].
;;*  On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
;;*  smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
;;*  right singular vectors for abs(SSMAX), giving the decomposition
;;*
;;*     [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
;;*     [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) DOUBLE PRECISION
;;*          The (1,1) element of the 2-by-2 matrix.
;;*
;;*  G       (input) DOUBLE PRECISION
;;*          The (1,2) element of the 2-by-2 matrix.
;;*
;;*  H       (input) DOUBLE PRECISION
;;*          The (2,2) element of the 2-by-2 matrix.
;;*
;;*  SSMIN   (output) DOUBLE PRECISION
;;*          abs(SSMIN) is the smaller singular value.
;;*
;;*  SSMAX   (output) DOUBLE PRECISION
;;*          abs(SSMAX) is the larger singular value.
;;*
;;*  SNL     (output) DOUBLE PRECISION
;;*  CSL     (output) DOUBLE PRECISION
;;*          The vector (CSL, SNL) is a unit left singular vector for the
;;*          singular value abs(SSMAX).
;;*
;;*  SNR     (output) DOUBLE PRECISION
;;*  CSR     (output) DOUBLE PRECISION
;;*          The vector (CSR, SNR) is a unit right singular vector for the
;;*          singular value abs(SSMAX).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Any input parameter may be aliased with any output parameter.
;;*
;;*  Barring over/underflow and assuming a guard digit in subtraction, all
;;*  output quantities are correct to within a few units in the last
;;*  place (ulps).
;;*
;;*  In IEEE arithmetic, the code works correctly if one matrix element is
;;*  infinite.
;;*
;;*  Overflow will not occur unless the largest singular value itself
;;*  overflows or is within a few ulps of overflow. (On machines with
;;*  partial overflow, like the Cray, overflow may occur if the largest
;;*  singular value is within a factor of 2 of overflow.)
;;*
;;*  Underflow is harmless if underflow is gradual. Otherwise, results
;;*  may correspond to a matrix modified by perturbations of size near
;;*  the underflow threshold.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasv2 (f  g  h  ssmin  ssmax  snr  csr  snl  csl  )
	((-idx0- (-double-)) f )
	((-idx0- (-double-)) g )
	((-idx0- (-double-)) h )
	((-idx0- (-double-)) ssmin )
	((-idx0- (-double-)) ssmax )
	((-idx0- (-double-)) snr )
	((-idx0- (-double-)) csr )
	((-idx0- (-double-)) snl )
	((-idx0- (-double-)) csl )
	#{ dlasv2_(IDX_PTR($f,double), IDX_PTR($g,double), IDX_PTR($h,double), IDX_PTR($ssmin,double), IDX_PTR($ssmax,double), IDX_PTR($snr,double), IDX_PTR($csr,double), IDX_PTR($snl,double), IDX_PTR($csl,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlaswp <n>  <a>  <lda>  <k1>  <k2>  <ipiv>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASWP performs a series of row interchanges on the matrix A.
;;*  One row interchange is initiated for each of rows K1 through K2 of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the matrix of column dimension N to which the row
;;*          interchanges will be applied.
;;*          On exit, the permuted matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*
;;*  K1      (input) INTEGER
;;*          The first element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  K2      (input) INTEGER
;;*          The last element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
;;*          The vector of pivot indices.  Only the elements in positions
;;*          K1 through K2 of IPIV are accessed.
;;*          IPIV(K) = L implies rows K and L are to be interchanged.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of IPIV.  If IPIV
;;*          is negative, the pivots are applied in reverse order.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by
;;*   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dlaswp (n  a  lda  k1  k2  ipiv  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) k1 )
	((-idx0- (-int-)) k2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) incx )
	#{ dlaswp_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($k1,int), IDX_PTR($k2,int), IDX_PTR($ipiv,int), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasy2 <ltranl>  <ltranr>  <isgn>  <n1>  <n2>  <tl>  <ldtl>  <tr>  <ldtr>  <b>  <ldb>  <scale>  <x>  <ldx>  <xnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
;;*
;;*         op(TL)*X + ISGN*X*op(TR) = SCALE*B,
;;*
;;*  where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
;;*  -1.  op(T) = T or T', where T' denotes the transpose of T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  LTRANL  (input) LOGICAL
;;*          On entry, LTRANL specifies the op(TL):
;;*             = .FALSE., op(TL) = TL,
;;*             = .TRUE., op(TL) = TL'.
;;*
;;*  LTRANR  (input) LOGICAL
;;*          On entry, LTRANR specifies the op(TR):
;;*            = .FALSE., op(TR) = TR,
;;*            = .TRUE., op(TR) = TR'.
;;*
;;*  ISGN    (input) INTEGER
;;*          On entry, ISGN specifies the sign of the equation
;;*          as described before. ISGN may only be 1 or -1.
;;*
;;*  N1      (input) INTEGER
;;*          On entry, N1 specifies the order of matrix TL.
;;*          N1 may only be 0, 1 or 2.
;;*
;;*  N2      (input) INTEGER
;;*          On entry, N2 specifies the order of matrix TR.
;;*          N2 may only be 0, 1 or 2.
;;*
;;*  TL      (input) DOUBLE PRECISION array, dimension (LDTL,2)
;;*          On entry, TL contains an N1 by N1 matrix.
;;*
;;*  LDTL    (input) INTEGER
;;*          The leading dimension of the matrix TL. LDTL >= max(1,N1).
;;*
;;*  TR      (input) DOUBLE PRECISION array, dimension (LDTR,2)
;;*          On entry, TR contains an N2 by N2 matrix.
;;*
;;*  LDTR    (input) INTEGER
;;*          The leading dimension of the matrix TR. LDTR >= max(1,N2).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,2)
;;*          On entry, the N1 by N2 matrix B contains the right-hand
;;*          side of the equation.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the matrix B. LDB >= max(1,N1).
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          On exit, SCALE contains the scale factor. SCALE is chosen
;;*          less than or equal to 1 to prevent the solution overflowing.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,2)
;;*          On exit, X contains the N1 by N2 solution.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the matrix X. LDX >= max(1,N1).
;;*
;;*  XNORM   (output) DOUBLE PRECISION
;;*          On exit, XNORM is the infinity-norm of the solution.
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, INFO is set to
;;*             0: successful exit.
;;*             1: TL and TR have too close eigenvalues, so TL or
;;*                TR is perturbed to get a nonsingular equation.
;;*          NOTE: In the interests of speed, this routine does not
;;*                check the inputs for errors.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasy2 (ltranl  ltranr  isgn  n1  n2  tl  ldtl  tr  ldtr  b  ldb  scale  x  ldx  xnorm  info  )
	((-idx0- (-int-)) ltranl )
	((-idx0- (-int-)) ltranr )
	((-idx0- (-int-)) isgn )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx2- (-double-)) tl )
	((-idx0- (-int-)) ldtl )
	((-idx2- (-double-)) tr )
	((-idx0- (-int-)) ldtr )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) scale )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) xnorm )
	((-idx0- (-int-)) info )
	#{ dlasy2_(IDX_PTR($ltranl,int), IDX_PTR($ltranr,int), IDX_PTR($isgn,int), IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($tl,double), IDX_PTR($ldtl,int), IDX_PTR($tr,double), IDX_PTR($ldtr,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($scale,double), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($xnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlasyf <uplo>  <n>  <nb>  <kb>  <a>  <lda>  <ipiv>  <w>  <ldw>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLASYF computes a partial factorization of a real symmetric matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method. The partial
;;*  factorization has the form:
;;*
;;*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or:
;;*        ( 0  U22 ) (  0   D  ) ( U12' U22' )
;;*
;;*  A  =  ( L11  0 ) (  D   0  ) ( L11' L21' )  if UPLO = 'L'
;;*        ( L21  I ) (  0  A22 ) (  0    I   )
;;*
;;*  where the order of D is at most NB. The actual order is returned in
;;*  the argument KB, and is either NB or NB-1, or N if N <= NB.
;;*
;;*  DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code
;;*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
;;*  A22 (if UPLO = 'L').
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NB      (input) INTEGER
;;*          The maximum number of columns of the matrix A that should be
;;*          factored.  NB should be at least 2 to allow for 2-by-2 pivot
;;*          blocks.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns of A that were actually factored.
;;*          KB is either NB-1 or NB, or N if N <= NB.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, A contains details of the partial factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If UPLO = 'U', only the last KB elements of IPIV are set;
;;*          if UPLO = 'L', only the first KB elements are set.
;;*
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  W       (workspace) DOUBLE PRECISION array, dimension (LDW,NB)
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W.  LDW >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlasyf (uplo  n  nb  kb  a  lda  ipiv  w  ldw  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) w )
	((-idx0- (-int-)) ldw )
	((-idx0- (-int-)) info )
	#{ dlasyf_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($w,double), IDX_PTR($ldw,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatbs <uplo>  <trans>  <diag>  <normin>  <n>  <kd>  <ab>  <ldab>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLATBS solves one of the triangular systems
;;*
;;*     A *x = s*b  or  A'*x = s*b
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular band matrix.  Here A' denotes the transpose of A, x and b
;;*  are n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine DTBSV is called.  If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b  (No transpose)
;;*          = 'T':  Solve A'* x = s*b  (Transpose)
;;*          = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of subdiagonals or superdiagonals in the
;;*          triangular matrix A.  KD >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first KD+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b  or  A'* x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) DOUBLE PRECISION array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, DTBSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine DTBSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A'*x = b.  The basic
;;*  algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call DTBSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatbs (uplo  trans  diag  normin  n  kd  ab  ldab  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) x )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) cnorm )
	((-idx0- (-int-)) info )
	#{ dlatbs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($x,double), IDX_PTR($scale,double), IDX_PTR($cnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatdf <ijob>  <n>  <z>  <ldz>  <rhs>  <rdsum>  <rdscal>  <ipiv>  <jpiv>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLATDF uses the LU factorization of the n-by-n matrix Z computed by
;;*  DGETC2 and computes a contribution to the reciprocal Dif-estimate
;;*  by solving Z * x = b for x, and choosing the r.h.s. b such that
;;*  the norm of x is as large as possible. On entry RHS = b holds the
;;*  contribution from earlier solved sub-systems, and on return RHS = x.
;;*
;;*  The factorization of Z returned by DGETC2 has the form Z = P*L*U*Q,
;;*  where P and Q are permutation matrices. L is lower triangular with
;;*  unit diagonal elements and U is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          IJOB = 2: First compute an approximative null-vector e
;;*              of Z using DGECON, e is normalized and solve for
;;*              Zx = +-e - f with the sign giving the greater value
;;*              of 2-norm(x). About 5 times as expensive as Default.
;;*          IJOB .ne. 2: Local look ahead strategy where all entries of
;;*              the r.h.s. b is choosen as either +1 or -1 (Default).
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Z.
;;*
;;*  Z       (input) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          On entry, the LU part of the factorization of the n-by-n
;;*          matrix Z computed by DGETC2:  Z = P * L * U * Q
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) DOUBLE PRECISION array, dimension N.
;;*          On entry, RHS contains contributions from other subsystems.
;;*          On exit, RHS contains the solution of the subsystem with
;;*          entries acoording to the value of IJOB (see above).
;;*
;;*  RDSUM   (input/output) DOUBLE PRECISION
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by DTGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when DTGSY2 is called by STGSYL.
;;*
;;*  RDSCAL  (input/output) DOUBLE PRECISION
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when DTGSY2 is called by
;;*                DTGSYL.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  This routine is a further developed implementation of algorithm
;;*  BSOLVE in [1] using complete pivoting in the LU factorization.
;;*
;;*  [1] Bo Kagstrom and Lars Westin,
;;*      Generalized Schur Methods with Condition Estimators for
;;*      Solving the Generalized Sylvester Equation, IEEE Transactions
;;*      on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751.
;;*
;;*  [2] Peter Poromaa,
;;*      On Efficient and Robust Estimators for the Separation
;;*      between two Regular Matrix Pairs with Applications in
;;*      Condition Estimation. Report IMINF-95.05, Departement of
;;*      Computing Science, Umea University, S-901 87 Umea, Sweden, 1995.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatdf (ijob  n  z  ldz  rhs  rdsum  rdscal  ipiv  jpiv  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) rhs )
	((-idx0- (-double-)) rdsum )
	((-idx0- (-double-)) rdscal )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	#{ dlatdf_(IDX_PTR($ijob,int), IDX_PTR($n,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($rhs,double), IDX_PTR($rdsum,double), IDX_PTR($rdscal,double), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatps <uplo>  <trans>  <diag>  <normin>  <n>  <ap>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLATPS solves one of the triangular systems
;;*
;;*     A *x = s*b  or  A'*x = s*b
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular matrix stored in packed form.  Here A' denotes the
;;*  transpose of A, x and b are n-element vectors, and s is a scaling
;;*  factor, usually less than or equal to 1, chosen so that the
;;*  components of x will be less than the overflow threshold.  If the
;;*  unscaled problem will not cause overflow, the Level 2 BLAS routine
;;*  DTPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
;;*  then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b  (No transpose)
;;*          = 'T':  Solve A'* x = s*b  (Transpose)
;;*          = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b  or  A'* x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) DOUBLE PRECISION array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, DTPSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine DTPSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A'*x = b.  The basic
;;*  algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call DTPSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatps (uplo  trans  diag  normin  n  ap  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) x )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) cnorm )
	((-idx0- (-int-)) info )
	#{ dlatps_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($x,double), IDX_PTR($scale,double), IDX_PTR($cnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatrd <uplo>  <n>  <nb>  <a>  <lda>  <e>  <tau>  <w>  <ldw>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLATRD reduces NB rows and columns of a real symmetric matrix A to
;;*  symmetric tridiagonal form by an orthogonal similarity
;;*  transformation Q' * A * Q, and returns the matrices V and W which are
;;*  needed to apply the transformation to the unreduced part of A.
;;*
;;*  If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
;;*  matrix, of which the upper triangle is supplied;
;;*  if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
;;*  matrix, of which the lower triangle is supplied.
;;*
;;*  This is an auxiliary routine called by DSYTRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U': Upper triangular
;;*          = 'L': Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of rows and columns to be reduced.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit:
;;*          if UPLO = 'U', the last NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements above the diagonal
;;*            with the array TAU, represent the orthogonal matrix Q as a
;;*            product of elementary reflectors;
;;*          if UPLO = 'L', the first NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements below the diagonal
;;*            with the array TAU, represent the  orthogonal matrix Q as a
;;*            product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= (1,N).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
;;*          elements of the last NB columns of the reduced matrix;
;;*          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
;;*          the first NB columns of the reduced matrix.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors, stored in
;;*          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
;;*          See Further Details.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (LDW,NB)
;;*          The n-by-nb matrix W required to update the unreduced part
;;*          of A.
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W. LDW >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n) H(n-1) . . . H(n-nb+1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
;;*  and tau in TAU(i-1).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the n-by-nb matrix V
;;*  which is needed, with W, to apply the transformation to the unreduced
;;*  part of the matrix, using a symmetric rank-2k update of the form:
;;*  A := A - V*W' - W*V'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5 and nb = 2:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  a   a   a   v4  v5 )              (  d                  )
;;*    (      a   a   v4  v5 )              (  1   d              )
;;*    (          a   1   v5 )              (  v1  1   a          )
;;*    (              d   1  )              (  v1  v2  a   a      )
;;*    (                  d  )              (  v1  v2  a   a   a  )
;;*
;;*  where d denotes a diagonal element of the reduced matrix, a denotes
;;*  an element of the original matrix that is unchanged, and vi denotes
;;*  an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatrd (uplo  n  nb  a  lda  e  tau  w  ldw  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) w )
	((-idx0- (-int-)) ldw )
	#{ dlatrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($w,double), IDX_PTR($ldw,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatrs <uplo>  <trans>  <diag>  <normin>  <n>  <a>  <lda>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLATRS solves one of the triangular systems
;;*
;;*     A *x = s*b  or  A'*x = s*b
;;*
;;*  with scaling to prevent overflow.  Here A is an upper or lower
;;*  triangular matrix, A' denotes the transpose of A, x and b are
;;*  n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b  (No transpose)
;;*          = 'T':  Solve A'* x = s*b  (Transpose)
;;*          = 'C':  Solve A'* x = s*b  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max (1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b  or  A'* x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) DOUBLE PRECISION array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, DTRSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine DTRSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A'*x = b.  The basic
;;*  algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call DTRSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatrs (uplo  trans  diag  normin  n  a  lda  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) cnorm )
	((-idx0- (-int-)) info )
	#{ dlatrs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($scale,double), IDX_PTR($cnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatrz <m>  <n>  <l>  <a>  <lda>  <tau>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLATRZ factors the M-by-(M+L) real upper trapezoidal matrix
;;*  [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means
;;*  of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal
;;*  matrix and, R and A1 are M-by-M upper triangular matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing the
;;*          meaningful part of the Householder vectors. N-M >= L >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements N-L+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          orthogonal matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an l element vector. tau and z( k )
;;*  are chosen to annihilate the elements of the kth row of A2.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A2, such that the elements of z( k ) are
;;*  in  a( k, l + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A1.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatrz (m  n  l  a  lda  tau  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	#{ dlatrz_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlatzm <side>  <m>  <n>  <v>  <incv>  <tau>  <c1>  <c2>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine DORMRZ.
;;*
;;*  DLATZM applies a Householder matrix generated by DTZRQF to a matrix.
;;*
;;*  Let P = I - tau*u*u',   u = ( 1 ),
;;*                              ( v )
;;*  where v is an (m-1) vector if SIDE = 'L', or a (n-1) vector if
;;*  SIDE = 'R'.
;;*
;;*  If SIDE equals 'L', let
;;*         C = [ C1 ] 1
;;*             [ C2 ] m-1
;;*               n
;;*  Then C is overwritten by P*C.
;;*
;;*  If SIDE equals 'R', let
;;*         C = [ C1, C2 ] m
;;*                1  n-1
;;*  Then C is overwritten by C*P.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form P * C
;;*          = 'R': form C * P
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) DOUBLE PRECISION array, dimension
;;*                  (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of P. V is not used
;;*          if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0
;;*
;;*  TAU     (input) DOUBLE PRECISION
;;*          The value tau in the representation of P.
;;*
;;*  C1      (input/output) DOUBLE PRECISION array, dimension
;;*                         (LDC,N) if SIDE = 'L'
;;*                         (M,1)   if SIDE = 'R'
;;*          On entry, the n-vector C1 if SIDE = 'L', or the m-vector C1
;;*          if SIDE = 'R'.
;;*
;;*          On exit, the first row of P*C if SIDE = 'L', or the first
;;*          column of C*P if SIDE = 'R'.
;;*
;;*  C2      (input/output) DOUBLE PRECISION array, dimension
;;*                         (LDC, N)   if SIDE = 'L'
;;*                         (LDC, N-1) if SIDE = 'R'
;;*          On entry, the (m - 1) x n matrix C2 if SIDE = 'L', or the
;;*          m x (n - 1) matrix C2 if SIDE = 'R'.
;;*
;;*          On exit, rows 2:m of P*C if SIDE = 'L', or columns 2:m of C*P
;;*          if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the arrays C1 and C2. LDC >= (1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                      (N) if SIDE = 'L'
;;*                      (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlatzm (side  m  n  v  incv  tau  c1  c2  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) v )
	((-idx0- (-int-)) incv )
	((-idx0- (-double-)) tau )
	((-idx2- (-double-)) c1 )
	((-idx2- (-double-)) c2 )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	#{ dlatzm_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($incv,int), IDX_PTR($tau,double), IDX_PTR($c1,double), IDX_PTR($c2,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlauu2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAUU2 computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the unblocked form of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlauu2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dlauu2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dlauum <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DLAUUM computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the blocked form of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dlauum (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dlauum_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dopgtr <uplo>  <n>  <ap>  <tau>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DOPGTR generates a real orthogonal matrix Q which is defined as the
;;*  product of n-1 elementary reflectors H(i) of order n, as returned by
;;*  DSPTRD using packed storage:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to DSPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to DSPTRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The vectors which define the elementary reflectors, as
;;*          returned by DSPTRD.
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DSPTRD.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          The N-by-N orthogonal matrix Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N-1)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dopgtr (uplo  n  ap  tau  q  ldq  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dopgtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($tau,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dopmtr <side>  <uplo>  <trans>  <m>  <n>  <ap>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DOPMTR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by DSPTRD using packed
;;*  storage:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to DSPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to DSPTRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension
;;*                               (M*(M+1)/2) if SIDE = 'L'
;;*                               (N*(N+1)/2) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by DSPTRD.  AP is modified by the routine but
;;*          restored on exit.
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (M-1) if SIDE = 'L'
;;*                                     or (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DSPTRD.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                                   (N) if SIDE = 'L'
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dopmtr (side  uplo  trans  m  n  ap  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dopmtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorg2l <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORG2L generates an m by n real matrix Q with orthonormal columns,
;;*  which is defined as the last n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by DGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQLF.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorg2l (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorg2l_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorg2r <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORG2R generates an m by n real matrix Q with orthonormal columns,
;;*  which is defined as the first n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by DGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQRF.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorg2r (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorg2r_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgbr <vect>  <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGBR generates one of the real orthogonal matrices Q or P**T
;;*  determined by DGEBRD when reducing a real matrix A to bidiagonal
;;*  form: A = Q * B * P**T.  Q and P**T are defined as products of
;;*  elementary reflectors H(i) or G(i) respectively.
;;*
;;*  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
;;*  is of order M:
;;*  if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
;;*  columns of Q, where m >= n >= k;
;;*  if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
;;*  M-by-M matrix.
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
;;*  is of order N:
;;*  if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
;;*  rows of P**T, where n >= m >= k;
;;*  if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
;;*  an N-by-N matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether the matrix Q or the matrix P**T is
;;*          required, as defined in the transformation applied by DGEBRD:
;;*          = 'Q':  generate Q;
;;*          = 'P':  generate P**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q or P**T to be returned.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q or P**T to be returned.
;;*          N >= 0.
;;*          If VECT = 'Q', M >= N >= min(M,K);
;;*          if VECT = 'P', N >= M >= min(N,K).
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original M-by-K
;;*          matrix reduced by DGEBRD.
;;*          If VECT = 'P', the number of rows in the original K-by-N
;;*          matrix reduced by DGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by DGEBRD.
;;*          On exit, the M-by-N matrix Q or P**T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension
;;*                                (min(M,K)) if VECT = 'Q'
;;*                                (min(N,K)) if VECT = 'P'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i), which determines Q or P**T, as
;;*          returned by DGEBRD in its array argument TAUQ or TAUP.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,min(M,N)).
;;*          For optimum performance LWORK >= min(M,N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgbr (vect  m  n  k  a  lda  tau  work  lwork  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorgbr_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorghr <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGHR generates a real orthogonal matrix Q which is defined as the
;;*  product of IHI-ILO elementary reflectors of order N, as returned by
;;*  DGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of DGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by DGEHRD.
;;*          On exit, the N-by-N orthogonal matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEHRD.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= IHI-ILO.
;;*          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorghr (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorghr_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgl2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGL2 generates an m by n real matrix Q with orthonormal rows,
;;*  which is defined as the first m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by DGELQF in the first k rows of its array argument A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGELQF.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgl2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorgl2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorglq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
;;*  which is defined as the first M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by DGELQF in the first k rows of its array argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGELQF.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorglq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorglq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgql <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGQL generates an M-by-N real matrix Q with orthonormal columns,
;;*  which is defined as the last N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by DGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQLF.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgql (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorgql_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgqr <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGQR generates an M-by-N real matrix Q with orthonormal columns,
;;*  which is defined as the first N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by DGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQRF.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgqr (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorgqr_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgr2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGR2 generates an m by n real matrix Q with orthonormal rows,
;;*  which is defined as the last m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by DGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGERQF.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgr2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorgr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgrq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGRQ generates an M-by-N real matrix Q with orthonormal rows,
;;*  which is defined as the last M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by DGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGERQF.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgrq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorgrq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorgtr <uplo>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORGTR generates a real orthogonal matrix Q which is defined as the
;;*  product of n-1 elementary reflectors of order N, as returned by
;;*  DSYTRD:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from DSYTRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from DSYTRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by DSYTRD.
;;*          On exit, the N-by-N orthogonal matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DSYTRD.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N-1).
;;*          For optimum performance LWORK >= (N-1)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorgtr (uplo  n  a  lda  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dorgtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorm2l <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORM2L overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQLF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorm2l (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorm2l_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorm2r <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORM2R overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQRF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorm2r (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorm2r_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormbr <vect>  <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      P * C          C * P
;;*  TRANS = 'T':      P**T * C       C * P**T
;;*
;;*  Here Q and P**T are the orthogonal matrices determined by DGEBRD when
;;*  reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
;;*  P**T are defined as products of elementary reflectors H(i) and G(i)
;;*  respectively.
;;*
;;*  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
;;*  order of the orthogonal matrix Q or P**T that is applied.
;;*
;;*  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
;;*  if nq >= k, Q = H(1) H(2) . . . H(k);
;;*  if nq < k, Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
;;*  if k < nq, P = G(1) G(2) . . . G(k);
;;*  if k >= nq, P = G(1) G(2) . . . G(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'Q': apply Q or Q**T;
;;*          = 'P': apply P or P**T.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q, Q**T, P or P**T from the Left;
;;*          = 'R': apply Q, Q**T, P or P**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q  or P;
;;*          = 'T':  Transpose, apply Q**T or P**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original
;;*          matrix reduced by DGEBRD.
;;*          If VECT = 'P', the number of rows in the original
;;*          matrix reduced by DGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                                (LDA,min(nq,K)) if VECT = 'Q'
;;*                                (LDA,nq)        if VECT = 'P'
;;*          The vectors which define the elementary reflectors H(i) and
;;*          G(i), whose products determine the matrices Q and P, as
;;*          returned by DGEBRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If VECT = 'Q', LDA >= max(1,nq);
;;*          if VECT = 'P', LDA >= max(1,min(nq,K)).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (min(nq,K))
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i) which determines Q or P, as returned
;;*          by DGEBRD in the array argument TAUQ or TAUP.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
;;*          or P*C or P**T*C or C*P or C*P**T.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dormbr (vect  side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) vect )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormbr_($vect->data, $side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormhr <side>  <trans>  <m>  <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMHR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  IHI-ILO elementary reflectors, as returned by DGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of DGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
;;*          ILO = 1 and IHI = 0, if M = 0;
;;*          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
;;*          ILO = 1 and IHI = 0, if N = 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by DGEHRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEHRD.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dormhr (side  trans  m  n  ilo  ihi  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormhr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dorml2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORML2 overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGELQF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dorml2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dorml2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormlq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMLQ overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGELQF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dormlq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormlq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormql <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMQL overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQLF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dormql (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormql_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormqr <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMQR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGEQRF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dormqr (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormqr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormr2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMR2 overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGERQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGERQF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dormr2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dormr2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormr3 <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMR3 overwrites the general real m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'T', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'T',
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by DTZRZF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'T': apply Q' (Transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DTZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DTZRZF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dormr3 (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dormr3_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormrq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMRQ overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DGERQF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dormrq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormrq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormrz <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMRZ overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          DTZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DTZRZF.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dormrz (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormrz_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dormtr <side>  <uplo>  <trans>  <m>  <n>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DORMTR overwrites the general real M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'T':      Q**T * C       C * Q**T
;;*
;;*  where Q is a real orthogonal matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by DSYTRD:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**T from the Left;
;;*          = 'R': apply Q or Q**T from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from DSYTRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from DSYTRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'T':  Transpose, apply Q**T.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by DSYTRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) DOUBLE PRECISION array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by DSYTRD.
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dormtr (side  uplo  trans  m  n  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dormtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbcon <uplo>  <n>  <kd>  <ab>  <ldab>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite band matrix using the
;;*  Cholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm (or infinity-norm) of the symmetric band matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbcon (uplo  n  kd  ab  ldab  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dpbcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbequ <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBEQU computes row and column scalings intended to equilibrate a
;;*  symmetric positive definite band matrix A and reduce its condition
;;*  number (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular of A is stored;
;;*          = 'L':  Lower triangular of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB     (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) DOUBLE PRECISION
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbequ (uplo  n  kd  ab  ldab  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ dpbequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbrfs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite
;;*  and banded, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  AFB     (input) DOUBLE PRECISION array, dimension (LDAFB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T of the band matrix A as computed by
;;*          DPBTRF, in the same storage format as A (see AB).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DPBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbrfs (uplo  n  kd  nrhs  ab  ldab  afb  ldafb  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dpbrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbstf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBSTF computes a split Cholesky factorization of a real
;;*  symmetric positive definite band matrix A.
;;*
;;*  This routine is designed to be used in conjunction with DSBGST.
;;*
;;*  The factorization has the form  A = S**T*S  where S is a band matrix
;;*  of the same bandwidth as A and the following structure:
;;*
;;*    S = ( U    )
;;*        ( M  L )
;;*
;;*  where U is upper triangular of order m = (n+kd)/2, and L is lower
;;*  triangular of order n-m.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first kd+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the factor S from the split Cholesky
;;*          factorization A = S**T*S. See Further Details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the factorization could not be completed,
;;*               because the updated element a(i,i) was negative; the
;;*               matrix A is not positive definite.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 7, KD = 2:
;;*
;;*  S = ( s11  s12  s13                     )
;;*      (      s22  s23  s24                )
;;*      (           s33  s34                )
;;*      (                s44                )
;;*      (           s53  s54  s55           )
;;*      (                s64  s65  s66      )
;;*      (                     s75  s76  s77 )
;;*
;;*  If UPLO = 'U', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*   *    *   a13  a24  a35  a46  a57   *    *   s13  s24  s53  s64  s75
;;*   *   a12  a23  a34  a45  a56  a67   *   s12  s23  s34  s54  s65  s76
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*
;;*  If UPLO = 'L', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*  a21  a32  a43  a54  a65  a76   *   s12  s23  s34  s54  s65  s76   *
;;*  a31  a42  a53  a64  a64   *    *   s13  s24  s53  s64  s75   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbstf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ dpbstf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbsv <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular band matrix, and L is a lower
;;*  triangular band matrix, with the same number of superdiagonals or
;;*  subdiagonals as A.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**T*U or A = L*L**T of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dpbsv (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dpbsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbsvx <fact>  <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
;;*  compute the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**T * U,  if UPLO = 'U', or
;;*        A = L * L**T,  if UPLO = 'L',
;;*     where U is an upper triangular band matrix, and L is a lower
;;*     triangular band matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AB and AFB will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right-hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array, except
;;*          if FACT = 'F' and EQUED = 'Y', then A must contain the
;;*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A
;;*          is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  AFB     (input or output) DOUBLE PRECISION array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the band matrix
;;*          A, in the same storage format as A (see AB).  If EQUED = 'Y',
;;*          then AFB is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11  a12  a13
;;*          a22  a23  a24
;;*               a33  a34  a35
;;*                    a44  a45  a46
;;*                         a55  a56
;;*     (aij=conjg(aji))         a66
;;*
;;*  Band storage of the upper triangle of A:
;;*
;;*      *    *   a13  a24  a35  a46
;;*      *   a12  a23  a34  a45  a56
;;*     a11  a22  a33  a44  a55  a66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*     a11  a22  a33  a44  a55  a66
;;*     a21  a32  a43  a54  a65   *
;;*     a31  a42  a53  a64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbsvx (fact  uplo  n  kd  nrhs  ab  ldab  afb  ldafb  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-str-) equed )
	((-idx1- (-double-)) s )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dpbsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), $equed->data, IDX_PTR($s,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbtf2 <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBTF2 computes the Cholesky factorization of a real symmetric
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix, U' is the transpose of U, and
;;*  L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbtf2 (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ dpbtf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbtrf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBTRF computes the Cholesky factorization of a real symmetric
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L  * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**T*U or A = L*L**T of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  Contributed by
;;*  Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpbtrf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ dpbtrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpbtrs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPBTRS solves a system of linear equations A*X = B with a symmetric
;;*  positive definite band matrix A using the Cholesky factorization
;;*  A = U**T*U or A = L*L**T computed by DPBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dpbtrs (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dpbtrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpocon <uplo>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite matrix using the
;;*  Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by DPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm (or infinity-norm) of the symmetric matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpocon (uplo  n  a  lda  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dpocon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpoequ <n>  <a>  <lda>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOEQU computes row and column scalings intended to equilibrate a
;;*  symmetric positive definite matrix A and reduce its condition number
;;*  (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The N-by-N symmetric positive definite matrix whose scaling
;;*          factors are to be computed.  Only the diagonal elements of A
;;*          are referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) DOUBLE PRECISION
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpoequ (n  a  lda  s  scond  amax  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ dpoequ_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dporfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPORFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite,
;;*  and provides error bounds and backward error estimates for the
;;*  solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) DOUBLE PRECISION array, dimension (LDAF,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by DPOTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DPOTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dporfs (uplo  n  nrhs  a  lda  af  ldaf  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dporfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dposv <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**T* U,  if UPLO = 'U', or
;;*     A = L * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dposv (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dposv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dposvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
;;*  compute the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**T* U,  if UPLO = 'U', or
;;*        A = L * L**T,  if UPLO = 'L',
;;*     where U is an upper triangular matrix and L is a lower triangular
;;*     matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  A and AF will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A, except if FACT = 'F' and
;;*          EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AF is the factored form
;;*          of the equilibrated matrix diag(S)*A*diag(S).
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the original
;;*          matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dposvx (fact  uplo  n  nrhs  a  lda  af  ldaf  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-str-) equed )
	((-idx1- (-double-)) s )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dposvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), $equed->data, IDX_PTR($s,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpotf2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOTF2 computes the Cholesky factorization of a real symmetric
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U'*U  or A = L*L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpotf2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dpotf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpotrf <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOTRF computes the Cholesky factorization of a real symmetric
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L  * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the block version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpotrf (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dpotrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpotri <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOTRI computes the inverse of a real symmetric positive definite
;;*  matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
;;*  computed by DPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, as computed by
;;*          DPOTRF.
;;*          On exit, the upper or lower triangle of the (symmetric)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dpotri (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dpotri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpotrs <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPOTRS solves a system of linear equations A*X = B with a symmetric
;;*  positive definite matrix A using the Cholesky factorization
;;*  A = U**T*U or A = L*L**T computed by DPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by DPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpotrs (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dpotrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dppcon <uplo>  <n>  <ap>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite packed matrix using
;;*  the Cholesky factorization A = U**T*U or A = L*L**T computed by
;;*  DPPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm (or infinity-norm) of the symmetric matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dppcon (uplo  n  ap  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dppcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dppequ <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPEQU computes row and column scalings intended to equilibrate a
;;*  symmetric positive definite matrix A in packed storage and reduce
;;*  its condition number (with respect to the two-norm).  S contains the
;;*  scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
;;*  B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
;;*  This choice of S puts the condition number of B within a factor N of
;;*  the smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) DOUBLE PRECISION
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dppequ (uplo  n  ap  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ dppequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, as computed by DPPTRF/ZPPTRF,
;;*          packed columnwise in a linear array in the same format as A
;;*          (see AP).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DPPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpprfs (uplo  n  nrhs  ap  afp  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) afp )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dpprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dppsv <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**T* U,  if UPLO = 'U', or
;;*     A = L * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, in the same storage
;;*          format as A.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dppsv (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dppsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dppsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to
;;*  compute the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**T* U,  if UPLO = 'U', or
;;*        A = L * L**T,  if UPLO = 'L',
;;*     where U is an upper triangular matrix and L is a lower triangular
;;*     matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFP contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AP and AFP will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array, except if FACT = 'F'
;;*          and EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  The j-th column of A is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  AFP     (input or output) DOUBLE PRECISION array, dimension
;;*                            (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U'*U or A = L*L', in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AFP is the factored
;;*          form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U'*U or A = L*L' of the original matrix A.
;;*
;;*          If FACT = 'E', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U'*U or A = L*L' of the equilibrated
;;*          matrix A (see the description of AP for the form of the
;;*          equilibrated matrix).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dppsvx (fact  uplo  n  nrhs  ap  afp  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) afp )
	((-str-) equed )
	((-idx1- (-double-)) s )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dppsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), $equed->data, IDX_PTR($s,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpptrf <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPTRF computes the Cholesky factorization of a real symmetric
;;*  positive definite matrix A stored in packed format.
;;*
;;*  The factorization has the form
;;*     A = U**T * U,  if UPLO = 'U', or
;;*     A = L  * L**T,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**T*U or A = L*L**T, in the same
;;*          storage format as A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpptrf (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx0- (-int-)) info )
	#{ dpptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpptri <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPTRI computes the inverse of a real symmetric positive definite
;;*  matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
;;*  computed by DPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor is stored in AP;
;;*          = 'L':  Lower triangular factor is stored in AP.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**T*U or A = L*L**T, packed columnwise as
;;*          a linear array.  The j-th column of U or L is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*          On exit, the upper or lower triangle of the (symmetric)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpptri (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx0- (-int-)) info )
	#{ dpptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpptrs <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPPTRS solves a system of linear equations A*X = B with a symmetric
;;*  positive definite matrix A in packed storage using the Cholesky
;;*  factorization A = U**T*U or A = L*L**T computed by DPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**T*U or A = L*L**T, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dpptrs (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dpptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dptcon <n>  <d>  <e>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTCON computes the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric positive definite tridiagonal matrix
;;*  using the factorization A = L*D*L**T or A = U**T*D*U computed by
;;*  DPTTRF.
;;*
;;*  Norm(inv(A)) is computed by a direct method, and the reciprocal of
;;*  the condition number is computed as
;;*               RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization of A, as computed by DPTTRF.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the unit bidiagonal factor
;;*          U or L from the factorization of A,  as computed by DPTTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the
;;*          1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The method used is described in Nicholas J. Higham, "Efficient
;;*  Algorithms for Computing the Condition Number of a Tridiagonal
;;*  Matrix", SIAM J. Sci. Stat. Comput., Vol. 7, No. 1, January 1986.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dptcon (n  d  e  anorm  rcond  work  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dptcon_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric positive definite tridiagonal matrix by first factoring the
;;*  matrix using DPTTRF, and then calling DBDSQR to compute the singular
;;*  values of the bidiagonal factor.
;;*
;;*  This routine computes the eigenvalues of the positive definite
;;*  tridiagonal matrix to high relative accuracy.  This means that if the
;;*  eigenvalues range over many orders of magnitude in size, then the
;;*  small eigenvalues and corresponding eigenvectors will be computed
;;*  more accurately than, for example, with the standard QR method.
;;*
;;*  The eigenvectors of a full or band symmetric positive definite matrix
;;*  can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to
;;*  reduce this matrix to tridiagonal form. (The reduction to tridiagonal
;;*  form, however, may preclude the possibility of obtaining high
;;*  relative accuracy in the small eigenvalues of the original matrix, if
;;*  these eigenvalues range over many orders of magnitude.)
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvectors of original symmetric
;;*                  matrix also.  Array Z contains the orthogonal
;;*                  matrix used to reduce the original matrix to
;;*                  tridiagonal form.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal
;;*          matrix.
;;*          On normal exit, D contains the eigenvalues, in descending
;;*          order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          On entry, if COMPZ = 'V', the orthogonal matrix used in the
;;*          reduction to tridiagonal form.
;;*          On exit, if COMPZ = 'V', the orthonormal eigenvectors of the
;;*          original symmetric matrix;
;;*          if COMPZ = 'I', the orthonormal eigenvectors of the
;;*          tridiagonal matrix.
;;*          If INFO > 0 on exit, Z contains the eigenvectors associated
;;*          with only the stored eigenvalues.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          COMPZ = 'V' or 'I', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, and i is:
;;*                <= N  the Cholesky factorization of the matrix could
;;*                      not be performed because the i-th principal minor
;;*                      was not positive definite.
;;*                > N   the SVD algorithm failed to converge;
;;*                      if INFO = N+i, i off-diagonal elements of the
;;*                      bidiagonal factor did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dpteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dptrfs <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric positive definite
;;*  and tridiagonal, and provides error bounds and backward error
;;*  estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix A.
;;*
;;*  DF      (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization computed by DPTTRF.
;;*
;;*  EF      (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal factor
;;*          L from the factorization computed by DPTTRF.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DPTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dptrfs (n  nrhs  d  e  df  ef  b  ldb  x  ldx  ferr  berr  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) df )
	((-idx1- (-double-)) ef )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dptrfs_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($df,double), IDX_PTR($ef,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dptsv <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTSV computes the solution to a real system of linear equations
;;*  A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
;;*  matrix, and X and B are N-by-NRHS matrices.
;;*
;;*  A is factored as A = L*D*L**T, and the factored form of A is then
;;*  used to solve the system of equations.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the factorization A = L*D*L**T.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L**T factorization of
;;*          A.  (E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U**T*D*U factorization of A.)
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the solution has not been
;;*                computed.  The factorization has not been completed
;;*                unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de dptsv (n  nrhs  d  e  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dptsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dptsvx <fact>  <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTSVX uses the factorization A = L*D*L**T to compute the solution
;;*  to a real system of linear equations A*X = B, where A is an N-by-N
;;*  symmetric positive definite tridiagonal matrix and X and B are
;;*  N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the matrix A is factored as A = L*D*L**T, where L
;;*     is a unit lower bidiagonal matrix and D is diagonal.  The
;;*     factorization can also be regarded as having the form
;;*     A = U**T*D*U.
;;*
;;*  2. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, DF and EF contain the factored form of A.
;;*                  D, E, DF, and EF will not be modified.
;;*          = 'N':  The matrix A will be copied to DF and EF and
;;*                  factored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix A.
;;*
;;*  DF      (input or output) DOUBLE PRECISION array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**T factorization of A.
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**T factorization of A.
;;*
;;*  EF      (input or output) DOUBLE PRECISION array, dimension (N-1)
;;*          If FACT = 'F', then EF is an input argument and on entry
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**T factorization of A.
;;*          If FACT = 'N', then EF is an output argument and on exit
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**T factorization of A.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal condition number of the matrix A.  If RCOND
;;*          is less than the machine precision (in particular, if
;;*          RCOND = 0), the matrix is singular to working precision.
;;*          This condition is indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in any
;;*          element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dptsvx (fact  n  nrhs  d  e  df  ef  b  ldb  x  ldx  rcond  ferr  berr  work  info  )
	((-str-) fact )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) df )
	((-idx1- (-double-)) ef )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dptsvx_($fact->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($df,double), IDX_PTR($ef,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpttrf <n>  <d>  <e>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTTRF computes the L*D*L' factorization of a real symmetric
;;*  positive definite tridiagonal matrix A.  The factorization may also
;;*  be regarded as having the form A = U'*D*U.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the L*D*L' factorization of A.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L' factorization of A.
;;*          E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U'*D*U factorization of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite; if k < N, the factorization could not
;;*               be completed, while if k = N, the factorization was
;;*               completed, but D(N) = 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dpttrf (n  d  e  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-int-)) info )
	#{ dpttrf_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dpttrs <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTTRS solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the L*D*L' factorization of A computed by DPTTRF.  D is a
;;*  diagonal matrix specified in the vector D, L is a unit bidiagonal
;;*  matrix whose subdiagonal is specified in the vector E, and X and B
;;*  are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          L*D*L' factorization of A.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal factor
;;*          L from the L*D*L' factorization of A.  E can also be regarded
;;*          as the superdiagonal of the unit bidiagonal factor U from the
;;*          factorization A = U'*D*U.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dpttrs (n  nrhs  d  e  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dpttrs_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dptts2 <n>  <nrhs>  <d>  <e>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DPTTS2 solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the L*D*L' factorization of A computed by DPTTRF.  D is a
;;*  diagonal matrix specified in the vector D, L is a unit bidiagonal
;;*  matrix whose subdiagonal is specified in the vector E, and X and B
;;*  are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          L*D*L' factorization of A.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the unit bidiagonal factor
;;*          L from the L*D*L' factorization of A.  E can also be regarded
;;*          as the superdiagonal of the unit bidiagonal factor U from the
;;*          factorization A = U'*D*U.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dptts2 (n  nrhs  d  e  b  ldb  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ dptts2_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (drscl <n>  <sa>  <sx>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DRSCL multiplies an n-element real vector x by the real scalar 1/a.
;;*  This is done without overflow or underflow as long as
;;*  the final result x/a does not overflow or underflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of components of the vector x.
;;*
;;*  SA      (input) DOUBLE PRECISION
;;*          The scalar a which is used to divide each component of x.
;;*          SA must be >= 0, or the subroutine will divide by zero.
;;*
;;*  SX      (input/output) DOUBLE PRECISION array, dimension
;;*                         (1+(N-1)*abs(INCX))
;;*          The n-element vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector SX.
;;*          > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1< i<= n
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de drscl (n  sa  sx  incx  )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) sa )
	((-idx1- (-double-)) sx )
	((-idx0- (-int-)) incx )
	#{ drscl_(IDX_PTR($n,int), IDX_PTR($sa,double), IDX_PTR($sx,double), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbevd <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBEVD computes all the eigenvalues and, optionally, eigenvectors of
;;*  a real symmetric band matrix A. If eigenvectors are desired, it uses
;;*  a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          IF N <= 1,                LWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 2, LWORK must be at least 2*N.
;;*          If JOBZ  = 'V' and N > 2, LWORK must be at least
;;*                         ( 1 + 5*N + 2*N**2 ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array LIWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 2, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbevd (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dsbevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbev <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBEV computes all the eigenvalues and, optionally, eigenvectors of
;;*  a real symmetric band matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbev (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsbev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbevx <jobz>  <range>  <uplo>  <n>  <kd>  <ab>  <ldab>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric band matrix A.  Eigenvalues and eigenvectors can
;;*  be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
;;*                         reduction to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'V', then
;;*          LDQ >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AB to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbevx (jobz  range  uplo  n  kd  ab  ldab  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dsbevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbgst <vect>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <x>  <ldx>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBGST reduces a real symmetric-definite banded generalized
;;*  eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
;;*  such that C has the same bandwidth as A.
;;*
;;*  B must have been previously factorized as S**T*S by DPBSTF, using a
;;*  split Cholesky factorization. A is overwritten by C = X**T*A*X, where
;;*  X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
;;*  bandwidth of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form the transformation matrix X;
;;*          = 'V':  form X.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= KB >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the transformed matrix X**T*A*X, stored in the same
;;*          format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input) DOUBLE PRECISION array, dimension (LDBB,N)
;;*          The banded factor S from the split Cholesky factorization of
;;*          B, as returned by DPBSTF, stored in the first KB+1 rows of
;;*          the array.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,N)
;;*          If VECT = 'V', the n-by-n matrix X.
;;*          If VECT = 'N', the array X is not referenced.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.
;;*          LDX >= max(1,N) if VECT = 'V'; LDX >= 1 otherwise.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbgst (vect  uplo  n  ka  kb  ab  ldab  bb  ldbb  x  ldx  work  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsbgst_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbgvd <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite banded eigenproblem, of the
;;*  form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
;;*  banded, and B is also positive definite.  If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KB >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) DOUBLE PRECISION array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**T*S, as returned by DPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i).  The eigenvectors are
;;*          normalized so Z**T*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= 3*N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if LIWORK > 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then DPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbgvd (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dsbgvd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbgv <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
;;*  and banded, and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) DOUBLE PRECISION array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**T*S, as returned by DPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**T*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then DPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dsbgv (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsbgv_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbgvx <jobz>  <range>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a real generalized symmetric-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
;;*  and banded, and B is also positive definite.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either all eigenvalues,
;;*  a range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KB >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) DOUBLE PRECISION array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**T*S, as returned by DPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the n-by-n matrix used in the reduction of
;;*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
;;*          and consequently C to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'N',
;;*          LDQ >= 1. If JOBZ = 'V', LDQ >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i).  The eigenvectors are
;;*          normalized so Z**T*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (7N)
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (5N)
;;*
;;*  IFAIL   (input) INTEGER array, dimension (M)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvalues that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0 : successful exit
;;*          < 0 : if INFO = -i, the i-th argument had an illegal value
;;*          <= N: if INFO = i, then i eigenvectors failed to converge.
;;*                  Their indices are stored in IFAIL.
;;*          > N : DPBSTF returned an error code; i.e.,
;;*                if INFO = N + i, for 1 <= i <= N, then the leading
;;*                minor of order i of B is not positive definite.
;;*                The factorization of B could not be completed and
;;*                no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbgvx (jobz  range  uplo  n  ka  kb  ab  ldab  bb  ldbb  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dsbgvx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsbtrd <vect>  <uplo>  <n>  <kd>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSBTRD reduces a real symmetric band matrix A to symmetric
;;*  tridiagonal form T by an orthogonal similarity transformation:
;;*  Q**T * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form Q;
;;*          = 'V':  form Q;
;;*          = 'U':  update a matrix X, by forming X*Q.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          On exit, the diagonal elements of AB are overwritten by the
;;*          diagonal elements of the tridiagonal matrix T; if KD > 0, the
;;*          elements on the first superdiagonal (if UPLO = 'U') or the
;;*          first subdiagonal (if UPLO = 'L') are overwritten by the
;;*          off-diagonal elements of T; the rest of AB is overwritten by
;;*          values generated during the reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          On entry, if VECT = 'U', then Q must contain an N-by-N
;;*          matrix X; if VECT = 'N' or 'V', then Q need not be set.
;;*
;;*          On exit:
;;*          if VECT = 'V', Q contains the N-by-N orthogonal matrix Q;
;;*          if VECT = 'U', Q contains the product X*Q;
;;*          if VECT = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1, and LDQ >= N if VECT = 'V' or 'U'.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by Linda Kaufman, Bell Labs.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbtrd (vect  uplo  n  kd  ab  ldab  d  e  q  ldq  work  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsbtrd_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsecnd <>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSECND returns the user time for a process in seconds.
;;*  This version gets the time from the system function ETIME.
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dsecnd (  )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dsecnd_() #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspcon <uplo>  <n>  <ap>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric packed matrix A using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by DSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSPTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  IWORK    (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspcon (uplo  n  ap  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dspcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspevd <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPEVD computes all the eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix A in packed storage. If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least 2*N.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least
;;*                                                 1 + 6*N + N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspevd (jobz  uplo  n  ap  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dspevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspev <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPEV computes all the eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric matrix A in packed storage.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspev (jobz  uplo  n  ap  w  z  ldz  work  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dspev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspevx <jobz>  <range>  <uplo>  <n>  <ap>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix A in packed storage.  Eigenvalues/vectors
;;*  can be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the selected eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (8*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspevx (jobz  range  uplo  n  ap  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dspevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspgst <itype>  <uplo>  <n>  <ap>  <bp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPGST reduces a real symmetric-definite generalized eigenproblem
;;*  to standard form, using packed storage.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
;;*
;;*  B must have been previously factorized as U**T*U or L*L**T by DPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T);
;;*          = 2 or 3: compute U*A*U**T or L**T*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**T*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  BP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          stored in the same format as A, as returned by DPPTRF.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspgst (itype  uplo  n  ap  bp  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) bp )
	((-idx0- (-int-)) info )
	#{ dspgst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspgvd <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be symmetric, stored in packed format, and B is also
;;*  positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T, in the same storage
;;*          format as B.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= 2*N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 1 + 6*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  DPPTRF or DSPEVD returned an error code:
;;*             <= N:  if INFO = i, DSPEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspgvd (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) bp )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dspgvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspgv <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPGV computes all the eigenvalues and, optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be symmetric, stored in packed format,
;;*  and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension
;;*                            (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T, in the same storage
;;*          format as B.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  DPPTRF or DSPEV returned an error code:
;;*             <= N:  if INFO = i, DSPEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero.
;;*             > N:   if INFO = n + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dspgv (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) bp )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dspgv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspgvx <itype>  <jobz>  <range>  <uplo>  <n>  <ap>  <bp>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
;;*  and B are assumed to be symmetric, stored in packed storage, and B
;;*  is also positive definite.  Eigenvalues and eigenvectors can be
;;*  selected by specifying either a range of values or a range of indices
;;*  for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A and B are stored;
;;*          = 'L':  Lower triangle of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix pencil (A,B).  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T, in the same storage
;;*          format as B.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (8*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  DPPTRF or DSPEVX returned an error code:
;;*             <= N:  if INFO = i, DSPEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dspgvx (itype  jobz  range  uplo  n  ap  bp  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) bp )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dspgvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The factored form of the matrix A.  AFP contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by DSPTRF, stored as a packed
;;*          triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSPTRF.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DSPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsprfs (uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dsprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspsv <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix stored in packed format and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, D is symmetric and block diagonal with 1-by-1
;;*  and 2-by-2 diagonal blocks.  The factored form of A is then used to
;;*  solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by DSPTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, so the solution could not be
;;*                computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dspsv (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dspsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dspsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
;;*  A = L*D*L**T to compute the solution to a real system of linear
;;*  equations A * X = B, where A is an N-by-N symmetric matrix stored
;;*  in packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A as
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AFP and IPIV contain the factored form of
;;*                  A.  AP, AFP and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*  AFP     (input or output) DOUBLE PRECISION array, dimension
;;*                            (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by DSPTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by DSPTRF.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspsvx (fact  uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dspsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsptrd <uplo>  <n>  <ap>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPTRD reduces a real symmetric matrix A stored in packed form to
;;*  symmetric tridiagonal form T by an orthogonal similarity
;;*  transformation: Q**T * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the orthogonal matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP,
;;*  overwriting A(1:i-1,i+1), and tau is stored in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP,
;;*  overwriting A(i+2:n,i), and tau is stored in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsptrd (uplo  n  ap  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ dsptrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsptrf <uplo>  <n>  <ap>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPTRF computes the factorization of a real symmetric matrix A stored
;;*  in packed format using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L, stored as a packed triangular
;;*          matrix overwriting A (see below for further details).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  5-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsptrf (uplo  n  ap  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dsptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsptri <uplo>  <n>  <ap>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPTRI computes the inverse of a real symmetric indefinite matrix
;;*  A in packed storage using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by DSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by DSPTRF,
;;*          stored as a packed triangular matrix.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix, stored as a packed triangular matrix. The j-th column
;;*          of inv(A) is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
;;*          if UPLO = 'L',
;;*             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSPTRF.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsptri (uplo  n  ap  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsptrs <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSPTRS solves a system of linear equations A*X = B with a real
;;*  symmetric matrix A stored in packed format using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by DSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSPTRF.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsptrs (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dsptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstebz <range>  <order>  <n>  <vl>  <vu>  <il>  <iu>  <abstol>  <d>  <e>  <m>  <nsplit>  <w>  <iblock>  <isplit>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEBZ computes the eigenvalues of a symmetric tridiagonal
;;*  matrix T.  The user may ask for all eigenvalues, all eigenvalues
;;*  in the half-open interval (VL, VU], or the IL-th through IU-th
;;*  eigenvalues.
;;*
;;*  To avoid overflow, the matrix must be scaled so that its
;;*  largest element is no greater than overflow**(1/2) *
;;*  underflow**(1/4) in absolute value, and for greatest
;;*  accuracy, it should not be much smaller than that.
;;*
;;*  See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
;;*  Matrix", Report CS41, Computer Science Dept., Stanford
;;*  University, July 21, 1966.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  RANGE   (input) CHARACTER
;;*          = 'A': ("All")   all eigenvalues will be found.
;;*          = 'V': ("Value") all eigenvalues in the half-open interval
;;*                           (VL, VU] will be found.
;;*          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
;;*                           entire matrix) will be found.
;;*
;;*  ORDER   (input) CHARACTER
;;*          = 'B': ("By Block") the eigenvalues will be grouped by
;;*                              split-off block (see IBLOCK, ISPLIT) and
;;*                              ordered from smallest to largest within
;;*                              the block.
;;*          = 'E': ("Entire matrix")
;;*                              the eigenvalues for the entire matrix
;;*                              will be ordered from smallest to
;;*                              largest.
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix T.  N >= 0.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues.  Eigenvalues less than or equal
;;*          to VL, or greater than VU, will not be returned.  VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute tolerance for the eigenvalues.  An eigenvalue
;;*          (or cluster) is considered to be located if it has been
;;*          determined to lie in an interval whose width is ABSTOL or
;;*          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
;;*          will be used, where |T| means the 1-norm of T.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the tridiagonal matrix T.
;;*
;;*  M       (output) INTEGER
;;*          The actual number of eigenvalues found. 0 <= M <= N.
;;*          (See also the description of INFO=2,3.)
;;*
;;*  NSPLIT  (output) INTEGER
;;*          The number of diagonal blocks in the matrix T.
;;*          1 <= NSPLIT <= N.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, the first M elements of W will contain the
;;*          eigenvalues.  (DSTEBZ may use the remaining N-M elements as
;;*          workspace.)
;;*
;;*  IBLOCK  (output) INTEGER array, dimension (N)
;;*          At each row/column j where E(j) is zero or small, the
;;*          matrix T is considered to split into a block diagonal
;;*          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
;;*          block (from 1 to the number of blocks) the eigenvalue W(i)
;;*          belongs.  (DSTEBZ may use the remaining N-M elements as
;;*          workspace.)
;;*
;;*  ISPLIT  (output) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to ISPLIT(1),
;;*          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
;;*          etc., and the NSPLIT-th consists of rows/columns
;;*          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
;;*          (Only the first NSPLIT elements will actually be used, but
;;*          since the user cannot know a priori what value NSPLIT will
;;*          have, N words must be reserved for ISPLIT.)
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  some or all of the eigenvalues failed to converge or
;;*                were not computed:
;;*                =1 or 3: Bisection failed to converge for some
;;*                        eigenvalues; these eigenvalues are flagged by a
;;*                        negative block number.  The effect is that the
;;*                        eigenvalues may not be as accurate as the
;;*                        absolute and relative tolerances.  This is
;;*                        generally caused by unexpectedly inaccurate
;;*                        arithmetic.
;;*                =2 or 3: RANGE='I' only: Not all of the eigenvalues
;;*                        IL:IU were found.
;;*                        Effect: M < IU+1-IL
;;*                        Cause:  non-monotonic arithmetic, causing the
;;*                                Sturm sequence to be non-monotonic.
;;*                        Cure:   recalculate, using RANGE='A', and pick
;;*                                out eigenvalues IL:IU.  In some cases,
;;*                                increasing the PARAMETER "FUDGE" may
;;*                                make things work.
;;*                = 4:    RANGE='I', and the Gershgorin interval
;;*                        initially used was too small.  No eigenvalues
;;*                        were computed.
;;*                        Probable cause: your machine has sloppy
;;*                                        floating-point arithmetic.
;;*                        Cure: Increase the PARAMETER "FUDGE",
;;*                              recompile, and try again.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  RELFAC  DOUBLE PRECISION, default = 2.0e0
;;*          The relative tolerance.  An interval (a,b] lies within
;;*          "relative tolerance" if  b-a < RELFAC*ulp*max(|a|,|b|),
;;*          where "ulp" is the machine precision (distance from 1 to
;;*          the next larger floating point number.)
;;*
;;*  FUDGE   DOUBLE PRECISION, default = 2
;;*          A "fudge factor" to widen the Gershgorin intervals.  Ideally,
;;*          a value of 1 should work, but on machines with sloppy
;;*          arithmetic, this needs to be larger.  The default for
;;*          publicly released versions should be large enough to handle
;;*          the worst machine around.  Note that this has no effect
;;*          on accuracy of the solution.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstebz (range  order  n  vl  vu  il  iu  abstol  d  e  m  nsplit  w  iblock  isplit  work  iwork  info  )
	((-str-) range )
	((-str-) order )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) nsplit )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-int-)) isplit )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dstebz_($range->data, $order->data, IDX_PTR($n,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($m,int), IDX_PTR($nsplit,int), IDX_PTR($w,double), IDX_PTR($iblock,int), IDX_PTR($isplit,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstedc <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the divide and conquer method.
;;*  The eigenvectors of a full or band real symmetric matrix can also be
;;*  found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
;;*  matrix to tridiagonal form.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.  See DLAED3 for details.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*          = 'V':  Compute eigenvectors of original dense symmetric
;;*                  matrix also.  On entry, Z contains the orthogonal
;;*                  matrix used to reduce the original matrix to
;;*                  tridiagonal form.
;;*
;;*  N       (input) INTEGER
;;*          The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the subdiagonal elements of the tridiagonal matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          On entry, if COMPZ = 'V', then Z contains the orthogonal
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original symmetric matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If eigenvectors are desired, then LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If COMPZ = 'N' or N <= 1 then LWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1 then LWORK must be at least
;;*                         ( 1 + 3*N + 2*N*lg N + 3*N**2 ),
;;*                         where lg( N ) = smallest integer k such
;;*                         that 2**k >= N.
;;*          If COMPZ = 'I' and N > 1 then LWORK must be at least
;;*                         ( 1 + 4*N + N**2 ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If COMPZ = 'N' or N <= 1 then LIWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1 then LIWORK must be at least
;;*                         ( 6 + 6*N + 5*N*lg N ).
;;*          If COMPZ = 'I' and N > 1 then LIWORK must be at least
;;*                         ( 3 + 5*N ).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstedc (compz  n  d  e  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dstedc_($compz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstegr <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;* DSTEGR computes selected eigenvalues and, optionally, eigenvectors
;;* of a real symmetric tridiagonal matrix T.  Eigenvalues and
;;* eigenvectors can be selected by specifying either a range of values
;;* or a range of indices for the desired eigenvalues. The eigenvalues
;;* are computed by the dqds algorithm, while orthogonal eigenvectors are
;;* computed from various ``good'' L D L^T representations (also known as
;;* Relatively Robust Representations). Gram-Schmidt orthogonalization is
;;* avoided as far as possible. More specifically, the various steps of
;;* the algorithm are as follows. For the i-th unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*         is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB/CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*  Note 1 : Currently DSTEGR is only set up to find ALL the n
;;*  eigenvalues and eigenvectors of T in O(n^2) time
;;*  Note 2 : Currently the routine DSTEIN is called when an appropriate
;;*  sigma_i cannot be chosen in step (c) above. DSTEIN invokes modified
;;*  Gram-Schmidt when eigenvalues are close.
;;*  Note 3 : DSTEGR works only on machines which follow ieee-754
;;*  floating-point standard in their handling of infinities and NaNs.
;;*  Normal execution of DSTEGR may create NaNs and infinities and hence
;;*  may abort due to a floating point exception in environments which
;;*  do not conform to the ieee standard.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** Only RANGE = 'A' is currently supported *********************
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          T. On exit, D is overwritten.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix T in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E is overwritten.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors. IF JOBZ = 'V', the eigenvalues and
;;*          eigenvectors output have residual norms bounded by ABSTOL,
;;*          and the dot products between different eigenvectors are
;;*          bounded by ABSTOL. If ABSTOL is less than N*EPS*|T|, then
;;*          N*EPS*|T| will be used in its place, where EPS is the
;;*          machine precision and |T| is the 1-norm of the tridiagonal
;;*          matrix. The eigenvalues are computed to an accuracy of
;;*          EPS*|T| irrespective of ABSTOL. If high relative accuracy
;;*          is important, set ABSTOL to DLAMCH( 'Safe minimum' ).
;;*          See Barlow and Demmel "Computing Accurate Eigensystems of
;;*          Scaled Diagonally Dominant Matrices", LAPACK Working Note #7
;;*          for a discussion of which matrices define their eigenvalues
;;*          to high relative accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal
;;*          (and minimal) LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,18*N)
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= max(1,10*N)
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in DLARRE,
;;*                if INFO = 2, internal error in DLARRV.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstegr (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dstegr_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstein <n>  <d>  <e>  <m>  <w>  <iblock>  <isplit>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEIN computes the eigenvectors of a real symmetric tridiagonal
;;*  matrix T corresponding to specified eigenvalues, using inverse
;;*  iteration.
;;*
;;*  The maximum number of iterations allowed for each eigenvector is
;;*  specified by an internal parameter MAXITS (currently set to 5).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix
;;*          T, in elements 1 to N-1.  E(N) need not be set.
;;*
;;*  M       (input) INTEGER
;;*          The number of eigenvectors to be found.  0 <= M <= N.
;;*
;;*  W       (input) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block.  ( The output array
;;*          W from DSTEBZ with ORDER = 'B' is expected here. )
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc.  ( The output array IBLOCK
;;*          from DSTEBZ is expected here. )
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*          ( The output array ISPLIT from DSTEBZ is expected here. )
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, M)
;;*          The computed eigenvectors.  The eigenvector associated
;;*          with the eigenvalue W(i) is stored in the i-th column of
;;*          Z.  Any vector which fails to converge is set to its current
;;*          iterate after MAXITS iterations.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (5*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (M)
;;*          On normal exit, all elements of IFAIL are zero.
;;*          If one or more eigenvectors fail to converge after
;;*          MAXITS iterations, then their indices are stored in
;;*          array IFAIL.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, then i eigenvectors failed to converge
;;*               in MAXITS iterations.  Their indices are stored in
;;*               array IFAIL.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXITS  INTEGER, default = 5
;;*          The maximum number of iterations performed.
;;*
;;*  EXTRA   INTEGER, default = 2
;;*          The number of iterations performed after norm growth
;;*          criterion is satisfied, should be at least 1.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstein (n  d  e  m  w  iblock  isplit  z  ldz  work  iwork  ifail  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-int-)) isplit )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dstein_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($iblock,int), IDX_PTR($isplit,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the implicit QL or QR method.
;;*  The eigenvectors of a full or band symmetric matrix can also be found
;;*  if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
;;*  tridiagonal form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvalues and eigenvectors of the original
;;*                  symmetric matrix.  On entry, Z must contain the
;;*                  orthogonal matrix used to reduce the original matrix
;;*                  to tridiagonal form.
;;*          = 'I':  Compute eigenvalues and eigenvectors of the
;;*                  tridiagonal matrix.  Z is initialized to the identity
;;*                  matrix.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          On entry, if  COMPZ = 'V', then Z contains the orthogonal
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original symmetric matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          eigenvectors are desired, then  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))
;;*          If COMPZ = 'N', then WORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm has failed to find all the eigenvalues in
;;*                a total of 30*N iterations; if INFO = i, then i
;;*                elements of E have not converged to zero; on exit, D
;;*                and E contain the elements of a symmetric tridiagonal
;;*                matrix which is orthogonally similar to the original
;;*                matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsterf <n>  <d>  <e>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
;;*  using the Pal-Walker-Kahan variant of the QL or QR algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm failed to find all of the eigenvalues in
;;*                a total of 30*N iterations; if INFO = i, then i
;;*                elements of E have not converged to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsterf (n  d  e  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-int-)) info )
	#{ dsterf_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstevd <jobz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEVD computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric tridiagonal matrix. If eigenvectors are desired, it
;;*  uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A, stored in elements 1 to N-1 of E; E(N) need not
;;*          be set, but is used by the routine.
;;*          On exit, the contents of E are destroyed.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with D(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If JOBZ  = 'N' or N <= 1 then LWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1 then LWORK must be at least
;;*                         ( 1 + 4*N + N**2 ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOBZ  = 'N' or N <= 1 then LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1 then LIWORK must be at least 3+5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of E did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstevd (jobz  n  d  e  z  ldz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dstevd_($jobz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstev <jobz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEV computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric tridiagonal matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A, stored in elements 1 to N-1 of E; E(N) need not
;;*          be set, but is used by the routine.
;;*          On exit, the contents of E are destroyed.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with D(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))
;;*          If JOBZ = 'N', WORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of E did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstev (jobz  n  d  e  z  ldz  work  info  )
	((-str-) jobz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dstev_($jobz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstevr <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEVR computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric tridiagonal matrix T.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either a range of values
;;*  or a range of indices for the desired eigenvalues.
;;*
;;*  Whenever possible, DSTEVR calls SSTEGR to compute the
;;*  eigenspectrum using Relatively Robust Representations.  DSTEGR
;;*  computes eigenvalues by the dqds algorithm, while orthogonal
;;*  eigenvectors are computed from various "good" L D L^T representations
;;*  (also known as Relatively Robust Representations). Gram-Schmidt
;;*  orthogonalization is avoided as far as possible. More specifically,
;;*  the various steps of the algorithm are as follows. For the i-th
;;*  unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*          is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB//CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*
;;*  Note 1 : DSTEVR calls SSTEGR when the full spectrum is requested
;;*  on machines which conform to the ieee-754 floating point standard.
;;*  DSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
;;*  when partial spectrum requests are made.
;;*
;;*  Normal execution of DSTEGR may create NaNs and infinities and
;;*  hence may abort due to a floating point exception in environments
;;*  which do not handle NaNs and infinities in the ieee standard default
;;*  manner.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** For RANGE = 'V' or 'I' and IU - IL < N - 1, DSTEBZ and
;;********** DSTEIN are called
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, D may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*          If high relative accuracy is important, set ABSTOL to
;;*          DLAMCH( 'Safe minimum' ).  Doing so will guarantee that
;;*          eigenvalues are computed to high relative accuracy when
;;*          possible in future releases.  The current code does not
;;*          make any guarantees about high relative accuracy, but
;;*          future releases will. See J. Barlow and J. Demmel,
;;*          "Computing Accurate Eigensystems of Scaled Diagonally
;;*          Dominant Matrices", LAPACK Working Note #7, for a discussion
;;*          of which matrices define their eigenvalues to high relative
;;*          accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;********** Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal (and
;;*          minimal) LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 20*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal (and
;;*          minimal) LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= 10*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  Internal error
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstevr (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dstevr_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dstevx <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSTEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric tridiagonal matrix A.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either a range of values
;;*  or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.
;;*          On exit, D may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E may be multiplied by a constant factor chosen
;;*          to avoid over/underflow in computing the eigenvalues.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less
;;*          than or equal to zero, then  EPS*|T|  will be used in
;;*          its place, where |T| is the 1-norm of the tridiagonal
;;*          matrix.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge (INFO > 0), then that
;;*          column of Z contains the latest approximation to the
;;*          eigenvector, and the index of the eigenvector is returned
;;*          in IFAIL.  If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (5*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dstevx (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  work  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dstevx_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsycon <uplo>  <n>  <a>  <lda>  <ipiv>  <anorm>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a real symmetric matrix A using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by DSYTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by DSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSYTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  IWORK    (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsycon (uplo  n  a  lda  ipiv  anorm  rcond  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dsycon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsyevd <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric matrix A. If eigenvectors are desired, it uses a
;;*  divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Because of large use of BLAS of level 3, DSYEVD needs N**2 more
;;*  workspace than DSYEVX.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least
;;*                                                1 + 6*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*  Modified by Francoise Tisseur, University of Tennessee.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyevd (jobz  uplo  n  a  lda  w  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dsyevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsyev <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYEV computes all eigenvalues and, optionally, eigenvectors of a
;;*  real symmetric matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,3*N-1).
;;*          For optimal efficiency, LWORK >= (NB+2)*N,
;;*          where NB is the blocksize for DSYTRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyev (jobz  uplo  n  a  lda  w  work  lwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dsyev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsyevr <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYEVR computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix T.  Eigenvalues and eigenvectors can be
;;*  selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Whenever possible, DSYEVR calls DSTEGR to compute the
;;*  eigenspectrum using Relatively Robust Representations.  DSTEGR
;;*  computes eigenvalues by the dqds algorithm, while orthogonal
;;*  eigenvectors are computed from various "good" L D L^T representations
;;*  (also known as Relatively Robust Representations). Gram-Schmidt
;;*  orthogonalization is avoided as far as possible. More specifically,
;;*  the various steps of the algorithm are as follows. For the i-th
;;*  unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*          is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB//CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*
;;*  Note 1 : DSYEVR calls DSTEGR when the full spectrum is requested
;;*  on machines which conform to the ieee-754 floating point standard.
;;*  DSYEVR calls DSTEBZ and SSTEIN on non-ieee machines and
;;*  when partial spectrum requests are made.
;;*
;;*  Normal execution of DSTEGR may create NaNs and infinities and
;;*  hence may abort due to a floating point exception in environments
;;*  which do not handle NaNs and infinities in the ieee standard default
;;*  manner.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** For RANGE = 'V' or 'I' and IU - IL < N - 1, DSTEBZ and
;;********** DSTEIN are called
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*          If high relative accuracy is important, set ABSTOL to
;;*          DLAMCH( 'Safe minimum' ).  Doing so will guarantee that
;;*          eigenvalues are computed to high relative accuracy when
;;*          possible in future releases.  The current code does not
;;*          make any guarantees about high relative accuracy, but
;;*          furutre releases will. See J. Barlow and J. Demmel,
;;*          "Computing Accurate Eigensystems of Scaled Diagonally
;;*          Dominant Matrices", LAPACK Working Note #7, for a discussion
;;*          of which matrices define their eigenvalues to high relative
;;*          accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;********** Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,26*N).
;;*          For optimal efficiency, LWORK >= (NB+6)*N,
;;*          where NB is the max of the blocksize for DSYTRD and DORMTR
;;*          returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  Internal error
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyevr (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dsyevr_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsyevx <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
;;*  selected by specifying either a range of values or a range of indices
;;*  for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,8*N).
;;*          For optimal efficiency, LWORK >= (NB+3)*N,
;;*          where NB is the max of the blocksize for DSYTRD and DORMTR
;;*          returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyevx (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dsyevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsygs2 <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYGS2 reduces a real symmetric-definite generalized eigenproblem
;;*  to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U` or L'*A*L.
;;*
;;*  B must have been previously factorized as U'*U or L*L' by DPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U')*A*inv(U) or inv(L)*A*inv(L');
;;*          = 2 or 3: compute U*A*U' or L'*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored, and how B has been factorized.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by DPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsygs2 (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dsygs2_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsygst <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYGST reduces a real symmetric-definite generalized eigenproblem
;;*  to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
;;*
;;*  B must have been previously factorized as U**T*U or L*L**T by DPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T);
;;*          = 2 or 3: compute U*A*U**T or L**T*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**T*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by DPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsygst (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dsygst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsygvd <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be symmetric and B is also positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the symmetric matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= 2*N+1.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 1 + 6*N + 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  DPOTRF or DSYEVD returned an error code:
;;*             <= N:  if INFO = i, DSYEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsygvd (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dsygvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsygv <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be symmetric and B is also
;;*  positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, the symmetric positive definite matrix B.
;;*          If UPLO = 'U', the leading N-by-N upper triangular part of B
;;*          contains the upper triangular part of the matrix B.
;;*          If UPLO = 'L', the leading N-by-N lower triangular part of B
;;*          contains the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,3*N-1).
;;*          For optimal efficiency, LWORK >= (NB+2)*N,
;;*          where NB is the blocksize for DSYTRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  DPOTRF or DSYEV returned an error code:
;;*             <= N:  if INFO = i, DSYEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsygv (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) w )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dsygv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsygvx <itype>  <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a real generalized symmetric-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
;;*  and B are assumed to be symmetric and B is also positive definite.
;;*  Eigenvalues and eigenvectors can be selected by specifying either a
;;*  range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A and B are stored;
;;*          = 'L':  Lower triangle of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix pencil (A,B).  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
;;*          On entry, the symmetric matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**T*U or B = L*L**T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,8*N).
;;*          For optimal efficiency, LWORK >= (NB+3)*N,
;;*          where NB is the blocksize for DSYTRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  DPOTRF or DSYEVX returned an error code:
;;*             <= N:  if INFO = i, DSYEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsygvx (itype  jobz  range  uplo  n  a  lda  b  ldb  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ dsygvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsyrfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite, and
;;*  provides error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) DOUBLE PRECISION array, dimension (LDAF,N)
;;*          The factored form of the matrix A.  AF contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by DSYTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSYTRF.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by DSYTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyrfs (uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dsyrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsysv <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYSV computes the solution to a real system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
;;*  used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the block diagonal matrix D and the
;;*          multipliers used to obtain the factor U or L from the
;;*          factorization A = U*D*U**T or A = L*D*L**T as computed by
;;*          DSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by DSYTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 1, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          DSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dsysv (uplo  n  nrhs  a  lda  ipiv  b  ldb  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dsysv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsysvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYSVX uses the diagonal pivoting factorization to compute the
;;*  solution to a real system of linear equations A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A.
;;*     The form of the factorization is
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices, and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AF and IPIV contain the factored form of
;;*                  A.  AF and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by DSYTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by DSYTRF.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 3*N, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          DSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsysvx (fact  uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  lwork  iwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dsysvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsytd2 <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
;;*  form T by an orthogonal similarity transformation: Q' * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the orthogonal matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsytd2 (uplo  n  a  lda  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ dsytd2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsytf2 <uplo>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYTF2 computes the factorization of a real symmetric matrix A using
;;*  the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U'  or  A = L*D*L'
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, U' is the transpose of U, and D is symmetric and
;;*  block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  1-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsytf2 (uplo  n  a  lda  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ dsytf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsytrd <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYTRD reduces a real symmetric matrix A to real symmetric
;;*  tridiagonal form T by an orthogonal similarity transformation:
;;*  Q**T * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the orthogonal
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the orthogonal matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 1.
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real scalar, and v is a real vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsytrd (uplo  n  a  lda  d  e  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dsytrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsytrf <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYTRF computes the factorization of a real symmetric matrix A using
;;*  the Bunch-Kaufman diagonal pivoting method.  The form of the
;;*  factorization is
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >=1.  For best performance
;;*          LWORK >= N*NB, where NB is the block size returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, and division by zero will occur if it
;;*                is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dsytrf (uplo  n  a  lda  ipiv  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dsytrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsytri <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYTRI computes the inverse of a real symmetric indefinite matrix
;;*  A using the factorization A = U*D*U**T or A = L*D*L**T computed by
;;*  DSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by DSYTRF.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix.  If UPLO = 'U', the upper triangular part of the
;;*          inverse is formed and the part of A below the diagonal is not
;;*          referenced; if UPLO = 'L' the lower triangular part of the
;;*          inverse is formed and the part of A above the diagonal is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSYTRF.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsytri (uplo  n  a  lda  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dsytri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dsytrs <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DSYTRS solves a system of linear equations A*X = B with a real
;;*  symmetric matrix A using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by DSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by DSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by DSYTRF.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsytrs (uplo  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dsytrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtbcon <norm>  <uplo>  <diag>  <n>  <kd>  <ab>  <ldab>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTBCON estimates the reciprocal of the condition number of a
;;*  triangular band matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtbcon (norm  uplo  diag  n  kd  ab  ldab  rcond  work  iwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtbcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtbrfs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTBRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular band
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by DTBTRS or some other
;;*  means before entering this routine.  DTBRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtbrfs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtbrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtbtrs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTBTRS solves a triangular system of the form
;;*
;;*     A * X = B  or  A**T * X = B,
;;*
;;*  where A is a triangular band matrix of order N, and B is an
;;*  N-by NRHS matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtbtrs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dtbtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgevc <side>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGEVC computes some or all of the right and/or left generalized
;;*  eigenvectors of a pair of real upper triangular matrices (A,B).
;;*
;;*  The right generalized eigenvector x and the left generalized
;;*  eigenvector y of (A,B) corresponding to a generalized eigenvalue
;;*  w are defined by:
;;*
;;*          (A - wB) * x = 0  and  y**H * (A - wB) = 0
;;*
;;*  where y**H denotes the conjugate tranpose of y.
;;*
;;*  If an eigenvalue w is determined by zero diagonal elements of both A
;;*  and B, a unit vector is returned as the corresponding eigenvector.
;;*
;;*  If all eigenvectors are requested, the routine may either return
;;*  the matrices X and/or Y of right or left eigenvectors of (A,B), or
;;*  the products Z*X and/or Q*Y, where Z and Q are input orthogonal
;;*  matrices.  If (A,B) was obtained from the generalized real-Schur
;;*  factorization of an original pair of matrices
;;*     (A0,B0) = (Q*A*Z**H,Q*B*Z**H),
;;*  then Z*X and Q*Y are the matrices of right or left eigenvectors of
;;*  A.
;;*
;;*  A must be block upper triangular, with 1-by-1 and 2-by-2 diagonal
;;*  blocks.  Corresponding to each 2-by-2 diagonal block is a complex
;;*  conjugate pair of eigenvalues and eigenvectors; only one
;;*  eigenvector of the pair is computed, namely the one corresponding
;;*  to the eigenvalue with positive imaginary part.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute all right and/or left eigenvectors;
;;*          = 'B': compute all right and/or left eigenvectors, and
;;*                 backtransform them using the input matrices supplied
;;*                 in VR and/or VL;
;;*          = 'S': compute selected right and/or left eigenvectors,
;;*                 specified by the logical array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY='S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY='A' or 'B', SELECT is not referenced.
;;*          To select the real eigenvector corresponding to the real
;;*          eigenvalue w(j), SELECT(j) must be set to .TRUE.  To select
;;*          the complex eigenvector corresponding to a complex conjugate
;;*          pair w(j) and w(j+1), either SELECT(j) or SELECT(j+1) must
;;*          be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The upper quasi-triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of array A.  LDA >= max(1, N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,N)
;;*          The upper triangular matrix B.  If A has a 2-by-2 diagonal
;;*          block, then the corresponding 2-by-2 block of B must be
;;*          diagonal with positive elements.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of array B.  LDB >= max(1,N).
;;*
;;*  VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Q
;;*          of left Schur vectors returned by DHGEQZ).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VL, in the same order as their eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part, and the second the imaginary part.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Z
;;*          of right Schur vectors returned by DHGEQZ).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Z*X;
;;*          if HOWMNY = 'S', the right eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VR, in the same order as their eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part and the second the imaginary part.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
;;*          is set to N.  Each selected real eigenvector occupies one
;;*          column and each selected complex eigenvector occupies two
;;*          columns.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the 2-by-2 block (INFO:INFO+1) does not have a complex
;;*                eigenvalue.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Allocation of workspace:
;;*  ---------- -- ---------
;;*
;;*     WORK( j ) = 1-norm of j-th column of A, above the diagonal
;;*     WORK( N+j ) = 1-norm of j-th column of B, above the diagonal
;;*     WORK( 2*N+1:3*N ) = real part of eigenvector
;;*     WORK( 3*N+1:4*N ) = imaginary part of eigenvector
;;*     WORK( 4*N+1:5*N ) = real part of back-transformed eigenvector
;;*     WORK( 5*N+1:6*N ) = imaginary part of back-transformed eigenvector
;;*
;;*  Rowwise vs. columnwise solution methods:
;;*  ------- --  ---------- -------- -------
;;*
;;*  Finding a generalized eigenvector consists basically of solving the
;;*  singular triangular system
;;*
;;*   (A - w B) x = 0     (for right) or:   (A - w B)**H y = 0  (for left)
;;*
;;*  Consider finding the i-th right eigenvector (assume all eigenvalues
;;*  are real). The equation to be solved is:
;;*       n                   i
;;*  0 = sum  C(j,k) v(k)  = sum  C(j,k) v(k)     for j = i,. . .,1
;;*      k=j                 k=j
;;*
;;*  where  C = (A - w B)  (The components v(i+1:n) are 0.)
;;*
;;*  The "rowwise" method is:
;;*
;;*  (1)  v(i) := 1
;;*  for j = i-1,. . .,1:
;;*                          i
;;*      (2) compute  s = - sum C(j,k) v(k)   and
;;*                        k=j+1
;;*
;;*      (3) v(j) := s / C(j,j)
;;*
;;*  Step 2 is sometimes called the "dot product" step, since it is an
;;*  inner product between the j-th row and the portion of the eigenvector
;;*  that has been computed so far.
;;*
;;*  The "columnwise" method consists basically in doing the sums
;;*  for all the rows in parallel.  As each v(j) is computed, the
;;*  contribution of v(j) times the j-th column of C is added to the
;;*  partial sums.  Since FORTRAN arrays are stored columnwise, this has
;;*  the advantage that at each step, the elements of C that are accessed
;;*  are adjacent to one another, whereas with the rowwise method, the
;;*  elements accessed at a step are spaced LDA (and LDB) words apart.
;;*
;;*  When finding left eigenvectors, the matrix in question is the
;;*  transpose of the one in storage, so the rowwise method then
;;*  actually accesses columns of A and B at each step, and so is the
;;*  preferred method.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgevc (side  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  mm  m  work  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dtgevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgex2 <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <j1>  <n1>  <n2>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
;;*  of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
;;*  (A, B) by an orthogonal equivalence transformation.
;;*
;;*  (A, B) must be in generalized real Schur canonical form (as returned
;;*  by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
;;*  diagonal blocks. B is upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A      (input/output) DOUBLE PRECISION arrays, dimensions (LDA,N)
;;*          On entry, the matrix A in the pair (A, B).
;;*          On exit, the updated matrix A.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B      (input/output) DOUBLE PRECISION arrays, dimensions (LDB,N)
;;*          On entry, the matrix B in the pair (A, B).
;;*          On exit, the updated matrix B.
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
;;*          On exit, the updated matrix Q.
;;*          Not referenced if WANTQ = .FALSE..
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1.
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          On entry, if WANTZ =.TRUE., the orthogonal matrix Z.
;;*          On exit, the updated matrix Z.
;;*          Not referenced if WANTZ = .FALSE..
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1.
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  J1      (input) INTEGER
;;*          The index to the first block (A11, B11). 1 <= J1 <= N.
;;*
;;*  N1      (input) INTEGER
;;*          The order of the first block (A11, B11). N1 = 0, 1 or 2.
;;*
;;*  N2      (input) INTEGER
;;*          The order of the second block (A22, B22). N2 = 0, 1 or 2.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK).
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          LWORK >=  MAX( N*(N2+N1), (N2+N1)*(N2+N1)*2 )
;;*
;;*  INFO    (output) INTEGER
;;*            =0: Successful exit
;;*            >0: If INFO = 1, the transformed matrix (A, B) would be
;;*                too far from generalized Schur form; the blocks are
;;*                not swapped and (A, B) and (Q, Z) are unchanged.
;;*                The problem of swapping is too ill-conditioned.
;;*            <0: If INFO = -16: LWORK is too small. Appropriate value
;;*                for LWORK is returned in WORK(1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  In the current code both weak and strong stability tests are
;;*  performed. The user can omit the strong stability test by changing
;;*  the internal logical parameter WANDS to .FALSE.. See ref. [2] for
;;*  details.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software,
;;*      Report UMINF - 94.04, Department of Computing Science, Umea
;;*      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
;;*      Note 87. To appear in Numerical Algorithms, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgex2 (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  j1  n1  n2  work  lwork  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) j1 )
	((-idx0- (-int-)) n1 )
	((-idx0- (-int-)) n2 )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dtgex2_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($j1,int), IDX_PTR($n1,int), IDX_PTR($n2,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgexc <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <ifst>  <ilst>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGEXC reorders the generalized real Schur decomposition of a real
;;*  matrix pair (A,B) using an orthogonal equivalence transformation
;;*
;;*                 (A, B) = Q * (A, B) * Z',
;;*
;;*  so that the diagonal block of (A, B) with row index IFST is moved
;;*  to row ILST.
;;*
;;*  (A, B) must be in generalized real Schur canonical form (as returned
;;*  by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
;;*  diagonal blocks. B is upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the matrix A in generalized real Schur canonical
;;*          form.
;;*          On exit, the updated matrix A, again in generalized
;;*          real Schur canonical form.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the matrix B in generalized real Schur canonical
;;*          form (A,B).
;;*          On exit, the updated matrix B, again in generalized
;;*          real Schur canonical form (A,B).
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          On entry, if WANTQ = .TRUE., the orthogonal matrix Q.
;;*          On exit, the updated matrix Q.
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1.
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., the orthogonal matrix Z.
;;*          On exit, the updated matrix Z.
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1.
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  IFST    (input/output) INTEGER
;;*  ILST    (input/output) INTEGER
;;*          Specify the reordering of the diagonal blocks of (A, B).
;;*          The block with row index IFST is moved to row ILST, by a
;;*          sequence of swapping between adjacent blocks.
;;*          On exit, if IFST pointed on entry to the second row of
;;*          a 2-by-2 block, it is changed to point to the first row;
;;*          ILST always points to the first row of the block in its
;;*          final position (which may differ from its input value by
;;*          +1 or -1). 1 <= IFST, ILST <= N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 4*N + 16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*           =0:  successful exit.
;;*           <0:  if INFO = -i, the i-th argument had an illegal value.
;;*           =1:  The transformed matrix pair (A, B) would be too far
;;*                from generalized Schur form; the problem is ill-
;;*                conditioned. (A, B) may have been partially reordered,
;;*                and ILST points to the first row of the current
;;*                position of the block being moved.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgexc (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  ifst  ilst  work  lwork  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dtgexc_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgsen <ijob>  <wantq>  <wantz>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <alphar>  <alphai>  <beta>  <q>  <ldq>  <z>  <ldz>  <m>  <pl>  <pr>  <dif>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGSEN reorders the generalized real Schur decomposition of a real
;;*  matrix pair (A, B) (in terms of an orthonormal equivalence trans-
;;*  formation Q' * (A, B) * Z), so that a selected cluster of eigenvalues
;;*  appears in the leading diagonal blocks of the upper quasi-triangular
;;*  matrix A and the upper triangular B. The leading columns of Q and
;;*  Z form orthonormal bases of the corresponding left and right eigen-
;;*  spaces (deflating subspaces). (A, B) must be in generalized real
;;*  Schur canonical form (as returned by DGGES), i.e. A is block upper
;;*  triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
;;*  triangular.
;;*
;;*  DTGSEN also computes the generalized eigenvalues
;;*
;;*              w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
;;*
;;*  of the reordered matrix pair (A, B).
;;*
;;*  Optionally, DTGSEN computes the estimates of reciprocal condition
;;*  numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
;;*  (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
;;*  between the matrix pairs (A11, B11) and (A22,B22) that correspond to
;;*  the selected cluster and the eigenvalues outside the cluster, resp.,
;;*  and norms of "projections" onto left and right eigenspaces w.r.t.
;;*  the selected cluster in the (1,1)-block.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (PL and PR) or the deflating subspaces
;;*          (Difu and Difl):
;;*           =0: Only reorder w.r.t. SELECT. No extras.
;;*           =1: Reciprocal of norms of "projections" onto left and right
;;*               eigenspaces w.r.t. the selected cluster (PL and PR).
;;*           =2: Upper bounds on Difu and Difl. F-norm-based estimate
;;*               (DIF(1:2)).
;;*           =3: Estimate of Difu and Difl. 1-norm-based estimate
;;*               (DIF(1:2)).
;;*               About 5 times as expensive as IJOB = 2.
;;*           =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
;;*               version to get it all.
;;*           =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster.
;;*          To select a real eigenvalue w(j), SELECT(j) must be set to
;;*          .TRUE.. To select a complex conjugate pair of eigenvalues
;;*          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
;;*          either SELECT(j) or SELECT(j+1) or both must be set to
;;*          .TRUE.; a complex conjugate pair of eigenvalues must be
;;*          either both included in the cluster or both excluded.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension(LDA,N)
;;*          On entry, the upper quasi-triangular matrix A, with (A, B) in
;;*          generalized real Schur canonical form.
;;*          On exit, A is overwritten by the reordered matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension(LDB,N)
;;*          On entry, the upper triangular matrix B, with (A, B) in
;;*          generalized real Schur canonical form.
;;*          On exit, B is overwritten by the reordered matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
;;*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
;;*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i
;;*          and BETA(j),j=1,...,N  are the diagonals of the complex Schur
;;*          form (S,T) that would result if the 2-by-2 diagonal blocks of
;;*          the real generalized Schur form of (A,B) were further reduced
;;*          to triangular form using complex unitary transformations.
;;*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
;;*          positive, then the j-th and (j+1)-st eigenvalues are a
;;*          complex conjugate pair, with ALPHAI(j+1) negative.
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
;;*          On exit, Q has been postmultiplied by the left orthogonal
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Q form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= 1;
;;*          and if WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
;;*          On exit, Z has been postmultiplied by the left orthogonal
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Z form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1;
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified pair of left and right eigen-
;;*          spaces (deflating subspaces). 0 <= M <= N.
;;*
;;*  PL, PR  (output) DOUBLE PRECISION
;;*          If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
;;*          reciprocal of the norm of "projections" onto left and right
;;*          eigenspaces with respect to the selected cluster.
;;*          0 < PL, PR <= 1.
;;*          If M = 0 or M = N, PL = PR  = 1.
;;*          If IJOB = 0, 2 or 3, PL and PR are not referenced.
;;*
;;*  DIF     (output) DOUBLE PRECISION array, dimension (2).
;;*          If IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.
;;*          If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
;;*          Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
;;*          estimates of Difu and Difl.
;;*          If M = 0 or N, DIF(1:2) = F-norm([A, B]).
;;*          If IJOB = 0 or 1, DIF is not referenced.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          IF IJOB = 0, WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >=  4*N+16.
;;*          If IJOB = 1, 2 or 4, LWORK >= MAX(4*N+16, 2*M*(N-M)).
;;*          If IJOB = 3 or 5, LWORK >= MAX(4*N+16, 4*M*(N-M)).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          IF IJOB = 0, IWORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK. LIWORK >= 1.
;;*          If IJOB = 1, 2 or 4, LIWORK >=  N+6.
;;*          If IJOB = 3 or 5, LIWORK >= MAX(2*M*(N-M), N+6).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*            =0: Successful exit.
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            =1: Reordering of (A, B) failed because the transformed
;;*                matrix pair (A, B) would be too far from generalized
;;*                Schur form; the problem is very ill-conditioned.
;;*                (A, B) may have been partially reordered.
;;*                If requested, 0 is returned in DIF(*), PL and PR.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  DTGSEN first collects the selected eigenvalues by computing
;;*  orthogonal U and W that move them to the top left corner of (A, B).
;;*  In other words, the selected eigenvalues are the eigenvalues of
;;*  (A11, B11) in:
;;*
;;*                U'*(A, B)*W = (A11 A12) (B11 B12) n1
;;*                              ( 0  A22),( 0  B22) n2
;;*                                n1  n2    n1  n2
;;*
;;*  where N = n1+n2 and U' means the transpose of U. The first n1 columns
;;*  of U and W span the specified pair of left and right eigenspaces
;;*  (deflating subspaces) of (A, B).
;;*
;;*  If (A, B) has been obtained from the generalized real Schur
;;*  decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the
;;*  reordered generalized real Schur form of (C, D) is given by
;;*
;;*           (C, D) = (Q*U)*(U'*(A, B)*W)*(Z*W)',
;;*
;;*  and the first n1 columns of Q*U and Z*W span the corresponding
;;*  deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).
;;*
;;*  Note that if the selected eigenvalue is sufficiently ill-conditioned,
;;*  then its value may differ significantly from its value before
;;*  reordering.
;;*
;;*  The reciprocal condition numbers of the left and right eigenspaces
;;*  spanned by the first n1 columns of U and W (or Q*U and Z*W) may
;;*  be returned in DIF(1:2), corresponding to Difu and Difl, resp.
;;*
;;*  The Difu and Difl are defined as:
;;*
;;*       Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
;;*  and
;;*       Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],
;;*
;;*  where sigma-min(Zu) is the smallest singular value of the
;;*  (2*n1*n2)-by-(2*n1*n2) matrix
;;*
;;*       Zu = [ kron(In2, A11)  -kron(A22', In1) ]
;;*            [ kron(In2, B11)  -kron(B22', In1) ].
;;*
;;*  Here, Inx is the identity matrix of size nx and A22' is the
;;*  transpose of A22. kron(X, Y) is the Kronecker product between
;;*  the matrices X and Y.
;;*
;;*  When DIF(2) is small, small changes in (A, B) can cause large changes
;;*  in the deflating subspace. An approximate (asymptotic) bound on the
;;*  maximum angular error in the computed deflating subspaces is
;;*
;;*       EPS * norm((A, B)) / DIF(2),
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal norm of the projectors on the left and right
;;*  eigenspaces associated with (A11, B11) may be returned in PL and PR.
;;*  They are computed as follows. First we compute L and R so that
;;*  P*(A, B)*Q is block diagonal, where
;;*
;;*       P = ( I -L ) n1           Q = ( I R ) n1
;;*           ( 0  I ) n2    and        ( 0 I ) n2
;;*             n1 n2                    n1 n2
;;*
;;*  and (L, R) is the solution to the generalized Sylvester equation
;;*
;;*       A11*R - L*A22 = -A12
;;*       B11*R - L*B22 = -B12
;;*
;;*  Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2).
;;*  An approximate (asymptotic) bound on the average absolute error of
;;*  the selected eigenvalues is
;;*
;;*       EPS * norm((A, B)) / PL.
;;*
;;*  There are also global error bounds which valid for perturbations up
;;*  to a certain restriction:  A lower bound (x) on the smallest
;;*  F-norm(E,F) for which an eigenvalue of (A11, B11) may move and
;;*  coalesce with an eigenvalue of (A22, B22) under perturbation (E,F),
;;*  (i.e. (A + E, B + F), is
;;*
;;*   x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).
;;*
;;*  An approximate bound on x can be computed from DIF(1:2), PL and PR.
;;*
;;*  If y = ( F-norm(E,F) / x) <= 1, the angles between the perturbed
;;*  (L', R') and unperturbed (L, R) left and right deflating subspaces
;;*  associated with the selected cluster in the (1,1)-blocks can be
;;*  bounded as
;;*
;;*   max-angle(L, L') <= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2))
;;*   max-angle(R, R') <= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))
;;*
;;*  See LAPACK User's Guide section 4.11 or the following references
;;*  for more information.
;;*
;;*  Note that if the default method for computing the Frobenius-norm-
;;*  based estimate DIF is not wanted (see DLATDF), then the parameter
;;*  IDIFJB (see below) should be changed from 3 to 4 (routine DLATDF
;;*  (IJOB = 2 will be used)). See DTGSYL for more details.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software,
;;*      Report UMINF - 94.04, Department of Computing Science, Umea
;;*      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
;;*      Note 87. To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
;;*      1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgsen (ijob  wantq  wantz  select  n  a  lda  b  ldb  alphar  alphai  beta  q  ldq  z  ldz  m  pl  pr  dif  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alphar )
	((-idx1- (-double-)) alphai )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) m )
	((-idx0- (-double-)) pl )
	((-idx0- (-double-)) pr )
	((-idx1- (-double-)) dif )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dtgsen_(IDX_PTR($ijob,int), IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alphar,double), IDX_PTR($alphai,double), IDX_PTR($beta,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($m,int), IDX_PTR($pl,double), IDX_PTR($pr,double), IDX_PTR($dif,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgsja <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <ncycle>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGSJA computes the generalized singular value decomposition (GSVD)
;;*  of two real upper triangular (or trapezoidal) matrices A and B.
;;*
;;*  On entry, it is assumed that matrices A and B have the following
;;*  forms, which may be obtained by the preprocessing subroutine DGGSVP
;;*  from a general M-by-N matrix A and P-by-N matrix B:
;;*
;;*               N-K-L  K    L
;;*     A =    K ( 0    A12  A13 ) if M-K-L >= 0;
;;*            L ( 0     0   A23 )
;;*        M-K-L ( 0     0    0  )
;;*
;;*             N-K-L  K    L
;;*     A =  K ( 0    A12  A13 ) if M-K-L < 0;
;;*        M-K ( 0     0   A23 )
;;*
;;*             N-K-L  K    L
;;*     B =  L ( 0     0   B13 )
;;*        P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.
;;*
;;*  On exit,
;;*
;;*              U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
;;*
;;*  where U, V and Q are orthogonal matrices, Z' denotes the transpose
;;*  of Z, R is a nonsingular upper triangular matrix, and D1 and D2 are
;;*  ``diagonal'' matrices, which are of the following structures:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                    K  L
;;*         D2 = L   ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                 N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 ) K
;;*              L (  0    0   R22 ) L
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                 K M-K K+L-M
;;*      D1 =   K ( I  0    0   )
;;*           M-K ( 0  C    0   )
;;*
;;*                   K M-K K+L-M
;;*      D2 =   M-K ( 0  S    0   )
;;*           K+L-M ( 0  0    I   )
;;*             P-L ( 0  0    0   )
;;*
;;*                 N-K-L  K   M-K  K+L-M
;;* ( 0 R ) =    K ( 0    R11  R12  R13  )
;;*            M-K ( 0     0   R22  R23  )
;;*          K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*  C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*  S = diag( BETA(K+1),  ... , BETA(M) ),
;;*  C**2 + S**2 = I.
;;*
;;*  R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
;;*      (  0  R22 R23 )
;;*  in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The computation of the orthogonal transformation matrices U, V or Q
;;*  is optional.  These matrices may either be formed explicitly, or they
;;*  may be postmultiplied into input matrices U1, V1, or Q1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  U must contain an orthogonal matrix U1 on entry, and
;;*                  the product U1*U is returned;
;;*          = 'I':  U is initialized to the unit matrix, and the
;;*                  orthogonal matrix U is returned;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  V must contain an orthogonal matrix V1 on entry, and
;;*                  the product V1*V is returned;
;;*          = 'I':  V is initialized to the unit matrix, and the
;;*                  orthogonal matrix V is returned;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Q must contain an orthogonal matrix Q1 on entry, and
;;*                  the product Q1*Q is returned;
;;*          = 'I':  Q is initialized to the unit matrix, and the
;;*                  orthogonal matrix Q is returned;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  K       (input) INTEGER
;;*  L       (input) INTEGER
;;*          K and L specify the subblocks in the input matrices A and B:
;;*          A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)
;;*          of A and B, whose GSVD is going to be computed by DTGSJA.
;;*          See Further details.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
;;*          matrix R or part of R.  See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
;;*          a part of R.  See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) DOUBLE PRECISION
;;*  TOLB    (input) DOUBLE PRECISION
;;*          TOLA and TOLB are the convergence criteria for the Jacobi-
;;*          Kogbetliantz iteration procedure. Generally, they are the
;;*          same as used in the preprocessing step, say
;;*              TOLA = max(M,N)*norm(A)*MAZHEPS,
;;*              TOLB = max(P,N)*norm(B)*MAZHEPS.
;;*
;;*  ALPHA   (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = diag(C),
;;*            BETA(K+1:K+L)  = diag(S),
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
;;*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
;;*          Furthermore, if K+L < N,
;;*            ALPHA(K+L+1:N) = 0 and
;;*            BETA(K+L+1:N)  = 0.
;;*
;;*  U       (input/output) DOUBLE PRECISION array, dimension (LDU,M)
;;*          On entry, if JOBU = 'U', U must contain a matrix U1 (usually
;;*          the orthogonal matrix returned by DGGSVP).
;;*          On exit,
;;*          if JOBU = 'I', U contains the orthogonal matrix U;
;;*          if JOBU = 'U', U contains the product U1*U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (input/output) DOUBLE PRECISION array, dimension (LDV,P)
;;*          On entry, if JOBV = 'V', V must contain a matrix V1 (usually
;;*          the orthogonal matrix returned by DGGSVP).
;;*          On exit,
;;*          if JOBV = 'I', V contains the orthogonal matrix V;
;;*          if JOBV = 'V', V contains the product V1*V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
;;*          the orthogonal matrix returned by DGGSVP).
;;*          On exit,
;;*          if JOBQ = 'I', Q contains the orthogonal matrix Q;
;;*          if JOBQ = 'Q', Q contains the product Q1*Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  NCYCLE  (output) INTEGER
;;*          The number of cycles required for convergence.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1:  the procedure does not converge after MAXIT cycles.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXIT   INTEGER
;;*          MAXIT specifies the total loops that the iterative procedure
;;*          may take. If after MAXIT cycles, the routine fails to
;;*          converge, we return INFO = 1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  DTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
;;*  min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
;;*  matrix B13 to the form:
;;*
;;*           U1'*A13*Q1 = C1*R1; V1'*B13*Q1 = S1*R1,
;;*
;;*  where U1, V1 and Q1 are orthogonal matrix, and Z' is the transpose
;;*  of Z.  C1 and S1 are diagonal matrices satisfying
;;*
;;*                C1**2 + S1**2 = I,
;;*
;;*  and R1 is an L-by-L nonsingular upper triangular matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgsja (jobu  jobv  jobq  m  p  n  k  l  a  lda  b  ldb  tola  tolb  alpha  beta  u  ldu  v  ldv  q  ldq  work  ncycle  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) tola )
	((-idx0- (-double-)) tolb )
	((-idx1- (-double-)) alpha )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) ncycle )
	((-idx0- (-int-)) info )
	#{ dtgsja_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($tola,double), IDX_PTR($tolb,double), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($ncycle,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgsna <job>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <dif>  <mm>  <m>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or eigenvectors of a matrix pair (A, B) in
;;*  generalized real Schur canonical form (or of any matrix pair
;;*  (Q*A*Z', Q*B*Z') with orthogonal matrices Q and Z, where
;;*  Z' denotes the transpose of Z.
;;*
;;*  (A, B) must be in generalized real Schur form (as returned by DGGES),
;;*  i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
;;*  blocks. B is upper triangular.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (DIF):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (DIF);
;;*          = 'B': for both eigenvalues and eigenvectors (S and DIF).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the eigenpair corresponding to a real eigenvalue w(j),
;;*          SELECT(j) must be set to .TRUE.. To select condition numbers
;;*          corresponding to a complex conjugate pair of eigenvalues w(j)
;;*          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
;;*          set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the square matrix pair (A, B). N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The upper quasi-triangular matrix A in the pair (A,B).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,N)
;;*          The upper triangular matrix B in the pair (A,B).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION array, dimension (LDVL,M)
;;*          If JOB = 'E' or 'B', VL must contain left eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT. The eigenvectors must be stored in consecutive
;;*          columns of VL, as returned by DTGEVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL. LDVL >= 1.
;;*          If JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) DOUBLE PRECISION array, dimension (LDVR,M)
;;*          If JOB = 'E' or 'B', VR must contain right eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT. The eigenvectors must be stored in consecutive
;;*          columns ov VR, as returned by DTGEVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR. LDVR >= 1.
;;*          If JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array. For a complex conjugate pair of eigenvalues two
;;*          consecutive elements of S are set to the same value. Thus
;;*          S(j), DIF(j), and the j-th columns of VL and VR all
;;*          correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  DIF     (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. For a complex eigenvector two
;;*          consecutive elements of DIF are set to the same value. If
;;*          the eigenvalues cannot be reordered to compute DIF(j), DIF(j)
;;*          is set to 0; this can only occur when the true value would be
;;*          very small anyway.
;;*          If JOB = 'E', DIF is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S and DIF. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and DIF used to store
;;*          the specified condition numbers; for each selected real
;;*          eigenvalue one element is used, and for each selected complex
;;*          conjugate pair of eigenvalues, two elements are used.
;;*          If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          If JOB = 'E', WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= N.
;;*          If JOB = 'V' or 'B' LWORK >= 2*N*(N+2)+16.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N + 6)
;;*          If JOB = 'E', IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          =0: Successful exit
;;*          <0: If INFO = -i, the i-th argument had an illegal value
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of a generalized eigenvalue
;;*  w = (a, b) is defined as
;;*
;;*       S(w) = (|u'Av|**2 + |u'Bv|**2)**(1/2) / (norm(u)*norm(v))
;;*
;;*  where u and v are the left and right eigenvectors of (A, B)
;;*  corresponding to w; |z| denotes the absolute value of the complex
;;*  number, and norm(u) denotes the 2-norm of the vector u.
;;*  The pair (a, b) corresponds to an eigenvalue w = a/b (= u'Av/u'Bv)
;;*  of the matrix pair (A, B). If both a and b equal zero, then (A B) is
;;*  singular and S(I) = -1 is returned.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*       chord(w, lambda) <= EPS * norm(A, B) / S(I)
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number DIF(i) of right eigenvector u
;;*  and left eigenvector v corresponding to the generalized eigenvalue w
;;*  is defined as follows:
;;*
;;*  a) If the i-th eigenvalue w = (a,b) is real
;;*
;;*     Suppose U and V are orthogonal transformations such that
;;*
;;*                U'*(A, B)*V  = (S, T) = ( a   *  ) ( b  *  )  1
;;*                                        ( 0  S22 ),( 0 T22 )  n-1
;;*                                          1  n-1     1 n-1
;;*
;;*     Then the reciprocal condition number DIF(i) is
;;*
;;*                Difl((a, b), (S22, T22)) = sigma-min( Zl ),
;;*
;;*     where sigma-min(Zl) denotes the smallest singular value of the
;;*     2(n-1)-by-2(n-1) matrix
;;*
;;*         Zl = [ kron(a, In-1)  -kron(1, S22) ]
;;*              [ kron(b, In-1)  -kron(1, T22) ] .
;;*
;;*     Here In-1 is the identity matrix of size n-1. kron(X, Y) is the
;;*     Kronecker product between the matrices X and Y.
;;*
;;*     Note that if the default method for computing DIF(i) is wanted
;;*     (see DLATDF), then the parameter DIFDRI (see below) should be
;;*     changed from 3 to 4 (routine DLATDF(IJOB = 2 will be used)).
;;*     See DTGSYL for more details.
;;*
;;*  b) If the i-th and (i+1)-th eigenvalues are complex conjugate pair,
;;*
;;*     Suppose U and V are orthogonal transformations such that
;;*
;;*                U'*(A, B)*V = (S, T) = ( S11  *   ) ( T11  *  )  2
;;*                                       ( 0    S22 ),( 0    T22) n-2
;;*                                         2    n-2     2    n-2
;;*
;;*     and (S11, T11) corresponds to the complex conjugate eigenvalue
;;*     pair (w, conjg(w)). There exist unitary matrices U1 and V1 such
;;*     that
;;*
;;*         U1'*S11*V1 = ( s11 s12 )   and U1'*T11*V1 = ( t11 t12 )
;;*                      (  0  s22 )                    (  0  t22 )
;;*
;;*     where the generalized eigenvalues w = s11/t11 and
;;*     conjg(w) = s22/t22.
;;*
;;*     Then the reciprocal condition number DIF(i) is bounded by
;;*
;;*         min( d1, max( 1, |real(s11)/real(s22)| )*d2 )
;;*
;;*     where, d1 = Difl((s11, t11), (s22, t22)) = sigma-min(Z1), where
;;*     Z1 is the complex 2-by-2 matrix
;;*
;;*              Z1 =  [ s11  -s22 ]
;;*                    [ t11  -t22 ],
;;*
;;*     This is done by computing (using real arithmetic) the
;;*     roots of the characteristical polynomial det(Z1' * Z1 - lambda I),
;;*     where Z1' denotes the conjugate transpose of Z1 and det(X) denotes
;;*     the determinant of X.
;;*
;;*     and d2 is an upper bound on Difl((S11, T11), (S22, T22)), i.e. an
;;*     upper bound on sigma-min(Z2), where Z2 is (2n-2)-by-(2n-2)
;;*
;;*              Z2 = [ kron(S11', In-2)  -kron(I2, S22) ]
;;*                   [ kron(T11', In-2)  -kron(I2, T22) ]
;;*
;;*     Note that if the default method for computing DIF is wanted (see
;;*     DLATDF), then the parameter DIFDRI (see below) should be changed
;;*     from 3 to 4 (routine DLATDF(IJOB = 2 will be used)). See DTGSYL
;;*     for more details.
;;*
;;*  For each eigenvalue/vector specified by SELECT, DIF stores a
;;*  Frobenius norm-based estimate of Difl.
;;*
;;*  An approximate error bound for the i-th computed eigenvector VL(i) or
;;*  VR(i) is given by
;;*
;;*             EPS * norm(A, B) / DIF(i).
;;*
;;*  See ref. [2-3] for more details and further references.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software,
;;*      Report UMINF - 94.04, Department of Computing Science, Umea
;;*      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
;;*      Note 87. To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
;;*      No 1, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgsna (job  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  s  dif  mm  m  work  lwork  iwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) dif )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtgsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($s,double), IDX_PTR($dif,double), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgsy2 <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <rdsum>  <rdscal>  <iwork>  <pq>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGSY2 solves the generalized Sylvester equation:
;;*
;;*              A * R - L * B = scale * C                (1)
;;*              D * R - L * E = scale * F,
;;*
;;*  using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
;;*  (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
;;*  N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
;;*  must be in generalized Schur canonical form, i.e. A, B are upper
;;*  quasi triangular and D, E are upper triangular. The solution (R, L)
;;*  overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
;;*  chosen to avoid overflow.
;;*
;;*  In matrix notation solving equation (1) corresponds to solve
;;*  Z*x = scale*b, where Z is defined as
;;*
;;*         Z = [ kron(In, A)  -kron(B', Im) ]             (2)
;;*             [ kron(In, D)  -kron(E', Im) ],
;;*
;;*  Ik is the identity matrix of size k and X' is the transpose of X.
;;*  kron(X, Y) is the Kronecker product between the matrices X and Y.
;;*  In the process of solving (1), we solve a number of such systems
;;*  where Dim(In), Dim(In) = 1 or 2.
;;*
;;*  If TRANS = 'T', solve the transposed system Z'*y = scale*b for y,
;;*  which is equivalent to solve for R and L in
;;*
;;*              A' * R  + D' * L   = scale *  C           (3)
;;*              R  * B' + L  * E'  = scale * -F
;;*
;;*  This case is used to compute an estimate of Dif[(A, D), (B, E)] =
;;*  sigma_min(Z) using reverse communicaton with DLACON.
;;*
;;*  DTGSY2 also (IJOB >= 1) contributes to the computation in STGSYL
;;*  of an upper bound on the separation between to matrix pairs. Then
;;*  the input (A, D), (B, E) are sub-pencils of the matrix pair in
;;*  DTGSYL. See STGSYL for details.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N', solve the generalized Sylvester equation (1).
;;*          = 'T': solve the 'transposed' system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*          = 0: solve (1) only.
;;*          = 1: A contribution from this subsystem to a Frobenius
;;*               norm-based estimate of the separation between two matrix
;;*               pairs is computed. (look ahead strategy is used).
;;*          = 2: A contribution from this subsystem to a Frobenius
;;*               norm-based estimate of the separation between two matrix
;;*               pairs is computed. (DGECON on sub-systems is used.)
;;*          Not referenced if TRANS = 'T'.
;;*
;;*  M       (input) INTEGER
;;*          On entry, M specifies the order of A and D, and the row
;;*          dimension of C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the order of B and E, and the column
;;*          dimension of C, F, R and L.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA, M)
;;*          On entry, A contains an upper quasi triangular matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the matrix A. LDA >= max(1, M).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB, N)
;;*          On entry, B contains an upper quasi triangular matrix.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the matrix B. LDB >= max(1, N).
;;*
;;*  C       (input/ output) DOUBLE PRECISION array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, C has been overwritten by the
;;*          solution R.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the matrix C. LDC >= max(1, M).
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (LDD, M)
;;*          On entry, D contains an upper triangular matrix.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the matrix D. LDD >= max(1, M).
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (LDE, N)
;;*          On entry, E contains an upper triangular matrix.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the matrix E. LDE >= max(1, N).
;;*
;;*  F       (input/ output) DOUBLE PRECISION array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, F has been overwritten by the
;;*          solution L.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the matrix F. LDF >= max(1, M).
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          On exit, 0 <= SCALE <= 1. If 0 < SCALE < 1, the solutions
;;*          R and L (C and F on entry) will hold the solutions to a
;;*          slightly perturbed system but the input matrices A, B, D and
;;*          E have not been changed. If SCALE = 0, R and L will hold the
;;*          solutions to the homogeneous system with C = F = 0. Normally,
;;*          SCALE = 1.
;;*
;;*  RDSUM   (input/output) DOUBLE PRECISION
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by DTGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when DTGSY2 is called by STGSYL.
;;*
;;*  RDSCAL  (input/output) DOUBLE PRECISION
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when DTGSY2 is called by
;;*                DTGSYL.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (M+N+2)
;;*
;;*  PQ      (output) INTEGER
;;*          On exit, the number of subsystems (of size 2-by-2, 4-by-4 and
;;*          8-by-8) solved by this routine.
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, if INFO is set to
;;*            =0: Successful exit
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            >0: The matrix pairs (A, D) and (B, E) have common or very
;;*                close eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgsy2 (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  rdsum  rdscal  iwork  pq  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) d )
	((-idx0- (-int-)) ldd )
	((-idx2- (-double-)) e )
	((-idx0- (-int-)) lde )
	((-idx2- (-double-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) rdsum )
	((-idx0- (-double-)) rdscal )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) pq )
	((-idx0- (-int-)) info )
	#{ dtgsy2_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($d,double), IDX_PTR($ldd,int), IDX_PTR($e,double), IDX_PTR($lde,int), IDX_PTR($f,double), IDX_PTR($ldf,int), IDX_PTR($scale,double), IDX_PTR($rdsum,double), IDX_PTR($rdscal,double), IDX_PTR($iwork,int), IDX_PTR($pq,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtgsyl <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <dif>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTGSYL solves the generalized Sylvester equation:
;;*
;;*              A * R - L * B = scale * C                 (1)
;;*              D * R - L * E = scale * F
;;*
;;*  where R and L are unknown m-by-n matrices, (A, D), (B, E) and
;;*  (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
;;*  respectively, with real entries. (A, D) and (B, E) must be in
;;*  generalized (real) Schur canonical form, i.e. A, B are upper quasi
;;*  triangular and D, E are upper triangular.
;;*
;;*  The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
;;*  scaling factor chosen to avoid overflow.
;;*
;;*  In matrix notation (1) is equivalent to solve  Zx = scale b, where
;;*  Z is defined as
;;*
;;*             Z = [ kron(In, A)  -kron(B', Im) ]         (2)
;;*                 [ kron(In, D)  -kron(E', Im) ].
;;*
;;*  Here Ik is the identity matrix of size k and X' is the transpose of
;;*  X. kron(X, Y) is the Kronecker product between the matrices X and Y.
;;*
;;*  If TRANS = 'T', DTGSYL solves the transposed system Z'*y = scale*b,
;;*  which is equivalent to solve for R and L in
;;*
;;*              A' * R  + D' * L   = scale *  C           (3)
;;*              R  * B' + L  * E'  = scale * (-F)
;;*
;;*  This case (TRANS = 'T') is used to compute an one-norm-based estimate
;;*  of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
;;*  and (B,E), using DLACON.
;;*
;;*  If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
;;*  of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
;;*  reciprocal of the smallest singular value of Z. See [1-2] for more
;;*  information.
;;*
;;*  This is a level 3 BLAS algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N', solve the generalized Sylvester equation (1).
;;*          = 'T', solve the 'transposed' system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*           =0: solve (1) only.
;;*           =1: The functionality of 0 and 3.
;;*           =2: The functionality of 0 and 4.
;;*           =3: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*               (look ahead strategy IJOB  = 1 is used).
;;*           =4: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*               ( DGECON on sub-systems is used ).
;;*          Not referenced if TRANS = 'T'.
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrices A and D, and the row dimension of
;;*          the matrices C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices B and E, and the column dimension
;;*          of the matrices C, F, R and L.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA, M)
;;*          The upper quasi triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1, M).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB, N)
;;*          The upper quasi triangular matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1, N).
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, C has been overwritten by
;;*          the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1, M).
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (LDD, M)
;;*          The upper triangular matrix D.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the array D. LDD >= max(1, M).
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (LDE, N)
;;*          The upper triangular matrix E.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the array E. LDE >= max(1, N).
;;*
;;*  F       (input/output) DOUBLE PRECISION array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, F has been overwritten by
;;*          the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1, M).
;;*
;;*  DIF     (output) DOUBLE PRECISION
;;*          On exit DIF is the reciprocal of a lower bound of the
;;*          reciprocal of the Dif-function, i.e. DIF is an upper bound of
;;*          Dif[(A,D), (B,E)] = sigma_min(Z), where Z as in (2).
;;*          IF IJOB = 0 or TRANS = 'T', DIF is not touched.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          On exit SCALE is the scaling factor in (1) or (3).
;;*          If 0 < SCALE < 1, C and F hold the solutions R and L, resp.,
;;*          to a slightly perturbed system but the input matrices A, B, D
;;*          and E have not been changed. If SCALE = 0, C and F hold the
;;*          solutions R and L, respectively, to the homogeneous system
;;*          with C = F = 0. Normally, SCALE = 1.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          If IJOB = 0, WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK > = 1.
;;*          If IJOB = 1 or 2 and TRANS = 'N', LWORK >= 2*M*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (M+N+6)
;;*
;;*  INFO    (output) INTEGER
;;*            =0: successful exit
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            >0: (A, D) and (B, E) have common or close eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
;;*      No 1, 1996.
;;*
;;*  [2] B. Kagstrom, A Perturbation Analysis of the Generalized Sylvester
;;*      Equation (AR - LB, DR - LE ) = (C, F), SIAM J. Matrix Anal.
;;*      Appl., 15(4):1045-1060, 1994
;;*
;;*  [3] B. Kagstrom and L. Westin, Generalized Schur Methods with
;;*      Condition Estimators for Solving the Generalized Sylvester
;;*      Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7,
;;*      July 1989, pp 745-751.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtgsyl (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  dif  work  lwork  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) d )
	((-idx0- (-int-)) ldd )
	((-idx2- (-double-)) e )
	((-idx0- (-int-)) lde )
	((-idx2- (-double-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) dif )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtgsyl_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($d,double), IDX_PTR($ldd,int), IDX_PTR($e,double), IDX_PTR($lde,int), IDX_PTR($f,double), IDX_PTR($ldf,int), IDX_PTR($scale,double), IDX_PTR($dif,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtpcon <norm>  <uplo>  <diag>  <n>  <ap>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTPCON estimates the reciprocal of the condition number of a packed
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtpcon (norm  uplo  diag  n  ap  rcond  work  iwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtpcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtprfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTPRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular packed
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by DTPTRS or some other
;;*  means before entering this routine.  DTPRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtprfs (uplo  trans  diag  n  nrhs  ap  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtprfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtptri <uplo>  <diag>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTPTRI computes the inverse of a real upper or lower triangular
;;*  matrix A stored in packed format.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangular matrix A, stored
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same packed storage format.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular
;;*                matrix is singular and its inverse can not be computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  A triangular matrix A can be transferred to packed storage using one
;;*  of the following program segments:
;;*
;;*  UPLO = 'U':                      UPLO = 'L':
;;*
;;*        JC = 1                           JC = 1
;;*        DO 2 J = 1, N                    DO 2 J = 1, N
;;*           DO 1 I = 1, J                    DO 1 I = J, N
;;*              AP(JC+I-1) = A(I,J)              AP(JC+I-J) = A(I,J)
;;*      1    CONTINUE                    1    CONTINUE
;;*           JC = JC + J                      JC = JC + N - J + 1
;;*      2 CONTINUE                       2 CONTINUE
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtptri (uplo  diag  n  ap  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx0- (-int-)) info )
	#{ dtptri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtptrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTPTRS solves a triangular system of the form
;;*
;;*     A * X = B  or  A**T * X = B,
;;*
;;*  where A is a triangular matrix of order N stored in packed format,
;;*  and B is an N-by-NRHS matrix.  A check is made to verify that A is
;;*  nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtptrs (uplo  trans  diag  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) ap )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dtptrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrcon <norm>  <uplo>  <diag>  <n>  <a>  <lda>  <rcond>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRCON estimates the reciprocal of the condition number of a
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrcon (norm  uplo  diag  n  a  lda  rcond  work  iwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtrcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrevc <side>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTREVC computes some or all of the right and/or left eigenvectors of
;;*  a real upper quasi-triangular matrix T.
;;*
;;*  The right eigenvector x and the left eigenvector y of T corresponding
;;*  to an eigenvalue w are defined by:
;;*
;;*               T*x = w*x,     y'*T = w*y'
;;*
;;*  where y' denotes the conjugate transpose of the vector y.
;;*
;;*  If all eigenvectors are requested, the routine may either return the
;;*  matrices X and/or Y of right or left eigenvectors of T, or the
;;*  products Q*X and/or Q*Y, where Q is an input orthogonal
;;*  matrix. If T was obtained from the real-Schur factorization of an
;;*  original matrix A = Q*T*Q', then Q*X and Q*Y are the matrices of
;;*  right or left eigenvectors of A.
;;*
;;*  T must be in Schur canonical form (as returned by DHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
;;*  diagonal block is a complex conjugate pair of eigenvalues and
;;*  eigenvectors; only one eigenvector of the pair is computed, namely
;;*  the one corresponding to the eigenvalue with positive imaginary part.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  compute right eigenvectors only;
;;*          = 'L':  compute left eigenvectors only;
;;*          = 'B':  compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A':  compute all right and/or left eigenvectors;
;;*          = 'B':  compute all right and/or left eigenvectors,
;;*                  and backtransform them using the input matrices
;;*                  supplied in VR and/or VL;
;;*          = 'S':  compute selected right and/or left eigenvectors,
;;*                  specified by the logical array SELECT.
;;*
;;*  SELECT  (input/output) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY = 'A' or 'B', SELECT is not referenced.
;;*          To select the real eigenvector corresponding to a real
;;*          eigenvalue w(j), SELECT(j) must be set to .TRUE..  To select
;;*          the complex eigenvector corresponding to a complex conjugate
;;*          pair w(j) and w(j+1), either SELECT(j) or SELECT(j+1) must be
;;*          set to .TRUE.; then on exit SELECT(j) is .TRUE. and
;;*          SELECT(j+1) is .FALSE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input) DOUBLE PRECISION array, dimension (LDT,N)
;;*          The upper quasi-triangular matrix T in Schur canonical form.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Q
;;*          of Schur vectors returned by DHSEQR).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
;;*                           VL has the same quasi-lower triangular form
;;*                           as T'. If T(i,i) is a real eigenvalue, then
;;*                           the i-th column VL(i) of VL  is its
;;*                           corresponding eigenvector. If T(i:i+1,i:i+1)
;;*                           is a 2-by-2 block whose eigenvalues are
;;*                           complex-conjugate eigenvalues of T, then
;;*                           VL(i)+sqrt(-1)*VL(i+1) is the complex
;;*                           eigenvector corresponding to the eigenvalue
;;*                           with positive real part.
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VL, in the same order as their
;;*                           eigenvalues.
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part, and the second the imaginary part.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= max(1,N) if
;;*          SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the orthogonal matrix Q
;;*          of Schur vectors returned by DHSEQR).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of T;
;;*                           VR has the same quasi-upper triangular form
;;*                           as T. If T(i,i) is a real eigenvalue, then
;;*                           the i-th column VR(i) of VR  is its
;;*                           corresponding eigenvector. If T(i:i+1,i:i+1)
;;*                           is a 2-by-2 block whose eigenvalues are
;;*                           complex-conjugate eigenvalues of T, then
;;*                           VR(i)+sqrt(-1)*VR(i+1) is the complex
;;*                           eigenvector corresponding to the eigenvalue
;;*                           with positive real part.
;;*          if HOWMNY = 'B', the matrix Q*X;
;;*          if HOWMNY = 'S', the right eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VR, in the same order as their
;;*                           eigenvalues.
;;*          A complex eigenvector corresponding to a complex eigenvalue
;;*          is stored in two consecutive columns, the first holding the
;;*          real part and the second the imaginary part.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= max(1,N) if
;;*          SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.
;;*          If HOWMNY = 'A' or 'B', M is set to N.
;;*          Each selected real eigenvector occupies one column and each
;;*          selected complex eigenvector occupies two columns.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The algorithm used in this program is basically backward (forward)
;;*  substitution, with scaling to make the the code robust against
;;*  possible overflow.
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x| + |y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrevc (side  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  mm  m  work  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dtrevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrexc <compq>  <n>  <t_>  <ldt>  <q>  <ldq>  <ifst>  <ilst>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTREXC reorders the real Schur factorization of a real matrix
;;*  A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
;;*  moved to row ILST.
;;*
;;*  The real Schur form T is reordered by an orthogonal similarity
;;*  transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
;;*  is updated by postmultiplying it with Z.
;;*
;;*  T must be in Schur canonical form (as returned by DHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V':  update the matrix Q of Schur vectors;
;;*          = 'N':  do not update Q.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
;;*          On entry, the upper quasi-triangular matrix T, in Schur
;;*          Schur canonical form.
;;*          On exit, the reordered upper quasi-triangular matrix, again
;;*          in Schur canonical form.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          orthogonal transformation matrix Z which reorders T.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  IFST    (input/output) INTEGER
;;*  ILST    (input/output) INTEGER
;;*          Specify the reordering of the diagonal blocks of T.
;;*          The block with row index IFST is moved to row ILST, by a
;;*          sequence of transpositions between adjacent blocks.
;;*          On exit, if IFST pointed on entry to the second row of a
;;*          2-by-2 block, it is changed to point to the first row; ILST
;;*          always points to the first row of the block in its final
;;*          position (which may differ from its input value by +1 or -1).
;;*          1 <= IFST <= N; 1 <= ILST <= N.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          = 1:  two adjacent blocks were too close to swap (the problem
;;*                is very ill-conditioned); T may have been partially
;;*                reordered, and ILST points to the first row of the
;;*                current position of the block being moved.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrexc (compq  n  t_  ldt  q  ldq  ifst  ilst  work  info  )
	((-str-) compq )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ dtrexc_($compq->data, IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrrfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by DTRTRS or some other
;;*  means before entering this routine.  DTRRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) DOUBLE PRECISION array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrrfs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  x  ldx  ferr  berr  work  iwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtrrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrsen <job>  <compq>  <select>  <n>  <t_>  <ldt>  <q>  <ldq>  <wr>  <wi>  <m>  <s>  <sep>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRSEN reorders the real Schur factorization of a real matrix
;;*  A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
;;*  the leading diagonal blocks of the upper quasi-triangular matrix T,
;;*  and the leading columns of Q form an orthonormal basis of the
;;*  corresponding right invariant subspace.
;;*
;;*  Optionally the routine computes the reciprocal condition numbers of
;;*  the cluster of eigenvalues and/or the invariant subspace.
;;*
;;*  T must be in Schur canonical form (as returned by DHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elemnts equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (S) or the invariant subspace (SEP):
;;*          = 'N': none;
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for invariant subspace only (SEP);
;;*          = 'B': for both eigenvalues and invariant subspace (S and
;;*                 SEP).
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V': update the matrix Q of Schur vectors;
;;*          = 'N': do not update Q.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster. To
;;*          select a real eigenvalue w(j), SELECT(j) must be set to
;;*          .TRUE.. To select a complex conjugate pair of eigenvalues
;;*          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
;;*          either SELECT(j) or SELECT(j+1) or both must be set to
;;*          .TRUE.; a complex conjugate pair of eigenvalues must be
;;*          either both included in the cluster or both excluded.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
;;*          On entry, the upper quasi-triangular matrix T, in Schur
;;*          canonical form.
;;*          On exit, T is overwritten by the reordered matrix T, again in
;;*          Schur canonical form, with the selected eigenvalues in the
;;*          leading diagonal blocks.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          orthogonal transformation matrix which reorders T; the
;;*          leading M columns of Q form an orthonormal basis for the
;;*          specified invariant subspace.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1; and if COMPQ = 'V', LDQ >= N.
;;*
;;*  WR      (output) DOUBLE PRECISION array, dimension (N)
;;*  WI      (output) DOUBLE PRECISION array, dimension (N)
;;*          The real and imaginary parts, respectively, of the reordered
;;*          eigenvalues of T. The eigenvalues are stored in the same
;;*          order as on the diagonal of T, with WR(i) = T(i,i) and, if
;;*          T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) > 0 and
;;*          WI(i+1) = -WI(i). Note that if a complex eigenvalue is
;;*          sufficiently ill-conditioned, then its value may differ
;;*          significantly from its value before reordering.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified invariant subspace.
;;*          0 < = M <= N.
;;*
;;*  S       (output) DOUBLE PRECISION
;;*          If JOB = 'E' or 'B', S is a lower bound on the reciprocal
;;*          condition number for the selected cluster of eigenvalues.
;;*          S cannot underestimate the true reciprocal condition number
;;*          by more than a factor of sqrt(N). If M = 0 or N, S = 1.
;;*          If JOB = 'N' or 'V', S is not referenced.
;;*
;;*  SEP     (output) DOUBLE PRECISION
;;*          If JOB = 'V' or 'B', SEP is the estimated reciprocal
;;*          condition number of the specified invariant subspace. If
;;*          M = 0 or N, SEP = norm(T).
;;*          If JOB = 'N' or 'E', SEP is not referenced.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If JOB = 'N', LWORK >= max(1,N);
;;*          if JOB = 'E', LWORK >= M*(N-M);
;;*          if JOB = 'V' or 'B', LWORK >= 2*M*(N-M).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          IF JOB = 'N' or 'E', IWORK is not referenced.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If JOB = 'N' or 'E', LIWORK >= 1;
;;*          if JOB = 'V' or 'B', LIWORK >= M*(N-M).
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1: reordering of T failed because some eigenvalues are too
;;*               close to separate (the problem is very ill-conditioned);
;;*               T may have been partially reordered, and WR and WI
;;*               contain the eigenvalues in the same order as in T; S and
;;*               SEP (if requested) are set to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  DTRSEN first collects the selected eigenvalues by computing an
;;*  orthogonal transformation Z to move them to the top left corner of T.
;;*  In other words, the selected eigenvalues are the eigenvalues of T11
;;*  in:
;;*
;;*                Z'*T*Z = ( T11 T12 ) n1
;;*                         (  0  T22 ) n2
;;*                            n1  n2
;;*
;;*  where N = n1+n2 and Z' means the transpose of Z. The first n1 columns
;;*  of Z span the specified invariant subspace of T.
;;*
;;*  If T has been obtained from the real Schur factorization of a matrix
;;*  A = Q*T*Q', then the reordered real Schur factorization of A is given
;;*  by A = (Q*Z)*(Z'*T*Z)*(Q*Z)', and the first n1 columns of Q*Z span
;;*  the corresponding invariant subspace of A.
;;*
;;*  The reciprocal condition number of the average of the eigenvalues of
;;*  T11 may be returned in S. S lies between 0 (very badly conditioned)
;;*  and 1 (very well conditioned). It is computed as follows. First we
;;*  compute R so that
;;*
;;*                         P = ( I  R ) n1
;;*                             ( 0  0 ) n2
;;*                               n1 n2
;;*
;;*  is the projector on the invariant subspace associated with T11.
;;*  R is the solution of the Sylvester equation:
;;*
;;*                        T11*R - R*T22 = T12.
;;*
;;*  Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
;;*  the two-norm of M. Then S is computed as the lower bound
;;*
;;*                      (1 + F-norm(R)**2)**(-1/2)
;;*
;;*  on the reciprocal of 2-norm(P), the true reciprocal condition number.
;;*  S cannot underestimate 1 / 2-norm(P) by more than a factor of
;;*  sqrt(N).
;;*
;;*  An approximate error bound for the computed average of the
;;*  eigenvalues of T11 is
;;*
;;*                         EPS * norm(T) / S
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal condition number of the right invariant subspace
;;*  spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
;;*  SEP is defined as the separation of T11 and T22:
;;*
;;*                     sep( T11, T22 ) = sigma-min( C )
;;*
;;*  where sigma-min(C) is the smallest singular value of the
;;*  n1*n2-by-n1*n2 matrix
;;*
;;*     C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )
;;*
;;*  I(m) is an m by m identity matrix, and kprod denotes the Kronecker
;;*  product. We estimate sigma-min(C) by the reciprocal of an estimate of
;;*  the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
;;*  cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).
;;*
;;*  When SEP is small, small changes in T can cause large changes in
;;*  the invariant subspace. An approximate bound on the maximum angular
;;*  error in the computed right invariant subspace is
;;*
;;*                      EPS * norm(T) / SEP
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrsen (job  compq  select  n  t_  ldt  q  ldq  wr  wi  m  s  sep  work  lwork  iwork  liwork  info  )
	((-str-) job )
	((-str-) compq )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) wr )
	((-idx1- (-double-)) wi )
	((-idx0- (-int-)) m )
	((-idx0- (-double-)) s )
	((-idx0- (-double-)) sep )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ dtrsen_($job->data, $compq->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($wr,double), IDX_PTR($wi,double), IDX_PTR($m,int), IDX_PTR($s,double), IDX_PTR($sep,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrsna <job>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <sep>  <mm>  <m>  <work>  <ldwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or right eigenvectors of a real upper
;;*  quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
;;*  orthogonal).
;;*
;;*  T must be in Schur canonical form (as returned by DHSEQR), that is,
;;*  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
;;*  2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (SEP):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (SEP);
;;*          = 'B': for both eigenvalues and eigenvectors (S and SEP).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the eigenpair corresponding to a real eigenvalue w(j),
;;*          SELECT(j) must be set to .TRUE.. To select condition numbers
;;*          corresponding to a complex conjugate pair of eigenvalues w(j)
;;*          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
;;*          set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input) DOUBLE PRECISION array, dimension (LDT,N)
;;*          The upper quasi-triangular matrix T, in Schur canonical form.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION array, dimension (LDVL,M)
;;*          If JOB = 'E' or 'B', VL must contain left eigenvectors of T
;;*          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VL, as returned by
;;*          DHSEIN or DTREVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) DOUBLE PRECISION array, dimension (LDVR,M)
;;*          If JOB = 'E' or 'B', VR must contain right eigenvectors of T
;;*          (or of any Q*T*Q**T with Q orthogonal), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VR, as returned by
;;*          DHSEIN or DTREVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array. For a complex conjugate pair of eigenvalues two
;;*          consecutive elements of S are set to the same value. Thus
;;*          S(j), SEP(j), and the j-th columns of VL and VR all
;;*          correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  SEP     (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. For a complex eigenvector two
;;*          consecutive elements of SEP are set to the same value. If
;;*          the eigenvalues cannot be reordered to compute SEP(j), SEP(j)
;;*          is set to 0; this can only occur when the true value would be
;;*          very small anyway.
;;*          If JOB = 'E', SEP is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S (if JOB = 'E' or 'B')
;;*           and/or SEP (if JOB = 'V' or 'B'). MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and/or SEP actually
;;*          used to store the estimated condition numbers.
;;*          If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LDWORK,N+1)
;;*          If JOB = 'E', WORK is not referenced.
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*          If JOB = 'E', IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of an eigenvalue lambda is
;;*  defined as
;;*
;;*          S(lambda) = |v'*u| / (norm(u)*norm(v))
;;*
;;*  where u and v are the right and left eigenvectors of T corresponding
;;*  to lambda; v' denotes the conjugate-transpose of v, and norm(u)
;;*  denotes the Euclidean norm. These reciprocal condition numbers always
;;*  lie between zero (very badly conditioned) and one (very well
;;*  conditioned). If n = 1, S(lambda) is defined to be 1.
;;*
;;*  An approximate error bound for a computed eigenvalue W(i) is given by
;;*
;;*                      EPS * norm(T) / S(i)
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number of the right eigenvector u
;;*  corresponding to lambda is defined as follows. Suppose
;;*
;;*              T = ( lambda  c  )
;;*                  (   0    T22 )
;;*
;;*  Then the reciprocal condition number is
;;*
;;*          SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )
;;*
;;*  where sigma-min denotes the smallest singular value. We approximate
;;*  the smallest singular value by the reciprocal of an estimate of the
;;*  one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is
;;*  defined to be abs(T(1,1)).
;;*
;;*  An approximate error bound for a computed right eigenvector VR(i)
;;*  is given by
;;*
;;*                      EPS * norm(T) / SEP(i)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrsna (job  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  s  sep  mm  m  work  ldwork  iwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx2- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx2- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) sep )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) ldwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ dtrsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($s,double), IDX_PTR($sep,double), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($ldwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrsyl <trana>  <tranb>  <isgn>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRSYL solves the real Sylvester matrix equation:
;;*
;;*     op(A)*X + X*op(B) = scale*C or
;;*     op(A)*X - X*op(B) = scale*C,
;;*
;;*  where op(A) = A or A**T, and  A and B are both upper quasi-
;;*  triangular. A is M-by-M and B is N-by-N; the right hand side C and
;;*  the solution X are M-by-N; and scale is an output scale factor, set
;;*  <= 1 to avoid overflow in X.
;;*
;;*  A and B must be in Schur canonical form (as returned by DHSEQR), that
;;*  is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
;;*  each 2-by-2 diagonal block has its diagonal elements equal and its
;;*  off-diagonal elements of opposite sign.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANA   (input) CHARACTER*1
;;*          Specifies the option op(A):
;;*          = 'N': op(A) = A    (No transpose)
;;*          = 'T': op(A) = A**T (Transpose)
;;*          = 'C': op(A) = A**H (Conjugate transpose = Transpose)
;;*
;;*  TRANB   (input) CHARACTER*1
;;*          Specifies the option op(B):
;;*          = 'N': op(B) = B    (No transpose)
;;*          = 'T': op(B) = B**T (Transpose)
;;*          = 'C': op(B) = B**H (Conjugate transpose = Transpose)
;;*
;;*  ISGN    (input) INTEGER
;;*          Specifies the sign in the equation:
;;*          = +1: solve op(A)*X + X*op(B) = scale*C
;;*          = -1: solve op(A)*X - X*op(B) = scale*C
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrix A, and the number of rows in the
;;*          matrices X and C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B, and the number of columns in the
;;*          matrices X and C. N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,M)
;;*          The upper quasi-triangular matrix A, in Schur canonical form.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB,N)
;;*          The upper quasi-triangular matrix B, in Schur canonical form.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
;;*          On entry, the M-by-N right hand side matrix C.
;;*          On exit, C is overwritten by the solution matrix X.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M)
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scale factor, scale, set <= 1 to avoid overflow in X.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1: A and B have common or very close eigenvalues; perturbed
;;*               values were used to solve the equation (but the matrices
;;*               A and B are unchanged).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrsyl (trana  tranb  isgn  m  n  a  lda  b  ldb  c  ldc  scale  info  )
	((-str-) trana )
	((-str-) tranb )
	((-idx0- (-int-)) isgn )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx0- (-double-)) scale )
	((-idx0- (-int-)) info )
	#{ dtrsyl_($trana->data, $tranb->data, IDX_PTR($isgn,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($scale,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrti2 <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRTI2 computes the inverse of a real upper or lower triangular
;;*  matrix.
;;*
;;*  This is the Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading n by n upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrti2 (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dtrti2_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrtri <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRTRI computes the inverse of a real upper or lower triangular
;;*  matrix A.
;;*
;;*  This is the Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
;;*               matrix is singular and its inverse can not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrtri (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ dtrtri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtrtrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTRTRS solves a triangular system of the form
;;*
;;*     A * X = B  or  A**T * X = B,
;;*
;;*  where A is a triangular matrix of order N, and B is an N-by-NRHS
;;*  matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B  (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the i-th diagonal element of A is zero,
;;*               indicating that the matrix is singular and the solutions
;;*               X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrtrs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ dtrtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtzrqf <m>  <n>  <a>  <lda>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine DTZRZF.
;;*
;;*  DTZRQF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
;;*  to upper triangular form by means of orthogonal transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= M.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          orthogonal matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtzrqf (m  n  a  lda  tau  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ dtzrqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dtzrzf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DTZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A
;;*  to upper triangular form by means of orthogonal transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N orthogonal matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          orthogonal matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) DOUBLE PRECISION array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtzrzf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) tau )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ dtzrzf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (dzsum1 <n>  <cx>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  DZSUM1 takes the sum of the absolute values of a complex
;;*  vector and returns a double precision result.
;;*
;;*  Based on DZASUM from the Level 1 BLAS.
;;*  The change is to use the 'genuine' absolute value.
;;*
;;*  Contributed by Nick Higham for use with ZLACON.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements in the vector CX.
;;*
;;*  CX      (input) COMPLEX*16 array, dimension (N)
;;*          The vector whose elements will be summed.
;;*
;;*  INCX    (input) INTEGER
;;*          The spacing between successive values of CX.  INCX > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de dzsum1 (n  cx  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) cx )
	((-idx0- (-int-)) incx )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dzsum1_(IDX_PTR($n,int), IDX_PTR($cx,double), IDX_PTR($incx,int)) #} rval))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar lapack-d-funclist-nonintel ())

(defvar lapack-d-funclist
  '("dbdsdc" "dbdsqr" "ddisna" "dgbbrd" "dgbcon"
    "dgbequ" "dgbrfs" "dgbsv" "dgbsvx" "dgbtf2" "dgbtrf" "dgbtrs" "dgebak"
    "dgebal" "dgebd2" "dgebrd" "dgecon" "dgeequ" "dgees" "dgeesx" "dgeev"
    "dgeevx" "dgegs" "dgegv" "dgehd2" "dgehrd" "dgelq2" "dgelqf" "dgelsd"
    "dgels" "dgelss" "dgelsx" "dgelsy" "dgeql2" "dgeqlf" "dgeqp3" "dgeqpf"
    "dgeqr2" "dgeqrf" "dgerfs" "dgerq2" "dgerqf" "dgesc2" "dgesdd"
    "dgesvd" "dgesv" "dgesvx" "dgetc2" "dgetf2" "dgetrf" "dgetri" "dgetrs"
    "dggbak" "dggbal" "dgges" "dggesx" "dggev" "dggevx" "dggglm" "dgghrd"
    "dgglse" "dggqrf" "dggrqf" "dggsvd" "dggsvp" "dgtcon" "dgtrfs" "dgtsv"
    "dgtsvx" "dgttrf" "dgttrs" "dgtts2" "dhgeqz" "dhsein" "dhseqr"
    "dlabad" "dlabrd" "dlacon" "dlacpy" "dladiv" "dlae2" "dlaebz" "dlaed0"
    "dlaed1" "dlaed2" "dlaed3" "dlaed4" "dlaed5" "dlaed6" "dlaed7"
    "dlaed8" "dlaed9" "dlaeda" "dlaein" "dlaev2" "dlaexc" "dlag2" "dlags2"
    "dlagtf" "dlagtm" "dlagts" "dlagv2" "dlahqr" "dlahrd" "dlaic1"
    "dlaln2" "dlals0" "dlalsa" "dlalsd" "dlamch" "dlamrg" "dlangb"
    "dlange" "dlangt" "dlanhs" "dlansb" "dlansp" "dlanst" "dlansy"
    "dlantb" "dlantp" "dlantr" "dlanv2" "dlapll" "dlapmt" "dlapy2"
    "dlapy3" "dlaqgb" "dlaqge" "dlaqp2" "dlaqps" "dlaqsb" "dlaqsp"
    "dlaqsy" "dlaqtr" "dlar1v" "dlar2v" "dlarfb" "dlarf" "dlarfg" "dlarft"
    "dlarfx" "dlargv" "dlarnv" "dlarrb" "dlarre" "dlarrf" "dlarrv"
    "dlartg" "dlartv" "dlaruv" "dlarzb" "dlarz" "dlarzt" "dlas2" "dlascl"
    "dlasd0" "dlasd1" "dlasd2" "dlasd3" "dlasd4" "dlasd5" "dlasd6"
    "dlasd7" "dlasd8"          "dlasda" "dlasdq" "dlasdt" "dlaset"
    "dlasq1" "dlasq2" "dlasq3" "dlasq4" "dlasq5" "dlasq6" "dlasr" "dlasrt"
    "dlassq" "dlasv2" "dlaswp" "dlasy2" "dlasyf" "dlatbs" "dlatdf"
    "dlatps" "dlatrd" "dlatrs" "dlatrz" "dlatzm" "dlauu2" "dlauum"
    "dopgtr" "dopmtr" "dorg2l" "dorg2r" "dorgbr" "dorghr" "dorgl2"
    "dorglq" "dorgql" "dorgqr" "dorgr2" "dorgrq" "dorgtr" "dorm2l"
    "dorm2r" "dormbr" "dormhr" "dorml2" "dormlq" "dormql" "dormqr"
    "dormr2" "dormr3" "dormrq" "dormrz" "dormtr" "dpbcon" "dpbequ"
    "dpbrfs" "dpbstf" "dpbsv" "dpbsvx" "dpbtf2" "dpbtrf" "dpbtrs" "dpocon"
    "dpoequ" "dporfs" "dposv" "dposvx" "dpotf2" "dpotrf" "dpotri" "dpotrs"
    "dppcon" "dppequ" "dpprfs" "dppsv" "dppsvx" "dpptrf" "dpptri" "dpptrs"
    "dptcon" "dpteqr" "dptrfs" "dptsv" "dptsvx" "dpttrf" "dpttrs" "dptts2"
    "drscl" "dsbevd" "dsbev" "dsbevx" "dsbgst" "dsbgvd" "dsbgv" "dsbgvx"
    "dsbtrd" "dsecnd" "dspcon" "dspevd" "dspev" "dspevx" "dspgst" "dspgvd"
    "dspgv" "dspgvx" "dsprfs" "dspsv" "dspsvx" "dsptrd" "dsptrf" "dsptri"
    "dsptrs" "dstebz" "dstedc" "dstegr" "dstein" "dsteqr" "dsterf"
    "dstevd" "dstev" "dstevr" "dstevx" "dsycon" "dsyevd" "dsyev" "dsyevr"
    "dsyevx" "dsygs2" "dsygst" "dsygvd" "dsygv" "dsygvx" "dsyrfs" "dsysv"
    "dsysvx" "dsytd2" "dsytf2" "dsytrd" "dsytrf" "dsytri" "dsytrs"
    "dtbcon" "dtbrfs" "dtbtrs" "dtgevc" "dtgex2" "dtgexc" "dtgsen"
    "dtgsja" "dtgsna" "dtgsy2" "dtgsyl" "dtpcon" "dtprfs" "dtptri"
    "dtptrs" "dtrcon" "dtrevc" "dtrexc" "dtrrfs" "dtrsen" "dtrsna"
    "dtrsyl" "dtrti2" "dtrtri" "dtrtrs" "dtzrqf" "dtzrzf" "dzsum1"
    ))

(with-namespace lush1-
(let ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags)))
  (dhc-make-all 
   ()
   (all ((x (cons "lapack-d-dummy" lapack-d-funclist)))
     (named (downcase x)))
   (append lapack-liblapack lapack-libfortran)))
)