#? * LAPACK: Double Precision Complex Functions
;;.AUTHOR Fu Jie Huang, Yann LeCun
;; This provides a complete interface to the FORTRAN LAPACK
;; library of low-level linear algebra functions.

(libload "blas/blas-d")
(libload "blas/blas-z")

(libload "lapack-config")
(libload "lapack-x")


;; Check if we can short-circuit by just mod-loading the object file
(let* ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags))
       (objfile (dhc-make-test ())) )
  (when objfile
    (mod-load objfile)
    (mapcar mod-load (append lapack-liblapack lapack-libfortran))
    (exit) ) )


(de lapack-z-dummy () (cheader "typedef int int_func();") ())

;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zbdsqr <uplo>  <n>  <ncvt>  <nru>  <ncc>  <d>  <e>  <vt>  <ldvt>  <u>  <ldu>  <c>  <ldc>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZBDSQR computes the singular value decomposition (SVD) of a real
;;*  N-by-N (upper or lower) bidiagonal matrix B:  B = Q * S * P' (P'
;;*  denotes the transpose of P), where S is a diagonal matrix with
;;*  non-negative diagonal elements (the singular values of B), and Q
;;*  and P are orthogonal matrices.
;;*
;;*  The routine computes S, and optionally computes U * Q, P' * VT,
;;*  or Q' * C, for given complex input matrices U, VT, and C.
;;*
;;*  See "Computing  Small Singular Values of Bidiagonal Matrices With
;;*  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
;;*  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
;;*  no. 5, pp. 873-912, Sept 1990) and
;;*  "Accurate singular values and differential qd algorithms," by
;;*  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
;;*  Department, University of California at Berkeley, July 1992
;;*  for a detailed description of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  B is upper bidiagonal;
;;*          = 'L':  B is lower bidiagonal.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B.  N >= 0.
;;*
;;*  NCVT    (input) INTEGER
;;*          The number of columns of the matrix VT. NCVT >= 0.
;;*
;;*  NRU     (input) INTEGER
;;*          The number of rows of the matrix U. NRU >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C. NCC >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the bidiagonal matrix B.
;;*          On exit, if INFO=0, the singular values of B in decreasing
;;*          order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the elements of E contain the
;;*          offdiagonal elements of of the bidiagonal matrix whose SVD
;;*          is desired. On normal exit (INFO = 0), E is destroyed.
;;*          If the algorithm does not converge (INFO > 0), D and E
;;*          will contain the diagonal and superdiagonal elements of a
;;*          bidiagonal matrix orthogonally equivalent to the one given
;;*          as input. E(N) is used for workspace.
;;*
;;*  VT      (input/output) COMPLEX*16 array, dimension (LDVT, NCVT)
;;*          On entry, an N-by-NCVT matrix VT.
;;*          On exit, VT is overwritten by P' * VT.
;;*          VT is not referenced if NCVT = 0.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.
;;*          LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
;;*
;;*  U       (input/output) COMPLEX*16 array, dimension (LDU, N)
;;*          On entry, an NRU-by-N matrix U.
;;*          On exit, U is overwritten by U * Q.
;;*          U is not referenced if NRU = 0.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= max(1,NRU).
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC, NCC)
;;*          On entry, an N-by-NCC matrix C.
;;*          On exit, C is overwritten by Q' * C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  If INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm did not converge; D and E contain the
;;*                elements of a bidiagonal matrix which is orthogonally
;;*                similar to the input matrix B;  if INFO = i, i
;;*                elements of E have not converged to zero.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
;;*          TOLMUL controls the convergence criterion of the QR loop.
;;*          If it is positive, TOLMUL*EPS is the desired relative
;;*             precision in the computed singular values.
;;*          If it is negative, abs(TOLMUL*EPS*sigma_max) is the
;;*             desired absolute accuracy in the computed singular
;;*             values (corresponds to relative accuracy
;;*             abs(TOLMUL*EPS) in the largest singular value.
;;*          abs(TOLMUL) should be between 1 and 1/EPS, and preferably
;;*             between 10 (for fast convergence) and .1/EPS
;;*             (for there to be some accuracy in the results).
;;*          Default is to lose at either one eighth or 2 of the
;;*             available decimal digits in each computed singular value
;;*             (whichever is smaller).
;;*
;;*  MAXITR  INTEGER, default = 6
;;*          MAXITR controls the maximum number of passes of the
;;*          algorithm through its inner loop. The algorithms stops
;;*          (and so fails to converge) if the number of passes
;;*          through the inner loop exceeds MAXITR*N**2.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zbdsqr (uplo  n  ncvt  nru  ncc  d  e  vt  ldvt  u  ldu  c  ldc  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncvt )
	((-idx0- (-int-)) nru )
	((-idx0- (-int-)) ncc )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx3- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zbdsqr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ncvt,int), IDX_PTR($nru,int), IDX_PTR($ncc,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zdrot <n>  <cx>  <incx>  <cy>  <incy>  <c>  <s>  )
;;.VP
;;*  Purpose
;;*  =======
;;*     applies a plane rotation, where the cos and sin (c and s) are real
;;*     and the vectors cx and cy are complex.
;;*     jack dongarra, linpack, 3/11/78.
;;*
;;*     ..
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zdrot (n  cx  incx  cy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) cy )
	((-idx0- (-int-)) incy )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) s )
	#{ zdrot_(IDX_PTR($n,int), IDX_PTR($cx,double), IDX_PTR($incx,int), IDX_PTR($cy,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($s,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zdrscl <n>  <sa>  <sx>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZDRSCL multiplies an n-element complex vector x by the real scalar
;;*  1/a.  This is done without overflow or underflow as long as
;;*  the final result x/a does not overflow or underflow.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of components of the vector x.
;;*
;;*  SA      (input) DOUBLE PRECISION
;;*          The scalar a which is used to divide each component of x.
;;*          SA must be >= 0, or the subroutine will divide by zero.
;;*
;;*  SX      (input/output) COMPLEX*16 array, dimension
;;*                         (1+(N-1)*abs(INCX))
;;*          The n-element vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector SX.
;;*          > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1< i<= n
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zdrscl (n  sa  sx  incx  )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) sa )
	((-idx2- (-double-)) sx )
	((-idx0- (-int-)) incx )
	#{ zdrscl_(IDX_PTR($n,int), IDX_PTR($sa,double), IDX_PTR($sx,double), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbbrd <vect>  <m>  <n>  <ncc>  <kl>  <ku>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <pt>  <ldpt>  <c>  <ldc>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBBRD reduces a complex general m-by-n band matrix A to real upper
;;*  bidiagonal form B by a unitary transformation: Q' * A * P = B.
;;*
;;*  The routine computes B, and optionally forms Q or P', or computes
;;*  Q'*C for a given matrix C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether or not the matrices Q and P' are to be
;;*          formed.
;;*          = 'N': do not form Q or P';
;;*          = 'Q': form Q only;
;;*          = 'P': form P' only;
;;*          = 'B': form both.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NCC     (input) INTEGER
;;*          The number of columns of the matrix C.  NCC >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals of the matrix A. KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals of the matrix A. KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the m-by-n band matrix A, stored in rows 1 to
;;*          KL+KU+1. The j-th column of A is stored in the j-th column of
;;*          the array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*          On exit, A is overwritten by values generated during the
;;*          reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A. LDAB >= KL+KU+1.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B.
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
;;*          The superdiagonal elements of the bidiagonal matrix B.
;;*
;;*  Q       (output) COMPLEX*16 array, dimension (LDQ,M)
;;*          If VECT = 'Q' or 'B', the m-by-m unitary matrix Q.
;;*          If VECT = 'N' or 'P', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= max(1,M) if VECT = 'Q' or 'B'; LDQ >= 1 otherwise.
;;*
;;*  PT      (output) COMPLEX*16 array, dimension (LDPT,N)
;;*          If VECT = 'P' or 'B', the n-by-n unitary matrix P'.
;;*          If VECT = 'N' or 'Q', the array PT is not referenced.
;;*
;;*  LDPT    (input) INTEGER
;;*          The leading dimension of the array PT.
;;*          LDPT >= max(1,N) if VECT = 'P' or 'B'; LDPT >= 1 otherwise.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,NCC)
;;*          On entry, an m-by-ncc matrix C.
;;*          On exit, C is overwritten by Q'*C.
;;*          C is not referenced if NCC = 0.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C.
;;*          LDC >= max(1,M) if NCC > 0; LDC >= 1 if NCC = 0.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (max(M,N))
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbbrd (vect  m  n  ncc  kl  ku  ab  ldab  d  e  q  ldq  pt  ldpt  c  ldc  work  rwork  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ncc )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) pt )
	((-idx0- (-int-)) ldpt )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgbbrd_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ncc,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($pt,double), IDX_PTR($ldpt,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbcon <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBCON estimates the reciprocal of the condition number of a complex
;;*  general band matrix A, in either the 1-norm or the infinity-norm,
;;*  using the LU factorization computed by ZGBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by ZGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbcon (norm  n  kl  ku  ab  ldab  ipiv  anorm  rcond  work  rwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgbcon_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbequ <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N band matrix A and reduce its condition number.  R returns the
;;*  row scale factors and C the column scale factors, chosen to try to
;;*  make the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  R       (output) DOUBLE PRECISION array, dimension (M)
;;*          If INFO = 0, or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) DOUBLE PRECISION
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) DOUBLE PRECISION
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbequ (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ zgbequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbrfs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is banded, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The original band matrix A, stored in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input) COMPLEX*16 array, dimension (LDAFB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by ZGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from ZGBTRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZGBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbrfs (trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgbrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbsv <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBSV computes the solution to a complex system of linear equations
;;*  A * X = B, where A is a band matrix of order N with KL subdiagonals
;;*  and KU superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as A = L * U, where L is a product of permutation
;;*  and unit lower triangular matrices with KL subdiagonals, and U is
;;*  upper triangular with KL+KU superdiagonals.  The factored form of A
;;*  is then used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de zgbsv (n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zgbsv_(IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbsvx <fact>  <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBSVX uses the LU factorization to compute the solution to a complex
;;*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
;;*  where A is a band matrix of order N with KL subdiagonals and KU
;;*  superdiagonals, and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed by this subroutine:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = L * U,
;;*     where L is a product of permutation and unit lower triangular
;;*     matrices with KL subdiagonals, and U is upper triangular with
;;*     KL+KU superdiagonals.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB and IPIV contain the factored form of
;;*                  A.  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  AB, AFB, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)
;;*
;;*          If FACT = 'F' and EQUED is not 'N', then A must have been
;;*          equilibrated by the scaling factors in R and/or C.  AB is not
;;*          modified if FACT = 'F' or 'N', or if FACT = 'E' and
;;*          EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  AFB     (input or output) COMPLEX*16 array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains details of the LU factorization of the band matrix
;;*          A, as computed by ZGBTRF.  U is stored as an upper triangular
;;*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,
;;*          and the multipliers used during the factorization are stored
;;*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. 'N', then AFB is
;;*          the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of A.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns details of the LU factorization of the equilibrated
;;*          matrix A (see the description of AB for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = L*U
;;*          as computed by ZGBTRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, RWORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If RWORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          RWORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbsvx (fact  trans  n  kl  ku  nrhs  ab  ldab  afb  ldafb  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgbsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbtf2 <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBTF2 computes an LU factorization of a complex m-by-n band matrix
;;*  A using partial pivoting with row interchanges.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U, because of fill-in resulting from the row
;;*  interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbtf2 (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zgbtf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbtrf <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBTRF computes an LU factorization of a complex m-by-n band matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows KL+1 to
;;*          2*KL+KU+1; rows 1 to KL of the array need not be set.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, details of the factorization: U is stored as an
;;*          upper triangular band matrix with KL+KU superdiagonals in
;;*          rows 1 to KL+KU+1, and the multipliers used during the
;;*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
;;*          See below for further details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  M = N = 6, KL = 2, KU = 1:
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *    *    +    +    +       *    *    *   u14  u25  u36
;;*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
;;*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
;;*
;;*  Array elements marked * are not used by the routine; elements marked
;;*  + need not be set on entry, but are required by the routine to store
;;*  elements of U because of fill-in resulting from the row interchanges.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbtrf (m  n  kl  ku  ab  ldab  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zgbtrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgbtrs <trans>  <n>  <kl>  <ku>  <nrhs>  <ab>  <ldab>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGBTRS solves a system of linear equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B
;;*  with a general band matrix A using the LU factorization computed
;;*  by ZGBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          Details of the LU factorization of the band matrix A, as
;;*          computed by ZGBTRF.  U is stored as an upper triangular band
;;*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
;;*          the multipliers used during the factorization are stored in
;;*          rows KL+KU+2 to 2*KL+KU+1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= N, row i of the matrix was
;;*          interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgbtrs (trans  n  kl  ku  nrhs  ab  ldab  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zgbtrs_($trans->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgebak <job>  <side>  <n>  <ilo>  <ihi>  <scale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEBAK forms the right or left eigenvectors of a complex general
;;*  matrix by backward transformation on the computed eigenvectors of the
;;*  balanced matrix output by ZGEBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N', do nothing, return immediately;
;;*          = 'P', do backward transformation for permutation only;
;;*          = 'S', do backward transformation for scaling only;
;;*          = 'B', do backward transformations for both permutation and
;;*                 scaling.
;;*          JOB must be the same as the argument JOB supplied to ZGEBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by ZGEBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  SCALE   (input) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutation and scaling factors, as returned
;;*          by ZGEBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) COMPLEX*16 array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by ZHSEIN or ZTREVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgebak (job  side  n  ilo  ihi  scale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) scale )
	((-idx0- (-int-)) m )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ zgebak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,double), IDX_PTR($m,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgebal <job>  <n>  <a>  <lda>  <ilo>  <ihi>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEBAL balances a general complex matrix A.  This involves, first,
;;*  permuting A by a similarity transformation to isolate eigenvalues
;;*  in the first 1 to ILO-1 and last IHI+1 to N elements on the
;;*  diagonal; and second, applying a diagonal similarity transformation
;;*  to rows and columns ILO to IHI to make the rows and columns as
;;*  close in norm as possible.  Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrix, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
;;*                  for i = 1,...,N;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit,  A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  SCALE   (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied to
;;*          A.  If P(j) is the index of the row and column interchanged
;;*          with row and column j and D(j) is the scaling factor
;;*          applied to row and column j, then
;;*          SCALE(j) = P(j)    for j = 1,...,ILO-1
;;*                   = D(j)    for j = ILO,...,IHI
;;*                   = P(j)    for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The permutations consist of row and column interchanges which put
;;*  the matrix in the form
;;*
;;*             ( T1   X   Y  )
;;*     P A P = (  0   B   Z  )
;;*             (  0   0   T2 )
;;*
;;*  where T1 and T2 are upper triangular matrices whose eigenvalues lie
;;*  along the diagonal.  The column indices ILO and IHI mark the starting
;;*  and ending columns of the submatrix B. Balancing consists of applying
;;*  a diagonal similarity transformation inv(D) * B * D to make the
;;*  1-norms of each row of B and its corresponding column nearly equal.
;;*  The output matrix is
;;*
;;*     ( T1     X*D          Y    )
;;*     (  0  inv(D)*B*D  inv(D)*Z ).
;;*     (  0      0           T2   )
;;*
;;*  Information about the permutations P and the diagonal matrix D is
;;*  returned in the vector SCALE.
;;*
;;*  This subroutine is based on the EISPACK routine CBAL.
;;*
;;*  Modified by Tzu-Yi Chen, Computer Science Division, University of
;;*    California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgebal (job  n  a  lda  ilo  ihi  scale  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) scale )
	((-idx0- (-int-)) info )
	#{ zgebal_($job->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgebd2 <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEBD2 reduces a complex general m by n matrix A to upper or lower
;;*  real bidiagonal form B by a unitary transformation: Q' * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the unitary matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the unitary matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) COMPLEX*16 array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q. See Further Details.
;;*
;;*  TAUP    (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix P. See Further Details.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (max(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
;;*  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, v and u are complex vectors;
;;*  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
;;*  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
;;*  tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgebd2 (m  n  a  lda  d  e  tauq  taup  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tauq )
	((-idx2- (-double-)) taup )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgebd2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tauq,double), IDX_PTR($taup,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgebrd <m>  <n>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEBRD reduces a general complex M-by-N matrix A to upper or lower
;;*  bidiagonal form B by a unitary transformation: Q**H * A * P = B.
;;*
;;*  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N general matrix to be reduced.
;;*          On exit,
;;*          if m >= n, the diagonal and the first superdiagonal are
;;*            overwritten with the upper bidiagonal matrix B; the
;;*            elements below the diagonal, with the array TAUQ, represent
;;*            the unitary matrix Q as a product of elementary
;;*            reflectors, and the elements above the first superdiagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors;
;;*          if m < n, the diagonal and the first subdiagonal are
;;*            overwritten with the lower bidiagonal matrix B; the
;;*            elements below the first subdiagonal, with the array TAUQ,
;;*            represent the unitary matrix Q as a product of
;;*            elementary reflectors, and the elements above the diagonal,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The diagonal elements of the bidiagonal matrix B:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
;;*          The off-diagonal elements of the bidiagonal matrix B:
;;*          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
;;*          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
;;*
;;*  TAUQ    (output) COMPLEX*16 array dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q. See Further Details.
;;*
;;*  TAUP    (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix P. See Further Details.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,M,N).
;;*          For optimum performance LWORK >= (M+N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*  If m >= n,
;;*
;;*     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
;;*  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n,
;;*
;;*     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in
;;*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
;;*    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
;;*    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
;;*    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
;;*    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
;;*    (  v1  v2  v3  v4  v5 )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of B, vi
;;*  denotes an element of the vector defining H(i), and ui an element of
;;*  the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgebrd (m  n  a  lda  d  e  tauq  taup  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tauq )
	((-idx2- (-double-)) taup )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgebrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tauq,double), IDX_PTR($taup,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgecon <norm>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGECON estimates the reciprocal of the condition number of a general
;;*  complex matrix A, in either the 1-norm or the infinity-norm, using
;;*  the LU factorization computed by ZGETRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by ZGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgecon (norm  n  a  lda  anorm  rcond  work  rwork  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgecon_($norm->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeequ <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEEQU computes row and column scalings intended to equilibrate an
;;*  M-by-N matrix A and reduce its condition number.  R returns the row
;;*  scale factors and C the column scale factors, chosen to try to make
;;*  the largest element in each row and column of the matrix B with
;;*  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
;;*
;;*  R(i) and C(j) are restricted to be between SMLNUM = smallest safe
;;*  number and BIGNUM = largest safe number.  Use of these scaling
;;*  factors is not guaranteed to reduce the condition number of A but
;;*  works well in practice.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The M-by-N matrix whose equilibration factors are
;;*          to be computed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  R       (output) DOUBLE PRECISION array, dimension (M)
;;*          If INFO = 0 or INFO > M, R contains the row scale factors
;;*          for A.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0,  C contains the column scale factors for A.
;;*
;;*  ROWCND  (output) DOUBLE PRECISION
;;*          If INFO = 0 or INFO > M, ROWCND contains the ratio of the
;;*          smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and
;;*          AMAX is neither too large nor too small, it is not worth
;;*          scaling by R.
;;*
;;*  COLCND  (output) DOUBLE PRECISION
;;*          If INFO = 0, COLCND contains the ratio of the smallest
;;*          C(i) to the largest C(i).  If COLCND >= 0.1, it is not
;;*          worth scaling by C.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i,  and i is
;;*                <= M:  the i-th row of A is exactly zero
;;*                >  M:  the (i-M)-th column of A is exactly zero
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeequ (m  n  a  lda  r  c  rowcnd  colcnd  amax  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ zgeequ_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgees <jobvs>  <sort>  <select>  <n>  <a>  <lda>  <sdim>  <w>  <vs>  <ldvs>  <work>  <lwork>  <rwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEES computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur
;;*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  Schur form so that selected eigenvalues are at the top left.
;;*  The leading columns of Z then form an orthonormal basis for the
;;*  invariant subspace corresponding to the selected eigenvalues.
;;*
;;*  A complex matrix is in Schur form if it is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered:
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of one COMPLEX*16 argument
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to order
;;*          to the top left of the Schur form.
;;*          IF SORT = 'N', SELECT is not referenced.
;;*          The eigenvalue W(j) is selected if SELECT(W(j)) is true.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten by its Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues for which
;;*                         SELECT is true.
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          W contains the computed eigenvalues, in the same order that
;;*          they appear on the diagonal of the output Schur form T.
;;*
;;*  VS      (output) COMPLEX*16 array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the unitary matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1; if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*               <= N:  the QR algorithm failed to compute all the
;;*                      eigenvalues; elements 1:ILO-1 and i+1:N of W
;;*                      contain those eigenvalues which have converged;
;;*                      if JOBVS = 'V', VS contains the matrix which
;;*                      reduces A to its partially converged Schur form.
;;*               = N+1: the eigenvalues could not be reordered because
;;*                      some eigenvalues were too close to separate (the
;;*                      problem is very ill-conditioned);
;;*               = N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Schur form no longer satisfy
;;*                      SELECT = .TRUE..  This could also be caused by
;;*                      underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgees (jobvs  sort  select  n  a  lda  sdim  w  vs  ldvs  work  lwork  rwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx2- (-double-)) w )
	((-idx3- (-double-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ zgees_($jobvs->data, $sort->data, $select, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($w,double), IDX_PTR($vs,double), IDX_PTR($ldvs,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeesx <jobvs>  <sort>  <select>  <sense>  <n>  <a>  <lda>  <sdim>  <w>  <vs>  <ldvs>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEESX computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur
;;*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
;;*
;;*  Optionally, it also orders the eigenvalues on the diagonal of the
;;*  Schur form so that selected eigenvalues are at the top left;
;;*  computes a reciprocal condition number for the average of the
;;*  selected eigenvalues (RCONDE); and computes a reciprocal condition
;;*  number for the right invariant subspace corresponding to the
;;*  selected eigenvalues (RCONDV).  The leading columns of Z form an
;;*  orthonormal basis for this invariant subspace.
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
;;*  these quantities are called s and sep respectively).
;;*
;;*  A complex matrix is in Schur form if it is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVS   (input) CHARACTER*1
;;*          = 'N': Schur vectors are not computed;
;;*          = 'V': Schur vectors are computed.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the Schur form.
;;*          = 'N': Eigenvalues are not ordered;
;;*          = 'S': Eigenvalues are ordered (see SELECT).
;;*
;;*  SELECT  (input) LOGICAL FUNCTION of one COMPLEX*16 argument
;;*          SELECT must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'S', SELECT is used to select eigenvalues to order
;;*          to the top left of the Schur form.
;;*          If SORT = 'N', SELECT is not referenced.
;;*          An eigenvalue W(j) is selected if SELECT(W(j)) is true.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for average of selected eigenvalues only;
;;*          = 'V': Computed for selected right invariant subspace only;
;;*          = 'B': Computed for both.
;;*          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A is overwritten by its Schur form T.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues for which
;;*                         SELECT is true.
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          W contains the computed eigenvalues, in the same order
;;*          that they appear on the diagonal of the output Schur form T.
;;*
;;*  VS      (output) COMPLEX*16 array, dimension (LDVS,N)
;;*          If JOBVS = 'V', VS contains the unitary matrix Z of Schur
;;*          vectors.
;;*          If JOBVS = 'N', VS is not referenced.
;;*
;;*  LDVS    (input) INTEGER
;;*          The leading dimension of the array VS.  LDVS >= 1, and if
;;*          JOBVS = 'V', LDVS >= N.
;;*
;;*  RCONDE  (output) DOUBLE PRECISION
;;*          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
;;*          condition number for the average of the selected eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION
;;*          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
;;*          condition number for the selected right invariant subspace.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          Also, if SENSE = 'E' or 'V' or 'B', LWORK >= 2*SDIM*(N-SDIM),
;;*          where SDIM is the number of selected eigenvalues computed by
;;*          this routine.  Note that 2*SDIM*(N-SDIM) <= N*N/2.
;;*          For good performance, LWORK must generally be larger.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0: if INFO = i, and i is
;;*             <= N: the QR algorithm failed to compute all the
;;*                   eigenvalues; elements 1:ILO-1 and i+1:N of W
;;*                   contain those eigenvalues which have converged; if
;;*                   JOBVS = 'V', VS contains the transformation which
;;*                   reduces A to its partially converged Schur form.
;;*             = N+1: the eigenvalues could not be reordered because some
;;*                   eigenvalues were too close to separate (the problem
;;*                   is very ill-conditioned);
;;*             = N+2: after reordering, roundoff changed values of some
;;*                   complex eigenvalues so that leading eigenvalues in
;;*                   the Schur form no longer satisfy SELECT=.TRUE.  This
;;*                   could also be caused by underflow due to scaling.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeesx (jobvs  sort  select  sense  n  a  lda  sdim  w  vs  ldvs  rconde  rcondv  work  lwork  rwork  bwork  info  )
	((-str-) jobvs )
	((-str-) sort )
	((-gptr-"int_func *")select )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) sdim )
	((-idx2- (-double-)) w )
	((-idx3- (-double-)) vs )
	((-idx0- (-int-)) ldvs )
	((-idx0- (-double-)) rconde )
	((-idx0- (-double-)) rcondv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ zgeesx_($jobvs->data, $sort->data, $select, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($sdim,int), IDX_PTR($w,double), IDX_PTR($vs,double), IDX_PTR($ldvs,int), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeev <jobvl>  <jobvr>  <n>  <a>  <lda>  <w>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of are computed.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          W contains the computed eigenvalues.
;;*
;;*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          u(j) = VL(:,j), the j-th column of VL.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          v(j) = VR(:,j), the j-th column of VR.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1; if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors have been computed;
;;*                elements and i+1:N of W contain eigenvalues which have
;;*                converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeev (jobvl  jobvr  n  a  lda  w  vl  ldvl  vr  ldvr  work  lwork  rwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) w )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgeev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($w,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <w>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <scale>  <abnrm>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
;;*  eigenvalues and, optionally, the left and/or right eigenvectors.
;;*
;;*  Optionally also, it computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
;;*  (RCONDE), and reciprocal condition numbers for the right
;;*  eigenvectors (RCONDV).
;;*
;;*  The right eigenvector v(j) of A satisfies
;;*                   A * v(j) = lambda(j) * v(j)
;;*  where lambda(j) is its eigenvalue.
;;*  The left eigenvector u(j) of A satisfies
;;*                u(j)**H * A = lambda(j) * u(j)**H
;;*  where u(j)**H denotes the conjugate transpose of u(j).
;;*
;;*  The computed eigenvectors are normalized to have Euclidean norm
;;*  equal to 1 and largest component real.
;;*
;;*  Balancing a matrix means permuting the rows and columns to make it
;;*  more nearly upper triangular, and applying a diagonal similarity
;;*  transformation D * A * D**(-1), where D is a diagonal matrix, to
;;*  make its rows and columns closer in norm and the condition numbers
;;*  of its eigenvalues and eigenvectors smaller.  The computed
;;*  reciprocal condition numbers correspond to the balanced matrix.
;;*  Permuting rows and columns will not change the condition numbers
;;*  (in exact arithmetic) but diagonal scaling will.  For further
;;*  explanation of balancing, see section 4.10.2 of the LAPACK
;;*  Users' Guide.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Indicates how the input matrix should be diagonally scaled
;;*          and/or permuted to improve the conditioning of its
;;*          eigenvalues.
;;*          = 'N': Do not diagonally scale or permute;
;;*          = 'P': Perform permutations to make the matrix more nearly
;;*                 upper triangular. Do not diagonally scale;
;;*          = 'S': Diagonally scale the matrix, ie. replace A by
;;*                 D*A*D**(-1), where D is a diagonal matrix chosen
;;*                 to make the rows and columns of A more equal in
;;*                 norm. Do not permute;
;;*          = 'B': Both diagonally scale and permute A.
;;*
;;*          Computed reciprocal condition numbers will be for the matrix
;;*          after balancing and/or permuting. Permuting does not change
;;*          condition numbers (in exact arithmetic), but balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N': left eigenvectors of A are not computed;
;;*          = 'V': left eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVL must = 'V'.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N': right eigenvectors of A are not computed;
;;*          = 'V': right eigenvectors of A are computed.
;;*          If SENSE = 'E' or 'B', JOBVR must = 'V'.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': None are computed;
;;*          = 'E': Computed for eigenvalues only;
;;*          = 'V': Computed for right eigenvectors only;
;;*          = 'B': Computed for eigenvalues and right eigenvectors.
;;*
;;*          If SENSE = 'E' or 'B', both left and right eigenvectors
;;*          must also be computed (JOBVL = 'V' and JOBVR = 'V').
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.
;;*          On exit, A has been overwritten.  If JOBVL = 'V' or
;;*          JOBVR = 'V', A contains the Schur form of the balanced
;;*          version of the matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          W contains the computed eigenvalues.
;;*
;;*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left eigenvectors u(j) are stored one
;;*          after another in the columns of VL, in the same order
;;*          as their eigenvalues.
;;*          If JOBVL = 'N', VL is not referenced.
;;*          u(j) = VL(:,j), the j-th column of VL.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= 1; if
;;*          JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right eigenvectors v(j) are stored one
;;*          after another in the columns of VR, in the same order
;;*          as their eigenvalues.
;;*          If JOBVR = 'N', VR is not referenced.
;;*          v(j) = VR(:,j), the j-th column of VR.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= 1; if
;;*          JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values determined when A was
;;*          balanced.  The balanced A(i,j) = 0 if I > J and
;;*          J = 1,...,ILO-1 or I = IHI+1,...,N.
;;*
;;*  SCALE   (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          when balancing A.  If P(j) is the index of the row and column
;;*          interchanged with row and column j, and D(j) is the scaling
;;*          factor applied to row and column j, then
;;*          SCALE(J) = P(J),    for J = 1,...,ILO-1
;;*                   = D(J),    for J = ILO,...,IHI
;;*                   = P(J)     for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) DOUBLE PRECISION
;;*          The one-norm of the balanced matrix (the maximum
;;*          of the sum of absolute values of elements of any column).
;;*
;;*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)
;;*          RCONDE(j) is the reciprocal condition number of the j-th
;;*          eigenvalue.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)
;;*          RCONDV(j) is the reciprocal condition number of the j-th
;;*          right eigenvector.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  If SENSE = 'N' or 'E',
;;*          LWORK >= max(1,2*N), and if SENSE = 'V' or 'B',
;;*          LWORK >= N*N+2*N.
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the QR algorithm failed to compute all the
;;*                eigenvalues, and no eigenvectors or condition numbers
;;*                have been computed; elements 1:ILO-1 and i+1:N of W
;;*                contain eigenvalues which have converged.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeevx (balanc  jobvl  jobvr  sense  n  a  lda  w  vl  ldvl  vr  ldvr  ilo  ihi  scale  abnrm  rconde  rcondv  work  lwork  rwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) w )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) scale )
	((-idx0- (-double-)) abnrm )
	((-idx1- (-double-)) rconde )
	((-idx1- (-double-)) rcondv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgeevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($w,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($scale,double), IDX_PTR($abnrm,double), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgegs <jobvsl>  <jobvsr>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine ZGGES.
;;*
;;*  ZGEGS computes for a pair of N-by-N complex nonsymmetric matrices A,
;;*  B:  the generalized eigenvalues (alpha, beta), the complex Schur
;;*  form (A, B), and optionally left and/or right Schur vectors
;;*  (VSL and VSR).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver ZGEGV
;;*  instead.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  The (generalized) Schur form of a pair of matrices is the result of
;;*  multiplying both matrices on the left by one unitary matrix and
;;*  both on the right by another unitary matrix, these two unitary
;;*  matrices being chosen so as to bring the pair of matrices into
;;*  upper triangular form with the diagonal elements of B being
;;*  non-negative real numbers (this is also called complex Schur form.)
;;*
;;*  The left and right Schur vectors are the columns of VSL and VSR,
;;*  respectively, where VSL and VSR are the unitary matrices
;;*  which reduce A and B to Schur form:
;;*
;;*  Schur form of (A,B) = ( (VSL)**H A (VSR), (VSL)**H B (VSR) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose generalized
;;*          eigenvalues and (optionally) Schur vectors are to be
;;*          computed.
;;*          On exit, the generalized Schur form of A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) Schur vectors are
;;*          to be computed.
;;*          On exit, the generalized Schur form of B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),
;;*          j=1,...,N  are the diagonals of the complex Schur form (A,B)
;;*          output by ZGEGS.  The  BETA(j) will be non-negative real.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VSL     (output) COMPLEX*16 array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >= 1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) COMPLEX*16 array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          (See "Purpose", above.)
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for ZGEQRF, ZUNMQR, and CUNGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for ZGEQRF, ZUNMQR, and CUNGQR;
;;*          the optimal LWORK is N*(NB+1).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHA(j) and BETA(j) should be correct for
;;*                j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from ZGGBAL
;;*                =N+2: error return from ZGEQRF
;;*                =N+3: error return from ZUNMQR
;;*                =N+4: error return from ZUNGQR
;;*                =N+5: error return from ZGGHRD
;;*                =N+6: error return from ZHGEQZ (other than failed
;;*                                               iteration)
;;*                =N+7: error return from ZGGBAK (computing VSL)
;;*                =N+8: error return from ZGGBAK (computing VSR)
;;*                =N+9: error return from ZLASCL (various places)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgegs (jobvsl  jobvsr  n  a  lda  b  ldb  alpha  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  rwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx3- (-double-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgegs_($jobvsl->data, $jobvsr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($vsl,double), IDX_PTR($ldvsl,int), IDX_PTR($vsr,double), IDX_PTR($ldvsr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgegv <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine ZGGEV.
;;*
;;*  ZGEGV computes for a pair of N-by-N complex nonsymmetric matrices A
;;*  and B, the generalized eigenvalues (alpha, beta), and optionally,
;;*  the left and/or right generalized eigenvectors (VL and VR).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
;;*  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
;;*  is singular.  It is usually represented as the pair (alpha,beta),
;;*  as there is a reasonable interpretation for beta=0, and even for
;;*  both being zero.  A good beginning reference is the book, "Matrix
;;*  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
;;*
;;*  A right generalized eigenvector corresponding to a generalized
;;*  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
;;*  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
;;*  l such that l**H * (A - w B) = 0, where l**H is the
;;*  conjugate-transpose of l.
;;*
;;*  Note: this routine performs "full balancing" on A and B -- see
;;*  "Further Details", below.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of A on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices whose
;;*          generalized eigenvalues and (optionally) generalized
;;*          eigenvectors are to be computed.
;;*          On exit, the contents will have been destroyed.  (For a
;;*          description of the contents of B on exit, see "Further
;;*          Details", below.)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors.  (See
;;*          "Purpose", above.)
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors.  (See
;;*          "Purpose", above.)
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1, *except*
;;*          that for eigenvalues with alpha=beta=0, a zero vector will
;;*          be returned as the corresponding eigenvector.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*          To compute the optimal value of LWORK, call ILAENV to get
;;*          blocksizes (for ZGEQRF, ZUNMQR, and CUNGQR.)  Then compute:
;;*          NB  -- MAX of the blocksizes for ZGEQRF, ZUNMQR, and CUNGQR;
;;*          The optimal LWORK is  MAX( 2*N, N*(NB+1) ).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (8*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHA(j) and BETA(j) should be
;;*                correct for j=INFO+1,...,N.
;;*          > N:  errors that usually indicate LAPACK problems:
;;*                =N+1: error return from ZGGBAL
;;*                =N+2: error return from ZGEQRF
;;*                =N+3: error return from ZUNMQR
;;*                =N+4: error return from ZUNGQR
;;*                =N+5: error return from ZGGHRD
;;*                =N+6: error return from ZHGEQZ (other than failed
;;*                                               iteration)
;;*                =N+7: error return from ZTGEVC
;;*                =N+8: error return from ZGGBAK (computing VL)
;;*                =N+9: error return from ZGGBAK (computing VR)
;;*                =N+10: error return from ZLASCL (various calls)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing
;;*  ---------
;;*
;;*  This driver calls ZGGBAL to both permute and scale rows and columns
;;*  of A and B.  The permutations PL and PR are chosen so that PL*A*PR
;;*  and PL*B*R will be upper triangular except for the diagonal blocks
;;*  A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
;;*  possible.  The diagonal scaling matrices DL and DR are chosen so
;;*  that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
;;*  one (except for the elements that start out zero.)
;;*
;;*  After the eigenvalues and eigenvectors of the balanced matrices
;;*  have been computed, ZGGBAK transforms the eigenvectors back to what
;;*  they would have been (in perfect arithmetic) if they had not been
;;*  balanced.
;;*
;;*  Contents of A and B on Exit
;;*  -------- -- - --- - -- ----
;;*
;;*  If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
;;*  both), then on exit the arrays A and B will contain the complex Schur
;;*  form[*] of the "balanced" versions of A and B.  If no eigenvectors
;;*  are computed, then only the diagonal blocks will be correct.
;;*
;;*  [*] In other words, upper triangular form.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgegv (jobvl  jobvr  n  a  lda  b  ldb  alpha  beta  vl  ldvl  vr  ldvr  work  lwork  rwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgegv_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgehd2 <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H
;;*  by a unitary similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to ZGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= max(1,N).
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the n by n general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the unitary matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgehd2 (n  ilo  ihi  a  lda  tau  work  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgehd2_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgehrd <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEHRD reduces a complex general matrix A to upper Hessenberg form H
;;*  by a unitary similarity transformation:  Q' * A * Q = H .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to ZGEBAL; otherwise they should be
;;*          set to 1 and N respectively. See Further Details.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          elements below the first subdiagonal, with the array TAU,
;;*          represent the unitary matrix Q as a product of elementary
;;*          reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
;;*          zero.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of (ihi-ilo) elementary
;;*  reflectors
;;*
;;*     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
;;*  exit in A(i+2:ihi,i), and tau in TAU(i).
;;*
;;*  The contents of A are illustrated by the following example, with
;;*  n = 7, ilo = 2 and ihi = 6:
;;*
;;*  on entry,                        on exit,
;;*
;;*  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
;;*  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
;;*  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
;;*  (                         a )    (                          a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgehrd (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgehrd_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgelq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGELQ2 computes an LQ factorization of a complex m by n matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m by min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
;;*  A(i,i+1:n), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgelq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgelq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgelqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGELQF computes an LQ factorization of a complex M-by-N matrix A:
;;*  A = L * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and below the diagonal of the array
;;*          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
;;*          lower triangular if m <= n); the elements above the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
;;*  A(i,i+1:n), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zgelqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgelqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgelsd <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGELSD computes the minimum-norm solution to a real linear least
;;*  squares problem:
;;*      minimize 2-norm(| b - A*x |)
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The problem is solved in three steps:
;;*  (1) Reduce the coefficient matrix A to bidiagonal form with
;;*      Householder tranformations, reducing the original problem
;;*      into a "bidiagonal least squares problem" (BLS)
;;*  (2) Solve the BLS using a divide and conquer approach.
;;*  (3) Apply back all the Householder tranformations to solve
;;*      the original least squares problem.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M,N).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK must be at least 1.
;;*          The exact minimum amount of workspace needed depends on M,
;;*          N and NRHS. As long as LWORK is at least
;;*              2 * N + N * NRHS
;;*          if M is greater than or equal to N or
;;*              2 * M + M * NRHS
;;*          if M is less than N, the code will execute correctly.
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension at least
;;*             10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
;;*             (SMLSIZ+1)**2
;;*          if M is greater than or equal to N or
;;*             10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +
;;*             (SMLSIZ+1)**2
;;*          if M is less than N, the code will execute correctly.
;;*          SMLSIZ is returned by ILAENV and is equal to the maximum
;;*          size of the subproblems at the bottom of the computation
;;*          tree (usually about 25), and
;;*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (LIWORK)
;;*          LIWORK >= 3 * MINMN * NLVL + 11 * MINMN,
;;*          where MINMN = MIN( M,N ).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgelsd (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  rwork  iwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zgelsd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($s,double), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgels <trans>  <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGELS solves overdetermined or underdetermined complex linear systems
;;*  involving an M-by-N matrix A, or its conjugate-transpose, using a QR
;;*  or LQ factorization of A.  It is assumed that A has full rank.
;;*
;;*  The following options are provided:
;;*
;;*  1. If TRANS = 'N' and m >= n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A*X ||.
;;*
;;*  2. If TRANS = 'N' and m < n:  find the minimum norm solution of
;;*     an underdetermined system A * X = B.
;;*
;;*  3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
;;*     an undetermined system A**H * X = B.
;;*
;;*  4. If TRANS = 'C' and m < n:  find the least squares solution of
;;*     an overdetermined system, i.e., solve the least squares problem
;;*                  minimize || B - A**H * X ||.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N': the linear system involves A;
;;*          = 'C': the linear system involves A**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*            if M >= N, A is overwritten by details of its QR
;;*                       factorization as returned by ZGEQRF;
;;*            if M <  N, A is overwritten by details of its LQ
;;*                       factorization as returned by ZGELQF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the matrix B of right hand side vectors, stored
;;*          columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
;;*          if TRANS = 'C'.
;;*          On exit, B is overwritten by the solution vectors, stored
;;*          columnwise:
;;*          if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
;;*          squares solution vectors; the residual sum of squares for the
;;*          solution in each column is given by the sum of squares of
;;*          elements N+1 to M in that column;
;;*          if TRANS = 'N' and m < n, rows 1 to N of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'C' and m >= n, rows 1 to M of B contain the
;;*          minimum norm solution vectors;
;;*          if TRANS = 'C' and m < n, rows 1 to M of B contain the
;;*          least squares solution vectors; the residual sum of squares
;;*          for the solution in each column is given by the sum of
;;*          squares of elements M+1 to N in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= MAX(1,M,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          LWORK >= max( 1, MN + max( MN, NRHS ) ).
;;*          For optimal performance,
;;*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).
;;*          where MN = min(M,N) and NB is the optimum block size.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgels (trans  m  n  nrhs  a  lda  b  ldb  work  lwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgels_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgelss <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <s>  <rcond>  <rank>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGELSS computes the minimum norm solution to a complex linear
;;*  least squares problem:
;;*
;;*  Minimize 2-norm(| b - A*x |).
;;*
;;*  using the singular value decomposition (SVD) of A. A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
;;*  X.
;;*
;;*  The effective rank of A is determined by treating as zero those
;;*  singular values which are less than RCOND times the largest singular
;;*  value.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the first min(m,n) rows of A are overwritten with
;;*          its right singular vectors, stored rowwise.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, B is overwritten by the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements n+1:m in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M,N).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A in decreasing order.
;;*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A.
;;*          Singular values S(i) <= RCOND*S(1) are treated as zero.
;;*          If RCOND < 0, machine precision is used instead.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the number of singular values
;;*          which are greater than RCOND*S(1).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1, and also:
;;*          LWORK >=  2*min(M,N) + max(M,N,NRHS)
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  the algorithm for computing the SVD failed to converge;
;;*                if INFO = i, i off-diagonal elements of an intermediate
;;*                bidiagonal form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgelss (m  n  nrhs  a  lda  b  ldb  s  rcond  rank  work  lwork  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgelss_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($s,double), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgelsx <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine ZGELSY.
;;*
;;*  ZGELSX computes the minimum-norm solution to a complex linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by unitary transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*          If m >= n and RANK = n, the residual sum-of-squares for
;;*          the solution in the i-th column is given by the sum of
;;*          squares of elements N+1:M in that column.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is an
;;*          initial column, otherwise it is a free column.  Before
;;*          the QR factorization of A, all initial columns are
;;*          permuted to the leading positions; only the remaining
;;*          free columns are moved as a result of column pivoting
;;*          during the factorization.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                      (min(M,N) + max( N, 2*min(M,N)+NRHS )),
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgelsx (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgelsx_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgelsy <m>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <jpvt>  <rcond>  <rank>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGELSY computes the minimum-norm solution to a complex linear least
;;*  squares problem:
;;*      minimize || A * X - B ||
;;*  using a complete orthogonal factorization of A.  A is an M-by-N
;;*  matrix which may be rank-deficient.
;;*
;;*  Several right hand side vectors b and solution vectors x can be
;;*  handled in a single call; they are stored as the columns of the
;;*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
;;*  matrix X.
;;*
;;*  The routine first computes a QR factorization with column pivoting:
;;*      A * P = Q * [ R11 R12 ]
;;*                  [  0  R22 ]
;;*  with R11 defined as the largest leading submatrix whose estimated
;;*  condition number is less than 1/RCOND.  The order of R11, RANK,
;;*  is the effective rank of A.
;;*
;;*  Then, R22 is considered to be negligible, and R12 is annihilated
;;*  by unitary transformations from the right, arriving at the
;;*  complete orthogonal factorization:
;;*     A * P = Q * [ T11 0 ] * Z
;;*                 [  0  0 ]
;;*  The minimum-norm solution is then
;;*     X = P * Z' [ inv(T11)*Q1'*B ]
;;*                [        0       ]
;;*  where Q1 consists of the first RANK columns of Q.
;;*
;;*  This routine is basically identical to the original xGELSX except
;;*  three differences:
;;*    o The permutation of matrix B (the right hand side) is faster and
;;*      more simple.
;;*    o The call to the subroutine xGEQPF has been substituted by the
;;*      the call to the subroutine xGEQP3. This subroutine is a Blas-3
;;*      version of the QR factorization with column pivoting.
;;*    o Matrix B (the right hand side) is updated with Blas-3.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of
;;*          columns of matrices B and X. NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A has been overwritten by details of its
;;*          complete orthogonal factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the M-by-NRHS right hand side matrix B.
;;*          On exit, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,M,N).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of AP, otherwise column i is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  RCOND   (input) DOUBLE PRECISION
;;*          RCOND is used to determine the effective rank of A, which
;;*          is defined as the order of the largest leading triangular
;;*          submatrix R11 in the QR factorization with pivoting of A,
;;*          whose estimated condition number < 1/RCOND.
;;*
;;*  RANK    (output) INTEGER
;;*          The effective rank of A, i.e., the order of the submatrix
;;*          R11.  This is the same as the order of the submatrix T11
;;*          in the complete orthogonal factorization of A.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          The unblocked strategy requires that:
;;*            LWORK >= MN + MAX( 2*MN, N+1, MN+NRHS )
;;*          where MN = min(M,N).
;;*          The block algorithm requires that:
;;*            LWORK >= MN + MAX( 2*MN, NB*(N+1), MN+MN*NB, MN+NB*NRHS )
;;*          where NB is an upper bound on the blocksize returned
;;*          by ILAENV for the routines ZGEQP3, ZTZRZF, CTZRQF, ZUNMQR,
;;*          and ZUNMRZ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgelsy (m  n  nrhs  a  lda  b  ldb  jpvt  rcond  rank  work  lwork  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-int-)) jpvt )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgelsy_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($jpvt,int), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeql2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEQL2 computes a QL factorization of a complex m by n matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the m by n lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          unitary matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeql2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgeql2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeqlf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEQLF computes a QL factorization of a complex M-by-N matrix A:
;;*  A = Q * L.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m >= n, the lower triangle of the subarray
;;*          A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
;;*          if m <= n, the elements on and below the (n-m)-th
;;*          superdiagonal contain the M-by-N lower trapezoidal matrix L;
;;*          the remaining elements, with the array TAU, represent the
;;*          unitary matrix Q as a product of elementary reflectors
;;*          (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
;;*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zgeqlf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgeqlf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeqp3 <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEQP3 computes a QR factorization with column pivoting of a
;;*  matrix A:  A*P = Q*R  using Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper trapezoidal matrix R; the elements below
;;*          the diagonal, together with the array TAU, represent the
;;*          unitary matrix Q as a product of min(M,N) elementary
;;*          reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(J).ne.0, the J-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(J)=0,
;;*          the J-th column of A is a free column.
;;*          On exit, if JPVT(J)=K, then the J-th column of A*P was the
;;*          the K-th column of A.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= N+1.
;;*          For optimal performance LWORK >= ( N+1 )*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit.
;;*          < 0: if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a real/complex scalar, and v is a real/complex vector
;;*  with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
;;*  A(i+1:m,i), and tau in TAU(i).
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeqp3 (m  n  a  lda  jpvt  tau  work  lwork  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgeqp3_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeqpf <m>  <n>  <a>  <lda>  <jpvt>  <tau>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine ZGEQP3.
;;*
;;*  ZGEQPF computes a QR factorization with column pivoting of a
;;*  complex M-by-N matrix A: A*P = Q*R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of the array contains the
;;*          min(M,N)-by-N upper triangular matrix R; the elements
;;*          below the diagonal, together with the array TAU,
;;*          represent the unitary matrix Q as a product of
;;*          min(m,n) elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n)
;;*
;;*  Each H(i) has the form
;;*
;;*     H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
;;*
;;*  The matrix P is represented in jpvt as follows: If
;;*     jpvt(j) = i
;;*  then the jth column of P is the ith canonical unit vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeqpf (m  n  a  lda  jpvt  tau  work  rwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgeqpf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeqr2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEQR2 computes a QR factorization of a complex m by n matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(m,n) by n upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgeqr2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgeqr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgeqrf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGEQRF computes a QR factorization of a complex M-by-N matrix A:
;;*  A = Q * R.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
;;*          upper triangular if m >= n); the elements below the diagonal,
;;*          with the array TAU, represent the unitary matrix Q as a
;;*          product of min(m,n) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
;;*  and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zgeqrf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgeqrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgerfs <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGERFS improves the computed solution to a system of linear
;;*  equations and provides error bounds and backward error estimates for
;;*  the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The original N-by-N matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX*16 array, dimension (LDAF,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by ZGETRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from ZGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZGETRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgerfs (trans  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgerfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgerq2 <m>  <n>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGERQ2 computes an RQ factorization of a complex m by n matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the m by n upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAU, represent the unitary matrix
;;*          Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
;;*  exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgerq2 (m  n  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgerq2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgerqf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGERQF computes an RQ factorization of a complex M-by-N matrix A:
;;*  A = R * Q.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if m <= n, the upper triangle of the subarray
;;*          A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
;;*          if m >= n, the elements on and above the (m-n)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R;
;;*          the remaining elements, with the array TAU, represent the
;;*          unitary matrix Q as a product of min(m,n) elementary
;;*          reflectors (see Further Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
;;*  exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zgerqf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgerqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgesc2 <n>  <a>  <lda>  <rhs>  <ipiv>  <jpiv>  <scale>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGESC2 solves a system of linear equations
;;*
;;*            A * X = scale* RHS
;;*
;;*  with a general N-by-N matrix A using the LU factorization with
;;*  complete pivoting computed by ZGETC2.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the  LU part of the factorization of the n-by-n
;;*          matrix A computed by ZGETC2:  A = P * L * U * Q
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) COMPLEX*16 array, dimension N.
;;*          On entry, the right hand side vector b.
;;*          On exit, the solution vector X.
;;*
;;*  IPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (iput) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  SCALE    (output) DOUBLE PRECISION
;;*           On exit, SCALE contains the scale factor. SCALE is chosen
;;*           0 <= SCALE <= 1 to prevent owerflow in the solution.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgesc2 (n  a  lda  rhs  ipiv  jpiv  scale  )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) rhs )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-double-)) scale )
	#{ zgesc2_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($rhs,double), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($scale,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgesdd <jobz>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGESDD computes the singular value decomposition (SVD) of a complex
;;*  M-by-N matrix A, optionally computing the left and/or right singular
;;*  vectors, by using divide-and-conquer method. The SVD is written
;;*
;;*       A = U * SIGMA * conjugate-transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
;;*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns VT = V**H, not V.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U and all N rows of V**H are
;;*                  returned in the arrays U and VT;
;;*          = 'S':  the first min(M,N) columns of U and the first
;;*                  min(M,N) rows of V**H are returned in the arrays U
;;*                  and VT;
;;*          = 'O':  If M >= N, the first N columns of U are overwritten
;;*                  on the array A and all rows of V**H are returned in
;;*                  the array VT;
;;*                  otherwise, all columns of U are returned in the
;;*                  array U and the first M rows of V**H are overwritten
;;*                  in the array VT;
;;*          = 'N':  no columns of U or rows of V**H are computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBZ = 'O',  A is overwritten with the first N columns
;;*                          of U (the left singular vectors, stored
;;*                          columnwise) if M >= N;
;;*                          A is overwritten with the first M rows
;;*                          of V**H (the right singular vectors, stored
;;*                          rowwise) otherwise.
;;*          if JOBZ .ne. 'O', the contents of A are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)
;;*          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
;;*          UCOL = min(M,N) if JOBZ = 'S'.
;;*          If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
;;*          unitary matrix U;
;;*          if JOBZ = 'S', U contains the first min(M,N) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
;;*
;;*  VT      (output) COMPLEX*16 array, dimension (LDVT,N)
;;*          If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
;;*          N-by-N unitary matrix V**H;
;;*          if JOBZ = 'S', VT contains the first min(M,N) rows of
;;*          V**H (the right singular vectors, stored rowwise);
;;*          if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
;;*          if JOBZ = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
;;*          if JOBZ = 'O',
;;*                LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
;;*          if JOBZ = 'S' or 'A',
;;*                LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
;;*          For good performance, LWORK should generally be larger.
;;*          If LWORK < 0 but other input arguments are legal, WORK(1)
;;*          returns the optimal LWORK.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (LRWORK)
;;*          If JOBZ = 'N', LRWORK >= 7*min(M,N).
;;*          Otherwise, LRWORK >= 5*min(M,N)*min(M,N) + 5*min(M,N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The updating process of DBDSDC did not converge.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgesdd (jobz  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  rwork  iwork  info  )
	((-str-) jobz )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx3- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zgesdd_($jobz->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgesvd <jobu>  <jobvt>  <m>  <n>  <a>  <lda>  <s>  <u>  <ldu>  <vt>  <ldvt>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGESVD computes the singular value decomposition (SVD) of a complex
;;*  M-by-N matrix A, optionally computing the left and/or right singular
;;*  vectors. The SVD is written
;;*
;;*       A = U * SIGMA * conjugate-transpose(V)
;;*
;;*  where SIGMA is an M-by-N matrix which is zero except for its
;;*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
;;*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
;;*  are the singular values of A; they are real and non-negative, and
;;*  are returned in descending order.  The first min(m,n) columns of
;;*  U and V are the left and right singular vectors of A.
;;*
;;*  Note that the routine returns V**H, not V.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix U:
;;*          = 'A':  all M columns of U are returned in array U:
;;*          = 'S':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are returned in the array U;
;;*          = 'O':  the first min(m,n) columns of U (the left singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no columns of U (no left singular vectors) are
;;*                  computed.
;;*
;;*  JOBVT   (input) CHARACTER*1
;;*          Specifies options for computing all or part of the matrix
;;*          V**H:
;;*          = 'A':  all N rows of V**H are returned in the array VT;
;;*          = 'S':  the first min(m,n) rows of V**H (the right singular
;;*                  vectors) are returned in the array VT;
;;*          = 'O':  the first min(m,n) rows of V**H (the right singular
;;*                  vectors) are overwritten on the array A;
;;*          = 'N':  no rows of V**H (no right singular vectors) are
;;*                  computed.
;;*
;;*          JOBVT and JOBU cannot both be 'O'.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the input matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the input matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit,
;;*          if JOBU = 'O',  A is overwritten with the first min(m,n)
;;*                          columns of U (the left singular vectors,
;;*                          stored columnwise);
;;*          if JOBVT = 'O', A is overwritten with the first min(m,n)
;;*                          rows of V**H (the right singular vectors,
;;*                          stored rowwise);
;;*          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
;;*                          are destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
;;*          The singular values of A, sorted so that S(i) >= S(i+1).
;;*
;;*  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)
;;*          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
;;*          If JOBU = 'A', U contains the M-by-M unitary matrix U;
;;*          if JOBU = 'S', U contains the first min(m,n) columns of U
;;*          (the left singular vectors, stored columnwise);
;;*          if JOBU = 'N' or 'O', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U.  LDU >= 1; if
;;*          JOBU = 'S' or 'A', LDU >= M.
;;*
;;*  VT      (output) COMPLEX*16 array, dimension (LDVT,N)
;;*          If JOBVT = 'A', VT contains the N-by-N unitary matrix
;;*          V**H;
;;*          if JOBVT = 'S', VT contains the first min(m,n) rows of
;;*          V**H (the right singular vectors, stored rowwise);
;;*          if JOBVT = 'N' or 'O', VT is not referenced.
;;*
;;*  LDVT    (input) INTEGER
;;*          The leading dimension of the array VT.  LDVT >= 1; if
;;*          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          LWORK >=  2*MIN(M,N)+MAX(M,N).
;;*          For good performance, LWORK should generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))
;;*          On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the
;;*          unconverged superdiagonal elements of an upper bidiagonal
;;*          matrix B whose diagonal is in S (not necessarily sorted).
;;*          B satisfies A = U * B * VT, so it has the same singular
;;*          values as A, and singular vectors related by U and VT.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if ZBDSQR did not converge, INFO specifies how many
;;*                superdiagonals of an intermediate bidiagonal form B
;;*                did not converge to zero. See the description of RWORK
;;*                above for details.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgesvd (jobu  jobvt  m  n  a  lda  s  u  ldu  vt  ldvt  work  lwork  rwork  info  )
	((-str-) jobu )
	((-str-) jobvt )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx3- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-double-)) vt )
	((-idx0- (-int-)) ldvt )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgesvd_($jobu->data, $jobvt->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($ldvt,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgesv <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGESV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  The LU decomposition with partial pivoting and row interchanges is
;;*  used to factor A as
;;*     A = P * L * U,
;;*  where P is a permutation matrix, L is unit lower triangular, and U is
;;*  upper triangular.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the N-by-N coefficient matrix A.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices that define the permutation matrix P;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS matrix of right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de zgesv (n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zgesv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgesvx <fact>  <trans>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <equed>  <r>  <c>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGESVX uses the LU factorization to compute the solution to a complex
;;*  system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
;;*        TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
;;*        TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N')
;;*     or diag(C)*B (if TRANS = 'T' or 'C').
;;*
;;*  2. If FACT = 'N' or 'E', the LU decomposition is used to factor the
;;*     matrix A (after equilibration if FACT = 'E') as
;;*        A = P * L * U,
;;*     where P is a permutation matrix, L is a unit lower triangular
;;*     matrix, and U is upper triangular.
;;*
;;*  3. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so
;;*     that it solves the original system before equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF and IPIV contain the factored form of A.
;;*                  If EQUED is not 'N', the matrix A has been
;;*                  equilibrated with scaling factors given by R and C.
;;*                  A, AF, and IPIV are not modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is
;;*          not 'N', then A must have been equilibrated by the scaling
;;*          factors in R and/or C.  A is not modified if FACT = 'F' or
;;*          'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if EQUED .ne. 'N', A is scaled as follows:
;;*          EQUED = 'R':  A := diag(R) * A
;;*          EQUED = 'C':  A := A * diag(C)
;;*          EQUED = 'B':  A := diag(R) * A * diag(C).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the factors L and U from the factorization
;;*          A = P*L*U as computed by ZGETRF.  If EQUED .ne. 'N', then
;;*          AF is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the factors L and U from the factorization A = P*L*U
;;*          of the equilibrated matrix A (see the description of A for
;;*          the form of the equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          as computed by ZGETRF; row i of the matrix was interchanged
;;*          with row IPIV(i).
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the original matrix A.
;;*
;;*          If FACT = 'E', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the factorization A = P*L*U
;;*          of the equilibrated matrix A.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  R       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The row scale factors for A.  If EQUED = 'R' or 'B', A is
;;*          multiplied on the left by diag(R); if EQUED = 'N' or 'C', R
;;*          is not accessed.  R is an input argument if FACT = 'F';
;;*          otherwise, R is an output argument.  If FACT = 'F' and
;;*          EQUED = 'R' or 'B', each element of R must be positive.
;;*
;;*  C       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.  If EQUED = 'C' or 'B', A is
;;*          multiplied on the right by diag(C); if EQUED = 'N' or 'R', C
;;*          is not accessed.  C is an input argument if FACT = 'F';
;;*          otherwise, C is an output argument.  If FACT = 'F' and
;;*          EQUED = 'C' or 'B', each element of C must be positive.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit,
;;*          if EQUED = 'N', B is not modified;
;;*          if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by
;;*          diag(R)*B;
;;*          if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is
;;*          overwritten by diag(C)*B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
;;*          to the original system of equations.  Note that A and B are
;;*          modified on exit if EQUED .ne. 'N', and the solution to the
;;*          equilibrated system is inv(diag(C))*X if TRANS = 'N' and
;;*          EQUED = 'C' or 'B', or inv(diag(R))*X if TRANS = 'T' or 'C'
;;*          and EQUED = 'R' or 'B'.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (2*N)
;;*          On exit, RWORK(1) contains the reciprocal pivot growth
;;*          factor norm(A)/norm(U). The "max absolute element" norm is
;;*          used. If RWORK(1) is much less than 1, then the stability
;;*          of the LU factorization of the (equilibrated) matrix A
;;*          could be poor. This also means that the solution X, condition
;;*          estimator RCOND, and forward error bound FERR could be
;;*          unreliable. If factorization fails with 0<INFO<=N, then
;;*          RWORK(1) contains the reciprocal pivot growth factor for the
;;*          leading INFO columns of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization has
;;*                       been completed, but the factor U is exactly
;;*                       singular, so the solution and error bounds
;;*                       could not be computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgesvx (fact  trans  n  nrhs  a  lda  af  ldaf  ipiv  equed  r  c  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-str-) equed )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgesvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), $equed->data, IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgetc2 <n>  <a>  <lda>  <ipiv>  <jpiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGETC2 computes an LU factorization, using complete pivoting, of the
;;*  n-by-n matrix A. The factorization has the form A = P * L * U * Q,
;;*  where P and Q are permutation matrices, L is lower triangular with
;;*  unit diagonal elements and U is upper triangular.
;;*
;;*  This is a level 1 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the n-by-n matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U*Q; the unit diagonal elements of L are not stored.
;;*          If U(k, k) appears to be less than SMIN, U(k, k) is given the
;;*          value of SMIN, giving a nonsingular perturbed system.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1, N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (output) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  INFO    (output) INTEGER
;;*           = 0: successful exit
;;*           > 0: if INFO = k, U(k, k) is likely to produce overflow if
;;*                one tries to solve for x in Ax = b. So U is perturbed
;;*                to avoid the overflow.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgetc2 (n  a  lda  ipiv  jpiv  info  )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	((-idx0- (-int-)) info )
	#{ zgetc2_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgetf2 <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGETF2 computes an LU factorization of a general m-by-n matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
;;*               has been completed, but the factor U is exactly
;;*               singular, and division by zero will occur if it is used
;;*               to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgetf2 (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zgetf2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgetrf <m>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGETRF computes an LU factorization of a general M-by-N matrix A
;;*  using partial pivoting with row interchanges.
;;*
;;*  The factorization has the form
;;*     A = P * L * U
;;*  where P is a permutation matrix, L is lower triangular with unit
;;*  diagonal elements (lower trapezoidal if m > n), and U is upper
;;*  triangular (upper trapezoidal if m < n).
;;*
;;*  This is the right-looking Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix to be factored.
;;*          On exit, the factors L and U from the factorization
;;*          A = P*L*U; the unit diagonal elements of L are not stored.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  IPIV    (output) INTEGER array, dimension (min(M,N))
;;*          The pivot indices; for 1 <= i <= min(M,N), row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgetrf (m  n  a  lda  ipiv  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zgetrf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgetri <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGETRI computes the inverse of a matrix using the LU factorization
;;*  computed by ZGETRF.
;;*
;;*  This method inverts U and then computes inv(A) by solving the system
;;*  inv(A)*L = inv(U) for inv(A).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the factors L and U from the factorization
;;*          A = P*L*U as computed by ZGETRF.
;;*          On exit, if INFO = 0, the inverse of the original matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from ZGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*          For optimal performance LWORK >= N*NB, where NB is
;;*          the optimal blocksize returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
;;*                singular and its inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgetri (n  a  lda  ipiv  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgetri_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgetrs <trans>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGETRS solves a system of linear equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B
;;*  with a general N-by-N matrix A using the LU factorization computed
;;*  by ZGETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The factors L and U from the factorization A = P*L*U
;;*          as computed by ZGETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices from ZGETRF; for 1<=i<=N, row i of the
;;*          matrix was interchanged with row IPIV(i).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgetrs (trans  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zgetrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggbak <job>  <side>  <n>  <ilo>  <ihi>  <lscale>  <rscale>  <m>  <v>  <ldv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGBAK forms the right or left eigenvectors of a complex generalized
;;*  eigenvalue problem A*x = lambda*B*x, by backward transformation on
;;*  the computed eigenvectors of the balanced pair of matrices output by
;;*  ZGGBAL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the type of backward transformation required:
;;*          = 'N':  do nothing, return immediately;
;;*          = 'P':  do backward transformation for permutation only;
;;*          = 'S':  do backward transformation for scaling only;
;;*          = 'B':  do backward transformations for both permutation and
;;*                  scaling.
;;*          JOB must be the same as the argument JOB supplied to ZGGBAL.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  V contains right eigenvectors;
;;*          = 'L':  V contains left eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrix V.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          The integers ILO and IHI determined by ZGGBAL.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  LSCALE  (input) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the left side of A and B, as returned by ZGGBAL.
;;*
;;*  RSCALE  (input) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and/or scaling factors applied
;;*          to the right side of A and B, as returned by ZGGBAL.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix V.  M >= 0.
;;*
;;*  V       (input/output) COMPLEX*16 array, dimension (LDV,M)
;;*          On entry, the matrix of right or left eigenvectors to be
;;*          transformed, as returned by ZTGEVC.
;;*          On exit, V is overwritten by the transformed eigenvectors.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the matrix V. LDV >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. Ward, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zggbak (job  side  n  ilo  ihi  lscale  rscale  m  v  ldv  info  )
	((-str-) job )
	((-str-) side )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) lscale )
	((-idx1- (-double-)) rscale )
	((-idx0- (-int-)) m )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx0- (-int-)) info )
	#{ zggbak_($job->data, $side->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,double), IDX_PTR($rscale,double), IDX_PTR($m,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggbal <job>  <n>  <a>  <lda>  <b>  <ldb>  <ilo>  <ihi>  <lscale>  <rscale>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGBAL balances a pair of general complex matrices (A,B).  This
;;*  involves, first, permuting A and B by similarity transformations to
;;*  isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
;;*  elements on the diagonal; and second, applying a diagonal similarity
;;*  transformation to rows and columns ILO to IHI to make the rows
;;*  and columns as close in norm as possible. Both steps are optional.
;;*
;;*  Balancing may reduce the 1-norm of the matrices, and improve the
;;*  accuracy of the computed eigenvalues and/or eigenvectors in the
;;*  generalized eigenvalue problem A*x = lambda*B*x.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies the operations to be performed on A and B:
;;*          = 'N':  none:  simply set ILO = 1, IHI = N, LSCALE(I) = 1.0
;;*                  and RSCALE(I) = 1.0 for i=1,...,N;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the input matrix A.
;;*          On exit, A is overwritten by the balanced matrix.
;;*          If JOB = 'N', A is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the input matrix B.
;;*          On exit, B is overwritten by the balanced matrix.
;;*          If JOB = 'N', B is not referenced.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ILO     (output) INTEGER
;;*  IHI     (output) INTEGER
;;*          ILO and IHI are set to integers such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If P(j) is the index of the
;;*          row interchanged with row j, and D(j) is the scaling factor
;;*          applied to row j, then
;;*            LSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If P(j) is the index of the
;;*          column interchanged with column j, and D(j) is the scaling
;;*          factor applied to column j, then
;;*            RSCALE(j) = P(j)    for J = 1,...,ILO-1
;;*                      = D(j)    for J = ILO,...,IHI
;;*                      = P(j)    for J = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  See R.C. WARD, Balancing the generalized eigenvalue problem,
;;*                 SIAM J. Sci. Stat. Comp. 2 (1981), 141-152.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zggbal (job  n  a  lda  b  ldb  ilo  ihi  lscale  rscale  work  info  )
	((-str-) job )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) lscale )
	((-idx1- (-double-)) rscale )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zggbal_($job->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,double), IDX_PTR($rscale,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgges <jobvsl>  <jobvsr>  <sort>  <delctg>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alpha>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <work>  <lwork>  <rwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGES computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, the generalized complex Schur
;;*  form (S, T), and optionally left and/or right Schur vectors (VSL
;;*  and VSR). This gives the generalized Schur factorization
;;*
;;*          (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
;;*
;;*  where (VSR)**H is the conjugate-transpose of VSR.
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  triangular matrix S and the upper triangular matrix T. The leading
;;*  columns of VSL and VSR then form an unitary basis for the
;;*  corresponding left and right eigenspaces (deflating subspaces).
;;*
;;*  (If only the generalized eigenvalues are needed, use the driver
;;*  ZGGEV instead, which is faster.)
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0, and even for both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized complex Schur form if S
;;*  and T are upper triangular and, in addition, the diagonal elements
;;*  of T are non-negative real numbers.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see DELZTG).
;;*
;;*  DELZTG  (input) LOGICAL FUNCTION of two COMPLEX*16 arguments
;;*          DELZTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', DELZTG is not referenced.
;;*          If SORT = 'S', DELZTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          An eigenvalue ALPHA(j)/BETA(j) is selected if
;;*          DELZTG(ALPHA(j),BETA(j)) is true.
;;*
;;*          Note that a selected complex eigenvalue may no longer satisfy
;;*          DELZTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned), in this
;;*          case INFO is set to N+2 (See INFO below).
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which DELZTG is true.
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),
;;*          j=1,...,N  are the diagonals of the complex Schur form (A,B)
;;*          output by ZGGES. The  BETA(j) will be non-negative real.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VSL     (output) COMPLEX*16 array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >= 1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) COMPLEX*16 array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (8*N)
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHA(j) and BETA(j) should be correct for
;;*                j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in ZHGEQZ
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy DELZTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering falied in ZTGSEN.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgges (jobvsl  jobvsr  sort  delctg  n  a  lda  b  ldb  sdim  alpha  beta  vsl  ldvsl  vsr  ldvsr  work  lwork  rwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")delctg )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx3- (-double-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ zgges_($jobvsl->data, $jobvsr->data, $sort->data, $delctg, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($vsl,double), IDX_PTR($ldvsl,int), IDX_PTR($vsr,double), IDX_PTR($ldvsr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggesx <jobvsl>  <jobvsr>  <sort>  <delctg>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <sdim>  <alpha>  <beta>  <vsl>  <ldvsl>  <vsr>  <ldvsr>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <iwork>  <liwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGESX computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, the complex Schur form (S,T),
;;*  and, optionally, the left and/or right matrices of Schur vectors (VSL
;;*  and VSR).  This gives the generalized Schur factorization
;;*
;;*       (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
;;*
;;*  where (VSR)**H is the conjugate-transpose of VSR.
;;*
;;*  Optionally, it also orders the eigenvalues so that a selected cluster
;;*  of eigenvalues appears in the leading diagonal blocks of the upper
;;*  triangular matrix S and the upper triangular matrix T; computes
;;*  a reciprocal condition number for the average of the selected
;;*  eigenvalues (RCONDE); and computes a reciprocal condition number for
;;*  the right and left deflating subspaces corresponding to the selected
;;*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form
;;*  an orthonormal basis for the corresponding left and right eigenspaces
;;*  (deflating subspaces).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
;;*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
;;*  usually represented as the pair (alpha,beta), as there is a
;;*  reasonable interpretation for beta=0 or for both being zero.
;;*
;;*  A pair of matrices (S,T) is in generalized complex Schur form if T is
;;*  upper triangular with non-negative diagonal and S is upper
;;*  triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVSL  (input) CHARACTER*1
;;*          = 'N':  do not compute the left Schur vectors;
;;*          = 'V':  compute the left Schur vectors.
;;*
;;*  JOBVSR  (input) CHARACTER*1
;;*          = 'N':  do not compute the right Schur vectors;
;;*          = 'V':  compute the right Schur vectors.
;;*
;;*  SORT    (input) CHARACTER*1
;;*          Specifies whether or not to order the eigenvalues on the
;;*          diagonal of the generalized Schur form.
;;*          = 'N':  Eigenvalues are not ordered;
;;*          = 'S':  Eigenvalues are ordered (see DELZTG).
;;*
;;*  DELZTG  (input) LOGICAL FUNCTION of two COMPLEX*16 arguments
;;*          DELZTG must be declared EXTERNAL in the calling subroutine.
;;*          If SORT = 'N', DELZTG is not referenced.
;;*          If SORT = 'S', DELZTG is used to select eigenvalues to sort
;;*          to the top left of the Schur form.
;;*          Note that a selected complex eigenvalue may no longer satisfy
;;*          DELZTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
;;*          ordering may change the value of complex eigenvalues
;;*          (especially if the eigenvalue is ill-conditioned), in this
;;*          case INFO is set to N+3 see INFO below).
;;*
;;*  SENSE   (input) CHARACTER
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N' : None are computed;
;;*          = 'E' : Computed for average of selected eigenvalues only;
;;*          = 'V' : Computed for selected deflating subspaces only;
;;*          = 'B' : Computed for both.
;;*          If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VSL, and VSR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the first of the pair of matrices.
;;*          On exit, A has been overwritten by its generalized Schur
;;*          form S.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the second of the pair of matrices.
;;*          On exit, B has been overwritten by its generalized Schur
;;*          form T.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  SDIM    (output) INTEGER
;;*          If SORT = 'N', SDIM = 0.
;;*          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
;;*          for which DELZTG is true.
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.  ALPHA(j) and BETA(j),j=1,...,N  are
;;*          the diagonals of the complex Schur form (S,T).  BETA(j) will
;;*          be non-negative real.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VSL     (output) COMPLEX*16 array, dimension (LDVSL,N)
;;*          If JOBVSL = 'V', VSL will contain the left Schur vectors.
;;*          Not referenced if JOBVSL = 'N'.
;;*
;;*  LDVSL   (input) INTEGER
;;*          The leading dimension of the matrix VSL. LDVSL >=1, and
;;*          if JOBVSL = 'V', LDVSL >= N.
;;*
;;*  VSR     (output) COMPLEX*16 array, dimension (LDVSR,N)
;;*          If JOBVSR = 'V', VSR will contain the right Schur vectors.
;;*          Not referenced if JOBVSR = 'N'.
;;*
;;*  LDVSR   (input) INTEGER
;;*          The leading dimension of the matrix VSR. LDVSR >= 1, and
;;*          if JOBVSR = 'V', LDVSR >= N.
;;*
;;*  RCONDE  (output) DOUBLE PRECISION array, dimension ( 2 )
;;*          If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
;;*          reciprocal condition numbers for the average of the selected
;;*          eigenvalues.
;;*          Not referenced if SENSE = 'N' or 'V'.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION array, dimension ( 2 )
;;*          If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
;;*          reciprocal condition number for the selected deflating
;;*          subspaces.
;;*          Not referenced if SENSE = 'N' or 'E'.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 2*N.
;;*          If SENSE = 'E', 'V', or 'B',
;;*          LWORK >= MAX(2*N, 2*SDIM*(N-SDIM)).
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension ( 8*N )
;;*          Real workspace.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          Not referenced if SENSE = 'N'.
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array WORK. LIWORK >= N+2.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          Not referenced if SORT = 'N'.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  (A,B) are not in Schur
;;*                form, but ALPHA(j) and BETA(j) should be correct for
;;*                j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in ZHGEQZ
;;*                =N+2: after reordering, roundoff changed values of
;;*                      some complex eigenvalues so that leading
;;*                      eigenvalues in the Generalized Schur form no
;;*                      longer satisfy DELZTG=.TRUE.  This could also
;;*                      be caused due to scaling.
;;*                =N+3: reordering failed in ZTGSEN.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zggesx (jobvsl  jobvsr  sort  delctg  sense  n  a  lda  b  ldb  sdim  alpha  beta  vsl  ldvsl  vsr  ldvsr  rconde  rcondv  work  lwork  rwork  iwork  liwork  bwork  info  )
	((-str-) jobvsl )
	((-str-) jobvsr )
	((-str-) sort )
	((-gptr-"int_func *")delctg )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) sdim )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) vsl )
	((-idx0- (-int-)) ldvsl )
	((-idx3- (-double-)) vsr )
	((-idx0- (-int-)) ldvsr )
	((-idx1- (-double-)) rconde )
	((-idx1- (-double-)) rcondv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ zggesx_($jobvsl->data, $jobvsr->data, $sort->data, $delctg, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($sdim,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($vsl,double), IDX_PTR($ldvsl,int), IDX_PTR($vsr,double), IDX_PTR($ldvsr,int), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggev <jobvl>  <jobvr>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGEV computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B), the generalized eigenvalues, and optionally, the left and/or
;;*  right generalized eigenvectors.
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right generalized eigenvector v(j) corresponding to the
;;*  generalized eigenvalue lambda(j) of (A,B) satisfies
;;*
;;*               A * v(j) = lambda(j) * B * v(j).
;;*
;;*  The left generalized eigenvector u(j) corresponding to the
;;*  generalized eigenvalues lambda(j) of (A,B) satisfies
;;*
;;*               u(j)**H * A = lambda(j) * u(j)**H * B
;;*
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
;;*          generalized eigenvalues.
;;*
;;*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio alpha/beta.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors u(j) are
;;*          stored one after another in the columns of VL, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors v(j) are
;;*          stored one after another in the columns of VR, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,2*N).
;;*          For good performance, LWORK must generally be larger.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (8*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          =1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHA(j) and BETA(j) should be
;;*                correct for j=INFO+1,...,N.
;;*          > N:  =N+1: other then QZ iteration failed in DHGEQZ,
;;*                =N+2: error return from DTGEVC.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zggev (jobvl  jobvr  n  a  lda  b  ldb  alpha  beta  vl  ldvl  vr  ldvr  work  lwork  rwork  info  )
	((-str-) jobvl )
	((-str-) jobvr )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zggev_($jobvl->data, $jobvr->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggevx <balanc>  <jobvl>  <jobvr>  <sense>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <vl>  <ldvl>  <vr>  <ldvr>  <ilo>  <ihi>  <lscale>  <rscale>  <abnrm>  <bbnrm>  <rconde>  <rcondv>  <work>  <lwork>  <rwork>  <iwork>  <bwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
;;*  (A,B) the generalized eigenvalues, and optionally, the left and/or
;;*  right generalized eigenvectors.
;;*
;;*  Optionally, it also computes a balancing transformation to improve
;;*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
;;*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
;;*  the eigenvalues (RCONDE), and reciprocal condition numbers for the
;;*  right eigenvectors (RCONDV).
;;*
;;*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
;;*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
;;*  singular. It is usually represented as the pair (alpha,beta), as
;;*  there is a reasonable interpretation for beta=0, and even for both
;;*  being zero.
;;*
;;*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*                   A * v(j) = lambda(j) * B * v(j) .
;;*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
;;*  of (A,B) satisfies
;;*                   u(j)**H * A  = lambda(j) * u(j)**H * B.
;;*  where u(j)**H is the conjugate-transpose of u(j).
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  BALANC  (input) CHARACTER*1
;;*          Specifies the balance option to be performed:
;;*          = 'N':  do not diagonally scale or permute;
;;*          = 'P':  permute only;
;;*          = 'S':  scale only;
;;*          = 'B':  both permute and scale.
;;*          Computed reciprocal condition numbers will be for the
;;*          matrices after permuting and/or balancing. Permuting does
;;*          not change condition numbers (in exact arithmetic), but
;;*          balancing does.
;;*
;;*  JOBVL   (input) CHARACTER*1
;;*          = 'N':  do not compute the left generalized eigenvectors;
;;*          = 'V':  compute the left generalized eigenvectors.
;;*
;;*  JOBVR   (input) CHARACTER*1
;;*          = 'N':  do not compute the right generalized eigenvectors;
;;*          = 'V':  compute the right generalized eigenvectors.
;;*
;;*  SENSE   (input) CHARACTER*1
;;*          Determines which reciprocal condition numbers are computed.
;;*          = 'N': none are computed;
;;*          = 'E': computed for eigenvalues only;
;;*          = 'V': computed for eigenvectors only;
;;*          = 'B': computed for eigenvalues and eigenvectors.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, VL, and VR.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the matrix A in the pair (A,B).
;;*          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then A contains the first part of the complex Schur
;;*          form of the "balanced" versions of the input A and B.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the matrix B in the pair (A,B).
;;*          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
;;*          or both, then B contains the second part of the complex
;;*          Schur form of the "balanced" versions of the input A and B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of B.  LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the generalized
;;*          eigenvalues.
;;*
;;*          Note: the quotient ALPHA(j)/BETA(j) ) may easily over- or
;;*          underflow, and BETA(j) may even be zero.  Thus, the user
;;*          should avoid naively computing the ratio ALPHA/BETA.
;;*          However, ALPHA will be always less than and usually
;;*          comparable with norm(A) in magnitude, and BETA always less
;;*          than and usually comparable with norm(B).
;;*
;;*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)
;;*          If JOBVL = 'V', the left generalized eigenvectors u(j) are
;;*          stored one after another in the columns of VL, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVL = 'N'.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the matrix VL. LDVL >= 1, and
;;*          if JOBVL = 'V', LDVL >= N.
;;*
;;*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)
;;*          If JOBVR = 'V', the right generalized eigenvectors v(j) are
;;*          stored one after another in the columns of VR, in the same
;;*          order as their eigenvalues.
;;*          Each eigenvector will be scaled so the largest component
;;*          will have abs(real part) + abs(imag. part) = 1.
;;*          Not referenced if JOBVR = 'N'.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the matrix VR. LDVR >= 1, and
;;*          if JOBVR = 'V', LDVR >= N.
;;*
;;*  ILO,IHI (output) INTEGER
;;*          ILO and IHI are integer values such that on exit
;;*          A(i,j) = 0 and B(i,j) = 0 if i > j and
;;*          j = 1,...,ILO-1 or i = IHI+1,...,N.
;;*          If BALANC = 'N' or 'S', ILO = 1 and IHI = N.
;;*
;;*  LSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the left side of A and B.  If PL(j) is the index of the
;;*          row interchanged with row j, and DL(j) is the scaling
;;*          factor applied to row j, then
;;*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1
;;*                      = DL(j)  for j = ILO,...,IHI
;;*                      = PL(j)  for j = IHI+1,...,N.
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  RSCALE  (output) DOUBLE PRECISION array, dimension (N)
;;*          Details of the permutations and scaling factors applied
;;*          to the right side of A and B.  If PR(j) is the index of the
;;*          column interchanged with column j, and DR(j) is the scaling
;;*          factor applied to column j, then
;;*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1
;;*                      = DR(j)  for j = ILO,...,IHI
;;*                      = PR(j)  for j = IHI+1,...,N
;;*          The order in which the interchanges are made is N to IHI+1,
;;*          then 1 to ILO-1.
;;*
;;*  ABNRM   (output) DOUBLE PRECISION
;;*          The one-norm of the balanced matrix A.
;;*
;;*  BBNRM   (output) DOUBLE PRECISION
;;*          The one-norm of the balanced matrix B.
;;*
;;*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)
;;*          If SENSE = 'E' or 'B', the reciprocal condition numbers of
;;*          the selected eigenvalues, stored in consecutive elements of
;;*          the array.
;;*          If SENSE = 'V', RCONDE is not referenced.
;;*
;;*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array. If the eigenvalues cannot be reordered
;;*          to compute RCONDV(j), RCONDV(j) is set to 0; this can only
;;*          occur when the true value would be very small anyway.
;;*          If SENSE = 'E', RCONDV is not referenced.
;;*          Not referenced if JOB = 'E'.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,2*N).
;;*          If SENSE = 'N' or 'E', LWORK >= 2*N.
;;*          If SENSE = 'V' or 'B', LWORK >= 2*N*N+2*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (6*N)
;;*          Real workspace.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N+2)
;;*          If SENSE = 'E', IWORK is not referenced.
;;*
;;*  BWORK   (workspace) LOGICAL array, dimension (N)
;;*          If SENSE = 'N', BWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1,...,N:
;;*                The QZ iteration failed.  No eigenvectors have been
;;*                calculated, but ALPHA(j) and BETA(j) should be correct
;;*                for j=INFO+1,...,N.
;;*          > N:  =N+1: other than QZ iteration failed in ZHGEQZ.
;;*                =N+2: error return from ZTGEVC.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Balancing a matrix pair (A,B) includes, first, permuting rows and
;;*  columns to isolate eigenvalues, second, applying diagonal similarity
;;*  transformation to the rows and columns to make the rows and columns
;;*  as close in norm as possible. The computed reciprocal condition
;;*  numbers correspond to the balanced matrix. Permuting rows and columns
;;*  will not change the condition numbers (in exact arithmetic) but
;;*  diagonal scaling will.  For further explanation of balancing, see
;;*  section 4.11.1.2 of LAPACK Users' Guide.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)
;;*
;;*  An approximate error bound for the angle between the i-th computed
;;*  eigenvector VL(i) or VR(i) is given by
;;*
;;*       EPS * norm(ABNRM, BBNRM) / DIF(i).
;;*
;;*  For further explanation of the reciprocal condition numbers RCONDE
;;*  and RCONDV, see section 4.11 of LAPACK User's Guide.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zggevx (balanc  jobvl  jobvr  sense  n  a  lda  b  ldb  alpha  beta  vl  ldvl  vr  ldvr  ilo  ihi  lscale  rscale  abnrm  bbnrm  rconde  rcondv  work  lwork  rwork  iwork  bwork  info  )
	((-str-) balanc )
	((-str-) jobvl )
	((-str-) jobvr )
	((-str-) sense )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx1- (-double-)) lscale )
	((-idx1- (-double-)) rscale )
	((-idx0- (-double-)) abnrm )
	((-idx0- (-double-)) bbnrm )
	((-idx1- (-double-)) rconde )
	((-idx1- (-double-)) rcondv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) bwork )
	((-idx0- (-int-)) info )
	#{ zggevx_($balanc->data, $jobvl->data, $jobvr->data, $sense->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($lscale,double), IDX_PTR($rscale,double), IDX_PTR($abnrm,double), IDX_PTR($bbnrm,double), IDX_PTR($rconde,double), IDX_PTR($rcondv,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($bwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggglm <n>  <m>  <p>  <a>  <lda>  <b>  <ldb>  <d>  <x>  <y>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGGLM solves a general Gauss-Markov linear model (GLM) problem:
;;*
;;*          minimize || y ||_2   subject to   d = A*x + B*y
;;*              x
;;*
;;*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
;;*  given N-vector. It is assumed that M <= N <= M+P, and
;;*
;;*             rank(A) = M    and    rank( A B ) = N.
;;*
;;*  Under these assumptions, the constrained equation is always
;;*  consistent, and there is a unique solution x and a minimal 2-norm
;;*  solution y, which is obtained using a generalized QR factorization
;;*  of A and B.
;;*
;;*  In particular, if matrix B is square nonsingular, then the problem
;;*  GLM is equivalent to the following weighted linear least squares
;;*  problem
;;*
;;*               minimize || inv(B)*(d-A*x) ||_2
;;*                   x
;;*
;;*  where inv(B) denotes the inverse of B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B.  N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  0 <= M <= N.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= N-M.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  D       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, D is the left hand side of the GLM equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) COMPLEX*16 array, dimension (M)
;;*  Y       (output) COMPLEX*16 array, dimension (P)
;;*          On exit, X and Y are the solutions of the GLM problem.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N+M+P).
;;*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          ZGEQRF, CGERQF, ZUNMQR and CUNMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  ===================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zggglm (n  m  p  a  lda  b  ldb  d  x  y  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) x )
	((-idx2- (-double-)) y )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zggglm_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($d,double), IDX_PTR($x,double), IDX_PTR($y,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgghrd <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGHRD reduces a pair of complex matrices (A,B) to generalized upper
;;*  Hessenberg form using unitary transformations, where A is a
;;*  general matrix and B is upper triangular:  Q' * A * Z = H and
;;*  Q' * B * Z = T, where H is upper Hessenberg, T is upper triangular,
;;*  and Q and Z are unitary, and ' means conjugate transpose.
;;*
;;*  The unitary matrices Q and Z are determined as products of Givens
;;*  rotations.  They may either be formed explicitly, or they may be
;;*  postmultiplied into input matrices Q1 and Z1, so that
;;*
;;*       Q1 * A * Z1' = (Q1*Q) * H * (Z1*Z)'
;;*       Q1 * B * Z1' = (Q1*Q) * T * (Z1*Z)'
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not compute Q;
;;*          = 'I': Q is initialized to the unit matrix, and the
;;*                 unitary matrix Q is returned;
;;*          = 'V': Q must contain a unitary matrix Q1 on entry,
;;*                 and the product Q1*Q is returned.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not compute Q;
;;*          = 'I': Q is initialized to the unit matrix, and the
;;*                 unitary matrix Q is returned;
;;*          = 'V': Q must contain a unitary matrix Q1 on entry,
;;*                 and the product Q1*Q is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.  ILO and IHI are normally set
;;*          by a previous call to ZGGBAL; otherwise they should be set
;;*          to 1 and N respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the N-by-N general matrix to be reduced.
;;*          On exit, the upper triangle and the first subdiagonal of A
;;*          are overwritten with the upper Hessenberg matrix H, and the
;;*          rest is set to zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.
;;*          On exit, the upper triangular matrix T = Q' B Z.  The
;;*          elements below the diagonal are set to zero.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ, N)
;;*          If COMPQ='N':  Q is not referenced.
;;*          If COMPQ='I':  on entry, Q need not be set, and on exit it
;;*                         contains the unitary matrix Q, where Q'
;;*                         is the product of the Givens transformations
;;*                         which are applied to A and B on the left.
;;*          If COMPQ='V':  on entry, Q must contain a unitary matrix
;;*                         Q1, and on exit this is overwritten by Q1*Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= N if COMPQ='V' or 'I'; LDQ >= 1 otherwise.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If COMPZ='N':  Z is not referenced.
;;*          If COMPZ='I':  on entry, Z need not be set, and on exit it
;;*                         contains the unitary matrix Z, which is
;;*                         the product of the Givens transformations
;;*                         which are applied to A and B on the right.
;;*          If COMPZ='V':  on entry, Z must contain a unitary matrix
;;*                         Z1, and on exit this is overwritten by Z1*Z.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= N if COMPZ='V' or 'I'; LDZ >= 1 otherwise.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine reduces A to Hessenberg and B to triangular form by
;;*  an unblocked reduction, as described in _Matrix_Computations_,
;;*  by Golub and van Loan (Johns Hopkins Press).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgghrd (compq  compz  n  ilo  ihi  a  lda  b  ldb  q  ldq  z  ldz  info  )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ zgghrd_($compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgglse <m>  <n>  <p>  <a>  <lda>  <b>  <ldb>  <c>  <d>  <x>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGLSE solves the linear equality-constrained least squares (LSE)
;;*  problem:
;;*
;;*          minimize || c - A*x ||_2   subject to   B*x = d
;;*
;;*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
;;*  M-vector, and d is a given P-vector. It is assumed that
;;*  P <= N <= M+P, and
;;*
;;*           rank(B) = P and  rank( ( A ) ) = N.
;;*                                ( ( B ) )
;;*
;;*  These conditions ensure that the LSE problem has a unique solution,
;;*  which is obtained using a GRQ factorization of the matrices B and A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B. 0 <= P <= N <= M+P.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B is destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (M)
;;*          On entry, C contains the right hand side vector for the
;;*          least squares part of the LSE problem.
;;*          On exit, the residual sum of squares for the solution
;;*          is given by the sum of squares of elements N-P+1 to M of
;;*          vector C.
;;*
;;*  D       (input/output) COMPLEX*16 array, dimension (P)
;;*          On entry, D contains the right hand side vector for the
;;*          constrained equation.
;;*          On exit, D is destroyed.
;;*
;;*  X       (output) COMPLEX*16 array, dimension (N)
;;*          On exit, X is the solution of the LSE problem.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M+N+P).
;;*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,
;;*          where NB is an upper bound for the optimal blocksizes for
;;*          ZGEQRF, CGERQF, ZUNMQR and CUNMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgglse (m  n  p  a  lda  b  ldb  c  d  x  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) c )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) x )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zgglse_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($d,double), IDX_PTR($x,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggqrf <n>  <m>  <p>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGQRF computes a generalized QR factorization of an N-by-M matrix A
;;*  and an N-by-P matrix B:
;;*
;;*              A = Q*R,        B = Q*T*Z,
;;*
;;*  where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
;;*  and R and T assume one of the forms:
;;*
;;*  if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
;;*                  (  0  ) N-M                         N   M-N
;;*                     M
;;*
;;*  where R11 is upper triangular, and
;;*
;;*  if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
;;*                   P-N  N                           ( T21 ) P
;;*                                                       P
;;*
;;*  where T12 or T21 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GQR factorization
;;*  of A and B implicitly gives the QR factorization of inv(B)*A:
;;*
;;*               inv(B)*A = Z'*(inv(T)*R)
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  conjugate transpose of matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of rows of the matrices A and B. N >= 0.
;;*
;;*  M       (input) INTEGER
;;*          The number of columns of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of columns of the matrix B.  P >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,M)
;;*          On entry, the N-by-M matrix A.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(N,M)-by-M upper trapezoidal matrix R (R is
;;*          upper triangular if N >= M); the elements below the diagonal,
;;*          with the array TAUA, represent the unitary matrix Q as a
;;*          product of min(N,M) elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAUA    (output) COMPLEX*16 array, dimension (min(N,M))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q (see Further Details).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,P)
;;*          On entry, the N-by-P matrix B.
;;*          On exit, if N <= P, the upper triangle of the subarray
;;*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
;;*          if N > P, the elements on and above the (N-P)-th subdiagonal
;;*          contain the N-by-P upper trapezoidal matrix T; the remaining
;;*          elements, with the array TAUB, represent the unitary
;;*          matrix Z as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  TAUB    (output) COMPLEX*16 array, dimension (min(N,P))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the QR factorization
;;*          of an N-by-M matrix, NB2 is the optimal blocksize for the
;;*          RQ factorization of an N-by-P matrix, and NB3 is the optimal
;;*          blocksize for a call of ZUNMQR.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*           = 0:  successful exit
;;*           < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(n,m).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine ZUNGQR.
;;*  To use Q to update another matrix, use LAPACK subroutine ZUNMQR.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(n,p).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a complex scalar, and v is a complex vector with
;;*  v(p-k+i+1:p) = 0 and v(p-k+i) = 1; v(1:p-k+i-1) is stored on exit in
;;*  B(n-k+i,1:p-k+i-1), and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine ZUNGRQ.
;;*  To use Z to update another matrix, use LAPACK subroutine ZUNMRQ.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zggqrf (n  m  p  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) taua )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) taub )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zggqrf_(IDX_PTR($n,int), IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($taua,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($taub,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggrqf <m>  <p>  <n>  <a>  <lda>  <taua>  <b>  <ldb>  <taub>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGRQF computes a generalized RQ factorization of an M-by-N matrix A
;;*  and a P-by-N matrix B:
;;*
;;*              A = R*Q,        B = Z*T*Q,
;;*
;;*  where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
;;*  matrix, and R and T assume one of the forms:
;;*
;;*  if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
;;*                   N-M  M                           ( R21 ) N
;;*                                                       N
;;*
;;*  where R12 or R21 is upper triangular, and
;;*
;;*  if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
;;*                  (  0  ) P-N                         P   N-P
;;*                     N
;;*
;;*  where T11 is upper triangular.
;;*
;;*  In particular, if B is square and nonsingular, the GRQ factorization
;;*  of A and B implicitly gives the RQ factorization of A*inv(B):
;;*
;;*               A*inv(B) = (R*inv(T))*Z'
;;*
;;*  where inv(B) denotes the inverse of the matrix B, and Z' denotes the
;;*  conjugate transpose of the matrix Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, if M <= N, the upper triangle of the subarray
;;*          A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
;;*          if M > N, the elements on and above the (M-N)-th subdiagonal
;;*          contain the M-by-N upper trapezoidal matrix R; the remaining
;;*          elements, with the array TAUA, represent the unitary
;;*          matrix Q as a product of elementary reflectors (see Further
;;*          Details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAUA    (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q (see Further Details).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, the elements on and above the diagonal of the array
;;*          contain the min(P,N)-by-N upper trapezoidal matrix T (T is
;;*          upper triangular if P >= N); the elements below the diagonal,
;;*          with the array TAUB, represent the unitary matrix Z as a
;;*          product of elementary reflectors (see Further Details).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TAUB    (output) COMPLEX*16 array, dimension (min(P,N))
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Z (see Further Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N,M,P).
;;*          For optimum performance LWORK >= max(N,M,P)*max(NB1,NB2,NB3),
;;*          where NB1 is the optimal blocksize for the RQ factorization
;;*          of an M-by-N matrix, NB2 is the optimal blocksize for the
;;*          QR factorization of a P-by-N matrix, and NB3 is the optimal
;;*          blocksize for a call of ZUNMRQ.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO=-i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taua * v * v'
;;*
;;*  where taua is a complex scalar, and v is a complex vector with
;;*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
;;*  A(m-k+i,1:n-k+i-1), and taua in TAUA(i).
;;*  To form Q explicitly, use LAPACK subroutine ZUNGRQ.
;;*  To use Q to update another matrix, use LAPACK subroutine ZUNMRQ.
;;*
;;*  The matrix Z is represented as a product of elementary reflectors
;;*
;;*     Z = H(1) H(2) . . . H(k), where k = min(p,n).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - taub * v * v'
;;*
;;*  where taub is a complex scalar, and v is a complex vector with
;;*  v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i),
;;*  and taub in TAUB(i).
;;*  To form Z explicitly, use LAPACK subroutine ZUNGQR.
;;*  To use Z to update another matrix, use LAPACK subroutine ZUNMQR.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zggrqf (m  p  n  a  lda  taua  b  ldb  taub  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) taua )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) taub )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zggrqf_(IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($taua,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($taub,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggsvd <jobu>  <jobv>  <jobq>  <m>  <n>  <p>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGSVD computes the generalized singular value decomposition (GSVD)
;;*  of an M-by-N complex matrix A and P-by-N complex matrix B:
;;*
;;*        U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R )
;;*
;;*  where U, V and Q are unitary matrices, and Z' means the conjugate
;;*  transpose of Z.  Let K+L = the effective numerical rank of the
;;*  matrix (A',B')', then R is a (K+L)-by-(K+L) nonsingular upper
;;*  triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
;;*  matrices and of the following structures, respectively:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                    K  L
;;*         D2 =   L ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                  N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 )
;;*              L (  0    0   R22 )
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                    K M-K K+L-M
;;*         D1 =   K ( I  0    0   )
;;*              M-K ( 0  C    0   )
;;*
;;*                      K M-K K+L-M
;;*         D2 =   M-K ( 0  S    0  )
;;*              K+L-M ( 0  0    I  )
;;*                P-L ( 0  0    0  )
;;*
;;*                     N-K-L  K   M-K  K+L-M
;;*    ( 0 R ) =     K ( 0    R11  R12  R13  )
;;*                M-K ( 0     0   R22  R23  )
;;*              K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*    S = diag( BETA(K+1),  ... , BETA(M) ),
;;*    C**2 + S**2 = I.
;;*
;;*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
;;*    ( 0  R22 R23 )
;;*    in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The routine computes C, S, R, and optionally the unitary
;;*  transformation matrices U, V and Q.
;;*
;;*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
;;*  A and B implicitly gives the SVD of A*inv(B):
;;*                       A*inv(B) = U*(D1*inv(D2))*V'.
;;*  If ( A',B')' has orthnormal columns, then the GSVD of A and B is also
;;*  equal to the CS decomposition of A and B. Furthermore, the GSVD can
;;*  be used to derive the solution of the eigenvalue problem:
;;*                       A'*A x = lambda* B'*B x.
;;*  In some literature, the GSVD of A and B is presented in the form
;;*                   U'*A*X = ( 0 D1 ),   V'*B*X = ( 0 D2 )
;;*  where U and V are orthogonal and X is nonsingular, and D1 and D2 are
;;*  ``diagonal''.  The former GSVD form can be converted to the latter
;;*  form by taking the nonsingular matrix X as
;;*
;;*                        X = Q*(  I   0    )
;;*                              (  0 inv(R) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Unitary matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Unitary matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Unitary matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in Purpose.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular matrix R, or part of R.
;;*          See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains part of the triangular matrix R if
;;*          M-K-L < 0.  See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  ALPHA   (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = C,
;;*            BETA(K+1:K+L)  = S,
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
;;*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1
;;*          and
;;*            ALPHA(K+L+1:N) = 0
;;*            BETA(K+L+1:N)  = 0
;;*
;;*  U       (output) COMPLEX*16 array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the M-by-M unitary matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) COMPLEX*16 array, dimension (LDV,P)
;;*          If JOBV = 'V', V contains the P-by-P unitary matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) COMPLEX*16 array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (max(3*N,M,P)+N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (N)
;;*          On exit, IWORK stores the sorting information. More
;;*          precisely, the following loop will sort ALPHA
;;*             for I = K+1, min(M,K+L)
;;*                 swap ALPHA(I) and ALPHA(IWORK(I))
;;*             endfor
;;*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
;;*
;;*  INFO    (output)INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, the Jacobi-type procedure failed to
;;*                converge.  For further details, see subroutine ZTGSJA.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  TOLA    DOUBLE PRECISION
;;*  TOLB    DOUBLE PRECISION
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          rank of (A',B')'. Generally, they are set to
;;*                   TOLA = MAX(M,N)*norm(A)*MAZHEPS,
;;*                   TOLB = MAX(P,N)*norm(B)*MAZHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  2-96 Based on modifications by
;;*     Ming Gu and Huan Ren, Computer Science Division, University of
;;*     California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zggsvd (jobu  jobv  jobq  m  n  p  k  l  a  lda  b  ldb  alpha  beta  u  ldu  v  ldv  q  ldq  work  rwork  iwork  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) alpha )
	((-idx1- (-double-)) beta )
	((-idx3- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zggsvd_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($p,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zggsvp <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <k>  <l>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <iwork>  <rwork>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGGSVP computes unitary matrices U, V and Q such that
;;*
;;*                   N-K-L  K    L
;;*   U'*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
;;*                L ( 0     0   A23 )
;;*            M-K-L ( 0     0    0  )
;;*
;;*                   N-K-L  K    L
;;*          =     K ( 0    A12  A13 )  if M-K-L < 0;
;;*              M-K ( 0     0   A23 )
;;*
;;*                 N-K-L  K    L
;;*   V'*B*Q =   L ( 0     0   B13 )
;;*            P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
;;*  numerical rank of the (M+P)-by-N matrix (A',B')'.  Z' denotes the
;;*  conjugate transpose of Z.
;;*
;;*  This decomposition is the preprocessing step for computing the
;;*  Generalized Singular Value Decomposition (GSVD), see subroutine
;;*  ZGGSVD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  Unitary matrix U is computed;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  Unitary matrix V is computed;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Unitary matrix Q is computed;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A contains the triangular (or trapezoidal) matrix
;;*          described in the Purpose section.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, B contains the triangular matrix described in
;;*          the Purpose section.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) DOUBLE PRECISION
;;*  TOLB    (input) DOUBLE PRECISION
;;*          TOLA and TOLB are the thresholds to determine the effective
;;*          numerical rank of matrix B and a subblock of A. Generally,
;;*          they are set to
;;*             TOLA = MAX(M,N)*norm(A)*MAZHEPS,
;;*             TOLB = MAX(P,N)*norm(B)*MAZHEPS.
;;*          The size of TOLA and TOLB may affect the size of backward
;;*          errors of the decomposition.
;;*
;;*  K       (output) INTEGER
;;*  L       (output) INTEGER
;;*          On exit, K and L specify the dimension of the subblocks
;;*          described in Purpose section.
;;*          K + L = effective numerical rank of (A',B')'.
;;*
;;*  U       (output) COMPLEX*16 array, dimension (LDU,M)
;;*          If JOBU = 'U', U contains the unitary matrix U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (output) COMPLEX*16 array, dimension (LDV,M)
;;*          If JOBV = 'V', V contains the unitary matrix V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (output) COMPLEX*16 array, dimension (LDQ,N)
;;*          If JOBQ = 'Q', Q contains the unitary matrix Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  TAU     (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (max(3*N,M,P))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The subroutine uses LAPACK subroutine ZGEQPF for the QR factorization
;;*  with column pivoting to detect the effective numerical rank of the
;;*  a matrix. It may be replaced by a better rank determination strategy.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zggsvp (jobu  jobv  jobq  m  p  n  a  lda  b  ldb  tola  tolb  k  l  u  ldu  v  ldv  q  ldq  iwork  rwork  tau  work  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) tola )
	((-idx0- (-double-)) tolb )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-int-)) iwork )
	((-idx1- (-double-)) rwork )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zggsvp_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($tola,double), IDX_PTR($tolb,double), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($iwork,int), IDX_PTR($rwork,double), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgtcon <norm>  <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTCON estimates the reciprocal of the condition number of a complex
;;*  tridiagonal matrix A using the LU factorization as computed by
;;*  ZGTTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by ZGTTRF.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) COMPLEX*16 array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          If NORM = '1' or 'O', the 1-norm of the original matrix A.
;;*          If NORM = 'I', the infinity-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgtcon (norm  n  dl  d  du  du2  ipiv  anorm  rcond  work  info  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx2- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zgtcon_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgtrfs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is tridiagonal, and provides
;;*  error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A as computed by ZGTTRF.
;;*
;;*  DF      (input) COMPLEX*16 array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DUF     (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input) COMPLEX*16 array, dimension (N-2)
;;*          The (n-2) elements of the second superdiagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZGTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgtrfs (trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx2- (-double-)) dlf )
	((-idx2- (-double-)) df )
	((-idx2- (-double-)) duf )
	((-idx2- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgtrfs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($dlf,double), IDX_PTR($df,double), IDX_PTR($duf,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgtsv <n>  <nrhs>  <dl>  <d>  <du>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTSV  solves the equation
;;*
;;*     A*X = B,
;;*
;;*  where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
;;*  partial pivoting.
;;*
;;*  Note that the equation  A'*X = B  may be solved by interchanging the
;;*  order of the arguments DU and DL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input/output) COMPLEX*16 array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) subdiagonal elements of
;;*          A.
;;*          On exit, DL is overwritten by the (n-2) elements of the
;;*          second superdiagonal of the upper triangular matrix U from
;;*          the LU factorization of A, in DL(1), ..., DL(n-2).
;;*
;;*  D       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*          On exit, D is overwritten by the n diagonal elements of U.
;;*
;;*  DU      (input/output) COMPLEX*16 array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) superdiagonal elements
;;*          of A.
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          superdiagonal of U.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, U(i,i) is exactly zero, and the solution
;;*                has not been computed.  The factorization has not been
;;*                completed unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgtsv (n  nrhs  dl  d  du  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zgtsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgtsvx <fact>  <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <dlf>  <df>  <duf>  <du2>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTSVX uses the LU factorization to compute the solution to a complex
;;*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
;;*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the LU decomposition is used to factor the matrix A
;;*     as A = L * U, where L is a product of permutation and unit lower
;;*     bidiagonal matrices and U is upper triangular with nonzeros in
;;*     only the main diagonal and first two superdiagonals.
;;*
;;*  2. If some U(i,i)=0, so that U is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  DLF, DF, DUF, DU2, and IPIV contain the factored form
;;*                  of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not
;;*                  be modified.
;;*          = 'N':  The matrix will be copied to DLF, DF, and DUF
;;*                  and factored.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of A.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The n diagonal elements of A.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) superdiagonal elements of A.
;;*
;;*  DLF     (input or output) COMPLEX*16 array, dimension (N-1)
;;*          If FACT = 'F', then DLF is an input argument and on entry
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A as computed by ZGTTRF.
;;*
;;*          If FACT = 'N', then DLF is an output argument and on exit
;;*          contains the (n-1) multipliers that define the matrix L from
;;*          the LU factorization of A.
;;*
;;*  DF      (input or output) COMPLEX*16 array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the upper triangular
;;*          matrix U from the LU factorization of A.
;;*
;;*  DUF     (input or output) COMPLEX*16 array, dimension (N-1)
;;*          If FACT = 'F', then DUF is an input argument and on entry
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*          If FACT = 'N', then DUF is an output argument and on exit
;;*          contains the (n-1) elements of the first superdiagonal of U.
;;*
;;*  DU2     (input or output) COMPLEX*16 array, dimension (N-2)
;;*          If FACT = 'F', then DU2 is an input argument and on entry
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*          If FACT = 'N', then DU2 is an output argument and on exit
;;*          contains the (n-2) elements of the second superdiagonal of
;;*          U.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains the pivot indices from the LU factorization of A as
;;*          computed by ZGTTRF.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains the pivot indices from the LU factorization of A;
;;*          row i of the matrix was interchanged with row IPIV(i).
;;*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates
;;*          a row interchange was not required.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  U(i,i) is exactly zero.  The factorization
;;*                       has not been completed unless i = N, but the
;;*                       factor U is exactly singular, so the solution
;;*                       and error bounds could not be computed.
;;*                       RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgtsvx (fact  trans  n  nrhs  dl  d  du  dlf  df  duf  du2  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx2- (-double-)) dlf )
	((-idx2- (-double-)) df )
	((-idx2- (-double-)) duf )
	((-idx2- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zgtsvx_($fact->data, $trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($dlf,double), IDX_PTR($df,double), IDX_PTR($duf,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgttrf <n>  <dl>  <d>  <du>  <du2>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTTRF computes an LU factorization of a complex tridiagonal matrix A
;;*  using elimination with partial pivoting and row interchanges.
;;*
;;*  The factorization has the form
;;*     A = L * U
;;*  where L is a product of permutation and unit lower bidiagonal
;;*  matrices and U is upper triangular with nonzeros in only the main
;;*  diagonal and first two superdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  DL      (input/output) COMPLEX*16 array, dimension (N-1)
;;*          On entry, DL must contain the (n-1) sub-diagonal elements of
;;*          A.
;;*
;;*          On exit, DL is overwritten by the (n-1) multipliers that
;;*          define the matrix L from the LU factorization of A.
;;*
;;*  D       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, D must contain the diagonal elements of A.
;;*
;;*          On exit, D is overwritten by the n diagonal elements of the
;;*          upper triangular matrix U from the LU factorization of A.
;;*
;;*  DU      (input/output) COMPLEX*16 array, dimension (N-1)
;;*          On entry, DU must contain the (n-1) super-diagonal elements
;;*          of A.
;;*
;;*          On exit, DU is overwritten by the (n-1) elements of the first
;;*          super-diagonal of U.
;;*
;;*  DU2     (output) COMPLEX*16 array, dimension (N-2)
;;*          On exit, DU2 is overwritten by the (n-2) elements of the
;;*          second super-diagonal of U.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*          > 0:  if INFO = k, U(k,k) is exactly zero. The factorization
;;*                has been completed, but the factor U is exactly
;;*                singular, and division by zero will occur if it is used
;;*                to solve a system of equations.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zgttrf (n  dl  d  du  du2  ipiv  info  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx2- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zgttrf_(IDX_PTR($n,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgttrs <trans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTTRS solves one of the systems of equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by ZGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the form of the system of equations.
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) COMPLEX*16 array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zgttrs (trans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  info  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx2- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zgttrs_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zgtts2 <itrans>  <n>  <nrhs>  <dl>  <d>  <du>  <du2>  <ipiv>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZGTTS2 solves one of the systems of equations
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*  with a tridiagonal matrix A using the LU factorization computed
;;*  by ZGTTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITRANS  (input) INTEGER
;;*          Specifies the form of the system of equations.
;;*          = 0:  A * X = B     (No transpose)
;;*          = 1:  A**T * X = B  (Transpose)
;;*          = 2:  A**H * X = B  (Conjugate transpose)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) multipliers that define the matrix L from the
;;*          LU factorization of A.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The n diagonal elements of the upper triangular matrix U from
;;*          the LU factorization of A.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) elements of the first super-diagonal of U.
;;*
;;*  DU2     (input) COMPLEX*16 array, dimension (N-2)
;;*          The (n-2) elements of the second super-diagonal of U.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          The pivot indices; for 1 <= i <= n, row i of the matrix was
;;*          interchanged with row IPIV(i).  IPIV(i) will always be either
;;*          i or i+1; IPIV(i) = i indicates a row interchange was not
;;*          required.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the matrix of right hand side vectors B.
;;*          On exit, B is overwritten by the solution vectors X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zgtts2 (itrans  n  nrhs  dl  d  du  du2  ipiv  b  ldb  )
	((-idx0- (-int-)) itrans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx2- (-double-)) du2 )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ zgtts2_(IDX_PTR($itrans,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($du2,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbevd <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBEVD computes all the eigenvalues and, optionally, eigenvectors of
;;*  a complex Hermitian band matrix A.  If eigenvectors are desired, it
;;*  uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LRWORK must be at least
;;*                        1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ = 'V' and N > 1, LIWORK must be at least 3 + 5*N .
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbevd (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zhbevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbev <jobz>  <uplo>  <n>  <kd>  <ab>  <ldab>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBEV computes all the eigenvalues and, optionally, eigenvectors of
;;*  a complex Hermitian band matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the first
;;*          superdiagonal and the diagonal of the tridiagonal matrix T
;;*          are returned in rows KD and KD+1 of AB, and if UPLO = 'L',
;;*          the diagonal and first subdiagonal of T are returned in the
;;*          first two rows of AB.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1,3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbev (jobz  uplo  n  kd  ab  ldab  w  z  ldz  work  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhbev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbevx <jobz>  <range>  <uplo>  <n>  <kd>  <ab>  <ldab>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors
;;*  can be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, AB is overwritten by values generated during the
;;*          reduction to tridiagonal form.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD + 1.
;;*
;;*  Q       (output) COMPLEX*16 array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the N-by-N unitary matrix used in the
;;*                          reduction to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'V', then
;;*          LDQ >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AB to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbevx (jobz  range  uplo  n  kd  ab  ldab  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zhbevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbgst <vect>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <x>  <ldx>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBGST reduces a complex Hermitian-definite banded generalized
;;*  eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
;;*  such that C has the same bandwidth as A.
;;*
;;*  B must have been previously factorized as S**H*S by ZPBSTF, using a
;;*  split Cholesky factorization. A is overwritten by C = X**H*A*X, where
;;*  X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
;;*  bandwidth of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form the transformation matrix X;
;;*          = 'V':  form X.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KA >= KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the transformed matrix X**H*A*X, stored in the same
;;*          format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input) COMPLEX*16 array, dimension (LDBB,N)
;;*          The banded factor S from the split Cholesky factorization of
;;*          B, as returned by ZPBSTF, stored in the first kb+1 rows of
;;*          the array.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,N)
;;*          If VECT = 'V', the n-by-n matrix X.
;;*          If VECT = 'N', the array X is not referenced.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.
;;*          LDX >= max(1,N) if VECT = 'V'; LDX >= 1 otherwise.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbgst (vect  uplo  n  ka  kb  ab  ldab  bb  ldbb  x  ldx  work  rwork  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhbgst_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbgvd <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
;;*  and banded, and B is also positive definite.  If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) COMPLEX*16 array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**H*S, as returned by ZPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**H*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 2*N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (LRWORK)
;;*          On exit, if INFO=0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO=0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then ZPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbgvd (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zhbgvd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbgv <jobz>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
;;*  and banded, and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) COMPLEX*16 array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**H*S, as returned by ZPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**H*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (3*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  the algorithm failed to converge:
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then ZPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zhbgv (jobz  uplo  n  ka  kb  ab  ldab  bb  ldbb  w  z  ldz  work  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhbgv_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbgvx <jobz>  <range>  <uplo>  <n>  <ka>  <kb>  <ab>  <ldab>  <bb>  <ldbb>  <q>  <ldq>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBGVX computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite banded eigenproblem, of
;;*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
;;*  and banded, and B is also positive definite.  Eigenvalues and
;;*  eigenvectors can be selected by specifying either all eigenvalues,
;;*  a range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  KA      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KA >= 0.
;;*
;;*  KB      (input) INTEGER
;;*          The number of superdiagonals of the matrix B if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'. KB >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first ka+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).
;;*
;;*          On exit, the contents of AB are destroyed.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KA+1.
;;*
;;*  BB      (input/output) COMPLEX*16 array, dimension (LDBB, N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix B, stored in the first kb+1 rows of the array.  The
;;*          j-th column of B is stored in the j-th column of the array BB
;;*          as follows:
;;*          if UPLO = 'U', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;
;;*          if UPLO = 'L', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).
;;*
;;*          On exit, the factor S from the split Cholesky factorization
;;*          B = S**H*S, as returned by ZPBSTF.
;;*
;;*  LDBB    (input) INTEGER
;;*          The leading dimension of the array BB.  LDBB >= KB+1.
;;*
;;*  Q       (output) COMPLEX*16 array, dimension (LDQ, N)
;;*          If JOBZ = 'V', the n-by-n matrix used in the reduction of
;;*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,
;;*          and consequently C to tridiagonal form.
;;*          If JOBZ = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  If JOBZ = 'N',
;;*          LDQ >= 1. If JOBZ = 'V', LDQ >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors, with the i-th column of Z holding the
;;*          eigenvector associated with W(i). The eigenvectors are
;;*          normalized so that Z**H*B*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= N.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is:
;;*             <= N:  then i eigenvectors failed to converge.  Their
;;*                    indices are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then ZPBSTF
;;*                    returned INFO = i: B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbgvx (jobz  range  uplo  n  ka  kb  ab  ldab  bb  ldbb  q  ldq  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ka )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) bb )
	((-idx0- (-int-)) ldbb )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zhbgvx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ka,int), IDX_PTR($kb,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($bb,double), IDX_PTR($ldbb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhbtrd <vect>  <uplo>  <n>  <kd>  <ab>  <ldab>  <d>  <e>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHBTRD reduces a complex Hermitian band matrix A to real symmetric
;;*  tridiagonal form T by a unitary similarity transformation:
;;*  Q**H * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'N':  do not form Q;
;;*          = 'V':  form Q;
;;*          = 'U':  update a matrix X, by forming X*Q.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          On exit, the diagonal elements of AB are overwritten by the
;;*          diagonal elements of the tridiagonal matrix T; if KD > 0, the
;;*          elements on the first superdiagonal (if UPLO = 'U') or the
;;*          first subdiagonal (if UPLO = 'L') are overwritten by the
;;*          off-diagonal elements of T; the rest of AB is overwritten by
;;*          values generated during the reduction.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*          On entry, if VECT = 'U', then Q must contain an N-by-N
;;*          matrix X; if VECT = 'N' or 'V', then Q need not be set.
;;*
;;*          On exit:
;;*          if VECT = 'V', Q contains the N-by-N unitary matrix Q;
;;*          if VECT = 'U', Q contains the product X*Q;
;;*          if VECT = 'N', the array Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1, and LDQ >= N if VECT = 'V' or 'U'.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by Linda Kaufman, Bell Labs.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhbtrd (vect  uplo  n  kd  ab  ldab  d  e  q  ldq  work  info  )
	((-str-) vect )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zhbtrd_($vect->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhecon <uplo>  <n>  <a>  <lda>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHECON estimates the reciprocal of the condition number of a complex
;;*  Hermitian matrix A using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by ZHETRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZHETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHETRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhecon (uplo  n  a  lda  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zhecon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zheevd <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a
;;*  complex Hermitian matrix A.  If eigenvectors are desired, it uses a
;;*  divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.
;;*          If N <= 1,                LWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
;;*          If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of the array RWORK.
;;*          If N <= 1,                LRWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LRWORK must be at least N.
;;*          If JOBZ  = 'V' and N > 1, LRWORK must be at least
;;*                         1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK must be at least 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zheevd (jobz  uplo  n  a  lda  w  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zheevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zheev <jobz>  <uplo>  <n>  <a>  <lda>  <w>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEEV computes all eigenvalues and, optionally, eigenvectors of a
;;*  complex Hermitian matrix A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          orthonormal eigenvectors of the matrix A.
;;*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
;;*          or the upper triangle (if UPLO='U') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the blocksize for ZHETRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zheev (jobz  uplo  n  a  lda  w  work  lwork  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zheev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zheevr <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEEVR computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian matrix T.  Eigenvalues and eigenvectors can
;;*  be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Whenever possible, ZHEEVR calls ZSTEGR to compute the
;;*  eigenspectrum using Relatively Robust Representations.  ZSTEGR
;;*  computes eigenvalues by the dqds algorithm, while orthogonal
;;*  eigenvectors are computed from various "good" L D L^T representations
;;*  (also known as Relatively Robust Representations). Gram-Schmidt
;;*  orthogonalization is avoided as far as possible. More specifically,
;;*  the various steps of the algorithm are as follows. For the i-th
;;*  unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*          is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB//CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*
;;*  Note 1 : ZHEEVR calls ZSTEGR when the full spectrum is requested
;;*  on machines which conform to the ieee-754 floating point standard.
;;*  ZHEEVR calls DSTEBZ and ZSTEIN on non-ieee machines and
;;*  when partial spectrum requests are made.
;;*
;;*  Normal execution of ZSTEGR may create NaNs and infinities and
;;*  hence may abort due to a floating point exception in environments
;;*  which do not handle NaNs and infinities in the ieee standard default
;;*  manner.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** For RANGE = 'V' or 'I' and IU - IL < N - 1, DSTEBZ and
;;********** ZSTEIN are called
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*          If high relative accuracy is important, set ABSTOL to
;;*          DLAMCH( 'Safe minimum' ).  Doing so will guarantee that
;;*          eigenvalues are computed to high relative accuracy when
;;*          possible in future releases.  The current code does not
;;*          make any guarantees about high relative accuracy, but
;;*          furutre releases will. See J. Barlow and J. Demmel,
;;*          "Computing Accurate Eigensystems of Scaled Diagonally
;;*          Dominant Matrices", LAPACK Working Note #7, for a discussion
;;*          of which matrices define their eigenvalues to high relative
;;*          accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;********** Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the max of the blocksize for ZHETRD and for
;;*          ZUNMTR as returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal
;;*          (and minimal) LRWORK.
;;*
;;* LRWORK  (input) INTEGER
;;*         The length of the array RWORK.  LRWORK >= max(1,24*N).
;;*
;;*         If LRWORK = -1, then a workspace query is assumed; the routine
;;*         only calculates the optimal size of the RWORK array, returns
;;*         this value as the first entry of the RWORK array, and no error
;;*         message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal
;;*          (and minimal) LIWORK.
;;*
;;* LIWORK  (input) INTEGER
;;*         The dimension of the array IWORK.  LIWORK >= max(1,10*N).
;;*
;;*         If LIWORK = -1, then a workspace query is assumed; the
;;*         routine only calculates the optimal size of the IWORK array,
;;*         returns this value as the first entry of the IWORK array, and
;;*         no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  Internal error
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zheevr (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zheevr_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zheevx <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
;;*  be selected by specifying either a range of values or a range of
;;*  indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*          On exit, the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the max of the blocksize for ZHETRD and for
;;*          ZUNMTR as returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zheevx (jobz  range  uplo  n  a  lda  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zheevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhegs2 <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEGS2 reduces a complex Hermitian-definite generalized
;;*  eigenproblem to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U` or L'*A*L.
;;*
;;*  B must have been previously factorized as U'*U or L*L' by ZPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U')*A*inv(U) or inv(L)*A*inv(L');
;;*          = 2 or 3: compute U*A*U' or L'*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored, and how B has been factorized.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by ZPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhegs2 (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zhegs2_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhegst <itype>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEGST reduces a complex Hermitian-definite generalized
;;*  eigenproblem to standard form.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
;;*
;;*  B must have been previously factorized as U**H*U or L*L**H by ZPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
;;*          = 2 or 3: compute U*A*U**H or L**H*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**H*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,N)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          as returned by ZPOTRF.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhegst (itype  uplo  n  a  lda  b  ldb  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zhegst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhegvd <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEGVD computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian and B is also positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the Hermitian matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.
;;*          If N <= 1,                LWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LWORK >= N + 1.
;;*          If JOBZ  = 'V' and N > 1, LWORK >= 2*N + N**2.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of the array RWORK.
;;*          If N <= 1,                LRWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LRWORK >= N.
;;*          If JOBZ  = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If N <= 1,                LIWORK >= 1.
;;*          If JOBZ  = 'N' and N > 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  ZPOTRF or ZHEEVD returned an error code:
;;*             <= N:  if INFO = i, ZHEEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhegvd (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zhegvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhegv <itype>  <jobz>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <w>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEGV computes all the eigenvalues, and optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be Hermitian and B is also
;;*  positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
;;*          matrix Z of eigenvectors.  The eigenvectors are normalized
;;*          as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
;;*          or the lower triangle (if UPLO='L') of A, including the
;;*          diagonal, is destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the Hermitian positive definite matrix B.
;;*          If UPLO = 'U', the leading N-by-N upper triangular part of B
;;*          contains the upper triangular part of the matrix B.
;;*          If UPLO = 'L', the leading N-by-N lower triangular part of B
;;*          contains the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the blocksize for ZHETRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  ZPOTRF or ZHEEV returned an error code:
;;*             <= N:  if INFO = i, ZHEEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not converge to zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhegv (itype  jobz  uplo  n  a  lda  b  ldb  w  work  lwork  rwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhegv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($w,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhegvx <itype>  <jobz>  <range>  <uplo>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHEGVX computes selected eigenvalues, and optionally, eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian and B is also positive definite.
;;*  Eigenvalues and eigenvectors can be selected by specifying either a
;;*  range of values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;**
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of A contains the
;;*          upper triangular part of the matrix A.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of A contains
;;*          the lower triangular part of the matrix A.
;;*
;;*          On exit,  the lower triangle (if UPLO='L') or the upper
;;*          triangle (if UPLO='U') of A, including the diagonal, is
;;*          destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the Hermitian matrix B.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of B contains the
;;*          upper triangular part of the matrix B.  If UPLO = 'L',
;;*          the leading N-by-N lower triangular part of B contains
;;*          the lower triangular part of the matrix B.
;;*
;;*          On exit, if INFO <= N, the part of B containing the matrix is
;;*          overwritten by the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing A to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**T*B*Z = I;
;;*          if ITYPE = 3, Z**T*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of the array WORK.  LWORK >= max(1,2*N-1).
;;*          For optimal efficiency, LWORK >= (NB+1)*N,
;;*          where NB is the blocksize for ZHETRD returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  ZPOTRF or ZHEEVX returned an error code:
;;*             <= N:  if INFO = i, ZHEEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhegvx (itype  jobz  range  uplo  n  a  lda  b  ldb  vl  vu  il  iu  abstol  m  w  z  ldz  work  lwork  rwork  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zhegvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zherfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHERFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian indefinite, and
;;*  provides error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX*16 array, dimension (LDAF,N)
;;*          The factored form of the matrix A.  AF contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**H or
;;*          A = L*D*L**H as computed by ZHETRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHETRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZHETRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zherfs (uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zherfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhesv <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHESV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**H,  if UPLO = 'U', or
;;*     A = L * D * L**H,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is Hermitian and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
;;*  used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the block diagonal matrix D and the
;;*          multipliers used to obtain the factor U or L from the
;;*          factorization A = U*D*U**H or A = L*D*L**H as computed by
;;*          ZHETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by ZHETRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 1, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          ZHETRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zhesv (uplo  n  nrhs  a  lda  ipiv  b  ldb  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zhesv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhesvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHESVX uses the diagonal pivoting factorization to compute the
;;*  solution to a complex system of linear equations A * X = B,
;;*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A.
;;*     The form of the factorization is
;;*        A = U * D * U**H,  if UPLO = 'U', or
;;*        A = L * D * L**H,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices, and D is Hermitian and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AF and IPIV contain the factored form
;;*                  of A.  A, AF and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by ZHETRF.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZHETRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZHETRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 2*N, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          ZHETRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhesvx (fact  uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  lwork  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhesvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhetd2 <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHETD2 reduces a complex Hermitian matrix A to real symmetric
;;*  tridiagonal form T by a unitary similarity transformation:
;;*  Q' * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the unitary
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the unitary matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhetd2 (uplo  n  a  lda  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ zhetd2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhetf2 <uplo>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHETF2 computes the factorization of a complex Hermitian matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U'  or  A = L*D*L'
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, U' is the conjugate transpose of U, and D is
;;*  Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  1-96 - Based on modifications by
;;*    J. Lewis, Boeing Computer Services Company
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhetf2 (uplo  n  a  lda  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zhetf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhetrd <uplo>  <n>  <a>  <lda>  <d>  <e>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHETRD reduces a complex Hermitian matrix A to real symmetric
;;*  tridiagonal form T by a unitary similarity transformation:
;;*  Q**H * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the unitary
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the unitary matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= 1.
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
;;*  A(1:i-1,i+1), and tau in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  d   e   v2  v3  v4 )              (  d                  )
;;*    (      d   e   v3  v4 )              (  e   d              )
;;*    (          d   e   v4 )              (  v1  e   d          )
;;*    (              d   e  )              (  v1  v2  e   d      )
;;*    (                  d  )              (  v1  v2  v3  e   d  )
;;*
;;*  where d and e denote diagonal and off-diagonal elements of T, and vi
;;*  denotes an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhetrd (uplo  n  a  lda  d  e  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zhetrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhetrf <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHETRF computes the factorization of a complex Hermitian matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method.  The form of the
;;*  factorization is
;;*
;;*     A = U*D*U**H  or  A = L*D*L**H
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is Hermitian and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >=1.  For best performance
;;*          LWORK >= N*NB, where NB is the block size returned by ILAENV.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, and division by zero will occur if it
;;*                is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zhetrf (uplo  n  a  lda  ipiv  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zhetrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhetri <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHETRI computes the inverse of a complex Hermitian indefinite matrix
;;*  A using the factorization A = U*D*U**H or A = L*D*L**H computed by
;;*  ZHETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by ZHETRF.
;;*
;;*          On exit, if INFO = 0, the (Hermitian) inverse of the original
;;*          matrix.  If UPLO = 'U', the upper triangular part of the
;;*          inverse is formed and the part of A below the diagonal is not
;;*          referenced; if UPLO = 'L' the lower triangular part of the
;;*          inverse is formed and the part of A above the diagonal is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHETRF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhetri (uplo  n  a  lda  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zhetri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhetrs <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHETRS solves a system of linear equations A*X = B with a complex
;;*  Hermitian matrix A using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by ZHETRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZHETRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHETRF.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhetrs (uplo  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zhetrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhgeqz <job>  <compq>  <compz>  <n>  <ilo>  <ihi>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <q>  <ldq>  <z>  <ldz>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHGEQZ implements a single-shift version of the QZ
;;*  method for finding the generalized eigenvalues w(i)=ALPHA(i)/BETA(i)
;;*  of the equation
;;*
;;*       det( A - w(i) B ) = 0
;;*
;;*  If JOB='S', then the pair (A,B) is simultaneously
;;*  reduced to Schur form (i.e., A and B are both upper triangular) by
;;*  applying one unitary tranformation (usually called Q) on the left and
;;*  another (usually called Z) on the right.  The diagonal elements of
;;*  A are then ALPHA(1),...,ALPHA(N), and of B are BETA(1),...,BETA(N).
;;*
;;*  If JOB='S' and COMPQ and COMPZ are 'V' or 'I', then the unitary
;;*  transformations used to reduce (A,B) are accumulated into the arrays
;;*  Q and Z s.t.:
;;*
;;*       Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
;;*       Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*
;;*
;;*  Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix
;;*       Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
;;*       pp. 241--256.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E': compute only ALPHA and BETA.  A and B will not
;;*                 necessarily be put into generalized Schur form.
;;*          = 'S': put A and B into generalized Schur form, as well
;;*                 as computing ALPHA and BETA.
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'N': do not modify Q.
;;*          = 'V': multiply the array Q on the right by the conjugate
;;*                 transpose of the unitary tranformation that is
;;*                 applied to the left side of A and B to reduce them
;;*                 to Schur form.
;;*          = 'I': like COMPQ='V', except that Q will be initialized to
;;*                 the identity first.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': do not modify Z.
;;*          = 'V': multiply the array Z on the right by the unitary
;;*                 tranformation that is applied to the right side of
;;*                 A and B to reduce them to Schur form.
;;*          = 'I': like COMPZ='V', except that Z will be initialized to
;;*                 the identity first.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A, B, Q, and Z.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that A is already upper triangular in rows and
;;*          columns 1:ILO-1 and IHI+1:N.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)
;;*          On entry, the N-by-N upper Hessenberg matrix A.  Elements
;;*          below the subdiagonal must be zero.
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to upper triangular form.
;;*          If JOB='E', then on exit A will have been destroyed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max( 1, N ).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, the N-by-N upper triangular matrix B.  Elements
;;*          below the diagonal must be zero.
;;*          If JOB='S', then on exit A and B will have been
;;*             simultaneously reduced to upper triangular form.
;;*          If JOB='E', then on exit B will have been destroyed.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max( 1, N ).
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*          The diagonal elements of A when the pair (A,B) has been
;;*          reduced to Schur form.  ALPHA(i)/BETA(i) i=1,...,N
;;*          are the generalized eigenvalues.
;;*
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          The diagonal elements of B when the pair (A,B) has been
;;*          reduced to Schur form.  ALPHA(i)/BETA(i) i=1,...,N
;;*          are the generalized eigenvalues.  A and B are normalized
;;*          so that BETA(1),...,BETA(N) are non-negative real numbers.
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ, N)
;;*          If COMPQ='N', then Q will not be referenced.
;;*          If COMPQ='V' or 'I', then the conjugate transpose of the
;;*             unitary transformations which are applied to A and B on
;;*             the left will be applied to the array Q on the right.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= 1.
;;*          If COMPQ='V' or 'I', then LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If COMPZ='N', then Z will not be referenced.
;;*          If COMPZ='V' or 'I', then the unitary transformations which
;;*             are applied to A and B on the right will be applied to the
;;*             array Z on the right.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If COMPZ='V' or 'I', then LDZ >= N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO >= 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1,...,N: the QZ iteration did not converge.  (A,B) is not
;;*                     in Schur form, but ALPHA(i) and BETA(i),
;;*                     i=INFO+1,...,N should be correct.
;;*          = N+1,...,2*N: the shift calculation failed.  (A,B) is not
;;*                     in Schur form, but ALPHA(i) and BETA(i),
;;*                     i=INFO-N+1,...,N should be correct.
;;*          > 2*N:     various "impossible" errors.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  We assume that complex ABS works as long as its value is less than
;;*  overflow.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhgeqz (job  compq  compz  n  ilo  ihi  a  lda  b  ldb  alpha  beta  q  ldq  z  ldz  work  lwork  rwork  info  )
	((-str-) job )
	((-str-) compq )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhgeqz_($job->data, $compq->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpcon <uplo>  <n>  <ap>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPCON estimates the reciprocal of the condition number of a complex
;;*  Hermitian packed matrix A using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by ZHPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZHPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHPTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhpcon (uplo  n  ap  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zhpcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpevd <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPEVD computes all the eigenvalues and, optionally, eigenvectors of
;;*  a complex Hermitian matrix A in packed storage.  If eigenvectors are
;;*  desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of array WORK.
;;*          If N <= 1,               LWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LWORK must be at least 2*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK must be at least 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK must be at least N.
;;*          If JOBZ = 'V' and N > 1, LRWORK must be at least
;;*                    1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhpevd (jobz  uplo  n  ap  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zhpevd_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpev <jobz>  <uplo>  <n>  <ap>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPEV computes all the eigenvalues and, optionally, eigenvectors of a
;;*  complex Hermitian matrix in packed storage.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
;;*          eigenvectors of the matrix A, with the i-th column of Z
;;*          holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (max(1, 2*N-1))
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the algorithm failed to converge; i
;;*                off-diagonal elements of an intermediate tridiagonal
;;*                form did not converge to zero.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhpev (jobz  uplo  n  ap  w  z  ldz  work  rwork  info  )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhpev_($jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpevx <jobz>  <range>  <uplo>  <n>  <ap>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPEVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex Hermitian matrix A in packed storage.
;;*  Eigenvalues/vectors can be selected by specifying either a range of
;;*  values or a range of indices for the desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, AP is overwritten by values generated during the
;;*          reduction to tridiagonal form.  If UPLO = 'U', the diagonal
;;*          and first superdiagonal of the tridiagonal matrix T overwrite
;;*          the corresponding elements of A, and if UPLO = 'L', the
;;*          diagonal and first subdiagonal of T overwrite the
;;*          corresponding elements of A.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*          See "Computing Small Singular Values of Bidiagonal Matrices
;;*          with Guaranteed High Relative Accuracy," by Demmel and
;;*          Kahan, LAPACK Working Note #3.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the selected eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and
;;*          the index of the eigenvector is returned in IFAIL.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, then i eigenvectors failed to converge.
;;*                Their indices are stored in array IFAIL.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhpevx (jobz  range  uplo  n  ap  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zhpevx_($jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpgst <itype>  <uplo>  <n>  <ap>  <bp>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPGST reduces a complex Hermitian-definite generalized
;;*  eigenproblem to standard form, using packed storage.
;;*
;;*  If ITYPE = 1, the problem is A*x = lambda*B*x,
;;*  and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
;;*
;;*  If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
;;*  B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
;;*
;;*  B must have been previously factorized as U**H*U or L*L**H by ZPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
;;*          = 2 or 3: compute U*A*U**H or L**H*A*L.
;;*
;;*  UPLO    (input) CHARACTER
;;*          = 'U':  Upper triangle of A is stored and B is factored as
;;*                  U**H*U;
;;*          = 'L':  Lower triangle of A is stored and B is factored as
;;*                  L*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, if INFO = 0, the transformed matrix, stored in the
;;*          same format as A.
;;*
;;*  BP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The triangular factor from the Cholesky factorization of B,
;;*          stored in the same format as A, as returned by ZPPTRF.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhpgst (itype  uplo  n  ap  bp  info  )
	((-idx0- (-int-)) itype )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) bp )
	((-idx0- (-int-)) info )
	#{ zhpgst_(IDX_PTR($itype,int), $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpgvd <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPGVD computes all the eigenvalues and, optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian, stored in packed format, and B is also
;;*  positive definite.
;;*  If eigenvectors are desired, it uses a divide and conquer algorithm.
;;*
;;*  The divide and conquer algorithm makes very mild assumptions about
;;*  floating point arithmetic. It will work on machines with a guard
;;*  digit in add/subtract, or on those binary machines without guard
;;*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
;;*  Cray-2. It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H, in the same storage
;;*          format as B.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of array WORK.
;;*          If N <= 1,               LWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LWORK >= 2*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of array RWORK.
;;*          If N <= 1,               LRWORK >= 1.
;;*          If JOBZ = 'N' and N > 1, LRWORK >= N.
;;*          If JOBZ = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of array IWORK.
;;*          If JOBZ  = 'N' or N <= 1, LIWORK >= 1.
;;*          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  ZPPTRF or ZHPEVD returned an error code:
;;*             <= N:  if INFO = i, ZHPEVD failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not convergeto zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zhpgvd (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) bp )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zhpgvd_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpgv <itype>  <jobz>  <uplo>  <n>  <ap>  <bp>  <w>  <z>  <ldz>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPGV computes all the eigenvalues and, optionally, the eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
;;*  Here A and B are assumed to be Hermitian, stored in packed format,
;;*  and B is also positive definite.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H, in the same storage
;;*          format as B.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, the eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'V', then if INFO = 0, Z contains the matrix Z of
;;*          eigenvectors.  The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*          If JOBZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (max(1, 2*N-1))
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  ZPPTRF or ZHPEV returned an error code:
;;*             <= N:  if INFO = i, ZHPEV failed to converge;
;;*                    i off-diagonal elements of an intermediate
;;*                    tridiagonal form did not convergeto zero;
;;*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zhpgv (itype  jobz  uplo  n  ap  bp  w  z  ldz  work  rwork  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) bp )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhpgv_(IDX_PTR($itype,int), $jobz->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpgvx <itype>  <jobz>  <range>  <uplo>  <n>  <ap>  <bp>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <work>  <rwork>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPGVX computes selected eigenvalues and, optionally, eigenvectors
;;*  of a complex generalized Hermitian-definite eigenproblem, of the form
;;*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
;;*  B are assumed to be Hermitian, stored in packed format, and B is also
;;*  positive definite.  Eigenvalues and eigenvectors can be selected by
;;*  specifying either a range of values or a range of indices for the
;;*  desired eigenvalues.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ITYPE   (input) INTEGER
;;*          Specifies the problem type to be solved:
;;*          = 1:  A*x = (lambda)*B*x
;;*          = 2:  A*B*x = (lambda)*x
;;*          = 3:  B*A*x = (lambda)*x
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found;
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found;
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangles of A and B are stored;
;;*          = 'L':  Lower triangles of A and B are stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the contents of AP are destroyed.
;;*
;;*  BP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          B, packed columnwise in a linear array.  The j-th column of B
;;*          is stored in the array BP as follows:
;;*          if UPLO = 'U', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.
;;*
;;*          On exit, the triangular factor U or L from the Cholesky
;;*          factorization B = U**H*U or B = L*L**H, in the same storage
;;*          format as B.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the eigenvalues.
;;*          An approximate eigenvalue is accepted as converged
;;*          when it is determined to lie in an interval [a,b]
;;*          of width less than or equal to
;;*
;;*                  ABSTOL + EPS *   max( |a|,|b| ) ,
;;*
;;*          where EPS is the machine precision.  If ABSTOL is less than
;;*          or equal to zero, then  EPS*|T|  will be used in its place,
;;*          where |T| is the 1-norm of the tridiagonal matrix obtained
;;*          by reducing AP to tridiagonal form.
;;*
;;*          Eigenvalues will be computed most accurately when ABSTOL is
;;*          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
;;*          If this routine returns with INFO>0, indicating that some
;;*          eigenvectors did not converge, try setting ABSTOL to
;;*          2*DLAMCH('S').
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          On normal exit, the first M elements contain the selected
;;*          eigenvalues in ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix A
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          The eigenvectors are normalized as follows:
;;*          if ITYPE = 1 or 2, Z**H*B*Z = I;
;;*          if ITYPE = 3, Z**H*inv(B)*Z = I.
;;*
;;*          If an eigenvector fails to converge, then that column of Z
;;*          contains the latest approximation to the eigenvector, and the
;;*          index of the eigenvector is returned in IFAIL.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (5*N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (N)
;;*          If JOBZ = 'V', then if INFO = 0, the first M elements of
;;*          IFAIL are zero.  If INFO > 0, then IFAIL contains the
;;*          indices of the eigenvectors that failed to converge.
;;*          If JOBZ = 'N', then IFAIL is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  ZPPTRF or ZHPEVX returned an error code:
;;*             <= N:  if INFO = i, ZHPEVX failed to converge;
;;*                    i eigenvectors failed to converge.  Their indices
;;*                    are stored in array IFAIL.
;;*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading
;;*                    minor of order i of B is not positive definite.
;;*                    The factorization of B could not be completed and
;;*                    no eigenvalues or eigenvectors were computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zhpgvx (itype  jobz  range  uplo  n  ap  bp  vl  vu  il  iu  abstol  m  w  z  ldz  work  rwork  iwork  ifail  info  )
	((-idx0- (-int-)) itype )
	((-str-) jobz )
	((-str-) range )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) bp )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zhpgvx_(IDX_PTR($itype,int), $jobz->data, $range->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($bp,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian indefinite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The factored form of the matrix A.  AFP contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**H or
;;*          A = L*D*L**H as computed by ZHPTRF, stored as a packed
;;*          triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHPTRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZHPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhprfs (uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpsv <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian matrix stored in packed format and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**H,  if UPLO = 'U', or
;;*     A = L * D * L**H,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, D is Hermitian and block diagonal with 1-by-1
;;*  and 2-by-2 diagonal blocks.  The factored form of A is then used to
;;*  solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by ZHPTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, so the solution could not be
;;*                computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de zhpsv (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zhpsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhpsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
;;*  A = L*D*L**H to compute the solution to a complex system of linear
;;*  equations A * X = B, where A is an N-by-N Hermitian matrix stored
;;*  in packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A as
;;*        A = U * D * U**H,  if UPLO = 'U', or
;;*        A = L * D * L**H,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices and D is Hermitian and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AFP and IPIV contain the factored form of
;;*                  A.  AFP and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZHPTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZHPTRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhpsvx (fact  uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zhpsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhptrd <uplo>  <n>  <ap>  <d>  <e>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPTRD reduces a complex Hermitian matrix A stored in packed form to
;;*  real symmetric tridiagonal form T by a unitary similarity
;;*  transformation: Q**H * A * Q = T.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          On exit, if UPLO = 'U', the diagonal and first superdiagonal
;;*          of A are overwritten by the corresponding elements of the
;;*          tridiagonal matrix T, and the elements above the first
;;*          superdiagonal, with the array TAU, represent the unitary
;;*          matrix Q as a product of elementary reflectors; if UPLO
;;*          = 'L', the diagonal and first subdiagonal of A are over-
;;*          written by the corresponding elements of the tridiagonal
;;*          matrix T, and the elements below the first subdiagonal, with
;;*          the array TAU, represent the unitary matrix Q as a product
;;*          of elementary reflectors. See Further Details.
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of the tridiagonal matrix T:
;;*          D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          The off-diagonal elements of the tridiagonal matrix T:
;;*          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors (see Further
;;*          Details).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n-1) . . . H(2) H(1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP,
;;*  overwriting A(1:i-1,i+1), and tau is stored in TAU(i).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP,
;;*  overwriting A(i+2:n,i), and tau is stored in TAU(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhptrd (uplo  n  ap  d  e  tau  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ zhptrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhptrf <uplo>  <n>  <ap>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPTRF computes the factorization of a complex Hermitian packed
;;*  matrix A using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U**H  or  A = L*D*L**H
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is Hermitian and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L, stored as a packed triangular
;;*          matrix overwriting A (see below for further details).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  5-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhptrf (uplo  n  ap  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zhptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhptri <uplo>  <n>  <ap>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPTRI computes the inverse of a complex Hermitian indefinite matrix
;;*  A in packed storage using the factorization A = U*D*U**H or
;;*  A = L*D*L**H computed by ZHPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by ZHPTRF,
;;*          stored as a packed triangular matrix.
;;*
;;*          On exit, if INFO = 0, the (Hermitian) inverse of the original
;;*          matrix, stored as a packed triangular matrix. The j-th column
;;*          of inv(A) is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
;;*          if UPLO = 'L',
;;*             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHPTRF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhptri (uplo  n  ap  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zhptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhptrs <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHPTRS solves a system of linear equations A*X = B with a complex
;;*  Hermitian matrix A stored in packed format using the factorization
;;*  A = U*D*U**H or A = L*D*L**H computed by ZHPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**H;
;;*          = 'L':  Lower triangular, form is A = L*D*L**H.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZHPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZHPTRF.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhptrs (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zhptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhsein <side>  <eigsrc>  <initv>  <select>  <n>  <h>  <ldh>  <w>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <rwork>  <ifaill>  <ifailr>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHSEIN uses inverse iteration to find specified right and/or left
;;*  eigenvectors of a complex upper Hessenberg matrix H.
;;*
;;*  The right eigenvector x and the left eigenvector y of the matrix H
;;*  corresponding to an eigenvalue w are defined by:
;;*
;;*               H * x = w * x,     y**h * H = w * y**h
;;*
;;*  where y**h denotes the conjugate transpose of the vector y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  EIGSRC  (input) CHARACTER*1
;;*          Specifies the source of eigenvalues supplied in W:
;;*          = 'Q': the eigenvalues were found using ZHSEQR; thus, if
;;*                 H has zero subdiagonal elements, and so is
;;*                 block-triangular, then the j-th eigenvalue can be
;;*                 assumed to be an eigenvalue of the block containing
;;*                 the j-th row/column.  This property allows ZHSEIN to
;;*                 perform inverse iteration on just one diagonal block.
;;*          = 'N': no assumptions are made on the correspondence
;;*                 between eigenvalues and diagonal blocks.  In this
;;*                 case, ZHSEIN must always perform inverse iteration
;;*                 using the whole matrix H.
;;*
;;*  INITV   (input) CHARACTER*1
;;*          = 'N': no initial vectors are supplied;
;;*          = 'U': user-supplied initial vectors are stored in the arrays
;;*                 VL and/or VR.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          Specifies the eigenvectors to be computed. To select the
;;*          eigenvector corresponding to the eigenvalue W(j),
;;*          SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) COMPLEX*16 array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  W       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, the eigenvalues of H.
;;*          On exit, the real parts of W may have been altered since
;;*          close eigenvalues are perturbed slightly in searching for
;;*          independent eigenvectors.
;;*
;;*  VL      (input/output) COMPLEX*16 array, dimension (LDVL,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
;;*          contain starting vectors for the inverse iteration for the
;;*          left eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column in which the eigenvector will be
;;*          stored.
;;*          On exit, if SIDE = 'L' or 'B', the left eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VL, in the same order as their eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) COMPLEX*16 array, dimension (LDVR,MM)
;;*          On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
;;*          contain starting vectors for the inverse iteration for the
;;*          right eigenvectors; the starting vector for each eigenvector
;;*          must be in the same column in which the eigenvector will be
;;*          stored.
;;*          On exit, if SIDE = 'R' or 'B', the right eigenvectors
;;*          specified by SELECT will be stored consecutively in the
;;*          columns of VR, in the same order as their eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR required to
;;*          store the eigenvectors (= the number of .TRUE. elements in
;;*          SELECT).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  IFAILL  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'L' or 'B', IFAILL(i) = j > 0 if the left
;;*          eigenvector in the i-th column of VL (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
;;*          eigenvector converged satisfactorily.
;;*          If SIDE = 'R', IFAILL is not referenced.
;;*
;;*  IFAILR  (output) INTEGER array, dimension (MM)
;;*          If SIDE = 'R' or 'B', IFAILR(i) = j > 0 if the right
;;*          eigenvector in the i-th column of VR (corresponding to the
;;*          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
;;*          eigenvector converged satisfactorily.
;;*          If SIDE = 'L', IFAILR is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, i is the number of eigenvectors which
;;*                failed to converge; see IFAILL and IFAILR for further
;;*                details.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x|+|y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhsein (side  eigsrc  initv  select  n  h  ldh  w  vl  ldvl  vr  ldvr  mm  m  work  rwork  ifaill  ifailr  info  )
	((-str-) side )
	((-str-) eigsrc )
	((-str-) initv )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx2- (-double-)) w )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) ifaill )
	((-idx1- (-int-)) ifailr )
	((-idx0- (-int-)) info )
	#{ zhsein_($side->data, $eigsrc->data, $initv->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($w,double), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($ifaill,int), IDX_PTR($ifailr,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zhseqr <job>  <compz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <w>  <z>  <ldz>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZHSEQR computes the eigenvalues of a complex upper Hessenberg
;;*  matrix H, and, optionally, the matrices T and Z from the Schur
;;*  decomposition H = Z T Z**H, where T is an upper triangular matrix
;;*  (the Schur form), and Z is the unitary matrix of Schur vectors.
;;*
;;*  Optionally Z may be postmultiplied into an input unitary matrix Q,
;;*  so that this routine can give the Schur factorization of a matrix A
;;*  which has been reduced to the Hessenberg form H by the unitary
;;*  matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          = 'E': compute eigenvalues only;
;;*          = 'S': compute eigenvalues and the Schur form T.
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N': no Schur vectors are computed;
;;*          = 'I': Z is initialized to the unit matrix and the matrix Z
;;*                 of Schur vectors of H is returned;
;;*          = 'V': Z must contain an unitary matrix Q on entry, and
;;*                 the product Q*Z is returned.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper triangular in rows
;;*          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
;;*          set by a previous call to ZGEBAL, and then passed to CGEHRD
;;*          when the matrix output by ZGEBAL is reduced to Hessenberg
;;*          form. Otherwise ILO and IHI should be set to 1 and N
;;*          respectively.
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  H       (input/output) COMPLEX*16 array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if JOB = 'S', H contains the upper triangular matrix
;;*          T from the Schur decomposition (the Schur form). If
;;*          JOB = 'E', the contents of H are unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          The computed eigenvalues. If JOB = 'S', the eigenvalues are
;;*          stored in the same order as on the diagonal of the Schur form
;;*          returned in H, with W(i) = H(i,i).
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          If COMPZ = 'N': Z is not referenced.
;;*          If COMPZ = 'I': on entry, Z need not be set, and on exit, Z
;;*          contains the unitary matrix Z of the Schur vectors of H.
;;*          If COMPZ = 'V': on entry Z must contain an N-by-N matrix Q,
;;*          which is assumed to be equal to the unit matrix except for
;;*          the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
;;*          Normally Q is the unitary matrix generated by ZUNGHR after
;;*          the call to ZGEHRD which formed the Hessenberg matrix H.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.
;;*          LDZ >= max(1,N) if COMPZ = 'I' or 'V'; LDZ >= 1 otherwise.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,N).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, ZHSEQR failed to compute all the
;;*                eigenvalues in a total of 30*(IHI-ILO+1) iterations;
;;*                elements 1:ilo-1 and i+1:n of W contain those
;;*                eigenvalues which have been successfully computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zhseqr (job  compz  n  ilo  ihi  h  ldh  w  z  ldz  work  lwork  info  )
	((-str-) job )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx2- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zhseqr_($job->data, $compz->data, IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlabrd <m>  <n>  <nb>  <a>  <lda>  <d>  <e>  <tauq>  <taup>  <x>  <ldx>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLABRD reduces the first NB rows and columns of a complex general
;;*  m by n matrix A to upper or lower real bidiagonal form by a unitary
;;*  transformation Q' * A * P, and returns the matrices X and Y which
;;*  are needed to apply the transformation to the unreduced part of A.
;;*
;;*  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
;;*  bidiagonal form.
;;*
;;*  This is an auxiliary routine called by ZGEBRD
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows in the matrix A.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns in the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of leading rows and columns of A to be reduced.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n general matrix to be reduced.
;;*          On exit, the first NB rows and columns of the matrix are
;;*          overwritten; the rest of the array is unchanged.
;;*          If m >= n, elements on and below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the unitary
;;*            matrix Q as a product of elementary reflectors; and
;;*            elements above the diagonal in the first NB rows, with the
;;*            array TAUP, represent the unitary matrix P as a product
;;*            of elementary reflectors.
;;*          If m < n, elements below the diagonal in the first NB
;;*            columns, with the array TAUQ, represent the unitary
;;*            matrix Q as a product of elementary reflectors, and
;;*            elements on and above the diagonal in the first NB rows,
;;*            with the array TAUP, represent the unitary matrix P as
;;*            a product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  D       (output) DOUBLE PRECISION array, dimension (NB)
;;*          The diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.  D(i) = A(i,i).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (NB)
;;*          The off-diagonal elements of the first NB rows and columns of
;;*          the reduced matrix.
;;*
;;*  TAUQ    (output) COMPLEX*16 array dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix Q. See Further Details.
;;*
;;*  TAUP    (output) COMPLEX*16 array, dimension (NB)
;;*          The scalar factors of the elementary reflectors which
;;*          represent the unitary matrix P. See Further Details.
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NB)
;;*          The m-by-nb matrix X required to update the unreduced part
;;*          of A.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X. LDX >= max(1,M).
;;*
;;*  Y       (output) COMPLEX*16 array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y required to update the unreduced part
;;*          of A.
;;*
;;*  LDY     (output) INTEGER
;;*          The leading dimension of the array Y. LDY >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrices Q and P are represented as products of elementary
;;*  reflectors:
;;*
;;*     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
;;*
;;*  Each H(i) and G(i) has the form:
;;*
;;*     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'
;;*
;;*  where tauq and taup are complex scalars, and v and u are complex
;;*  vectors.
;;*
;;*  If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
;;*  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
;;*  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
;;*  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
;;*
;;*  The elements of the vectors v and u together form the m-by-nb matrix
;;*  V and the nb-by-n matrix U' which are needed, with X and Y, to apply
;;*  the transformation to the unreduced part of the matrix, using a block
;;*  update of the form:  A := A - V*Y' - X*U'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with nb = 2:
;;*
;;*  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
;;*
;;*    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
;;*    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
;;*    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
;;*    (  v1  v2  a   a   a  )
;;*
;;*  where a denotes an element of the original matrix which is unchanged,
;;*  vi denotes an element of the vector defining H(i), and ui an element
;;*  of the vector defining G(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlabrd (m  n  nb  a  lda  d  e  tauq  taup  x  ldx  y  ldy  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tauq )
	((-idx2- (-double-)) taup )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx3- (-double-)) y )
	((-idx0- (-int-)) ldy )
	#{ zlabrd_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($tauq,double), IDX_PTR($taup,double), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($y,double), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlacgv <n>  <x>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLACGV conjugates a complex vector of length N.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The length of the vector X.  N >= 0.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension
;;*                         (1+(N-1)*abs(INCX))
;;*          On entry, the vector of length N to be conjugated.
;;*          On exit, X is overwritten with conjg(X).
;;*
;;*  INCX    (input) INTEGER
;;*          The spacing between successive elements of X.
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlacgv (n  x  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ zlacgv_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlacon <n>  <v>  <x>  <est>  <kase>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLACON estimates the 1-norm of a square, complex matrix A.
;;*  Reverse communication is used for evaluating matrix-vector products.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The order of the matrix.  N >= 1.
;;*
;;*  V      (workspace) COMPLEX*16 array, dimension (N)
;;*         On the final return, V = A*W,  where  EST = norm(V)/norm(W)
;;*         (W is not returned).
;;*
;;*  X      (input/output) COMPLEX*16 array, dimension (N)
;;*         On an intermediate return, X should be overwritten by
;;*               A * X,   if KASE=1,
;;*               A' * X,  if KASE=2,
;;*         where A' is the conjugate transpose of A, and ZLACON must be
;;*         re-called with all the other parameters unchanged.
;;*
;;*  EST    (output) DOUBLE PRECISION
;;*         An estimate (a lower bound) for norm(A).
;;*
;;*  KASE   (input/output) INTEGER
;;*         On the initial call to ZLACON, KASE should be 0.
;;*         On an intermediate return, KASE will be 1 or 2, indicating
;;*         whether X should be overwritten by A * X  or A' * X.
;;*         On the final return from ZLACON, KASE will again be 0.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  Contributed by Nick Higham, University of Manchester.
;;*  Originally named CONEST, dated March 16, 1988.
;;*
;;*  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of
;;*  a real or complex matrix, with applications to condition estimation",
;;*  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
;;*
;;*  Last modified:  April, 1999
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlacon (n  v  x  est  kase  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) v )
	((-idx2- (-double-)) x )
	((-idx0- (-double-)) est )
	((-idx0- (-int-)) kase )
	#{ zlacon_(IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($x,double), IDX_PTR($est,double), IDX_PTR($kase,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlacp2 <uplo>  <m>  <n>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLACP2 copies all or part of a real two-dimensional matrix A to a
;;*  complex matrix B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be copied to B.
;;*          = 'U':      Upper triangular part
;;*          = 'L':      Lower triangular part
;;*          Otherwise:  All of the matrix A
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
;;*          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
;;*          is accessed; if UPLO = 'L', only the lower trapezium is
;;*          accessed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (output) COMPLEX*16 array, dimension (LDB,N)
;;*          On exit, B = A in the locations specified by UPLO.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlacp2 (uplo  m  n  a  lda  b  ldb  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ zlacp2_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlacpy <uplo>  <m>  <n>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLACPY copies all or part of a two-dimensional matrix A to another
;;*  matrix B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be copied to B.
;;*          = 'U':      Upper triangular part
;;*          = 'L':      Lower triangular part
;;*          Otherwise:  All of the matrix A
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
;;*          is accessed; if UPLO = 'L', only the lower trapezium is
;;*          accessed.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  B       (output) COMPLEX*16 array, dimension (LDB,N)
;;*          On exit, B = A in the locations specified by UPLO.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlacpy (uplo  m  n  a  lda  b  ldb  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ zlacpy_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlacrm <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <rwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLACRM performs a very simple matrix-matrix multiplication:
;;*           C := A * B,
;;*  where A is M by N and complex; B is N by N and real;
;;*  C is M by N and complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A and of the matrix C.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns and rows of the matrix B and
;;*          the number of columns of the matrix C.
;;*          N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA, N)
;;*          A contains the M by N matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >=max(1,M).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB, N)
;;*          B contains the N by N matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >=max(1,N).
;;*
;;*  C       (input) COMPLEX*16 array, dimension (LDC, N)
;;*          C contains the M by N matrix C.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >=max(1,N).
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlacrm (m  n  a  lda  b  ldb  c  ldc  rwork  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) rwork )
	#{ zlacrm_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($rwork,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlacrt <n>  <cx>  <incx>  <cy>  <incy>  <c>  <s>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLACRT performs the operation
;;*
;;*     (  c  s )( x )  ==> ( x )
;;*     ( -s  c )( y )      ( y )
;;*
;;*  where c and s are complex and the vectors x and y are complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements in the vectors CX and CY.
;;*
;;*  CX      (input/output) COMPLEX*16 array, dimension (N)
;;*          On input, the vector x.
;;*          On output, CX is overwritten with c*x + s*y.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of CX.  INCX <> 0.
;;*
;;*  CY      (input/output) COMPLEX*16 array, dimension (N)
;;*          On input, the vector y.
;;*          On output, CY is overwritten with -s*x + c*y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive values of CY.  INCY <> 0.
;;*
;;*  C       (input) COMPLEX*16
;;*  S       (input) COMPLEX*16
;;*          C and S define the matrix
;;*             [  C   S  ].
;;*             [ -S   C  ]
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlacrt (n  cx  incx  cy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) cy )
	((-idx0- (-int-)) incy )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	#{ zlacrt_(IDX_PTR($n,int), IDX_PTR($cx,double), IDX_PTR($incx,int), IDX_PTR($cy,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($s,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zladiv <x>  <y>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y
;;*  will not overflow on an intermediary step unless the results
;;*  overflows.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  X       (input) COMPLEX*16
;;*  Y       (input) COMPLEX*16
;;*          The complex scalars X and Y.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zladiv (x  y  )
	((-idx1- (-double-)) x )
	((-idx1- (-double-)) y )
	(let ((rval 0))
	#{ $rval=zladiv_(IDX_PTR($x,double), IDX_PTR($y,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaed0 <qsiz>  <n>  <d>  <e>  <q>  <ldq>  <qstore>  <ldqs>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Using the divide and conquer method, ZLAED0 computes all eigenvalues
;;*  of a symmetric tridiagonal matrix which is one diagonal block of
;;*  those from reducing a dense or band Hermitian matrix and
;;*  corresponding eigenvectors of the dense or band matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the unitary matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, the diagonal elements of the tridiagonal matrix.
;;*         On exit, the eigenvalues in ascending order.
;;*
;;*  E      (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*         On entry, the off-diagonal elements of the tridiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  Q      (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*         On entry, Q must contain an QSIZ x N matrix whose columns
;;*         unitarily orthonormal. It is a part of the unitary matrix
;;*         that reduces the full dense Hermitian matrix to a
;;*         (reducible) symmetric tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  IWORK  (workspace) INTEGER array,
;;*         the dimension of IWORK must be at least
;;*                      6 + 6*N + 5*N*lg N
;;*                      ( lg( N ) = smallest integer k
;;*                                  such that 2^k >= N )
;;*
;;*  RWORK  (workspace) DOUBLE PRECISION array,
;;*                               dimension (1 + 3*N + 2*N*lg N + 3*N**2)
;;*                        ( lg( N ) = smallest integer k
;;*                                    such that 2^k >= N )
;;*
;;*  QSTORE (workspace) COMPLEX*16 array, dimension (LDQS, N)
;;*         Used to store parts of
;;*         the eigenvector matrix when the updating matrix multiplies
;;*         take place.
;;*
;;*  LDQS   (input) INTEGER
;;*         The leading dimension of the array QSTORE.
;;*         LDQS >= max(1,N).
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  =====================================================================
;;*
;;*  Warning:      N could be as big as QSIZ!
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaed0 (qsiz  n  d  e  q  ldq  qstore  ldqs  rwork  iwork  info  )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) qstore )
	((-idx0- (-int-)) ldqs )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zlaed0_(IDX_PTR($qsiz,int), IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($qstore,double), IDX_PTR($ldqs,int), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaed7 <n>  <cutpnt>  <qsiz>  <tlvls>  <curlvl>  <curpbm>  <d>  <q>  <ldq>  <rho>  <indxq>  <qstore>  <qptr>  <prmptr>  <perm>  <givptr>  <givcol>  <givnum>  <work>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAED7 computes the updated eigensystem of a diagonal
;;*  matrix after modification by a rank-one symmetric matrix. This
;;*  routine is used only for the eigenproblem which requires all
;;*  eigenvalues and optionally eigenvectors of a dense or banded
;;*  Hermitian matrix that has been reduced to tridiagonal form.
;;*
;;*    T = Q(in) ( D(in) + RHO * Z*Z' ) Q'(in) = Q(out) * D(out) * Q'(out)
;;*
;;*    where Z = Q'u, u is a vector of length N with ones in the
;;*    CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
;;*
;;*     The eigenvectors of the original matrix are stored in Q, and the
;;*     eigenvalues are in D.  The algorithm consists of three stages:
;;*
;;*        The first stage consists of deflating the size of the problem
;;*        when there are multiple eigenvalues or if there is a zero in
;;*        the Z vector.  For each such occurence the dimension of the
;;*        secular equation problem is reduced by one.  This stage is
;;*        performed by the routine DLAED2.
;;*
;;*        The second stage consists of calculating the updated
;;*        eigenvalues. This is done by finding the roots of the secular
;;*        equation via the routine DLAED4 (as called by SLAED3).
;;*        This routine also calculates the eigenvectors of the current
;;*        problem.
;;*
;;*        The final stage consists of computing the updated eigenvectors
;;*        directly using the updated eigenvalues.  The eigenvectors for
;;*        the current problem are multiplied with the eigenvectors from
;;*        the overall problem.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  CUTPNT (input) INTEGER
;;*         Contains the location of the last eigenvalue in the leading
;;*         sub-matrix.  min(1,N) <= CUTPNT <= N.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the unitary matrix used to reduce
;;*         the full matrix to tridiagonal form.  QSIZ >= N.
;;*
;;*  TLVLS  (input) INTEGER
;;*         The total number of merging levels in the overall divide and
;;*         conquer tree.
;;*
;;*  CURLVL (input) INTEGER
;;*         The current level in the overall merge routine,
;;*         0 <= curlvl <= tlvls.
;;*
;;*  CURPBM (input) INTEGER
;;*         The current problem in the current level in the overall
;;*         merge routine (counting from upper left to lower right).
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, the eigenvalues of the rank-1-perturbed matrix.
;;*         On exit, the eigenvalues of the repaired matrix.
;;*
;;*  Q      (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*         On entry, the eigenvectors of the rank-1-perturbed matrix.
;;*         On exit, the eigenvectors of the repaired tridiagonal matrix.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  RHO    (input) DOUBLE PRECISION
;;*         Contains the subdiagonal element used to create the rank-1
;;*         modification.
;;*
;;*  INDXQ  (output) INTEGER array, dimension (N)
;;*         This contains the permutation which will reintegrate the
;;*         subproblem just solved back into sorted order,
;;*         ie. D( INDXQ( I = 1, N ) ) will be in ascending order.
;;*
;;*  IWORK  (workspace) INTEGER array, dimension (4*N)
;;*
;;*  RWORK  (workspace) DOUBLE PRECISION array,
;;*                                 dimension (3*N+2*QSIZ*N)
;;*
;;*  WORK   (workspace) COMPLEX*16 array, dimension (QSIZ*N)
;;*
;;*  QSTORE (input/output) DOUBLE PRECISION array, dimension (N**2+1)
;;*         Stores eigenvectors of submatrices encountered during
;;*         divide and conquer, packed together. QPTR points to
;;*         beginning of the submatrices.
;;*
;;*  QPTR   (input/output) INTEGER array, dimension (N+2)
;;*         List of indices pointing to beginning of submatrices stored
;;*         in QSTORE. The submatrices are numbered starting at the
;;*         bottom left of the divide and conquer tree, from left to
;;*         right and bottom to top.
;;*
;;*  PRMPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in PERM a
;;*         level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
;;*         indicates the size of the permutation and also the size of
;;*         the full, non-deflated problem.
;;*
;;*  PERM   (input) INTEGER array, dimension (N lg N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (input) INTEGER array, dimension (N lg N)
;;*         Contains a list of pointers which indicate where in GIVCOL a
;;*         level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
;;*         indicates the number of Givens rotations.
;;*
;;*  GIVCOL (input) INTEGER array, dimension (2, N lg N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension (2, N lg N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = 1, an eigenvalue did not converge
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlaed7 (n  cutpnt  qsiz  tlvls  curlvl  curpbm  d  q  ldq  rho  indxq  qstore  qptr  prmptr  perm  givptr  givcol  givnum  work  rwork  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) cutpnt )
	((-idx0- (-int-)) qsiz )
	((-idx0- (-int-)) tlvls )
	((-idx0- (-int-)) curlvl )
	((-idx0- (-int-)) curpbm )
	((-idx1- (-double-)) d )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-double-)) rho )
	((-idx1- (-int-)) indxq )
	((-idx1- (-double-)) qstore )
	((-idx1- (-int-)) qptr )
	((-idx1- (-int-)) prmptr )
	((-idx1- (-int-)) perm )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-double-)) givnum )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zlaed7_(IDX_PTR($n,int), IDX_PTR($cutpnt,int), IDX_PTR($qsiz,int), IDX_PTR($tlvls,int), IDX_PTR($curlvl,int), IDX_PTR($curpbm,int), IDX_PTR($d,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($rho,double), IDX_PTR($indxq,int), IDX_PTR($qstore,double), IDX_PTR($qptr,int), IDX_PTR($prmptr,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaed8 <k>  <n>  <qsiz>  <q>  <ldq>  <d>  <rho>  <cutpnt>  <z>  <dlamda>  <q2>  <ldq2>  <w>  <indxp>  <indx>  <indxq>  <perm>  <givptr>  <givcol>  <givnum>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAED8 merges the two sets of eigenvalues together into a single
;;*  sorted set.  Then it tries to deflate the size of the problem.
;;*  There are two ways in which deflation can occur:  when two or more
;;*  eigenvalues are close together or if there is a tiny element in the
;;*  Z vector.  For each such occurrence the order of the related secular
;;*  equation problem is reduced by one.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  K      (output) INTEGER
;;*         Contains the number of non-deflated eigenvalues.
;;*         This is the order of the related secular equation.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  QSIZ   (input) INTEGER
;;*         The dimension of the unitary matrix used to reduce
;;*         the dense or band matrix to tridiagonal form.
;;*         QSIZ >= N if ICOMPQ = 1.
;;*
;;*  Q      (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*         On entry, Q contains the eigenvectors of the partially solved
;;*         system which has been previously updated in matrix
;;*         multiplies with other partially solved eigensystems.
;;*         On exit, Q contains the trailing (N-K) updated eigenvectors
;;*         (those which were deflated) in its last N-K columns.
;;*
;;*  LDQ    (input) INTEGER
;;*         The leading dimension of the array Q.  LDQ >= max( 1, N ).
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry, D contains the eigenvalues of the two submatrices to
;;*         be combined.  On exit, D contains the trailing (N-K) updated
;;*         eigenvalues (those which were deflated) sorted into increasing
;;*         order.
;;*
;;*  RHO    (input/output) DOUBLE PRECISION
;;*         Contains the off diagonal element associated with the rank-1
;;*         cut which originally split the two submatrices which are now
;;*         being recombined. RHO is modified during the computation to
;;*         the value required by DLAED3.
;;*
;;*  CUTPNT (input) INTEGER
;;*         Contains the location of the last eigenvalue in the leading
;;*         sub-matrix.  MIN(1,N) <= CUTPNT <= N.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension (N)
;;*         On input this vector contains the updating vector (the last
;;*         row of the first sub-eigenvector matrix and the first row of
;;*         the second sub-eigenvector matrix).  The contents of Z are
;;*         destroyed during the updating process.
;;*
;;*  DLAMDA (output) DOUBLE PRECISION array, dimension (N)
;;*         Contains a copy of the first K eigenvalues which will be used
;;*         by DLAED3 to form the secular equation.
;;*
;;*  Q2     (output) COMPLEX*16 array, dimension (LDQ2,N)
;;*         If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
;;*         Contains a copy of the first K eigenvectors which will be used
;;*         by DLAED7 in a matrix multiply (DGEMM) to update the new
;;*         eigenvectors.
;;*
;;*  LDQ2   (input) INTEGER
;;*         The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).
;;*
;;*  W      (output) DOUBLE PRECISION array, dimension (N)
;;*         This will hold the first k values of the final
;;*         deflation-altered z-vector and will be passed to DLAED3.
;;*
;;*  INDXP  (workspace) INTEGER array, dimension (N)
;;*         This will contain the permutation used to place deflated
;;*         values of D at the end of the array. On output INDXP(1:K)
;;*         points to the nondeflated D-values and INDXP(K+1:N)
;;*         points to the deflated eigenvalues.
;;*
;;*  INDX   (workspace) INTEGER array, dimension (N)
;;*         This will contain the permutation used to sort the contents of
;;*         D into ascending order.
;;*
;;*  INDXQ  (input) INTEGER array, dimension (N)
;;*         This contains the permutation which separately sorts the two
;;*         sub-problems in D into ascending order.  Note that elements in
;;*         the second half of this permutation must first have CUTPNT
;;*         added to their values in order to be accurate.
;;*
;;*  PERM   (output) INTEGER array, dimension (N)
;;*         Contains the permutations (from deflation and sorting) to be
;;*         applied to each eigenblock.
;;*
;;*  GIVPTR (output) INTEGER
;;*         Contains the number of Givens rotations which took place in
;;*         this subproblem.
;;*
;;*  GIVCOL (output) INTEGER array, dimension (2, N)
;;*         Each pair of numbers indicates a pair of columns to take place
;;*         in a Givens rotation.
;;*
;;*  GIVNUM (output) DOUBLE PRECISION array, dimension (2, N)
;;*         Each number indicates the S value to be used in the
;;*         corresponding Givens rotation.
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaed8 (k  n  qsiz  q  ldq  d  rho  cutpnt  z  dlamda  q2  ldq2  w  indxp  indx  indxq  perm  givptr  givcol  givnum  info  )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) qsiz )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx1- (-double-)) d )
	((-idx0- (-double-)) rho )
	((-idx0- (-int-)) cutpnt )
	((-idx1- (-double-)) z )
	((-idx1- (-double-)) dlamda )
	((-idx3- (-double-)) q2 )
	((-idx0- (-int-)) ldq2 )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) indxp )
	((-idx1- (-int-)) indx )
	((-idx1- (-int-)) indxq )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx2- (-double-)) givnum )
	((-idx0- (-int-)) info )
	#{ zlaed8_(IDX_PTR($k,int), IDX_PTR($n,int), IDX_PTR($qsiz,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($d,double), IDX_PTR($rho,double), IDX_PTR($cutpnt,int), IDX_PTR($z,double), IDX_PTR($dlamda,double), IDX_PTR($q2,double), IDX_PTR($ldq2,int), IDX_PTR($w,double), IDX_PTR($indxp,int), IDX_PTR($indx,int), IDX_PTR($indxq,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($givnum,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaein <rightv>  <noinit>  <n>  <h>  <ldh>  <w>  <v>  <b>  <ldb>  <rwork>  <eps3>  <smlnum>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAEIN uses inverse iteration to find a right or left eigenvector
;;*  corresponding to the eigenvalue W of a complex upper Hessenberg
;;*  matrix H.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  RIGHTV   (input) LOGICAL
;;*          = .TRUE. : compute right eigenvector;
;;*          = .FALSE.: compute left eigenvector.
;;*
;;*  NOINIT   (input) LOGICAL
;;*          = .TRUE. : no initial vector supplied in V
;;*          = .FALSE.: initial vector supplied in V.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  H       (input) COMPLEX*16 array, dimension (LDH,N)
;;*          The upper Hessenberg matrix H.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H.  LDH >= max(1,N).
;;*
;;*  W       (input) COMPLEX*16
;;*          The eigenvalue of H whose corresponding right or left
;;*          eigenvector is to be computed.
;;*
;;*  V       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, if NOINIT = .FALSE., V must contain a starting
;;*          vector for inverse iteration; otherwise V need not be set.
;;*          On exit, V contains the computed eigenvector, normalized so
;;*          that the component of largest magnitude has magnitude 1; here
;;*          the magnitude of a complex number (x,y) is taken to be
;;*          |x| + |y|.
;;*
;;*  B       (workspace) COMPLEX*16 array, dimension (LDB,N)
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  EPS3    (input) DOUBLE PRECISION
;;*          A small machine-dependent value which is used to perturb
;;*          close eigenvalues, and to replace zero pivots.
;;*
;;*  SMLNUM  (input) DOUBLE PRECISION
;;*          A machine-dependent value close to the underflow threshold.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          = 1:  inverse iteration did not converge; V is set to the
;;*                last iterate.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaein (rightv  noinit  n  h  ldh  w  v  b  ldb  rwork  eps3  smlnum  info  )
	((-idx0- (-int-)) rightv )
	((-idx0- (-int-)) noinit )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx1- (-double-)) w )
	((-idx2- (-double-)) v )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-double-)) rwork )
	((-idx0- (-double-)) eps3 )
	((-idx0- (-double-)) smlnum )
	((-idx0- (-int-)) info )
	#{ zlaein_(IDX_PTR($rightv,int), IDX_PTR($noinit,int), IDX_PTR($n,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($w,double), IDX_PTR($v,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($rwork,double), IDX_PTR($eps3,double), IDX_PTR($smlnum,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaesy <a>  <b>  <c>  <rt1>  <rt2>  <evscal>  <cs1>  <sn1>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
;;*     ( ( A, B );( B, C ) )
;;*  provided the norm of the matrix of eigenvectors is larger than
;;*  some threshold value.
;;*
;;*  RT1 is the eigenvalue of larger absolute value, and RT2 of
;;*  smaller absolute value.  If the eigenvectors are computed, then
;;*  on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
;;*
;;*  [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
;;*  [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A       (input) COMPLEX*16
;;*          The ( 1, 1 ) element of input matrix.
;;*
;;*  B       (input) COMPLEX*16
;;*          The ( 1, 2 ) element of input matrix.  The ( 2, 1 ) element
;;*          is also given by B, since the 2-by-2 matrix is symmetric.
;;*
;;*  C       (input) COMPLEX*16
;;*          The ( 2, 2 ) element of input matrix.
;;*
;;*  RT1     (output) COMPLEX*16
;;*          The eigenvalue of larger modulus.
;;*
;;*  RT2     (output) COMPLEX*16
;;*          The eigenvalue of smaller modulus.
;;*
;;*  EVSCAL  (output) COMPLEX*16
;;*          The complex value by which the eigenvector matrix was scaled
;;*          to make it orthonormal.  If EVSCAL is zero, the eigenvectors
;;*          were not computed.  This means one of two things:  the 2-by-2
;;*          matrix could not be diagonalized, or the norm of the matrix
;;*          of eigenvectors before scaling was larger than the threshold
;;*          value THRESH (set below).
;;*
;;*  CS1     (output) COMPLEX*16
;;*  SN1     (output) COMPLEX*16
;;*          If EVSCAL .NE. 0,  ( CS1, SN1 ) is the unit right eigenvector
;;*          for RT1.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaesy (a  b  c  rt1  rt2  evscal  cs1  sn1  )
	((-idx1- (-double-)) a )
	((-idx1- (-double-)) b )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) rt1 )
	((-idx1- (-double-)) rt2 )
	((-idx1- (-double-)) evscal )
	((-idx1- (-double-)) cs1 )
	((-idx1- (-double-)) sn1 )
	#{ zlaesy_(IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($rt1,double), IDX_PTR($rt2,double), IDX_PTR($evscal,double), IDX_PTR($cs1,double), IDX_PTR($sn1,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaev2 <a>  <b>  <c>  <rt1>  <rt2>  <cs1>  <sn1>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix
;;*     [  A         B  ]
;;*     [  CONJG(B)  C  ].
;;*  On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
;;*  eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
;;*  eigenvector for RT1, giving the decomposition
;;*
;;*  [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
;;*  [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].
;;*
;;*  Arguments
;;*  =========
;;*
;;*  A      (input) COMPLEX*16
;;*         The (1,1) element of the 2-by-2 matrix.
;;*
;;*  B      (input) COMPLEX*16
;;*         The (1,2) element and the conjugate of the (2,1) element of
;;*         the 2-by-2 matrix.
;;*
;;*  C      (input) COMPLEX*16
;;*         The (2,2) element of the 2-by-2 matrix.
;;*
;;*  RT1    (output) DOUBLE PRECISION
;;*         The eigenvalue of larger absolute value.
;;*
;;*  RT2    (output) DOUBLE PRECISION
;;*         The eigenvalue of smaller absolute value.
;;*
;;*  CS1    (output) DOUBLE PRECISION
;;*  SN1    (output) COMPLEX*16
;;*         The vector (CS1, SN1) is a unit right eigenvector for RT1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  RT1 is accurate to a few ulps barring over/underflow.
;;*
;;*  RT2 may be inaccurate if there is massive cancellation in the
;;*  determinant A*C-B*B; higher precision or correctly rounded or
;;*  correctly truncated arithmetic would be needed to compute RT2
;;*  accurately in all cases.
;;*
;;*  CS1 and SN1 are accurate to a few ulps barring over/underflow.
;;*
;;*  Overflow is possible only if RT1 is within a factor of 5 of overflow.
;;*  Underflow is harmless if the input data is 0 or exceeds
;;*     underflow_threshold / macheps.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaev2 (a  b  c  rt1  rt2  cs1  sn1  )
	((-idx1- (-double-)) a )
	((-idx1- (-double-)) b )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rt1 )
	((-idx0- (-double-)) rt2 )
	((-idx0- (-double-)) cs1 )
	((-idx1- (-double-)) sn1 )
	#{ zlaev2_(IDX_PTR($a,double), IDX_PTR($b,double), IDX_PTR($c,double), IDX_PTR($rt1,double), IDX_PTR($rt2,double), IDX_PTR($cs1,double), IDX_PTR($sn1,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlags2 <upper>  <a1>  <a2>  <a3>  <b1>  <b2>  <b3>  <csu>  <snu>  <csv>  <snv>  <csq>  <snq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAGS2 computes 2-by-2 unitary matrices U, V and Q, such
;;*  that if ( UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 A2 )*Q = ( x  0  )
;;*                        ( 0  A3 )     ( x  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 B2 )*Q = ( x  0  )
;;*                        ( 0  B3 )     ( x  x  )
;;*
;;*  or if ( .NOT.UPPER ) then
;;*
;;*            U'*A*Q = U'*( A1 0  )*Q = ( x  x  )
;;*                        ( A2 A3 )     ( 0  x  )
;;*  and
;;*            V'*B*Q = V'*( B1 0  )*Q = ( x  x  )
;;*                        ( B2 B3 )     ( 0  x  )
;;*  where
;;*
;;*    U = (     CSU      SNU ), V = (     CSV     SNV ),
;;*        ( -CONJG(SNU)  CSU )      ( -CONJG(SNV) CSV )
;;*
;;*    Q = (     CSQ      SNQ )
;;*        ( -CONJG(SNQ)  CSQ )
;;*
;;*  Z' denotes the conjugate transpose of Z.
;;*
;;*  The rows of the transformed A and B are parallel. Moreover, if the
;;*  input 2-by-2 matrix A is not zero, then the transformed (1,1) entry
;;*  of A is not zero. If the input matrices A and B are both not zero,
;;*  then the transformed (2,2) element of B is not zero, except when the
;;*  first rows of input A and B are parallel and the second rows are
;;*  zero.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPPER   (input) LOGICAL
;;*          = .TRUE.: the input matrices A and B are upper triangular.
;;*          = .FALSE.: the input matrices A and B are lower triangular.
;;*
;;*  A1      (input) DOUBLE PRECISION
;;*  A2      (input) COMPLEX*16
;;*  A3      (input) DOUBLE PRECISION
;;*          On entry, A1, A2 and A3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix A.
;;*
;;*  B1      (input) DOUBLE PRECISION
;;*  B2      (input) COMPLEX*16
;;*  B3      (input) DOUBLE PRECISION
;;*          On entry, B1, B2 and B3 are elements of the input 2-by-2
;;*          upper (lower) triangular matrix B.
;;*
;;*  CSU     (output) DOUBLE PRECISION
;;*  SNU     (output) COMPLEX*16
;;*          The desired unitary matrix U.
;;*
;;*  CSV     (output) DOUBLE PRECISION
;;*  SNV     (output) COMPLEX*16
;;*          The desired unitary matrix V.
;;*
;;*  CSQ     (output) DOUBLE PRECISION
;;*  SNQ     (output) COMPLEX*16
;;*          The desired unitary matrix Q.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlags2 (upper  a1  a2  a3  b1  b2  b3  csu  snu  csv  snv  csq  snq  )
	((-idx0- (-int-)) upper )
	((-idx0- (-double-)) a1 )
	((-idx1- (-double-)) a2 )
	((-idx0- (-double-)) a3 )
	((-idx0- (-double-)) b1 )
	((-idx1- (-double-)) b2 )
	((-idx0- (-double-)) b3 )
	((-idx0- (-double-)) csu )
	((-idx1- (-double-)) snu )
	((-idx0- (-double-)) csv )
	((-idx1- (-double-)) snv )
	((-idx0- (-double-)) csq )
	((-idx1- (-double-)) snq )
	#{ zlags2_(IDX_PTR($upper,int), IDX_PTR($a1,double), IDX_PTR($a2,double), IDX_PTR($a3,double), IDX_PTR($b1,double), IDX_PTR($b2,double), IDX_PTR($b3,double), IDX_PTR($csu,double), IDX_PTR($snu,double), IDX_PTR($csv,double), IDX_PTR($snv,double), IDX_PTR($csq,double), IDX_PTR($snq,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlagtm <trans>  <n>  <nrhs>  <alpha>  <dl>  <d>  <du>  <x>  <ldx>  <beta>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAGTM performs a matrix-vector product of the form
;;*
;;*     B := alpha * A * X + beta * B
;;*
;;*  where A is a tridiagonal matrix of order N, B and X are N by NRHS
;;*  matrices, and alpha and beta are real scalars, each of which may be
;;*  0., 1., or -1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          Specifies the operation applied to A.
;;*          = 'N':  No transpose, B := alpha * A * X + beta * B
;;*          = 'T':  Transpose,    B := alpha * A**T * X + beta * B
;;*          = 'C':  Conjugate transpose, B := alpha * A**H * X + beta * B
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices X and B.
;;*
;;*  ALPHA   (input) DOUBLE PRECISION
;;*          The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 0.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of T.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The diagonal elements of T.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of T.
;;*
;;*  X       (input) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          The N by NRHS matrix X.
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(N,1).
;;*
;;*  BETA    (input) DOUBLE PRECISION
;;*          The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
;;*          it is assumed to be 1.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N by NRHS matrix B.
;;*          On exit, B is overwritten by the matrix expression
;;*          B := alpha * A * X + beta * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(N,1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlagtm (trans  n  nrhs  alpha  dl  d  du  x  ldx  beta  b  ldb  )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) beta )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ zlagtm_($trans->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($alpha,double), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($beta,double), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlahef <uplo>  <n>  <nb>  <kb>  <a>  <lda>  <ipiv>  <w>  <ldw>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAHEF computes a partial factorization of a complex Hermitian
;;*  matrix A using the Bunch-Kaufman diagonal pivoting method. The
;;*  partial factorization has the form:
;;*
;;*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or:
;;*        ( 0  U22 ) (  0   D  ) ( U12' U22' )
;;*
;;*  A  =  ( L11  0 ) (  D   0  ) ( L11' L21' )  if UPLO = 'L'
;;*        ( L21  I ) (  0  A22 ) (  0    I   )
;;*
;;*  where the order of D is at most NB. The actual order is returned in
;;*  the argument KB, and is either NB or NB-1, or N if N <= NB.
;;*  Note that U' denotes the conjugate transpose of U.
;;*
;;*  ZLAHEF is an auxiliary routine called by ZHETRF. It uses blocked code
;;*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
;;*  A22 (if UPLO = 'L').
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NB      (input) INTEGER
;;*          The maximum number of columns of the matrix A that should be
;;*          factored.  NB should be at least 2 to allow for 2-by-2 pivot
;;*          blocks.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns of A that were actually factored.
;;*          KB is either NB-1 or NB, or N if N <= NB.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, A contains details of the partial factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If UPLO = 'U', only the last KB elements of IPIV are set;
;;*          if UPLO = 'L', only the first KB elements are set.
;;*
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  W       (workspace) COMPLEX*16 array, dimension (LDW,NB)
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W.  LDW >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlahef (uplo  n  nb  kb  a  lda  ipiv  w  ldw  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) w )
	((-idx0- (-int-)) ldw )
	((-idx0- (-int-)) info )
	#{ zlahef_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($w,double), IDX_PTR($ldw,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlahqr <wantt>  <wantz>  <n>  <ilo>  <ihi>  <h>  <ldh>  <w>  <iloz>  <ihiz>  <z>  <ldz>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAHQR is an auxiliary routine called by ZHSEQR to update the
;;*  eigenvalues and Schur decomposition already computed by ZHSEQR, by
;;*  dealing with the Hessenberg submatrix in rows and columns ILO to IHI.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTT   (input) LOGICAL
;;*          = .TRUE. : the full Schur form T is required;
;;*          = .FALSE.: only eigenvalues are required.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          = .TRUE. : the matrix of Schur vectors Z is required;
;;*          = .FALSE.: Schur vectors are not required.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix H.  N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          It is assumed that H is already upper triangular in rows and
;;*          columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
;;*          ZLAHQR works primarily with the Hessenberg submatrix in rows
;;*          and columns ILO to IHI, but applies transformations to all of
;;*          H if WANTT is .TRUE..
;;*          1 <= ILO <= max(1,IHI); IHI <= N.
;;*
;;*  H       (input/output) COMPLEX*16 array, dimension (LDH,N)
;;*          On entry, the upper Hessenberg matrix H.
;;*          On exit, if WANTT is .TRUE., H is upper triangular in rows
;;*          and columns ILO:IHI, with any 2-by-2 diagonal blocks in
;;*          standard form. If WANTT is .FALSE., the contents of H are
;;*          unspecified on exit.
;;*
;;*  LDH     (input) INTEGER
;;*          The leading dimension of the array H. LDH >= max(1,N).
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          The computed eigenvalues ILO to IHI are stored in the
;;*          corresponding elements of W. If WANTT is .TRUE., the
;;*          eigenvalues are stored in the same order as on the diagonal
;;*          of the Schur form returned in H, with W(i) = H(i,i).
;;*
;;*  ILOZ    (input) INTEGER
;;*  IHIZ    (input) INTEGER
;;*          Specify the rows of Z to which transformations must be
;;*          applied if WANTZ is .TRUE..
;;*          1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          If WANTZ is .TRUE., on entry Z must contain the current
;;*          matrix Z of transformations accumulated by ZHSEQR, and on
;;*          exit Z has been updated; transformations are applied only to
;;*          the submatrix Z(ILOZ:IHIZ,ILO:IHI).
;;*          If WANTZ is .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = i, ZLAHQR failed to compute all the
;;*               eigenvalues ILO to IHI in a total of 30*(IHI-ILO+1)
;;*               iterations; elements i+1:ihi of W contain those
;;*               eigenvalues which have been successfully computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlahqr (wantt  wantz  n  ilo  ihi  h  ldh  w  iloz  ihiz  z  ldz  info  )
	((-idx0- (-int-)) wantt )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) h )
	((-idx0- (-int-)) ldh )
	((-idx2- (-double-)) w )
	((-idx0- (-int-)) iloz )
	((-idx0- (-int-)) ihiz )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) info )
	#{ zlahqr_(IDX_PTR($wantt,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($h,double), IDX_PTR($ldh,int), IDX_PTR($w,double), IDX_PTR($iloz,int), IDX_PTR($ihiz,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlahrd <n>  <k>  <nb>  <a>  <lda>  <tau>  <t_>  <ldt>  <y>  <ldy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAHRD reduces the first NB columns of a complex general n-by-(n-k+1)
;;*  matrix A so that elements below the k-th subdiagonal are zero. The
;;*  reduction is performed by a unitary similarity transformation
;;*  Q' * A * Q. The routine returns the matrices V and T which determine
;;*  Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
;;*
;;*  This is an auxiliary routine called by ZGEHRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  K       (input) INTEGER
;;*          The offset for the reduction. Elements below the k-th
;;*          subdiagonal in the first NB columns are reduced to zero.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to be reduced.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N-K+1)
;;*          On entry, the n-by-(n-k+1) general matrix A.
;;*          On exit, the elements on and above the k-th subdiagonal in
;;*          the first NB columns are overwritten with the corresponding
;;*          elements of the reduced matrix; the elements below the k-th
;;*          subdiagonal, with the array TAU, represent the matrix Q as a
;;*          product of elementary reflectors. The other columns of A are
;;*          unchanged. See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (NB)
;;*          The scalar factors of the elementary reflectors. See Further
;;*          Details.
;;*
;;*  T       (output) COMPLEX*16 array, dimension (LDT,NB)
;;*          The upper triangular matrix T.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T.  LDT >= NB.
;;*
;;*  Y       (output) COMPLEX*16 array, dimension (LDY,NB)
;;*          The n-by-nb matrix Y.
;;*
;;*  LDY     (input) INTEGER
;;*          The leading dimension of the array Y. LDY >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The matrix Q is represented as a product of nb elementary reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
;;*  A(i+k+1:n,i), and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the (n-k+1)-by-nb matrix
;;*  V which is needed, with T and Y, to apply the transformation to the
;;*  unreduced part of the matrix, using an update of the form:
;;*  A := (I - V*T*V') * (A - Y*V').
;;*
;;*  The contents of A on exit are illustrated by the following example
;;*  with n = 7, k = 3 and nb = 2:
;;*
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( a   h   a   a   a )
;;*     ( h   h   a   a   a )
;;*     ( v1  h   a   a   a )
;;*     ( v1  v2  a   a   a )
;;*     ( v1  v2  a   a   a )
;;*
;;*  where a denotes an element of the original matrix A, h denotes a
;;*  modified element of the upper Hessenberg matrix H, and vi denotes an
;;*  element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlahrd (n  k  nb  a  lda  tau  t_  ldt  y  ldy  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) nb )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) y )
	((-idx0- (-int-)) ldy )
	#{ zlahrd_(IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($nb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($y,double), IDX_PTR($ldy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaic1 <job>  <j>  <x>  <sest>  <w>  <gamma>  <sestpr>  <s>  <c>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAIC1 applies one step of incremental condition estimation in
;;*  its simplest version:
;;*
;;*  Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
;;*  lower triangular matrix L, such that
;;*           twonorm(L*x) = sest
;;*  Then ZLAIC1 computes sestpr, s, c such that
;;*  the vector
;;*                  [ s*x ]
;;*           xhat = [  c  ]
;;*  is an approximate singular vector of
;;*                  [ L     0  ]
;;*           Lhat = [ w' gamma ]
;;*  in the sense that
;;*           twonorm(Lhat*xhat) = sestpr.
;;*
;;*  Depending on JOB, an estimate for the largest or smallest singular
;;*  value is computed.
;;*
;;*  Note that [s c]' and sestpr**2 is an eigenpair of the system
;;*
;;*      diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
;;*                                            [ conjg(gamma) ]
;;*
;;*  where  alpha =  conjg(x)'*w.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) INTEGER
;;*          = 1: an estimate for the largest singular value is computed.
;;*          = 2: an estimate for the smallest singular value is computed.
;;*
;;*  J       (input) INTEGER
;;*          Length of X and W
;;*
;;*  X       (input) COMPLEX*16 array, dimension (J)
;;*          The j-vector x.
;;*
;;*  SEST    (input) DOUBLE PRECISION
;;*          Estimated singular value of j by j matrix L
;;*
;;*  W       (input) COMPLEX*16 array, dimension (J)
;;*          The j-vector w.
;;*
;;*  GAMMA   (input) COMPLEX*16
;;*          The diagonal element gamma.
;;*
;;*  SESTPR  (output) DOUBLE PRECISION
;;*          Estimated singular value of (j+1) by (j+1) matrix Lhat.
;;*
;;*  S       (output) COMPLEX*16
;;*          Sine needed in forming xhat.
;;*
;;*  C       (output) COMPLEX*16
;;*          Cosine needed in forming xhat.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaic1 (job  j  x  sest  w  gamma  sestpr  s  c  )
	((-idx0- (-int-)) job )
	((-idx0- (-int-)) j )
	((-idx2- (-double-)) x )
	((-idx0- (-double-)) sest )
	((-idx2- (-double-)) w )
	((-idx1- (-double-)) gamma )
	((-idx0- (-double-)) sestpr )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) c )
	#{ zlaic1_(IDX_PTR($job,int), IDX_PTR($j,int), IDX_PTR($x,double), IDX_PTR($sest,double), IDX_PTR($w,double), IDX_PTR($gamma,double), IDX_PTR($sestpr,double), IDX_PTR($s,double), IDX_PTR($c,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlals0 <icompq>  <nl>  <nr>  <sqre>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <perm>  <givptr>  <givcol>  <ldgcol>  <givnum>  <ldgnum>  <poles>  <difl>  <difr>  <z>  <k>  <c>  <s>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLALS0 applies back the multiplying factors of either the left or the
;;*  right singular vector matrix of a diagonal matrix appended by a row
;;*  to the right hand side matrix B in solving the least squares problem
;;*  using the divide-and-conquer SVD approach.
;;*
;;*  For the left singular vector matrix, three types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1L) Givens rotations: the number of such rotations is GIVPTR; the
;;*       pairs of columns/rows they were applied to are stored in GIVCOL;
;;*       and the C- and S-values of these rotations are stored in GIVNUM.
;;*
;;*  (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
;;*       row, and for J=2:N, PERM(J)-th row of B is to be moved to the
;;*       J-th row.
;;*
;;*  (3L) The left singular vector matrix of the remaining matrix.
;;*
;;*  For the right singular vector matrix, four types of orthogonal
;;*  matrices are involved:
;;*
;;*  (1R) The right singular vector matrix of the remaining matrix.
;;*
;;*  (2R) If SQRE = 1, one extra Givens rotation to generate the right
;;*       null space.
;;*
;;*  (3R) The inverse transformation of (2L).
;;*
;;*  (4R) The inverse transformation of (1L).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether singular vectors are to be computed in
;;*         factored form:
;;*         = 0: Left singular vector matrix.
;;*         = 1: Right singular vector matrix.
;;*
;;*  NL     (input) INTEGER
;;*         The row dimension of the upper block. NL >= 1.
;;*
;;*  NR     (input) INTEGER
;;*         The row dimension of the lower block. NR >= 1.
;;*
;;*  SQRE   (input) INTEGER
;;*         = 0: the lower block is an NR-by-NR square matrix.
;;*         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
;;*
;;*         The bidiagonal matrix has row dimension N = NL + NR + 1,
;;*         and column dimension M = N + SQRE.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input/output) COMPLEX*16 array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B. LDB must be at least
;;*         max(1,MAX( M, N ) ).
;;*
;;*  BX     (workspace) COMPLEX*16 array, dimension ( LDBX, NRHS )
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  PERM   (input) INTEGER array, dimension ( N )
;;*         The permutations (from deflation and sorting) applied
;;*         to the two blocks.
;;*
;;*  GIVPTR (input) INTEGER
;;*         The number of Givens rotations which took place in this
;;*         subproblem.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 )
;;*         Each pair of numbers indicates a pair of rows/columns
;;*         involved in a Givens rotation.
;;*
;;*  LDGCOL (input) INTEGER
;;*         The leading dimension of GIVCOL, must be at least N.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         Each number indicates the C or S value used in the
;;*         corresponding Givens rotation.
;;*
;;*  LDGNUM (input) INTEGER
;;*         The leading dimension of arrays DIFR, POLES and
;;*         GIVNUM, must be at least K.
;;*
;;*  POLES  (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
;;*         On entry, POLES(1:K, 1) contains the new singular
;;*         values obtained from solving the secular equation, and
;;*         POLES(1:K, 2) is an array containing the poles in the secular
;;*         equation.
;;*
;;*  DIFL   (input) DOUBLE PRECISION array, dimension ( K ).
;;*         On entry, DIFL(I) is the distance between I-th updated
;;*         (undeflated) singular value and the I-th (undeflated) old
;;*         singular value.
;;*
;;*  DIFR   (input) DOUBLE PRECISION array, dimension ( LDGNUM, 2 ).
;;*         On entry, DIFR(I, 1) contains the distances between I-th
;;*         updated (undeflated) singular value and the I+1-th
;;*         (undeflated) old singular value. And DIFR(I, 2) is the
;;*         normalizing factor for the I-th right singular vector.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( K )
;;*         Contain the components of the deflation-adjusted updating row
;;*         vector.
;;*
;;*  K      (input) INTEGER
;;*         Contains the dimension of the non-deflated matrix,
;;*         This is the order of the related secular equation. 1 <= K <=N.
;;*
;;*  C      (input) DOUBLE PRECISION
;;*         C contains garbage if SQRE =0 and the C-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  S      (input) DOUBLE PRECISION
;;*         S contains garbage if SQRE =0 and the S-value of a Givens
;;*         rotation related to the right null space if SQRE = 1.
;;*
;;*  RWORK  (workspace) DOUBLE PRECISION array, dimension
;;*         ( K*(1+NRHS) + 2*NRHS )
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlals0 (icompq  nl  nr  sqre  nrhs  b  ldb  bx  ldbx  perm  givptr  givcol  ldgcol  givnum  ldgnum  poles  difl  difr  z  k  c  s  rwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) nl )
	((-idx0- (-int-)) nr )
	((-idx0- (-int-)) sqre )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx1- (-int-)) perm )
	((-idx0- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-double-)) givnum )
	((-idx0- (-int-)) ldgnum )
	((-idx2- (-double-)) poles )
	((-idx1- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx1- (-double-)) z )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) c )
	((-idx0- (-double-)) s )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zlals0_(IDX_PTR($icompq,int), IDX_PTR($nl,int), IDX_PTR($nr,int), IDX_PTR($sqre,int), IDX_PTR($nrhs,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($bx,double), IDX_PTR($ldbx,int), IDX_PTR($perm,int), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($givnum,double), IDX_PTR($ldgnum,int), IDX_PTR($poles,double), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($z,double), IDX_PTR($k,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlalsa <icompq>  <smlsiz>  <n>  <nrhs>  <b>  <ldb>  <bx>  <ldbx>  <u>  <ldu>  <vt>  <k>  <difl>  <difr>  <z>  <poles>  <givptr>  <givcol>  <ldgcol>  <perm>  <givnum>  <c>  <s>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLALSA is an itermediate step in solving the least squares problem
;;*  by computing the SVD of the coefficient matrix in compact form (The
;;*  singular vectors are computed as products of simple orthorgonal
;;*  matrices.).
;;*
;;*  If ICOMPQ = 0, ZLALSA applies the inverse of the left singular vector
;;*  matrix of an upper bidiagonal matrix to the right hand side; and if
;;*  ICOMPQ = 1, ZLALSA applies the right singular vector matrix to the
;;*  right hand side. The singular vector matrices were generated in
;;*  compact form by ZLALSA.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  ICOMPQ (input) INTEGER
;;*         Specifies whether the left or the right singular vector
;;*         matrix is involved.
;;*         = 0: Left singular vector matrix
;;*         = 1: Right singular vector matrix
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The row and column dimensions of the upper bidiagonal matrix.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B and BX. NRHS must be at least 1.
;;*
;;*  B      (input) COMPLEX*16 array, dimension ( LDB, NRHS )
;;*         On input, B contains the right hand sides of the least
;;*         squares problem in rows 1 through M. On output, B contains
;;*         the solution X in rows 1 through N.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,MAX( M, N ) ).
;;*
;;*  BX     (output) COMPLEX*16 array, dimension ( LDBX, NRHS )
;;*         On exit, the result of applying the left or right singular
;;*         vector matrix to B.
;;*
;;*  LDBX   (input) INTEGER
;;*         The leading dimension of BX.
;;*
;;*  U      (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
;;*         On entry, U contains the left singular vector matrices of all
;;*         subproblems at the bottom level.
;;*
;;*  LDU    (input) INTEGER, LDU = > N.
;;*         The leading dimension of arrays U, VT, DIFL, DIFR,
;;*         POLES, GIVNUM, and Z.
;;*
;;*  VT     (input) DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
;;*         On entry, VT' contains the right singular vector matrices of
;;*         all subproblems at the bottom level.
;;*
;;*  K      (input) INTEGER array, dimension ( N ).
;;*
;;*  DIFL   (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
;;*         where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.
;;*
;;*  DIFR   (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
;;*         distances between singular values on the I-th level and
;;*         singular values on the (I -1)-th level, and DIFR(*, 2 * I)
;;*         record the normalizing factors of the right singular vectors
;;*         matrices of subproblems on I-th level.
;;*
;;*  Z      (input) DOUBLE PRECISION array, dimension ( LDU, NLVL ).
;;*         On entry, Z(1, I) contains the components of the deflation-
;;*         adjusted updating row vector for subproblems on the I-th
;;*         level.
;;*
;;*  POLES  (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
;;*         singular values involved in the secular equations on the I-th
;;*         level.
;;*
;;*  GIVPTR (input) INTEGER array, dimension ( N ).
;;*         On entry, GIVPTR( I ) records the number of Givens
;;*         rotations performed on the I-th problem on the computation
;;*         tree.
;;*
;;*  GIVCOL (input) INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
;;*         On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
;;*         locations of Givens rotations performed on the I-th level on
;;*         the computation tree.
;;*
;;*  LDGCOL (input) INTEGER, LDGCOL = > N.
;;*         The leading dimension of arrays GIVCOL and PERM.
;;*
;;*  PERM   (input) INTEGER array, dimension ( LDGCOL, NLVL ).
;;*         On entry, PERM(*, I) records permutations done on the I-th
;;*         level of the computation tree.
;;*
;;*  GIVNUM (input) DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
;;*         On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
;;*         values of Givens rotations performed on the I-th level on the
;;*         computation tree.
;;*
;;*  C      (input) DOUBLE PRECISION array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         C( I ) contains the C-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  S      (input) DOUBLE PRECISION array, dimension ( N ).
;;*         On entry, if the I-th subproblem is not square,
;;*         S( I ) contains the S-value of a Givens rotation related to
;;*         the right null space of the I-th subproblem.
;;*
;;*  RWORK  (workspace) DOUBLE PRECISION array, dimension at least
;;*         max ( N, (SMLSZ+1)*NRHS*3 ).
;;*
;;*  IWORK  (workspace) INTEGER array.
;;*         The dimension must be at least 3 * N
;;*
;;*  INFO   (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlalsa (icompq  smlsiz  n  nrhs  b  ldb  bx  ldbx  u  ldu  vt  k  difl  difr  z  poles  givptr  givcol  ldgcol  perm  givnum  c  s  rwork  iwork  info  )
	((-idx0- (-int-)) icompq )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) bx )
	((-idx0- (-int-)) ldbx )
	((-idx2- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx2- (-double-)) vt )
	((-idx1- (-int-)) k )
	((-idx2- (-double-)) difl )
	((-idx2- (-double-)) difr )
	((-idx2- (-double-)) z )
	((-idx2- (-double-)) poles )
	((-idx1- (-int-)) givptr )
	((-idx2- (-int-)) givcol )
	((-idx0- (-int-)) ldgcol )
	((-idx2- (-int-)) perm )
	((-idx2- (-double-)) givnum )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zlalsa_(IDX_PTR($icompq,int), IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($bx,double), IDX_PTR($ldbx,int), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($vt,double), IDX_PTR($k,int), IDX_PTR($difl,double), IDX_PTR($difr,double), IDX_PTR($z,double), IDX_PTR($poles,double), IDX_PTR($givptr,int), IDX_PTR($givcol,int), IDX_PTR($ldgcol,int), IDX_PTR($perm,int), IDX_PTR($givnum,double), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlalsd <uplo>  <smlsiz>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <rcond>  <rank>  <work>  <rwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLALSD uses the singular value decomposition of A to solve the least
;;*  squares problem of finding X to minimize the Euclidean norm of each
;;*  column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
;;*  are N-by-NRHS. The solution X overwrites B.
;;*
;;*  The singular values of A smaller than RCOND times the largest
;;*  singular value are treated as zero in solving the least squares
;;*  problem; in this case a minimum norm solution is returned.
;;*  The actual singular values are returned in D in ascending order.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO   (input) CHARACTER*1
;;*         = 'U': D and E define an upper bidiagonal matrix.
;;*         = 'L': D and E define a  lower bidiagonal matrix.
;;*
;;*  SMLSIZ (input) INTEGER
;;*         The maximum size of the subproblems at the bottom of the
;;*         computation tree.
;;*
;;*  N      (input) INTEGER
;;*         The dimension of the  bidiagonal matrix.  N >= 0.
;;*
;;*  NRHS   (input) INTEGER
;;*         The number of columns of B. NRHS must be at least 1.
;;*
;;*  D      (input/output) DOUBLE PRECISION array, dimension (N)
;;*         On entry D contains the main diagonal of the bidiagonal
;;*         matrix. On exit, if INFO = 0, D contains its singular values.
;;*
;;*  E      (input) DOUBLE PRECISION array, dimension (N-1)
;;*         Contains the super-diagonal entries of the bidiagonal matrix.
;;*         On exit, E has been destroyed.
;;*
;;*  B      (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*         On input, B contains the right hand sides of the least
;;*         squares problem. On output, B contains the solution X.
;;*
;;*  LDB    (input) INTEGER
;;*         The leading dimension of B in the calling subprogram.
;;*         LDB must be at least max(1,N).
;;*
;;*  RCOND  (input) DOUBLE PRECISION
;;*         The singular values of A less than or equal to RCOND times
;;*         the largest singular value are treated as zero in solving
;;*         the least squares problem. If RCOND is negative,
;;*         machine precision is used instead.
;;*         For example, if diag(S)*X=B were the least squares problem,
;;*         where diag(S) is a diagonal matrix of singular values, the
;;*         solution would be X(i) = B(i) / S(i) if S(i) is greater than
;;*         RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
;;*         RCOND*max(S).
;;*
;;*  RANK   (output) INTEGER
;;*         The number of singular values of A greater than RCOND times
;;*         the largest singular value.
;;*
;;*  WORK   (workspace) COMPLEX*16 array, dimension at least
;;*         (N * NRHS).
;;*
;;*  RWORK  (workspace) DOUBLE PRECISION array, dimension at least
;;*         (9*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS + (SMLSIZ+1)**2),
;;*         where
;;*         NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
;;*
;;*  IWORK  (workspace) INTEGER array, dimension at least
;;*         (3*N*NLVL + 11*N).
;;*
;;*  INFO   (output) INTEGER
;;*         = 0:  successful exit.
;;*         < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*         > 0:  The algorithm failed to compute an singular value while
;;*               working on the submatrix lying in rows and columns
;;*               INFO/(N+1) through MOD(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Ming Gu and Ren-Cang Li, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlalsd (uplo  smlsiz  n  nrhs  d  e  b  ldb  rcond  rank  work  rwork  iwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) smlsiz )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) rcond )
	((-idx0- (-int-)) rank )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zlalsd_($uplo->data, IDX_PTR($smlsiz,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($rcond,double), IDX_PTR($rank,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlangb <norm>  <n>  <kl>  <ku>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANGB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANGB returns the value
;;*
;;*     ZLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANGB as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANGB is
;;*          set to zero.
;;*
;;*  KL      (input) INTEGER
;;*          The number of sub-diagonals of the matrix A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of super-diagonals of the matrix A.  KU >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The band matrix A, stored in rows 1 to KL+KU+1.  The j-th
;;*          column of A is stored in the j-th column of the array AB as
;;*          follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KL+KU+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlangb (norm  n  kl  ku  ab  ldab  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlangb_($norm->data, IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlange <norm>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANGE  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANGE returns the value
;;*
;;*     ZLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANGE as described
;;*          above.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.  When M = 0,
;;*          ZLANGE is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.  When N = 0,
;;*          ZLANGE is set to zero.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The m by n matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlange (norm  m  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlange_($norm->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlangt <norm>  <n>  <dl>  <d>  <du>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANGT  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANGT returns the value
;;*
;;*     ZLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANGT as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANGT is
;;*          set to zero.
;;*
;;*  DL      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) sub-diagonal elements of A.
;;*
;;*  D       (input) COMPLEX*16 array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  DU      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlangt (norm  n  dl  d  du  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) dl )
	((-idx2- (-double-)) d )
	((-idx2- (-double-)) du )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlangt_($norm->data, IDX_PTR($n,int), IDX_PTR($dl,double), IDX_PTR($d,double), IDX_PTR($du,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlanhb <norm>  <uplo>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANHB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n hermitian band matrix A,  with k super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANHB returns the value
;;*
;;*     ZLANHB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANHB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          band matrix A is supplied.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANHB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals or sub-diagonals of the
;;*          band matrix A.  K >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangle of the hermitian band matrix A,
;;*          stored in the first K+1 rows of AB.  The j-th column of A is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*          Note that the imaginary parts of the diagonal elements need
;;*          not be set and are assumed to be zero.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlanhb (norm  uplo  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlanhb_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlanhe <norm>  <uplo>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANHE  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex hermitian matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANHE returns the value
;;*
;;*     ZLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANHE as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          hermitian matrix A is to be referenced.
;;*          = 'U':  Upper triangular part of A is referenced
;;*          = 'L':  Lower triangular part of A is referenced
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANHE is
;;*          set to zero.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The hermitian matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced. Note that the imaginary parts of the diagonal
;;*          elements need not be set and are assumed to be zero.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlanhe (norm  uplo  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlanhe_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlanhp <norm>  <uplo>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANHP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex hermitian matrix A,  supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANHP returns the value
;;*
;;*     ZLANHP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANHP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          hermitian matrix A is supplied.
;;*          = 'U':  Upper triangular part of A is supplied
;;*          = 'L':  Lower triangular part of A is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANHP is
;;*          set to zero.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          Note that the  imaginary parts of the diagonal elements need
;;*          not be set and are assumed to be zero.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlanhp (norm  uplo  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlanhp_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlanhs <norm>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANHS  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  Hessenberg matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANHS returns the value
;;*
;;*     ZLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANHS as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANHS is
;;*          set to zero.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The n by n upper Hessenberg matrix A; the part of A below the
;;*          first sub-diagonal is not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlanhs (norm  n  a  lda  work  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlanhs_($norm->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlanht <norm>  <n>  <d>  <e>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANHT  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex Hermitian tridiagonal matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANHT returns the value
;;*
;;*     ZLANHT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANHT as described
;;*          above.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANHT is
;;*          set to zero.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The diagonal elements of A.
;;*
;;*  E       (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) sub-diagonal or super-diagonal elements of A.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlanht (norm  n  d  e  )
	((-str-) norm )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlanht_($norm->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlansb <norm>  <uplo>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANSB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n symmetric band matrix A,  with k super-diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANSB returns the value
;;*
;;*     ZLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANSB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          band matrix A is supplied.
;;*          = 'U':  Upper triangular part is supplied
;;*          = 'L':  Lower triangular part is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANSB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals or sub-diagonals of the
;;*          band matrix A.  K >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangle of the symmetric band matrix A,
;;*          stored in the first K+1 rows of AB.  The j-th column of A is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlansb (norm  uplo  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlansb_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlansp <norm>  <uplo>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANSP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex symmetric matrix A,  supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANSP returns the value
;;*
;;*     ZLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANSP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is supplied.
;;*          = 'U':  Upper triangular part of A is supplied
;;*          = 'L':  Lower triangular part of A is supplied
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANSP is
;;*          set to zero.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlansp (norm  uplo  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlansp_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlansy <norm>  <uplo>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANSY  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  complex symmetric matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANSY returns the value
;;*
;;*     ZLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANSY as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is to be referenced.
;;*          = 'U':  Upper triangular part of A is referenced
;;*          = 'L':  Lower triangular part of A is referenced
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANSY is
;;*          set to zero.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
;;*          WORK is not referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlansy (norm  uplo  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlansy_($norm->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlantb <norm>  <uplo>  <diag>  <n>  <k>  <ab>  <ldab>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANTB  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the element of  largest absolute value  of an
;;*  n by n triangular band matrix A,  with ( k + 1 ) diagonals.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANTB returns the value
;;*
;;*     ZLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANTB as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANTB is
;;*          set to zero.
;;*
;;*  K       (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals of the matrix A if UPLO = 'L'.
;;*          K >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first k+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j<=i<=min(n,j+k).
;;*          Note that when DIAG = 'U', the elements of the array AB
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= K+1.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlantb (norm  uplo  diag  n  k  ab  ldab  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlantb_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlantp <norm>  <uplo>  <diag>  <n>  <ap>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANTP  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  triangular matrix A, supplied in packed form.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANTP returns the value
;;*
;;*     ZLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANTP as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.  When N = 0, ZLANTP is
;;*          set to zero.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          Note that when DIAG = 'U', the elements of the array AP
;;*          corresponding to the diagonal elements of the matrix A are
;;*          not referenced, but are assumed to be one.
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlantp (norm  uplo  diag  n  ap  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlantp_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlantr <norm>  <uplo>  <diag>  <m>  <n>  <a>  <lda>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLANTR  returns the value of the one norm,  or the Frobenius norm, or
;;*  the  infinity norm,  or the  element of  largest absolute value  of a
;;*  trapezoidal or triangular matrix A.
;;*
;;*  Description
;;*  ===========
;;*
;;*  ZLANTR returns the value
;;*
;;*     ZLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
;;*              (
;;*              ( norm1(A),         NORM = '1', 'O' or 'o'
;;*              (
;;*              ( normI(A),         NORM = 'I' or 'i'
;;*              (
;;*              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
;;*
;;*  where  norm1  denotes the  one norm of a matrix (maximum column sum),
;;*  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
;;*  normF  denotes the  Frobenius norm of a matrix (square root of sum of
;;*  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies the value to be returned in ZLANTR as described
;;*          above.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower trapezoidal.
;;*          = 'U':  Upper trapezoidal
;;*          = 'L':  Lower trapezoidal
;;*          Note that A is triangular instead of trapezoidal if M = N.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A has unit diagonal.
;;*          = 'N':  Non-unit diagonal
;;*          = 'U':  Unit diagonal
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0, and if
;;*          UPLO = 'U', M <= N.  When M = 0, ZLANTR is set to zero.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0, and if
;;*          UPLO = 'L', N <= M.  When N = 0, ZLANTR is set to zero.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The trapezoidal matrix A (A is triangular if M = N).
;;*          If UPLO = 'U', the leading m by n upper trapezoidal part of
;;*          the array A contains the upper trapezoidal matrix, and the
;;*          strictly lower triangular part of A is not referenced.
;;*          If UPLO = 'L', the leading m by n lower trapezoidal part of
;;*          the array A contains the lower trapezoidal matrix, and the
;;*          strictly upper triangular part of A is not referenced.  Note
;;*          that when DIAG = 'U', the diagonal elements of A are not
;;*          referenced and are assumed to be one.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK),
;;*          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
;;*          referenced.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlantr (norm  uplo  diag  m  n  a  lda  work  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) work )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=zlantr_($norm->data, $uplo->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($work,double)) #} rval))
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlapll <n>  <x>  <incx>  <y>  <incy>  <ssmin>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  Given two column vectors X and Y, let
;;*
;;*                       A = ( X Y ).
;;*
;;*  The subroutine first computes the QR factorization of A = Q*R,
;;*  and then computes the SVD of the 2-by-2 upper triangular matrix R.
;;*  The smaller singular value of R is returned in SSMIN, which is used
;;*  as the measurement of the linear dependency of the vectors X and Y.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The length of the vectors X and Y.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCX)
;;*          On entry, X contains the N-vector X.
;;*          On exit, X is overwritten.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive elements of X. INCX > 0.
;;*
;;*  Y       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCY)
;;*          On entry, Y contains the N-vector Y.
;;*          On exit, Y is overwritten.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive elements of Y. INCY > 0.
;;*
;;*  SSMIN   (output) DOUBLE PRECISION
;;*          The smallest singular value of the N-by-2 matrix A = ( X Y ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlapll (n  x  incx  y  incy  ssmin  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx0- (-double-)) ssmin )
	#{ zlapll_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($ssmin,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlapmt <forwrd>  <m>  <n>  <x>  <ldx>  <k>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAPMT rearranges the columns of the M by N matrix X as specified
;;*  by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
;;*  If FORWRD = .TRUE.,  forward permutation:
;;*
;;*       X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
;;*
;;*  If FORWRD = .FALSE., backward permutation:
;;*
;;*       X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FORWRD  (input) LOGICAL
;;*          = .TRUE., forward permutation
;;*          = .FALSE., backward permutation
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix X. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix X. N >= 0.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,N)
;;*          On entry, the M by N matrix X.
;;*          On exit, X contains the permuted matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X, LDX >= MAX(1,M).
;;*
;;*  K       (input) INTEGER array, dimension (N)
;;*          On entry, K contains the permutation vector.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlapmt (forwrd  m  n  x  ldx  k  )
	((-idx0- (-int-)) forwrd )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-int-)) k )
	#{ zlapmt_(IDX_PTR($forwrd,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($k,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqgb <m>  <n>  <kl>  <ku>  <ab>  <ldab>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQGB equilibrates a general M by N band matrix A with KL
;;*  subdiagonals and KU superdiagonals using the row and scaling factors
;;*  in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  KL      (input) INTEGER
;;*          The number of subdiagonals within the band of A.  KL >= 0.
;;*
;;*  KU      (input) INTEGER
;;*          The number of superdiagonals within the band of A.  KU >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.
;;*          The j-th column of A is stored in the j-th column of the
;;*          array AB as follows:
;;*          AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
;;*
;;*          On exit, the equilibrated matrix, in the same storage format
;;*          as A.  See EQUED for the form of the equilibrated matrix.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDA >= KL+KU+1.
;;*
;;*  R       (output) DOUBLE PRECISION array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (output) DOUBLE PRECISION
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (output) DOUBLE PRECISION
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqgb (m  n  kl  ku  ab  ldab  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqgb_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqge <m>  <n>  <a>  <lda>  <r>  <c>  <rowcnd>  <colcnd>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQGE equilibrates a general M by N matrix A using the row and
;;*  scaling factors in the vectors R and C.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M by N matrix A.
;;*          On exit, the equilibrated matrix.  See EQUED for the form of
;;*          the equilibrated matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(M,1).
;;*
;;*  R       (input) DOUBLE PRECISION array, dimension (M)
;;*          The row scale factors for A.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (N)
;;*          The column scale factors for A.
;;*
;;*  ROWCND  (input) DOUBLE PRECISION
;;*          Ratio of the smallest R(i) to the largest R(i).
;;*
;;*  COLCND  (input) DOUBLE PRECISION
;;*          Ratio of the smallest C(i) to the largest C(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration
;;*          = 'R':  Row equilibration, i.e., A has been premultiplied by
;;*                  diag(R).
;;*          = 'C':  Column equilibration, i.e., A has been postmultiplied
;;*                  by diag(C).
;;*          = 'B':  Both row and column equilibration, i.e., A has been
;;*                  replaced by diag(R) * A * diag(C).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if row or column scaling
;;*  should be done based on the ratio of the row or column scaling
;;*  factors.  If ROWCND < THRESH, row scaling is done, and if
;;*  COLCND < THRESH, column scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if row scaling
;;*  should be done based on the absolute size of the largest matrix
;;*  element.  If AMAX > LARGE or AMAX < SMALL, row scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqge (m  n  a  lda  r  c  rowcnd  colcnd  amax  equed  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) r )
	((-idx1- (-double-)) c )
	((-idx0- (-double-)) rowcnd )
	((-idx0- (-double-)) colcnd )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqge_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($r,double), IDX_PTR($c,double), IDX_PTR($rowcnd,double), IDX_PTR($colcnd,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqhb <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQHB equilibrates a symmetric band matrix A using the scaling
;;*  factors in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqhb (uplo  n  kd  ab  ldab  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqhb_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqhe <uplo>  <n>  <a>  <lda>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQHE equilibrates a Hermitian matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if EQUED = 'Y', the equilibrated matrix:
;;*          diag(S) * A * diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqhe (uplo  n  a  lda  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqhe_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqhp <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQHP equilibrates a Hermitian matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
;;*          the same storage format as A.
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqhp (uplo  n  ap  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqhp_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqp2 <m>  <n>  <offset>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQP2 computes a QR factorization with column pivoting of
;;*  the block A(OFFSET+1:M,1:N).
;;*  The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0.
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of the matrix A that must be pivoted
;;*          but no factorized. OFFSET >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
;;*          the triangular factor obtained; the elements in block
;;*          A(OFFSET+1:M,1:N) below the diagonal, together with the
;;*          array TAU, represent the orthogonal matrix Q as a product of
;;*          elementary reflectors. Block A(1:OFFSET,1:N) has been
;;*          accordingly pivoted, but no factorized.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
;;*          to the front of A*P (a leading column); if JPVT(i) = 0,
;;*          the i-th column of A is a free column.
;;*          On exit, if JPVT(i) = k, then the i-th column of A*P
;;*          was the k-th column of A.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqp2 (m  n  offset  a  lda  jpvt  tau  vn1  vn2  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-double-)) tau )
	((-idx1- (-double-)) vn1 )
	((-idx1- (-double-)) vn2 )
	((-idx2- (-double-)) work )
	#{ zlaqp2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($vn1,double), IDX_PTR($vn2,double), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqps <m>  <n>  <offset>  <nb>  <kb>  <a>  <lda>  <jpvt>  <tau>  <vn1>  <vn2>  <auxv>  <f>  <ldf>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQPS computes a step of QR factorization with column pivoting
;;*  of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
;;*  NB columns from A starting from the row OFFSET+1, and updates all
;;*  of the matrix with Blas-3 xGEMM.
;;*
;;*  In some cases, due to catastrophic cancellations, it cannot
;;*  factorize NB columns.  Hence, the actual number of factorized
;;*  columns is returned in KB.
;;*
;;*  Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A. N >= 0
;;*
;;*  OFFSET  (input) INTEGER
;;*          The number of rows of A that have been factorized in
;;*          previous steps.
;;*
;;*  NB      (input) INTEGER
;;*          The number of columns to factorize.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns actually factorized.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, block A(OFFSET+1:M,1:KB) is the triangular
;;*          factor obtained and block A(1:OFFSET,1:N) has been
;;*          accordingly pivoted, but no factorized.
;;*          The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
;;*          been updated.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  JPVT    (input/output) INTEGER array, dimension (N)
;;*          JPVT(I) = K <==> Column K of the full matrix A has been
;;*          permuted into position I in AP.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (KB)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  VN1     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the partial column norms.
;;*
;;*  VN2     (input/output) DOUBLE PRECISION array, dimension (N)
;;*          The vector with the exact column norms.
;;*
;;*  AUXV    (input/output) COMPLEX*16 array, dimension (NB)
;;*          Auxiliar vector.
;;*
;;*  F       (input/output) COMPLEX*16 array, dimension (LDF,NB)
;;*          Matrix F' = L*Y'*A.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
;;*    X. Sun, Computer Science Dept., Duke University, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqps (m  n  offset  nb  kb  a  lda  jpvt  tau  vn1  vn2  auxv  f  ldf  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) offset )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) jpvt )
	((-idx2- (-double-)) tau )
	((-idx1- (-double-)) vn1 )
	((-idx1- (-double-)) vn2 )
	((-idx2- (-double-)) auxv )
	((-idx3- (-double-)) f )
	((-idx0- (-int-)) ldf )
	#{ zlaqps_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($offset,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($jpvt,int), IDX_PTR($tau,double), IDX_PTR($vn1,double), IDX_PTR($vn2,double), IDX_PTR($auxv,double), IDX_PTR($f,double), IDX_PTR($ldf,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqsb <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQSB equilibrates a symmetric band matrix A using the scaling
;;*  factors in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the symmetric band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqsb (uplo  n  kd  ab  ldab  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqsb_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqsp <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQSP equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
;;*          the same storage format as A.
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqsp (uplo  n  ap  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqsp_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaqsy <uplo>  <n>  <a>  <lda>  <s>  <scond>  <amax>  <equed>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAQSY equilibrates a symmetric matrix A using the scaling factors
;;*  in the vector S.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if EQUED = 'Y', the equilibrated matrix:
;;*          diag(S) * A * diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(N,1).
;;*
;;*  S       (input) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A.
;;*
;;*  SCOND   (input) DOUBLE PRECISION
;;*          Ratio of the smallest S(i) to the largest S(i).
;;*
;;*  AMAX    (input) DOUBLE PRECISION
;;*          Absolute value of largest matrix entry.
;;*
;;*  EQUED   (output) CHARACTER*1
;;*          Specifies whether or not equilibration was done.
;;*          = 'N':  No equilibration.
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  THRESH is a threshold value used to decide if scaling should be done
;;*  based on the ratio of the scaling factors.  If SCOND < THRESH,
;;*  scaling is done.
;;*
;;*  LARGE and SMALL are threshold values used to decide if scaling should
;;*  be done based on the absolute size of the largest matrix element.
;;*  If AMAX > LARGE or AMAX < SMALL, scaling is done.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlaqsy (uplo  n  a  lda  s  scond  amax  equed  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-str-) equed )
	#{ zlaqsy_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), $equed->data) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlar1v <n>  <b1>  <bn>  <sigma>  <d>  <l>  <ld>  <lld>  <gersch>  <z>  <ztz>  <mingma>  <r>  <isuppz>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAR1V computes the (scaled) r-th column of the inverse of
;;*  the sumbmatrix in rows B1 through BN of the tridiagonal matrix
;;*  L D L^T - sigma I. The following steps accomplish this computation :
;;*  (a) Stationary qd transform,  L D L^T - sigma I = L(+) D(+) L(+)^T,
;;*  (b) Progressive qd transform, L D L^T - sigma I = U(-) D(-) U(-)^T,
;;*  (c) Computation of the diagonal elements of the inverse of
;;*      L D L^T - sigma I by combining the above transforms, and choosing
;;*      r as the index where the diagonal of the inverse is (one of the)
;;*      largest in magnitude.
;;*  (d) Computation of the (scaled) r-th column of the inverse using the
;;*      twisted factorization obtained by combining the top part of the
;;*      the stationary and the bottom part of the progressive transform.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N        (input) INTEGER
;;*           The order of the matrix L D L^T.
;;*
;;*  B1       (input) INTEGER
;;*           First index of the submatrix of L D L^T.
;;*
;;*  BN       (input) INTEGER
;;*           Last index of the submatrix of L D L^T.
;;*
;;*  SIGMA    (input) DOUBLE PRECISION
;;*           The shift. Initially, when R = 0, SIGMA should be a good
;;*           approximation to an eigenvalue of L D L^T.
;;*
;;*  L        (input) DOUBLE PRECISION array, dimension (N-1)
;;*           The (n-1) subdiagonal elements of the unit bidiagonal matrix
;;*           L, in elements 1 to N-1.
;;*
;;*  D        (input) DOUBLE PRECISION array, dimension (N)
;;*           The n diagonal elements of the diagonal matrix D.
;;*
;;*  LD       (input) DOUBLE PRECISION array, dimension (N-1)
;;*           The n-1 elements L(i)*D(i).
;;*
;;*  LLD      (input) DOUBLE PRECISION array, dimension (N-1)
;;*           The n-1 elements L(i)*L(i)*D(i).
;;*
;;*  GERSCH   (input) DOUBLE PRECISION array, dimension (2*N)
;;*           The n Gerschgorin intervals. These are used to restrict
;;*           the initial search for R, when R is input as 0.
;;*
;;*  Z        (output) COMPLEX*16 array, dimension (N)
;;*           The (scaled) r-th column of the inverse. Z(R) is returned
;;*           to be 1.
;;*
;;*  ZTZ      (output) DOUBLE PRECISION
;;*           The square of the norm of Z.
;;*
;;*  MINGMA   (output) DOUBLE PRECISION
;;*           The reciprocal of the largest (in magnitude) diagonal
;;*           element of the inverse of L D L^T - sigma I.
;;*
;;*  R        (input/output) INTEGER
;;*           Initially, R should be input to be 0 and is then output as
;;*           the index where the diagonal element of the inverse is
;;*           largest in magnitude. In later iterations, this same value
;;*           of R should be input.
;;*
;;*  ISUPPZ   (output) INTEGER array, dimension (2)
;;*           The support of the vector in Z, i.e., the vector Z is
;;*           nonzero only in elements ISUPPZ(1) through ISUPPZ( 2 ).
;;*
;;*  WORK     (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlar1v (n  b1  bn  sigma  d  l  ld  lld  gersch  z  ztz  mingma  r  isuppz  work  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) b1 )
	((-idx0- (-int-)) bn )
	((-idx0- (-double-)) sigma )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) l )
	((-idx1- (-double-)) ld )
	((-idx1- (-double-)) lld )
	((-idx1- (-double-)) gersch )
	((-idx2- (-double-)) z )
	((-idx0- (-double-)) ztz )
	((-idx0- (-double-)) mingma )
	((-idx0- (-int-)) r )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	#{ zlar1v_(IDX_PTR($n,int), IDX_PTR($b1,int), IDX_PTR($bn,int), IDX_PTR($sigma,double), IDX_PTR($d,double), IDX_PTR($l,double), IDX_PTR($ld,double), IDX_PTR($lld,double), IDX_PTR($gersch,double), IDX_PTR($z,double), IDX_PTR($ztz,double), IDX_PTR($mingma,double), IDX_PTR($r,int), IDX_PTR($isuppz,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlar2v <n>  <x>  <y>  <z>  <incx>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAR2V applies a vector of complex plane rotations with real cosines
;;*  from both sides to a sequence of 2-by-2 complex Hermitian matrices,
;;*  defined by the elements of the vectors x, y and z. For i = 1,2,...,n
;;*
;;*     (       x(i)  z(i) ) :=
;;*     ( conjg(z(i)) y(i) )
;;*
;;*       (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
;;*       ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCX)
;;*          The vector x; the elements of x are assumed to be real.
;;*
;;*  Y       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCX)
;;*          The vector y; the elements of y are assumed to be real.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCX)
;;*          The vector z.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X, Y and Z. INCX > 0.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) COMPLEX*16 array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlar2v (n  x  y  z  incx  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx2- (-double-)) y )
	((-idx2- (-double-)) z )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) c )
	((-idx2- (-double-)) s )
	((-idx0- (-int-)) incc )
	#{ zlar2v_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($y,double), IDX_PTR($z,double), IDX_PTR($incx,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarcm <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <rwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARCM performs a very simple matrix-matrix multiplication:
;;*           C := A * B,
;;*  where A is M by M and real; B is M by N and complex;
;;*  C is M by N and complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A and of the matrix C.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns and rows of the matrix B and
;;*          the number of columns of the matrix C.
;;*          N >= 0.
;;*
;;*  A       (input) DOUBLE PRECISION array, dimension (LDA, M)
;;*          A contains the M by M matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >=max(1,M).
;;*
;;*  B       (input) DOUBLE PRECISION array, dimension (LDB, N)
;;*          B contains the M by N matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >=max(1,M).
;;*
;;*  C       (input) COMPLEX*16 array, dimension (LDC, N)
;;*          C contains the M by N matrix C.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >=max(1,M).
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarcm (m  n  a  lda  b  ldb  c  ldc  rwork  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx1- (-double-)) rwork )
	#{ zlarcm_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($rwork,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarfb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARFB applies a complex block reflector H or its transpose H' to a
;;*  complex M-by-N matrix C, from either the left or the right.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'C': apply H' (Conjugate transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  V       (input) COMPLEX*16 array, dimension
;;*                                (LDV,K) if STOREV = 'C'
;;*                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
;;*                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
;;*          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
;;*          if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) COMPLEX*16 array, dimension (LDT,K)
;;*          The triangular K-by-K matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarfb (side  trans  direct  storev  m  n  k  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-double-)) work )
	((-idx0- (-int-)) ldwork )
	#{ zlarfb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarfg <n>  <alpha>  <x>  <incx>  <tau>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARFG generates a complex elementary reflector H of order n, such
;;*  that
;;*
;;*        H' * ( alpha ) = ( beta ),   H' * H = I.
;;*             (   x   )   (   0  )
;;*
;;*  where alpha and beta are scalars, with beta real, and x is an
;;*  (n-1)-element complex vector. H is represented in the form
;;*
;;*        H = I - tau * ( 1 ) * ( 1 v' ) ,
;;*                      ( v )
;;*
;;*  where tau is a complex scalar and v is a complex (n-1)-element
;;*  vector. Note that H is not hermitian.
;;*
;;*  If the elements of x are all zero and alpha is real, then tau = 0
;;*  and H is taken to be the unit matrix.
;;*
;;*  Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the elementary reflector.
;;*
;;*  ALPHA   (input/output) COMPLEX*16
;;*          On entry, the value alpha.
;;*          On exit, it is overwritten with the value beta.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension
;;*                         (1+(N-2)*abs(INCX))
;;*          On entry, the vector x.
;;*          On exit, it is overwritten with the vector v.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  TAU     (output) COMPLEX*16
;;*          The value tau.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarfg (n  alpha  x  incx  tau  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) alpha )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) tau )
	#{ zlarfg_(IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($tau,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarf <side>  <m>  <n>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARF applies a complex elementary reflector H to a complex M-by-N
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar and v is a complex vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*  To apply H' (the conjugate transpose of H), supply conjg(tau) instead
;;*  tau.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) COMPLEX*16 array, dimension
;;*                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of H. V is not used if
;;*          TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) COMPLEX*16
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarf (side  m  n  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) incv )
	((-idx1- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	#{ zlarf_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($incv,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarft <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARFT forms the triangular factor T of a complex block reflector H
;;*  of order n, which is defined as a product of k elementary reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) COMPLEX*16 array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) COMPLEX*16 array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
;;*                   ( v1  1    )                     (     1 v2 v2 v2 )
;;*                   ( v1 v2  1 )                     (        1 v3 v3 )
;;*                   ( v1 v2 v3 )
;;*                   ( v1 v2 v3 )
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
;;*                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
;;*                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
;;*                   (     1 v3 )
;;*                   (        1 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarft (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ zlarft_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($tau,double), IDX_PTR($t_,double), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarfx <side>  <m>  <n>  <v>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARFX applies a complex elementary reflector H to a complex m by n
;;*  matrix C, from either the left or the right. H is represented in the
;;*  form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar and v is a complex vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix
;;*
;;*  This version uses inline code if H has order < 11.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) COMPLEX*16 array, dimension (M) if SIDE = 'L'
;;*                                        or (N) if SIDE = 'R'
;;*          The vector v in the representation of H.
;;*
;;*  TAU     (input) COMPLEX*16
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the m by n matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDA >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N) if SIDE = 'L'
;;*                                            or (M) if SIDE = 'R'
;;*          WORK is not referenced if H has order < 11.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarfx (side  m  n  v  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) v )
	((-idx1- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	#{ zlarfx_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlargv <n>  <x>  <incx>  <y>  <incy>  <c>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARGV generates a vector of complex plane rotations with real
;;*  cosines, determined by elements of the complex vectors x and y.
;;*  For i = 1,2,...,n
;;*
;;*     (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
;;*     ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )
;;*
;;*     where c(i)**2 + ABS(s(i))**2 = 1
;;*
;;*  The following conventions are used (these are the same as in ZLARTG,
;;*  but differ from the BLAS1 routine ZROTG):
;;*     If y(i)=0, then c(i)=1 and s(i)=0.
;;*     If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be generated.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCX)
;;*          On entry, the vector x.
;;*          On exit, x(i) is overwritten by r(i), for i = 1,...,n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCY)
;;*          On entry, the vector y.
;;*          On exit, the sines of the plane rotations.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (output) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C. INCC > 0.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  6-6-96 - Modified with a new algorithm by W. Kahan and J. Demmel
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlargv (n  x  incx  y  incy  c  incc  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-double-)) c )
	((-idx0- (-int-)) incc )
	#{ zlargv_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarnv <idist>  <iseed>  <n>  <x>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARNV returns a vector of n random complex numbers from a uniform or
;;*  normal distribution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IDIST   (input) INTEGER
;;*          Specifies the distribution of the random numbers:
;;*          = 1:  real and imaginary parts each uniform (0,1)
;;*          = 2:  real and imaginary parts each uniform (-1,1)
;;*          = 3:  real and imaginary parts each normal (0,1)
;;*          = 4:  uniformly distributed on the disc abs(z) < 1
;;*          = 5:  uniformly distributed on the circle abs(z) = 1
;;*
;;*  ISEED   (input/output) INTEGER array, dimension (4)
;;*          On entry, the seed of the random number generator; the array
;;*          elements must be between 0 and 4095, and ISEED(4) must be
;;*          odd.
;;*          On exit, the seed is updated.
;;*
;;*  N       (input) INTEGER
;;*          The number of random numbers to be generated.
;;*
;;*  X       (output) COMPLEX*16 array, dimension (N)
;;*          The generated random numbers.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  This routine calls the auxiliary routine DLARUV to generate random
;;*  real numbers from a uniform (0,1) distribution, in batches of up to
;;*  128 using vectorisable code. The Box-Muller method is used to
;;*  transform numbers from a uniform to a normal distribution.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarnv (idist  iseed  n  x  )
	((-idx0- (-int-)) idist )
	((-idx1- (-int-)) iseed )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	#{ zlarnv_(IDX_PTR($idist,int), IDX_PTR($iseed,int), IDX_PTR($n,int), IDX_PTR($x,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarrv <n>  <d>  <l>  <isplit>  <m>  <w>  <iblock>  <gersch>  <tol>  <z>  <ldz>  <isuppz>  <work>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARRV computes the eigenvectors of the tridiagonal matrix
;;*  T = L D L^T given L, D and the eigenvalues of L D L^T.
;;*  The input eigenvalues should have high relative accuracy with
;;*  respect to the entries of L and D. The desired accuracy of the
;;*  output can be specified by the input parameter TOL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the diagonal matrix D.
;;*          On exit, D may be overwritten.
;;*
;;*  L       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the unit
;;*          bidiagonal matrix L in elements 1 to N-1 of L. L(N) need
;;*          not be set. On exit, L is overwritten.
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*
;;*  TOL     (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors.
;;*          Errors in the input eigenvalues must be bounded by TOL.
;;*          The eigenvectors output have residual norms
;;*          bounded by TOL, and the dot products between different
;;*          eigenvectors are bounded by TOL. TOL must be at least
;;*          N*EPS*|T|, where EPS is the machine precision and |T| is
;;*          the 1-norm of the tridiagonal matrix.
;;*
;;*  M       (input) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (input) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block ( The output array
;;*          W from DLARRE is expected here ).
;;*          Errors in W must be bounded by TOL (see above).
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (13*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (6*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in DLARRB
;;*                if INFO = 2, internal error in ZSTEIN
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarrv (n  d  l  isplit  m  w  iblock  gersch  tol  z  ldz  isuppz  work  iwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) l )
	((-idx1- (-int-)) isplit )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-double-)) gersch )
	((-idx0- (-double-)) tol )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ zlarrv_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($l,double), IDX_PTR($isplit,int), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($iblock,int), IDX_PTR($gersch,double), IDX_PTR($tol,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlartg <f>  <g>  <cs>  <sn>  <r>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARTG generates a plane rotation so that
;;*
;;*     [  CS  SN  ]     [ F ]     [ R ]
;;*     [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
;;*     [ -SN  CS  ]     [ G ]     [ 0 ]
;;*
;;*  This is a faster version of the BLAS1 routine ZROTG, except for
;;*  the following differences:
;;*     F and G are unchanged on return.
;;*     If G=0, then CS=1 and SN=0.
;;*     If F=0, then CS=0 and SN is chosen so that R is real.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  F       (input) COMPLEX*16
;;*          The first component of vector to be rotated.
;;*
;;*  G       (input) COMPLEX*16
;;*          The second component of vector to be rotated.
;;*
;;*  CS      (output) DOUBLE PRECISION
;;*          The cosine of the rotation.
;;*
;;*  SN      (output) COMPLEX*16
;;*          The sine of the rotation.
;;*
;;*  R       (output) COMPLEX*16
;;*          The nonzero component of the rotated vector.
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlartg (f  g  cs  sn  r  )
	((-idx1- (-double-)) f )
	((-idx1- (-double-)) g )
	((-idx0- (-double-)) cs )
	((-idx1- (-double-)) sn )
	((-idx1- (-double-)) r )
	#{ zlartg_(IDX_PTR($f,double), IDX_PTR($g,double), IDX_PTR($cs,double), IDX_PTR($sn,double), IDX_PTR($r,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlartv <n>  <x>  <incx>  <y>  <incy>  <c>  <s>  <incc>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARTV applies a vector of complex plane rotations with real cosines
;;*  to elements of the complex vectors x and y. For i = 1,2,...,n
;;*
;;*     ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
;;*     ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of plane rotations to be applied.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCX)
;;*          The vector x.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between elements of X. INCX > 0.
;;*
;;*  Y       (input/output) COMPLEX*16 array, dimension (1+(N-1)*INCY)
;;*          The vector y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between elements of Y. INCY > 0.
;;*
;;*  C       (input) DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
;;*          The cosines of the plane rotations.
;;*
;;*  S       (input) COMPLEX*16 array, dimension (1+(N-1)*INCC)
;;*          The sines of the plane rotations.
;;*
;;*  INCC    (input) INTEGER
;;*          The increment between elements of C and S. INCC > 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlartv (n  x  incx  y  incy  c  s  incc  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-double-)) c )
	((-idx2- (-double-)) s )
	((-idx0- (-int-)) incc )
	#{ zlartv_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($incc,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarzb <side>  <trans>  <direct>  <storev>  <m>  <n>  <k>  <l>  <v>  <ldv>  <t_>  <ldt>  <c>  <ldc>  <work>  <ldwork>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARZB applies a complex block reflector H or its transpose H**H
;;*  to a complex distributed M-by-N  C from the left or the right.
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply H or H' from the Left
;;*          = 'R': apply H or H' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply H (No transpose)
;;*          = 'C': apply H' (Conjugate transpose)
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Indicates how H is formed from a product of elementary
;;*          reflectors
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Indicates how the vectors which define the elementary
;;*          reflectors are stored:
;;*          = 'C': Columnwise                        (not supported yet)
;;*          = 'R': Rowwise
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  K       (input) INTEGER
;;*          The order of the matrix T (= the number of elementary
;;*          reflectors whose product defines the block reflector).
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix V containing the
;;*          meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) COMPLEX*16 array, dimension (LDV,NV).
;;*          If STOREV = 'C', NV = K; if STOREV = 'R', NV = L.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= L; if STOREV = 'R', LDV >= K.
;;*
;;*  T       (input) COMPLEX*16 array, dimension (LDT,K)
;;*          The triangular K-by-K matrix T in the representation of the
;;*          block reflector.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (LDWORK,K)
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          If SIDE = 'L', LDWORK >= max(1,N);
;;*          if SIDE = 'R', LDWORK >= max(1,M).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarzb (side  trans  direct  storev  m  n  k  l  v  ldv  t_  ldt  c  ldc  work  ldwork  )
	((-str-) side )
	((-str-) trans )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-double-)) work )
	((-idx0- (-int-)) ldwork )
	#{ zlarzb_($side->data, $trans->data, $direct->data, $storev->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($ldwork,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarz <side>  <m>  <n>  <l>  <v>  <incv>  <tau>  <c>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARZ applies a complex elementary reflector H to a complex
;;*  M-by-N matrix C, from either the left or the right. H is represented
;;*  in the form
;;*
;;*        H = I - tau * v * v'
;;*
;;*  where tau is a complex scalar and v is a complex vector.
;;*
;;*  If tau = 0, then H is taken to be the unit matrix.
;;*
;;*  To apply H' (the conjugate transpose of H), supply conjg(tau) instead
;;*  tau.
;;*
;;*  H is a product of k elementary reflectors as returned by ZTZRZF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form  H * C
;;*          = 'R': form  C * H
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  L       (input) INTEGER
;;*          The number of entries of the vector V containing
;;*          the meaningful part of the Householder vectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  V       (input) COMPLEX*16 array, dimension (1+(L-1)*abs(INCV))
;;*          The vector v in the representation of H as returned by
;;*          ZTZRZF. V is not used if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0.
;;*
;;*  TAU     (input) COMPLEX*16
;;*          The value tau in the representation of H.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
;;*          or C * H if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                         (N) if SIDE = 'L'
;;*                      or (M) if SIDE = 'R'
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarz (side  m  n  l  v  incv  tau  c  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) incv )
	((-idx1- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	#{ zlarz_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($v,double), IDX_PTR($incv,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlarzt <direct>  <storev>  <n>  <k>  <v>  <ldv>  <tau>  <t_>  <ldt>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLARZT forms the triangular factor T of a complex block reflector
;;*  H of order > n, which is defined as a product of k elementary
;;*  reflectors.
;;*
;;*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
;;*
;;*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
;;*
;;*  If STOREV = 'C', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th column of the array V, and
;;*
;;*     H  =  I - V * T * V'
;;*
;;*  If STOREV = 'R', the vector which defines the elementary reflector
;;*  H(i) is stored in the i-th row of the array V, and
;;*
;;*     H  =  I - V' * T * V
;;*
;;*  Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies the order in which the elementary reflectors are
;;*          multiplied to form the block reflector:
;;*          = 'F': H = H(1) H(2) . . . H(k) (Forward, not supported yet)
;;*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
;;*
;;*  STOREV  (input) CHARACTER*1
;;*          Specifies how the vectors which define the elementary
;;*          reflectors are stored (see also Further Details):
;;*          = 'C': columnwise                        (not supported yet)
;;*          = 'R': rowwise
;;*
;;*  N       (input) INTEGER
;;*          The order of the block reflector H. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The order of the triangular factor T (= the number of
;;*          elementary reflectors). K >= 1.
;;*
;;*  V       (input/output) COMPLEX*16 array, dimension
;;*                               (LDV,K) if STOREV = 'C'
;;*                               (LDV,N) if STOREV = 'R'
;;*          The matrix V. See further details.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V.
;;*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i).
;;*
;;*  T       (output) COMPLEX*16 array, dimension (LDT,K)
;;*          The k by k triangular factor T of the block reflector.
;;*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
;;*          lower triangular. The rest of the array is not used.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= K.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The shape of the matrix V and the storage of the vectors which define
;;*  the H(i) is best illustrated by the following example with n = 5 and
;;*  k = 3. The elements equal to 1 are not stored; the corresponding
;;*  array elements are modified but restored on exit. The rest of the
;;*  array is not used.
;;*
;;*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
;;*
;;*                                              ______V_____
;;*         ( v1 v2 v3 )                        /            \
;;*         ( v1 v2 v3 )                      ( v1 v1 v1 v1 v1 . . . . 1 )
;;*     V = ( v1 v2 v3 )                      ( v2 v2 v2 v2 v2 . . . 1   )
;;*         ( v1 v2 v3 )                      ( v3 v3 v3 v3 v3 . . 1     )
;;*         ( v1 v2 v3 )
;;*            .  .  .
;;*            .  .  .
;;*            1  .  .
;;*               1  .
;;*                  1
;;*
;;*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
;;*
;;*                                                        ______V_____
;;*            1                                          /            \
;;*            .  1                           ( 1 . . . . v1 v1 v1 v1 v1 )
;;*            .  .  1                        ( . 1 . . . v2 v2 v2 v2 v2 )
;;*            .  .  .                        ( . . 1 . . v3 v3 v3 v3 v3 )
;;*            .  .  .
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*     V = ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*         ( v1 v2 v3 )
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlarzt (direct  storev  n  k  v  ldv  tau  t_  ldt  )
	((-str-) direct )
	((-str-) storev )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	#{ zlarzt_($direct->data, $storev->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($tau,double), IDX_PTR($t_,double), IDX_PTR($ldt,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlascl <type>  <kl>  <ku>  <cfrom>  <cto>  <m>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLASCL multiplies the M by N complex matrix A by the real scalar
;;*  CTO/CFROM.  This is done without over/underflow as long as the final
;;*  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
;;*  A may be full, upper triangular, lower triangular, upper Hessenberg,
;;*  or banded.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TYPE    (input) CHARACTER*1
;;*          TYPE indices the storage type of the input matrix.
;;*          = 'G':  A is a full matrix.
;;*          = 'L':  A is a lower triangular matrix.
;;*          = 'U':  A is an upper triangular matrix.
;;*          = 'H':  A is an upper Hessenberg matrix.
;;*          = 'B':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the lower
;;*                  half stored.
;;*          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
;;*                  and upper bandwidth KU and with the only the upper
;;*                  half stored.
;;*          = 'Z':  A is a band matrix with lower bandwidth KL and upper
;;*                  bandwidth KU.
;;*
;;*  KL      (input) INTEGER
;;*          The lower bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  KU      (input) INTEGER
;;*          The upper bandwidth of A.  Referenced only if TYPE = 'B',
;;*          'Q' or 'Z'.
;;*
;;*  CFROM   (input) DOUBLE PRECISION
;;*  CTO     (input) DOUBLE PRECISION
;;*          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
;;*          without over/underflow if the final result CTO*A(I,J)/CFROM
;;*          can be represented without over/underflow.  CFROM must be
;;*          nonzero.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,M)
;;*          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
;;*          storage type.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  INFO    (output) INTEGER
;;*          0  - successful exit
;;*          <0 - if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlascl (type  kl  ku  cfrom  cto  m  n  a  lda  info  )
	((-str-) type )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-double-)) cfrom )
	((-idx0- (-double-)) cto )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ zlascl_($type->data, IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($cfrom,double), IDX_PTR($cto,double), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaset <uplo>  <m>  <n>  <alpha>  <beta>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLASET initializes a 2-D array A to BETA on the diagonal and
;;*  ALPHA on the offdiagonals.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the part of the matrix A to be set.
;;*          = 'U':      Upper triangular part is set. The lower triangle
;;*                      is unchanged.
;;*          = 'L':      Lower triangular part is set. The upper triangle
;;*                      is unchanged.
;;*          Otherwise:  All of the matrix A is set.
;;*
;;*  M       (input) INTEGER
;;*          On entry, M specifies the number of rows of A.
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the number of columns of A.
;;*
;;*  ALPHA   (input) COMPLEX*16
;;*          All the offdiagonal array elements are set to ALPHA.
;;*
;;*  BETA    (input) COMPLEX*16
;;*          All the diagonal array elements are set to BETA.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the m by n matrix A.
;;*          On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j;
;;*                   A(i,i) = BETA , 1 <= i <= min(m,n)
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlaset (uplo  m  n  alpha  beta  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) alpha )
	((-idx1- (-double-)) beta )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ zlaset_($uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlasr <side>  <pivot>  <direct>  <m>  <n>  <c>  <s>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLASR   performs the transformation
;;*
;;*     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )
;;*
;;*     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )
;;*
;;*  where A is an m by n complex matrix and P is an orthogonal matrix,
;;*  consisting of a sequence of plane rotations determined by the
;;*  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
;;*  and z = n when SIDE = 'R' or 'r' ):
;;*
;;*  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then
;;*
;;*     P = P( z - 1 )*...*P( 2 )*P( 1 ),
;;*
;;*  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then
;;*
;;*     P = P( 1 )*P( 2 )*...*P( z - 1 ),
;;*
;;*  where  P( k ) is a plane rotation matrix for the following planes:
;;*
;;*     when  PIVOT = 'V' or 'v'  ( Variable pivot ),
;;*        the plane ( k, k + 1 )
;;*
;;*     when  PIVOT = 'T' or 't'  ( Top pivot ),
;;*        the plane ( 1, k + 1 )
;;*
;;*     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),
;;*        the plane ( k, z )
;;*
;;*  c( k ) and s( k )  must contain the  cosine and sine that define the
;;*  matrix  P( k ).  The two by two plane rotation part of the matrix
;;*  P( k ), R( k ), is assumed to be of the form
;;*
;;*     R( k ) = (  c( k )  s( k ) ).
;;*              ( -s( k )  c( k ) )
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          Specifies whether the plane rotation matrix P is applied to
;;*          A on the left or the right.
;;*          = 'L':  Left, compute A := P*A
;;*          = 'R':  Right, compute A:= A*P'
;;*
;;*  DIRECT  (input) CHARACTER*1
;;*          Specifies whether P is a forward or backward sequence of
;;*          plane rotations.
;;*          = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )
;;*          = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )
;;*
;;*  PIVOT   (input) CHARACTER*1
;;*          Specifies the plane for which P(k) is a plane rotation
;;*          matrix.
;;*          = 'V':  Variable pivot, the plane (k,k+1)
;;*          = 'T':  Top pivot, the plane (1,k+1)
;;*          = 'B':  Bottom pivot, the plane (k,z)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  If m <= 1, an immediate
;;*          return is effected.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  If n <= 1, an
;;*          immediate return is effected.
;;*
;;*  C, S    (input) DOUBLE PRECISION arrays, dimension
;;*                  (M-1) if SIDE = 'L'
;;*                  (N-1) if SIDE = 'R'
;;*          c(k) and s(k) contain the cosine and sine that define the
;;*          matrix P(k).  The two by two plane rotation part of the
;;*          matrix P(k), R(k), is assumed to be of the form
;;*          R( k ) = (  c( k )  s( k ) ).
;;*                   ( -s( k )  c( k ) )
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          The m by n matrix A.  On exit, A is overwritten by P*A if
;;*          SIDE = 'R' or by A*P' if SIDE = 'L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlasr (side  pivot  direct  m  n  c  s  a  lda  )
	((-str-) side )
	((-str-) pivot )
	((-str-) direct )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) c )
	((-idx1- (-double-)) s )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ zlasr_($side->data, $pivot->data, $direct->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($c,double), IDX_PTR($s,double), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlassq <n>  <x>  <incx>  <scale>  <sumsq>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLASSQ returns the values scl and ssq such that
;;*
;;*     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
;;*
;;*  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
;;*  assumed to be at least unity and the value of ssq will then satisfy
;;*
;;*     1.0 .le. ssq .le. ( sumsq + 2*n ).
;;*
;;*  scale is assumed to be non-negative and scl returns the value
;;*
;;*     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
;;*            i
;;*
;;*  scale and sumsq must be supplied in SCALE and SUMSQ respectively.
;;*  SCALE and SUMSQ are overwritten by scl and ssq respectively.
;;*
;;*  The routine makes only one pass through the vector X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements to be used from the vector X.
;;*
;;*  X       (input) COMPLEX*16 array, dimension (N)
;;*          The vector x as described above.
;;*             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of the vector X.
;;*          INCX > 0.
;;*
;;*  SCALE   (input/output) DOUBLE PRECISION
;;*          On entry, the value  scale  in the equation above.
;;*          On exit, SCALE is overwritten with the value  scl .
;;*
;;*  SUMSQ   (input/output) DOUBLE PRECISION
;;*          On entry, the value  sumsq  in the equation above.
;;*          On exit, SUMSQ is overwritten with the value  ssq .
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlassq (n  x  incx  scale  sumsq  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) sumsq )
	#{ zlassq_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($scale,double), IDX_PTR($sumsq,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlaswp <n>  <a>  <lda>  <k1>  <k2>  <ipiv>  <incx>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLASWP performs a series of row interchanges on the matrix A.
;;*  One row interchange is initiated for each of rows K1 through K2 of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the matrix of column dimension N to which the row
;;*          interchanges will be applied.
;;*          On exit, the permuted matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*
;;*  K1      (input) INTEGER
;;*          The first element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  K2      (input) INTEGER
;;*          The last element of IPIV for which a row interchange will
;;*          be done.
;;*
;;*  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
;;*          The vector of pivot indices.  Only the elements in positions
;;*          K1 through K2 of IPIV are accessed.
;;*          IPIV(K) = L implies rows K and L are to be interchanged.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of IPIV.  If IPIV
;;*          is negative, the pivots are applied in reverse order.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Modified by
;;*   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zlaswp (n  a  lda  k1  k2  ipiv  incx  )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) k1 )
	((-idx0- (-int-)) k2 )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) incx )
	#{ zlaswp_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($k1,int), IDX_PTR($k2,int), IDX_PTR($ipiv,int), IDX_PTR($incx,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlasyf <uplo>  <n>  <nb>  <kb>  <a>  <lda>  <ipiv>  <w>  <ldw>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLASYF computes a partial factorization of a complex symmetric matrix
;;*  A using the Bunch-Kaufman diagonal pivoting method. The partial
;;*  factorization has the form:
;;*
;;*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or:
;;*        ( 0  U22 ) (  0   D  ) ( U12' U22' )
;;*
;;*  A  =  ( L11  0 ) ( D    0  ) ( L11' L21' )  if UPLO = 'L'
;;*        ( L21  I ) ( 0   A22 ) (  0    I   )
;;*
;;*  where the order of D is at most NB. The actual order is returned in
;;*  the argument KB, and is either NB or NB-1, or N if N <= NB.
;;*  Note that U' denotes the transpose of U.
;;*
;;*  ZLASYF is an auxiliary routine called by ZSYTRF. It uses blocked code
;;*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
;;*  A22 (if UPLO = 'L').
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NB      (input) INTEGER
;;*          The maximum number of columns of the matrix A that should be
;;*          factored.  NB should be at least 2 to allow for 2-by-2 pivot
;;*          blocks.
;;*
;;*  KB      (output) INTEGER
;;*          The number of columns of A that were actually factored.
;;*          KB is either NB-1 or NB, or N if N <= NB.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit, A contains details of the partial factorization.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If UPLO = 'U', only the last KB elements of IPIV are set;
;;*          if UPLO = 'L', only the first KB elements are set.
;;*
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  W       (workspace) COMPLEX*16 array, dimension (LDW,NB)
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W.  LDW >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlasyf (uplo  n  nb  kb  a  lda  ipiv  w  ldw  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx0- (-int-)) kb )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) w )
	((-idx0- (-int-)) ldw )
	((-idx0- (-int-)) info )
	#{ zlasyf_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($kb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($w,double), IDX_PTR($ldw,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatbs <uplo>  <trans>  <diag>  <normin>  <n>  <kd>  <ab>  <ldab>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLATBS solves one of the triangular systems
;;*
;;*     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular band matrix.  Here A' denotes the transpose of A, x and b
;;*  are n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine ZTBSV is called.  If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b     (No transpose)
;;*          = 'T':  Solve A**T * x = s*b  (Transpose)
;;*          = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of subdiagonals or superdiagonals in the
;;*          triangular matrix A.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first KD+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) DOUBLE PRECISION array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, ZTBSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine ZTBSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A**T *x = b  or
;;*  A**H *x = b.  The basic algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call ZTBSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatbs (uplo  trans  diag  normin  n  kd  ab  ldab  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx2- (-double-)) x )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) cnorm )
	((-idx0- (-int-)) info )
	#{ zlatbs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($x,double), IDX_PTR($scale,double), IDX_PTR($cnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatdf <ijob>  <n>  <z>  <ldz>  <rhs>  <rdsum>  <rdscal>  <ipiv>  <jpiv>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLATDF computes the contribution to the reciprocal Dif-estimate
;;*  by solving for x in Z * x = b, where b is chosen such that the norm
;;*  of x is as large as possible. It is assumed that LU decomposition
;;*  of Z has been computed by ZGETC2. On entry RHS = f holds the
;;*  contribution from earlier solved sub-systems, and on return RHS = x.
;;*
;;*  The factorization of Z returned by ZGETC2 has the form
;;*  Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
;;*  triangular with unit diagonal elements and U is upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) INTEGER
;;*          IJOB = 2: First compute an approximative null-vector e
;;*              of Z using ZGECON, e is normalized and solve for
;;*              Zx = +-e - f with the sign giving the greater value of
;;*              2-norm(x).  About 5 times as expensive as Default.
;;*          IJOB .ne. 2: Local look ahead strategy where
;;*              all entries of the r.h.s. b is choosen as either +1 or
;;*              -1.  Default.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Z.
;;*
;;*  Z       (input) DOUBLE PRECISION array, dimension (LDZ, N)
;;*          On entry, the LU part of the factorization of the n-by-n
;;*          matrix Z computed by ZGETC2:  Z = P * L * U * Q
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDA >= max(1, N).
;;*
;;*  RHS     (input/output) DOUBLE PRECISION array, dimension (N).
;;*          On entry, RHS contains contributions from other subsystems.
;;*          On exit, RHS contains the solution of the subsystem with
;;*          entries according to the value of IJOB (see above).
;;*
;;*  RDSUM   (input/output) DOUBLE PRECISION
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by ZTGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when ZTGSY2 is called by CTGSYL.
;;*
;;*  RDSCAL  (input/output) DOUBLE PRECISION
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when ZTGSY2 is called by
;;*          ZTGSYL.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= i <= N, row i of the
;;*          matrix has been interchanged with row IPIV(i).
;;*
;;*  JPIV    (input) INTEGER array, dimension (N).
;;*          The pivot indices; for 1 <= j <= N, column j of the
;;*          matrix has been interchanged with column JPIV(j).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  This routine is a further developed implementation of algorithm
;;*  BSOLVE in [1] using complete pivoting in the LU factorization.
;;*
;;*   [1]   Bo Kagstrom and Lars Westin,
;;*         Generalized Schur Methods with Condition Estimators for
;;*         Solving the Generalized Sylvester Equation, IEEE Transactions
;;*         on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751.
;;*
;;*   [2]   Peter Poromaa,
;;*         On Efficient and Robust Estimators for the Separation
;;*         between two Regular Matrix Pairs with Applications in
;;*         Condition Estimation. Report UMINF-95.05, Department of
;;*         Computing Science, Umea University, S-901 87 Umea, Sweden,
;;*         1995.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatdf (ijob  n  z  ldz  rhs  rdsum  rdscal  ipiv  jpiv  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) rhs )
	((-idx0- (-double-)) rdsum )
	((-idx0- (-double-)) rdscal )
	((-idx1- (-int-)) ipiv )
	((-idx1- (-int-)) jpiv )
	#{ zlatdf_(IDX_PTR($ijob,int), IDX_PTR($n,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($rhs,double), IDX_PTR($rdsum,double), IDX_PTR($rdscal,double), IDX_PTR($ipiv,int), IDX_PTR($jpiv,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatps <uplo>  <trans>  <diag>  <normin>  <n>  <ap>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLATPS solves one of the triangular systems
;;*
;;*     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
;;*
;;*  with scaling to prevent overflow, where A is an upper or lower
;;*  triangular matrix stored in packed form.  Here A**T denotes the
;;*  transpose of A, A**H denotes the conjugate transpose of A, x and b
;;*  are n-element vectors, and s is a scaling factor, usually less than
;;*  or equal to 1, chosen so that the components of x will be less than
;;*  the overflow threshold.  If the unscaled problem will not cause
;;*  overflow, the Level 2 BLAS routine ZTPSV is called. If the matrix A
;;*  is singular (A(j,j) = 0 for some j), then s is set to 0 and a
;;*  non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b     (No transpose)
;;*          = 'T':  Solve A**T * x = s*b  (Transpose)
;;*          = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) DOUBLE PRECISION array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, ZTPSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine ZTPSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A**T *x = b  or
;;*  A**H *x = b.  The basic algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call ZTPSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatps (uplo  trans  diag  normin  n  ap  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) x )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) cnorm )
	((-idx0- (-int-)) info )
	#{ zlatps_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($x,double), IDX_PTR($scale,double), IDX_PTR($cnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatrd <uplo>  <n>  <nb>  <a>  <lda>  <e>  <tau>  <w>  <ldw>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to
;;*  Hermitian tridiagonal form by a unitary similarity
;;*  transformation Q' * A * Q, and returns the matrices V and W which are
;;*  needed to apply the transformation to the unreduced part of A.
;;*
;;*  If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
;;*  matrix, of which the upper triangle is supplied;
;;*  if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
;;*  matrix, of which the lower triangle is supplied.
;;*
;;*  This is an auxiliary routine called by ZHETRD.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U': Upper triangular
;;*          = 'L': Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.
;;*
;;*  NB      (input) INTEGER
;;*          The number of rows and columns to be reduced.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*          On exit:
;;*          if UPLO = 'U', the last NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements above the diagonal
;;*            with the array TAU, represent the unitary matrix Q as a
;;*            product of elementary reflectors;
;;*          if UPLO = 'L', the first NB columns have been reduced to
;;*            tridiagonal form, with the diagonal elements overwriting
;;*            the diagonal elements of A; the elements below the diagonal
;;*            with the array TAU, represent the  unitary matrix Q as a
;;*            product of elementary reflectors.
;;*          See Further Details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  E       (output) DOUBLE PRECISION array, dimension (N-1)
;;*          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
;;*          elements of the last NB columns of the reduced matrix;
;;*          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
;;*          the first NB columns of the reduced matrix.
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (N-1)
;;*          The scalar factors of the elementary reflectors, stored in
;;*          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
;;*          See Further Details.
;;*
;;*  W       (output) COMPLEX*16 array, dimension (LDW,NB)
;;*          The n-by-nb matrix W required to update the unreduced part
;;*          of A.
;;*
;;*  LDW     (input) INTEGER
;;*          The leading dimension of the array W. LDW >= max(1,N).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(n) H(n-1) . . . H(n-nb+1).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
;;*  and tau in TAU(i-1).
;;*
;;*  If UPLO = 'L', the matrix Q is represented as a product of elementary
;;*  reflectors
;;*
;;*     Q = H(1) H(2) . . . H(nb).
;;*
;;*  Each H(i) has the form
;;*
;;*     H(i) = I - tau * v * v'
;;*
;;*  where tau is a complex scalar, and v is a complex vector with
;;*  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
;;*  and tau in TAU(i).
;;*
;;*  The elements of the vectors v together form the n-by-nb matrix V
;;*  which is needed, with W, to apply the transformation to the unreduced
;;*  part of the matrix, using a Hermitian rank-2k update of the form:
;;*  A := A - V*W' - W*V'.
;;*
;;*  The contents of A on exit are illustrated by the following examples
;;*  with n = 5 and nb = 2:
;;*
;;*  if UPLO = 'U':                       if UPLO = 'L':
;;*
;;*    (  a   a   a   v4  v5 )              (  d                  )
;;*    (      a   a   v4  v5 )              (  1   d              )
;;*    (          a   1   v5 )              (  v1  1   a          )
;;*    (              d   1  )              (  v1  v2  a   a      )
;;*    (                  d  )              (  v1  v2  a   a   a  )
;;*
;;*  where d denotes a diagonal element of the reduced matrix, a denotes
;;*  an element of the original matrix that is unchanged, and vi denotes
;;*  an element of the vector defining H(i).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatrd (uplo  n  nb  a  lda  e  tau  w  ldw  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nb )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) e )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) w )
	((-idx0- (-int-)) ldw )
	#{ zlatrd_($uplo->data, IDX_PTR($n,int), IDX_PTR($nb,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($e,double), IDX_PTR($tau,double), IDX_PTR($w,double), IDX_PTR($ldw,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatrs <uplo>  <trans>  <diag>  <normin>  <n>  <a>  <lda>  <x>  <scale>  <cnorm>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLATRS solves one of the triangular systems
;;*
;;*     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
;;*
;;*  with scaling to prevent overflow.  Here A is an upper or lower
;;*  triangular matrix, A**T denotes the transpose of A, A**H denotes the
;;*  conjugate transpose of A, x and b are n-element vectors, and s is a
;;*  scaling factor, usually less than or equal to 1, chosen so that the
;;*  components of x will be less than the overflow threshold.  If the
;;*  unscaled problem will not cause overflow, the Level 2 BLAS routine
;;*  ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
;;*  then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the operation applied to A.
;;*          = 'N':  Solve A * x = s*b     (No transpose)
;;*          = 'T':  Solve A**T * x = s*b  (Transpose)
;;*          = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  NORMIN  (input) CHARACTER*1
;;*          Specifies whether CNORM has been set or not.
;;*          = 'Y':  CNORM contains the column norms on entry
;;*          = 'N':  CNORM is not set on entry.  On exit, the norms will
;;*                  be computed and stored in CNORM.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading n by n
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading n by n lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max (1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (N)
;;*          On entry, the right hand side b of the triangular system.
;;*          On exit, X is overwritten by the solution vector x.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scaling factor s for the triangular system
;;*             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
;;*          If SCALE = 0, the matrix A is singular or badly scaled, and
;;*          the vector x is an exact or approximate solution to A*x = 0.
;;*
;;*  CNORM   (input or output) DOUBLE PRECISION array, dimension (N)
;;*
;;*          If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
;;*          contains the norm of the off-diagonal part of the j-th column
;;*          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
;;*          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
;;*          must be greater than or equal to the 1-norm.
;;*
;;*          If NORMIN = 'N', CNORM is an output argument and CNORM(j)
;;*          returns the 1-norm of the offdiagonal part of the j-th column
;;*          of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -k, the k-th argument had an illegal value
;;*
;;*  Further Details
;;*  ======= =======
;;*
;;*  A rough bound on x is computed; if that is less than overflow, ZTRSV
;;*  is called, otherwise, specific code is used which checks for possible
;;*  overflow or divide-by-zero at every operation.
;;*
;;*  A columnwise scheme is used for solving A*x = b.  The basic algorithm
;;*  if A is lower triangular is
;;*
;;*       x[1:n] := b[1:n]
;;*       for j = 1, ..., n
;;*            x(j) := x(j) / A(j,j)
;;*            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
;;*       end
;;*
;;*  Define bounds on the components of x after j iterations of the loop:
;;*     M(j) = bound on x[1:j]
;;*     G(j) = bound on x[j+1:n]
;;*  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
;;*
;;*  Then for iteration j+1 we have
;;*     M(j+1) <= G(j) / | A(j+1,j+1) |
;;*     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
;;*            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
;;*
;;*  where CNORM(j+1) is greater than or equal to the infinity-norm of
;;*  column j+1 of A, not counting the diagonal.  Hence
;;*
;;*     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
;;*                  1<=i<=j
;;*  and
;;*
;;*     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
;;*                                   1<=i< j
;;*
;;*  Since |x(j)| <= M(j), we use the Level 2 BLAS routine ZTRSV if the
;;*  reciprocal of the largest M(j), j=1,..,n, is larger than
;;*  max(underflow, 1/overflow).
;;*
;;*  The bound on x(j) is also used to determine when a step in the
;;*  columnwise method can be performed without fear of overflow.  If
;;*  the computed bound is greater than a large constant, x is scaled to
;;*  prevent overflow, but if the bound overflows, x is set to 0, x(j) to
;;*  1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
;;*
;;*  Similarly, a row-wise scheme is used to solve A**T *x = b  or
;;*  A**H *x = b.  The basic algorithm for A upper triangular is
;;*
;;*       for j = 1, ..., n
;;*            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
;;*       end
;;*
;;*  We simultaneously compute two bounds
;;*       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
;;*       M(j) = bound on x(i), 1<=i<=j
;;*
;;*  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
;;*  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
;;*  Then the bound on x(j) is
;;*
;;*       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
;;*
;;*            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
;;*                      1<=i<=j
;;*
;;*  and we can safely call ZTRSV if 1/M(n) and 1/G(n) are both greater
;;*  than max(underflow, 1/overflow).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatrs (uplo  trans  diag  normin  n  a  lda  x  scale  cnorm  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-str-) normin )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) x )
	((-idx0- (-double-)) scale )
	((-idx1- (-double-)) cnorm )
	((-idx0- (-int-)) info )
	#{ zlatrs_($uplo->data, $trans->data, $diag->data, $normin->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($scale,double), IDX_PTR($cnorm,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatrz <m>  <n>  <l>  <a>  <lda>  <tau>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLATRZ factors the M-by-(M+L) complex upper trapezoidal matrix
;;*  [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
;;*  of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
;;*  matrix and, R and A1 are M-by-M upper triangular matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing the
;;*          meaningful part of the Householder vectors. N-M >= L >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements N-L+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          unitary matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (M)
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an l element vector. tau and z( k )
;;*  are chosen to annihilate the elements of the kth row of A2.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A2, such that the elements of z( k ) are
;;*  in  a( k, l + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A1.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatrz (m  n  l  a  lda  tau  work  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	#{ zlatrz_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlatzm <side>  <m>  <n>  <v>  <incv>  <tau>  <c1>  <c2>  <ldc>  <work>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine ZUNMRZ.
;;*
;;*  ZLATZM applies a Householder matrix generated by ZTZRQF to a matrix.
;;*
;;*  Let P = I - tau*u*u',   u = ( 1 ),
;;*                              ( v )
;;*  where v is an (m-1) vector if SIDE = 'L', or a (n-1) vector if
;;*  SIDE = 'R'.
;;*
;;*  If SIDE equals 'L', let
;;*         C = [ C1 ] 1
;;*             [ C2 ] m-1
;;*               n
;;*  Then C is overwritten by P*C.
;;*
;;*  If SIDE equals 'R', let
;;*         C = [ C1, C2 ] m
;;*                1  n-1
;;*  Then C is overwritten by C*P.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': form P * C
;;*          = 'R': form C * P
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C.
;;*
;;*  V       (input) COMPLEX*16 array, dimension
;;*                  (1 + (M-1)*abs(INCV)) if SIDE = 'L'
;;*                  (1 + (N-1)*abs(INCV)) if SIDE = 'R'
;;*          The vector v in the representation of P. V is not used
;;*          if TAU = 0.
;;*
;;*  INCV    (input) INTEGER
;;*          The increment between elements of v. INCV <> 0
;;*
;;*  TAU     (input) COMPLEX*16
;;*          The value tau in the representation of P.
;;*
;;*  C1      (input/output) COMPLEX*16 array, dimension
;;*                         (LDC,N) if SIDE = 'L'
;;*                         (M,1)   if SIDE = 'R'
;;*          On entry, the n-vector C1 if SIDE = 'L', or the m-vector C1
;;*          if SIDE = 'R'.
;;*
;;*          On exit, the first row of P*C if SIDE = 'L', or the first
;;*          column of C*P if SIDE = 'R'.
;;*
;;*  C2      (input/output) COMPLEX*16 array, dimension
;;*                         (LDC, N)   if SIDE = 'L'
;;*                         (LDC, N-1) if SIDE = 'R'
;;*          On entry, the (m - 1) x n matrix C2 if SIDE = 'L', or the
;;*          m x (n - 1) matrix C2 if SIDE = 'R'.
;;*
;;*          On exit, rows 2:m of P*C if SIDE = 'L', or columns 2:m of C*P
;;*          if SIDE = 'R'.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the arrays C1 and C2.
;;*          LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                      (N) if SIDE = 'L'
;;*                      (M) if SIDE = 'R'
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlatzm (side  m  n  v  incv  tau  c1  c2  ldc  work  )
	((-str-) side )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) v )
	((-idx0- (-int-)) incv )
	((-idx1- (-double-)) tau )
	((-idx3- (-double-)) c1 )
	((-idx3- (-double-)) c2 )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	#{ zlatzm_($side->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($v,double), IDX_PTR($incv,int), IDX_PTR($tau,double), IDX_PTR($c1,double), IDX_PTR($c2,double), IDX_PTR($ldc,int), IDX_PTR($work,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlauu2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAUU2 computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the unblocked form of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlauu2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ zlauu2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zlauum <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZLAUUM computes the product U * U' or L' * L, where the triangular
;;*  factor U or L is stored in the upper or lower triangular part of
;;*  the array A.
;;*
;;*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
;;*  overwriting the factor U in A.
;;*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
;;*  overwriting the factor L in A.
;;*
;;*  This is the blocked form of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the triangular factor stored in the array A
;;*          is upper or lower triangular:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the triangular factor U or L.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L.
;;*          On exit, if UPLO = 'U', the upper triangle of A is
;;*          overwritten with the upper triangle of the product U * U';
;;*          if UPLO = 'L', the lower triangle of A is overwritten with
;;*          the lower triangle of the product L' * L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zlauum (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ zlauum_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbcon <uplo>  <n>  <kd>  <ab>  <ldab>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite band matrix using
;;*  the Cholesky factorization A = U**H*U or A = L*L**H computed by
;;*  ZPBTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm (or infinity-norm) of the Hermitian band matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbcon (uplo  n  kd  ab  ldab  anorm  rcond  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zpbcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbequ <uplo>  <n>  <kd>  <ab>  <ldab>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBEQU computes row and column scalings intended to equilibrate a
;;*  Hermitian positive definite band matrix A and reduce its condition
;;*  number (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular of A is stored;
;;*          = 'L':  Lower triangular of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangle of the Hermitian band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB     (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) DOUBLE PRECISION
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbequ (uplo  n  kd  ab  ldab  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ zpbequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbrfs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite
;;*  and banded, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
;;*          The upper or lower triangle of the Hermitian band matrix A,
;;*          stored in the first KD+1 rows of the array.  The j-th column
;;*          of A is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  AFB     (input) COMPLEX*16 array, dimension (LDAFB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H of the band matrix A as computed by
;;*          ZPBTRF, in the same storage format as A (see AB).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZPBTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbrfs (uplo  n  kd  nrhs  ab  ldab  afb  ldafb  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zpbrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbstf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBSTF computes a split Cholesky factorization of a complex
;;*  Hermitian positive definite band matrix A.
;;*
;;*  This routine is designed to be used in conjunction with ZHBGST.
;;*
;;*  The factorization has the form  A = S**H*S  where S is a band matrix
;;*  of the same bandwidth as A and the following structure:
;;*
;;*    S = ( U    )
;;*        ( M  L )
;;*
;;*  where U is upper triangular of order m = (n+kd)/2, and L is lower
;;*  triangular of order n-m.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first kd+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the factor S from the split Cholesky
;;*          factorization A = S**H*S. See Further Details.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the factorization could not be completed,
;;*               because the updated element a(i,i) was negative; the
;;*               matrix A is not positive definite.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 7, KD = 2:
;;*
;;*  S = ( s11  s12  s13                     )
;;*      (      s22  s23  s24                )
;;*      (           s33  s34                )
;;*      (                s44                )
;;*      (           s53  s54  s55           )
;;*      (                s64  s65  s66      )
;;*      (                     s75  s76  s77 )
;;*
;;*  If UPLO = 'U', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*   *    *   a13  a24  a35  a46  a57   *    *   s13  s24  s53' s64' s75'
;;*   *   a12  a23  a34  a45  a56  a67   *   s12  s23  s34  s54' s65' s76'
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*
;;*  If UPLO = 'L', the array AB holds:
;;*
;;*  on entry:                          on exit:
;;*
;;*  a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55  s66  s77
;;*  a21  a32  a43  a54  a65  a76   *   s12' s23' s34' s54  s65  s76   *
;;*  a31  a42  a53  a64  a64   *    *   s13' s24' s53  s64  s75   *    *
;;*
;;*  Array elements marked * are not used by the routine; s12' denotes
;;*  conjg(s12); the diagonal elements of S are real.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbstf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ zpbstf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbsv <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular band matrix, and L is a lower
;;*  triangular band matrix, with the same number of superdiagonals or
;;*  subdiagonals as A.  The factored form of A is then used to solve the
;;*  system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**H*U or A = L*L**H of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de zpbsv (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zpbsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbsvx <fact>  <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <afb>  <ldafb>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
;;*  compute the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite band matrix and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**H * U,  if UPLO = 'U', or
;;*        A = L * L**H,  if UPLO = 'L',
;;*     where U is an upper triangular band matrix, and L is a lower
;;*     triangular band matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFB contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AB and AFB will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFB and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFB and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right-hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array, except
;;*          if FACT = 'F' and EQUED = 'Y', then A must contain the
;;*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A
;;*          is stored in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
;;*          See below for further details.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array A.  LDAB >= KD+1.
;;*
;;*  AFB     (input or output) COMPLEX*16 array, dimension (LDAFB,N)
;;*          If FACT = 'F', then AFB is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the band matrix
;;*          A, in the same storage format as A (see AB).  If EQUED = 'Y',
;;*          then AFB is the factored form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H.
;;*
;;*          If FACT = 'E', then AFB is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAFB   (input) INTEGER
;;*          The leading dimension of the array AFB.  LDAFB >= KD+1.
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11  a12  a13
;;*          a22  a23  a24
;;*               a33  a34  a35
;;*                    a44  a45  a46
;;*                         a55  a56
;;*     (aij=conjg(aji))         a66
;;*
;;*  Band storage of the upper triangle of A:
;;*
;;*      *    *   a13  a24  a35  a46
;;*      *   a12  a23  a34  a45  a56
;;*     a11  a22  a33  a44  a55  a66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*     a11  a22  a33  a44  a55  a66
;;*     a21  a32  a43  a54  a65   *
;;*     a31  a42  a53  a64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbsvx (fact  uplo  n  kd  nrhs  ab  ldab  afb  ldafb  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) afb )
	((-idx0- (-int-)) ldafb )
	((-str-) equed )
	((-idx1- (-double-)) s )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zpbsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($afb,double), IDX_PTR($ldafb,int), $equed->data, IDX_PTR($s,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbtf2 <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBTF2 computes the Cholesky factorization of a complex Hermitian
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix, U' is the conjugate transpose
;;*  of U, and L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of super-diagonals of the matrix A if UPLO = 'U',
;;*          or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U'*U or A = L*L' of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbtf2 (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ zpbtf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbtrf <uplo>  <n>  <kd>  <ab>  <ldab>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBTRF computes the Cholesky factorization of a complex Hermitian
;;*  positive definite band matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L  * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)
;;*          On entry, the upper or lower triangle of the Hermitian band
;;*          matrix A, stored in the first KD+1 rows of the array.  The
;;*          j-th column of A is stored in the j-th column of the array AB
;;*          as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**H*U or A = L*L**H of the band
;;*          matrix A, in the same storage format as A.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The band storage scheme is illustrated by the following example, when
;;*  N = 6, KD = 2, and UPLO = 'U':
;;*
;;*  On entry:                       On exit:
;;*
;;*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
;;*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
;;*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
;;*
;;*  Similarly, if UPLO = 'L' the format of A is as follows:
;;*
;;*  On entry:                       On exit:
;;*
;;*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
;;*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
;;*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
;;*
;;*  Array elements marked * are not used by the routine.
;;*
;;*  Contributed by
;;*  Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpbtrf (uplo  n  kd  ab  ldab  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-int-)) info )
	#{ zpbtrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpbtrs <uplo>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPBTRS solves a system of linear equations A*X = B with a Hermitian
;;*  positive definite band matrix A using the Cholesky factorization
;;*  A = U**H*U or A = L*L**H computed by ZPBTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor stored in AB;
;;*          = 'L':  Lower triangular factor stored in AB.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals of the matrix A if UPLO = 'U',
;;*          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H of the band matrix A, stored in the
;;*          first KD+1 rows of the array.  The j-th column of U or L is
;;*          stored in the j-th column of the array AB as follows:
;;*          if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zpbtrs (uplo  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zpbtrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpocon <uplo>  <n>  <a>  <lda>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite matrix using the
;;*  Cholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by ZPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm (or infinity-norm) of the Hermitian matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpocon (uplo  n  a  lda  anorm  rcond  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zpocon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpoequ <n>  <a>  <lda>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOEQU computes row and column scalings intended to equilibrate a
;;*  Hermitian positive definite matrix A and reduce its condition number
;;*  (with respect to the two-norm).  S contains the scale factors,
;;*  S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
;;*  elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
;;*  choice of S puts the condition number of B within a factor N of the
;;*  smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The N-by-N Hermitian positive definite matrix whose scaling
;;*          factors are to be computed.  Only the diagonal elements of A
;;*          are referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) DOUBLE PRECISION
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpoequ (n  a  lda  s  scond  amax  info  )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ zpoequ_(IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zporfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPORFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite,
;;*  and provides error bounds and backward error estimates for the
;;*  solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The Hermitian matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX*16 array, dimension (LDAF,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by ZPOTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZPOTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zporfs (uplo  n  nrhs  a  lda  af  ldaf  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zporfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zposv <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**H* U,  if UPLO = 'U', or
;;*     A = L * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and  L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de zposv (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zposv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zposvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
;;*  compute the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U**H* U,  if UPLO = 'U', or
;;*        A = L * L**H,  if UPLO = 'L',
;;*     where U is an upper triangular matrix and L is a lower triangular
;;*     matrix.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AF contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  A and AF will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A, except if FACT = 'F' and
;;*          EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AF is the factored form
;;*          of the equilibrated matrix diag(S)*A*diag(S).
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the original
;;*          matrix A.
;;*
;;*          If FACT = 'E', then AF is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the equilibrated
;;*          matrix A (see the description of A for the form of the
;;*          equilibrated matrix).
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS righthand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zposvx (fact  uplo  n  nrhs  a  lda  af  ldaf  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-str-) equed )
	((-idx1- (-double-)) s )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zposvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), $equed->data, IDX_PTR($s,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpotf2 <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOTF2 computes the Cholesky factorization of a complex Hermitian
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U' * U ,  if UPLO = 'U', or
;;*     A = L  * L',  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          Hermitian matrix A is stored.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          n by n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U'*U  or A = L*L'.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite, and the factorization could not be
;;*               completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpotf2 (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ zpotf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpotrf <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOTRF computes the Cholesky factorization of a complex Hermitian
;;*  positive definite matrix A.
;;*
;;*  The factorization has the form
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L  * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  This is the block version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpotrf (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ zpotrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpotri <uplo>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOTRI computes the inverse of a complex Hermitian positive definite
;;*  matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
;;*  computed by ZPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, as computed by
;;*          ZPOTRF.
;;*          On exit, the upper or lower triangle of the (Hermitian)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de zpotri (uplo  n  a  lda  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ zpotri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpotrs <uplo>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPOTRS solves a system of linear equations A*X = B with a Hermitian
;;*  positive definite matrix A using the Cholesky factorization
;;*  A = U**H*U or A = L*L**H computed by ZPOTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by ZPOTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpotrs (uplo  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zpotrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zppcon <uplo>  <n>  <ap>  <anorm>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite packed matrix using
;;*  the Cholesky factorization A = U**H*U or A = L*L**H computed by
;;*  ZPPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm (or infinity-norm) of the Hermitian matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zppcon (uplo  n  ap  anorm  rcond  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zppcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zppequ <uplo>  <n>  <ap>  <s>  <scond>  <amax>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPEQU computes row and column scalings intended to equilibrate a
;;*  Hermitian positive definite matrix A in packed storage and reduce
;;*  its condition number (with respect to the two-norm).  S contains the
;;*  scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
;;*  B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
;;*  This choice of S puts the condition number of B within a factor N of
;;*  the smallest possible condition number over all possible diagonal
;;*  scalings.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (N)
;;*          If INFO = 0, S contains the scale factors for A.
;;*
;;*  SCOND   (output) DOUBLE PRECISION
;;*          If INFO = 0, S contains the ratio of the smallest S(i) to
;;*          the largest S(i).  If SCOND >= 0.1 and AMAX is neither too
;;*          large nor too small, it is not worth scaling by S.
;;*
;;*  AMAX    (output) DOUBLE PRECISION
;;*          Absolute value of largest matrix element.  If AMAX is very
;;*          close to overflow or very close to underflow, the matrix
;;*          should be scaled.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element is nonpositive.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zppequ (uplo  n  ap  s  scond  amax  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-double-)) s )
	((-idx0- (-double-)) scond )
	((-idx0- (-double-)) amax )
	((-idx0- (-int-)) info )
	#{ zppequ_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($s,double), IDX_PTR($scond,double), IDX_PTR($amax,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the Hermitian matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, as computed by DPPTRF/ZPPTRF,
;;*          packed columnwise in a linear array in the same format as A
;;*          (see AP).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZPPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpprfs (uplo  n  nrhs  ap  afp  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) afp )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zpprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zppsv <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  The Cholesky decomposition is used to factor A as
;;*     A = U**H* U,  if UPLO = 'U', or
;;*     A = L * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is a lower triangular
;;*  matrix.  The factored form of A is then used to solve the system of
;;*  equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, in the same storage
;;*          format as A.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i of A is not
;;*                positive definite, so the factorization could not be
;;*                completed, and the solution has not been computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de zppsv (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zppsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zppsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <equed>  <s>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
;;*  compute the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N Hermitian positive definite matrix stored in
;;*  packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'E', real scaling factors are computed to equilibrate
;;*     the system:
;;*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
;;*     Whether or not the system will be equilibrated depends on the
;;*     scaling of the matrix A, but if equilibration is used, A is
;;*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.
;;*
;;*  2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
;;*     factor the matrix A (after equilibration if FACT = 'E') as
;;*        A = U'* U ,  if UPLO = 'U', or
;;*        A = L * L',  if UPLO = 'L',
;;*     where U is an upper triangular matrix, L is a lower triangular
;;*     matrix, and ' indicates conjugate transpose.
;;*
;;*  3. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  4. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  5. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  6. If equilibration was used, the matrix X is premultiplied by
;;*     diag(S) so that it solves the original system before
;;*     equilibration.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix A is
;;*          supplied on entry, and if not, whether the matrix A should be
;;*          equilibrated before it is factored.
;;*          = 'F':  On entry, AFP contains the factored form of A.
;;*                  If EQUED = 'Y', the matrix A has been equilibrated
;;*                  with scaling factors given by S.  AP and AFP will not
;;*                  be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*          = 'E':  The matrix A will be equilibrated if necessary, then
;;*                  copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array, except if FACT = 'F'
;;*          and EQUED = 'Y', then A must contain the equilibrated matrix
;;*          diag(S)*A*diag(S).  The j-th column of A is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.  A is not modified if
;;*          FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.
;;*
;;*          On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
;;*          diag(S)*A*diag(S).
;;*
;;*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, in the same storage
;;*          format as A.  If EQUED .ne. 'N', then AFP is the factored
;;*          form of the equilibrated matrix A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the original
;;*          matrix A.
;;*
;;*          If FACT = 'E', then AFP is an output argument and on exit
;;*          returns the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H of the equilibrated
;;*          matrix A (see the description of AP for the form of the
;;*          equilibrated matrix).
;;*
;;*  EQUED   (input or output) CHARACTER*1
;;*          Specifies the form of equilibration that was done.
;;*          = 'N':  No equilibration (always true if FACT = 'N').
;;*          = 'Y':  Equilibration was done, i.e., A has been replaced by
;;*                  diag(S) * A * diag(S).
;;*          EQUED is an input argument if FACT = 'F'; otherwise, it is an
;;*          output argument.
;;*
;;*  S       (input or output) DOUBLE PRECISION array, dimension (N)
;;*          The scale factors for A; not accessed if EQUED = 'N'.  S is
;;*          an input argument if FACT = 'F'; otherwise, S is an output
;;*          argument.  If FACT = 'F' and EQUED = 'Y', each element of S
;;*          must be positive.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
;;*          B is overwritten by diag(S) * B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
;;*          the original system of equations.  Note that if EQUED = 'Y',
;;*          A and B are modified on exit, and the solution to the
;;*          equilibrated system is inv(diag(S))*X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A after equilibration (if done).  If RCOND is less than the
;;*          machine precision (in particular, if RCOND = 0), the matrix
;;*          is singular to working precision.  This condition is
;;*          indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zppsvx (fact  uplo  n  nrhs  ap  afp  equed  s  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) afp )
	((-str-) equed )
	((-idx1- (-double-)) s )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zppsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), $equed->data, IDX_PTR($s,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpptrf <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPTRF computes the Cholesky factorization of a complex Hermitian
;;*  positive definite matrix A stored in packed format.
;;*
;;*  The factorization has the form
;;*     A = U**H * U,  if UPLO = 'U', or
;;*     A = L  * L**H,  if UPLO = 'L',
;;*  where U is an upper triangular matrix and L is lower triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the Hermitian matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, if INFO = 0, the triangular factor U or L from the
;;*          Cholesky factorization A = U**H*U or A = L*L**H, in the same
;;*          storage format as A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the factorization could not be
;;*                completed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the Hermitian matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = conjg(aji))
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpptrf (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx0- (-int-)) info )
	#{ zpptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpptri <uplo>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPTRI computes the inverse of a complex Hermitian positive definite
;;*  matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
;;*  computed by ZPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangular factor is stored in AP;
;;*          = 'L':  Lower triangular factor is stored in AP.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the triangular factor U or L from the Cholesky
;;*          factorization A = U**H*U or A = L*L**H, packed columnwise as
;;*          a linear array.  The j-th column of U or L is stored in the
;;*          array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*          On exit, the upper or lower triangle of the (Hermitian)
;;*          inverse of A, overwriting the input factor U or L.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
;;*                zero, and the inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpptri (uplo  n  ap  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx0- (-int-)) info )
	#{ zpptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpptrs <uplo>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPPTRS solves a system of linear equations A*X = B with a Hermitian
;;*  positive definite matrix A in packed storage using the Cholesky
;;*  factorization A = U**H*U or A = L*L**H computed by ZPPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The triangular factor U or L from the Cholesky factorization
;;*          A = U**H*U or A = L*L**H, packed columnwise in a linear
;;*          array.  The j-th column of U or L is stored in the array AP
;;*          as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zpptrs (uplo  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zpptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zptcon <n>  <d>  <e>  <anorm>  <rcond>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTCON computes the reciprocal of the condition number (in the
;;*  1-norm) of a complex Hermitian positive definite tridiagonal matrix
;;*  using the factorization A = L*D*L**H or A = U**H*D*U computed by
;;*  ZPTTRF.
;;*
;;*  Norm(inv(A)) is computed by a direct method, and the reciprocal of
;;*  the condition number is computed as
;;*                   RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization of A, as computed by ZPTTRF.
;;*
;;*  E       (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the unit bidiagonal factor
;;*          U or L from the factorization of A, as computed by ZPTTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the
;;*          1-norm of inv(A) computed in this routine.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The method used is described in Nicholas J. Higham, "Efficient
;;*  Algorithms for Computing the Condition Number of a Tridiagonal
;;*  Matrix", SIAM J. Sci. Stat. Comput., Vol. 7, No. 1, January 1986.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zptcon (n  d  e  anorm  rcond  rwork  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zptcon_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric positive definite tridiagonal matrix by first factoring the
;;*  matrix using DPTTRF and then calling ZBDSQR to compute the singular
;;*  values of the bidiagonal factor.
;;*
;;*  This routine computes the eigenvalues of the positive definite
;;*  tridiagonal matrix to high relative accuracy.  This means that if the
;;*  eigenvalues range over many orders of magnitude in size, then the
;;*  small eigenvalues and corresponding eigenvectors will be computed
;;*  more accurately than, for example, with the standard QR method.
;;*
;;*  The eigenvectors of a full or band positive definite Hermitian matrix
;;*  can also be found if ZHETRD, ZHPTRD, or ZHBTRD has been used to
;;*  reduce this matrix to tridiagonal form.  (The reduction to
;;*  tridiagonal form, however, may preclude the possibility of obtaining
;;*  high relative accuracy in the small eigenvalues of the original
;;*  matrix, if these eigenvalues range over many orders of magnitude.)
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvectors of original Hermitian
;;*                  matrix also.  Array Z contains the unitary matrix
;;*                  used to reduce the original matrix to tridiagonal
;;*                  form.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix.
;;*          On normal exit, D contains the eigenvalues, in descending
;;*          order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ, N)
;;*          On entry, if COMPZ = 'V', the unitary matrix used in the
;;*          reduction to tridiagonal form.
;;*          On exit, if COMPZ = 'V', the orthonormal eigenvectors of the
;;*          original Hermitian matrix;
;;*          if COMPZ = 'I', the orthonormal eigenvectors of the
;;*          tridiagonal matrix.
;;*          If INFO > 0 on exit, Z contains the eigenvectors associated
;;*          with only the stored eigenvalues.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          COMPZ = 'V' or 'I', LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  if INFO = i, and i is:
;;*                <= N  the Cholesky factorization of the matrix could
;;*                      not be performed because the i-th principal minor
;;*                      was not positive definite.
;;*                > N   the SVD algorithm failed to converge;
;;*                      if INFO = N+i, i off-diagonal elements of the
;;*                      bidiagonal factor did not converge to zero.
;;*
;;*  ====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zpteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zptrfs <uplo>  <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is Hermitian positive definite
;;*  and tridiagonal, and provides error bounds and backward error
;;*  estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the superdiagonal or the subdiagonal of the
;;*          tridiagonal matrix A is stored and the form of the
;;*          factorization:
;;*          = 'U':  E is the superdiagonal of A, and A = U**H*D*U;
;;*          = 'L':  E is the subdiagonal of A, and A = L*D*L**H.
;;*          (The two forms are equivalent if A is real.)
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n real diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the tridiagonal matrix A
;;*          (see UPLO).
;;*
;;*  DF      (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from
;;*          the factorization computed by ZPTTRF.
;;*
;;*  EF      (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) off-diagonal elements of the unit bidiagonal
;;*          factor U or L from the factorization computed by ZPTTRF
;;*          (see UPLO).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZPTTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zptrfs (uplo  n  nrhs  d  e  df  ef  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx1- (-double-)) df )
	((-idx2- (-double-)) ef )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zptrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($df,double), IDX_PTR($ef,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zptsv <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTSV computes the solution to a complex system of linear equations
;;*  A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
;;*  matrix, and X and B are N-by-NRHS matrices.
;;*
;;*  A is factored as A = L*D*L**H, and the factored form of A is then
;;*  used to solve the system of equations.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the factorization A = L*D*L**H.
;;*
;;*  E       (input/output) COMPLEX*16 array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L**H factorization of
;;*          A.  E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U**H*D*U factorization of A.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the leading minor of order i is not
;;*                positive definite, and the solution has not been
;;*                computed.  The factorization has not been completed
;;*                unless i = N.
;;*
;;*  =====================================================================
;;*
;;*     .. External Subroutines ..
;;*  =====================================================================

(de zptsv (n  nrhs  d  e  b  ldb  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zptsv_(IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zptsvx <fact>  <n>  <nrhs>  <d>  <e>  <df>  <ef>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTSVX uses the factorization A = L*D*L**H to compute the solution
;;*  to a complex system of linear equations A*X = B, where A is an
;;*  N-by-N Hermitian positive definite tridiagonal matrix and X and B
;;*  are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the matrix A is factored as A = L*D*L**H, where L
;;*     is a unit lower bidiagonal matrix and D is diagonal.  The
;;*     factorization can also be regarded as having the form
;;*     A = U**H*D*U.
;;*
;;*  2. If the leading i-by-i principal minor is not positive definite,
;;*     then the routine returns with INFO = i. Otherwise, the factored
;;*     form of A is used to estimate the condition number of the matrix
;;*     A.  If the reciprocal of the condition number is less than machine
;;*     precision, INFO = N+1 is returned as a warning, but the routine
;;*     still goes on to solve for X and compute error bounds as
;;*     described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of the matrix
;;*          A is supplied on entry.
;;*          = 'F':  On entry, DF and EF contain the factored form of A.
;;*                  D, E, DF, and EF will not be modified.
;;*          = 'N':  The matrix A will be copied to DF and EF and
;;*                  factored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix A.
;;*
;;*  E       (input) COMPLEX*16 array, dimension (N-1)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix A.
;;*
;;*  DF      (input or output) DOUBLE PRECISION array, dimension (N)
;;*          If FACT = 'F', then DF is an input argument and on entry
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**H factorization of A.
;;*          If FACT = 'N', then DF is an output argument and on exit
;;*          contains the n diagonal elements of the diagonal matrix D
;;*          from the L*D*L**H factorization of A.
;;*
;;*  EF      (input or output) COMPLEX*16 array, dimension (N-1)
;;*          If FACT = 'F', then EF is an input argument and on entry
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**H factorization of A.
;;*          If FACT = 'N', then EF is an output argument and on exit
;;*          contains the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the L*D*L**H factorization of A.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal condition number of the matrix A.  If RCOND
;;*          is less than the machine precision (in particular, if
;;*          RCOND = 0), the matrix is singular to working precision.
;;*          This condition is indicated by a return code of INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in any
;;*          element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  the leading minor of order i of A is
;;*                       not positive definite, so the factorization
;;*                       could not be completed, and the solution has not
;;*                       been computed. RCOND = 0 is returned.
;;*                = N+1: U is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zptsvx (fact  n  nrhs  d  e  df  ef  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx1- (-double-)) df )
	((-idx2- (-double-)) ef )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zptsvx_($fact->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($df,double), IDX_PTR($ef,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpttrf <n>  <d>  <e>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTTRF computes the L*D*L' factorization of a complex Hermitian
;;*  positive definite tridiagonal matrix A.  The factorization may also
;;*  be regarded as having the form A = U'*D*U.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          A.  On exit, the n diagonal elements of the diagonal matrix
;;*          D from the L*D*L' factorization of A.
;;*
;;*  E       (input/output) COMPLEX*16 array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix A.  On exit, the (n-1) subdiagonal elements of the
;;*          unit bidiagonal factor L from the L*D*L' factorization of A.
;;*          E can also be regarded as the superdiagonal of the unit
;;*          bidiagonal factor U from the U'*D*U factorization of A.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, the leading minor of order k is not
;;*               positive definite; if k < N, the factorization could not
;;*               be completed, while if k = N, the factorization was
;;*               completed, but D(N) = 0.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zpttrf (n  d  e  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx0- (-int-)) info )
	#{ zpttrf_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zpttrs <uplo>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTTRS solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the factorization A = U'*D*U or A = L*D*L' computed by ZPTTRF.
;;*  D is a diagonal matrix specified in the vector D, U (or L) is a unit
;;*  bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
;;*  the vector E, and X and B are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies the form of the factorization and whether the
;;*          vector E is the superdiagonal of the upper bidiagonal factor
;;*          U or the subdiagonal of the lower bidiagonal factor L.
;;*          = 'U':  A = U'*D*U, E is the superdiagonal of U
;;*          = 'L':  A = L*D*L', E is the subdiagonal of L
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization A = U'*D*U or A = L*D*L'.
;;*
;;*  E       (input) COMPLEX*16 array, dimension (N-1)
;;*          If UPLO = 'U', the (n-1) superdiagonal elements of the unit
;;*          bidiagonal factor U from the factorization A = U'*D*U.
;;*          If UPLO = 'L', the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the factorization A = L*D*L'.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zpttrs (uplo  n  nrhs  d  e  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zpttrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zptts2 <iuplo>  <n>  <nrhs>  <d>  <e>  <b>  <ldb>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZPTTS2 solves a tridiagonal system of the form
;;*     A * X = B
;;*  using the factorization A = U'*D*U or A = L*D*L' computed by ZPTTRF.
;;*  D is a diagonal matrix specified in the vector D, U (or L) is a unit
;;*  bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
;;*  the vector E, and X and B are N by NRHS matrices.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IUPLO   (input) INTEGER
;;*          Specifies the form of the factorization and whether the
;;*          vector E is the superdiagonal of the upper bidiagonal factor
;;*          U or the subdiagonal of the lower bidiagonal factor L.
;;*          = 1:  A = U'*D*U, E is the superdiagonal of U
;;*          = 0:  A = L*D*L', E is the subdiagonal of L
;;*
;;*  N       (input) INTEGER
;;*          The order of the tridiagonal matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the diagonal matrix D from the
;;*          factorization A = U'*D*U or A = L*D*L'.
;;*
;;*  E       (input) COMPLEX*16 array, dimension (N-1)
;;*          If IUPLO = 1, the (n-1) superdiagonal elements of the unit
;;*          bidiagonal factor U from the factorization A = U'*D*U.
;;*          If IUPLO = 0, the (n-1) subdiagonal elements of the unit
;;*          bidiagonal factor L from the factorization A = L*D*L'.
;;*
;;*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
;;*          On entry, the right hand side vectors B for the system of
;;*          linear equations.
;;*          On exit, the solution vectors, X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zptts2 (iuplo  n  nrhs  d  e  b  ldb  )
	((-idx0- (-int-)) iuplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx1- (-double-)) d )
	((-idx2- (-double-)) e )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ zptts2_(IDX_PTR($iuplo,int), IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zrot <n>  <cx>  <incx>  <cy>  <incy>  <c>  <s>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZROT   applies a plane rotation, where the cos (C) is real and the
;;*  sin (S) is complex, and the vectors CX and CY are complex.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The number of elements in the vectors CX and CY.
;;*
;;*  CX      (input/output) COMPLEX*16 array, dimension (N)
;;*          On input, the vector X.
;;*          On output, CX is overwritten with C*X + S*Y.
;;*
;;*  INCX    (input) INTEGER
;;*          The increment between successive values of CY.  INCX <> 0.
;;*
;;*  CY      (input/output) COMPLEX*16 array, dimension (N)
;;*          On input, the vector Y.
;;*          On output, CY is overwritten with -CONJG(S)*X + C*Y.
;;*
;;*  INCY    (input) INTEGER
;;*          The increment between successive values of CY.  INCX <> 0.
;;*
;;*  C       (input) DOUBLE PRECISION
;;*  S       (input) COMPLEX*16
;;*          C and S define a rotation
;;*             [  C          S  ]
;;*             [ -conjg(S)   C  ]
;;*          where C*C + S*CONJG(S) = 1.0.
;;*
;;* =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zrot (n  cx  incx  cy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) cy )
	((-idx0- (-int-)) incy )
	((-idx0- (-double-)) c )
	((-idx1- (-double-)) s )
	#{ zrot_(IDX_PTR($n,int), IDX_PTR($cx,double), IDX_PTR($incx,int), IDX_PTR($cy,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($s,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zspcon <uplo>  <n>  <ap>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex symmetric packed matrix A using the
;;*  factorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSPTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zspcon (uplo  n  ap  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zspcon_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zspmv <uplo>  <n>  <alpha>  <ap>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPMV  performs the matrix-vector operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric matrix, supplied in packed form.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX*16
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX*16 array, dimension at least
;;*           ( ( N*( N + 1 ) )/2 ).
;;*           Before entry, with UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on.
;;*           Before entry, with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX*16 array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX*16
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX*16 array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zspmv (uplo  n  alpha  ap  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) alpha )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ zspmv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($ap,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsprfs <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite
;;*  and packed, and provides error bounds and backward error estimates
;;*  for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  AFP     (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The factored form of the matrix A.  AFP contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by ZSPTRF, stored as a packed
;;*          triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSPTRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZSPTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsprfs (uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zsprfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zspr <uplo>  <n>  <alpha>  <x>  <incx>  <ap>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPR    performs the symmetric rank 1 operation
;;*
;;*     A := alpha*x*conjg( x' ) + A,
;;*
;;*  where alpha is a complex scalar, x is an n element vector and A is an
;;*  n by n symmetric matrix, supplied in packed form.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX*16
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX*16 array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX*16 array, dimension at least
;;*           ( ( N*( N + 1 ) )/2 ).
;;*           Before entry, with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the upper triangular part of the
;;*           updated matrix.
;;*           Before entry, with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the lower triangular part of the
;;*           updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set, they are assumed to be zero, and on exit they
;;*           are set to zero.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zspr (uplo  n  alpha  x  incx  ap  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) alpha )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) ap )
	#{ zspr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($ap,double)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zspsv <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix stored in packed format and X
;;*  and B are N-by-NRHS matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, D is symmetric and block diagonal with 1-by-1
;;*  and 2-by-2 diagonal blocks.  The factored form of A is then used to
;;*  solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by ZSPTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, so the solution could not be
;;*                computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de zspsv (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zspsv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zspsvx <fact>  <uplo>  <n>  <nrhs>  <ap>  <afp>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
;;*  A = L*D*L**T to compute the solution to a complex system of linear
;;*  equations A * X = B, where A is an N-by-N symmetric matrix stored
;;*  in packed format and X and B are N-by-NRHS matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A as
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AFP and IPIV contain the factored form
;;*                  of A.  AP, AFP and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AFP and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangle of the symmetric matrix A, packed
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*
;;*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          If FACT = 'F', then AFP is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*          If FACT = 'N', then AFP is an output argument and on exit
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
;;*          a packed triangular matrix in the same storage format as A.
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZSPTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZSPTRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The packed storage scheme is illustrated by the following example
;;*  when N = 4, UPLO = 'U':
;;*
;;*  Two-dimensional storage of the symmetric matrix A:
;;*
;;*     a11 a12 a13 a14
;;*         a22 a23 a24
;;*             a33 a34     (aij = aji)
;;*                 a44
;;*
;;*  Packed storage of the upper triangle of A:
;;*
;;*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zspsvx (fact  uplo  n  nrhs  ap  afp  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) afp )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zspsvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($afp,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsptrf <uplo>  <n>  <ap>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPTRF computes the factorization of a complex symmetric matrix A
;;*  stored in packed format using the Bunch-Kaufman diagonal pivoting
;;*  method:
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangle of the symmetric matrix
;;*          A, packed columnwise in a linear array.  The j-th column of A
;;*          is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L, stored as a packed triangular
;;*          matrix overwriting A (see below for further details).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  5-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsptrf (uplo  n  ap  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zsptrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsptri <uplo>  <n>  <ap>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPTRI computes the inverse of a complex symmetric indefinite matrix
;;*  A in packed storage using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by ZSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by ZSPTRF,
;;*          stored as a packed triangular matrix.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix, stored as a packed triangular matrix. The j-th column
;;*          of inv(A) is stored in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;
;;*          if UPLO = 'L',
;;*             AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSPTRF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsptri (uplo  n  ap  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zsptri_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsptrs <uplo>  <n>  <nrhs>  <ap>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSPTRS solves a system of linear equations A*X = B with a complex
;;*  symmetric matrix A stored in packed format using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZSPTRF, stored as a
;;*          packed triangular matrix.
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSPTRF.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsptrs (uplo  n  nrhs  ap  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zsptrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zstedc <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <lwork>  <rwork>  <lrwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the divide and conquer method.
;;*  The eigenvectors of a full or band complex Hermitian matrix can also
;;*  be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
;;*  matrix to tridiagonal form.
;;*
;;*  This code makes very mild assumptions about floating point
;;*  arithmetic. It will work on machines with a guard digit in
;;*  add/subtract, or on those binary machines without guard digits
;;*  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
;;*  It could conceivably fail on hexadecimal or decimal machines
;;*  without guard digits, but we know of none.  See DLAED3 for details.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'I':  Compute eigenvectors of tridiagonal matrix also.
;;*          = 'V':  Compute eigenvectors of original Hermitian matrix
;;*                  also.  On entry, Z contains the unitary matrix used
;;*                  to reduce the original matrix to tridiagonal form.
;;*
;;*  N       (input) INTEGER
;;*          The dimension of the symmetric tridiagonal matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the subdiagonal elements of the tridiagonal matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          On entry, if COMPZ = 'V', then Z contains the unitary
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original Hermitian matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If  COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1.
;;*          If eigenvectors are desired, then LDZ >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace/output) DOUBLE PRECISION array,
;;*                                         dimension (LRWORK)
;;*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
;;*
;;*  LRWORK  (input) INTEGER
;;*          The dimension of the array RWORK.
;;*          If COMPZ = 'N' or N <= 1, LRWORK must be at least 1.
;;*          If COMPZ = 'V' and N > 1, LRWORK must be at least
;;*                         1 + 3*N + 2*N*lg N + 3*N**2 ,
;;*                         where lg( N ) = smallest integer k such
;;*                         that 2**k >= N.
;;*          If COMPZ = 'I' and N > 1, LRWORK must be at least
;;*                         1 + 4*N + 2*N**2 .
;;*
;;*          If LRWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the RWORK array,
;;*          returns this value as the first entry of the RWORK array, and
;;*          no error message related to LRWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.
;;*          If COMPZ = 'N' or N <= 1, LIWORK must be at least 1.
;;*          If COMPZ = 'V' or N > 1,  LIWORK must be at least
;;*                                    6 + 6*N + 5*N*lg N.
;;*          If COMPZ = 'I' or N > 1,  LIWORK must be at least
;;*                                    3 + 5*N .
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          > 0:  The algorithm failed to compute an eigenvalue while
;;*                working on the submatrix lying in rows and columns
;;*                INFO/(N+1) through mod(INFO,N+1).
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Jeff Rutter, Computer Science Division, University of California
;;*     at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zstedc (compz  n  d  e  z  ldz  work  lwork  rwork  lrwork  iwork  liwork  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) lrwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zstedc_($compz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($lrwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zstegr <jobz>  <range>  <n>  <d>  <e>  <vl>  <vu>  <il>  <iu>  <abstol>  <m>  <w>  <z>  <ldz>  <isuppz>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;* ZSTEGR computes selected eigenvalues and, optionally, eigenvectors
;;* of a real symmetric tridiagonal matrix T.  Eigenvalues and
;;* eigenvectors can be selected by specifying either a range of values
;;* or a range of indices for the desired eigenvalues. The eigenvalues
;;* are computed by the dqds algorithm, while orthogonal eigenvectors are
;;* computed from various ``good'' L D L^T representations (also known as
;;* Relatively Robust Representations). Gram-Schmidt orthogonalization is
;;* avoided as far as possible. More specifically, the various steps of
;;* the algorithm are as follows. For the i-th unreduced block of T,
;;*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
;;*         is a relatively robust representation,
;;*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
;;*         relative accuracy by the dqds algorithm,
;;*     (c) If there is a cluster of close eigenvalues, "choose" sigma_i
;;*         close to the cluster, and go to step (a),
;;*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
;;*         compute the corresponding eigenvector by forming a
;;*         rank-revealing twisted factorization.
;;*  The desired accuracy of the output can be specified by the input
;;*  parameter ABSTOL.
;;*
;;*  For more details, see "A new O(n^2) algorithm for the symmetric
;;*  tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
;;*  Computer Science Division Technical Report No. UCB/CSD-97-971,
;;*  UC Berkeley, May 1997.
;;*
;;*  Note 1 : Currently ZSTEGR is only set up to find ALL the n
;;*  eigenvalues and eigenvectors of T in O(n^2) time
;;*  Note 2 : Currently the routine ZSTEIN is called when an appropriate
;;*  sigma_i cannot be chosen in step (c) above. ZSTEIN invokes modified
;;*  Gram-Schmidt when eigenvalues are close.
;;*  Note 3 : ZSTEGR works only on machines which follow ieee-754
;;*  floating-point standard in their handling of infinities and NaNs.
;;*  Normal execution of ZSTEGR may create NaNs and infinities and hence
;;*  may abort due to a floating point exception in environments which
;;*  do not conform to the ieee standard.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBZ    (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only;
;;*          = 'V':  Compute eigenvalues and eigenvectors.
;;*
;;*  RANGE   (input) CHARACTER*1
;;*          = 'A': all eigenvalues will be found.
;;*          = 'V': all eigenvalues in the half-open interval (VL,VU]
;;*                 will be found.
;;*          = 'I': the IL-th through IU-th eigenvalues will be found.
;;********** Only RANGE = 'A' is currently supported *********************
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the n diagonal elements of the tridiagonal matrix
;;*          T. On exit, D is overwritten.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix T in elements 1 to N-1 of E; E(N) need not be set.
;;*          On exit, E is overwritten.
;;*
;;*  VL      (input) DOUBLE PRECISION
;;*  VU      (input) DOUBLE PRECISION
;;*          If RANGE='V', the lower and upper bounds of the interval to
;;*          be searched for eigenvalues. VL < VU.
;;*          Not referenced if RANGE = 'A' or 'I'.
;;*
;;*  IL      (input) INTEGER
;;*  IU      (input) INTEGER
;;*          If RANGE='I', the indices (in ascending order) of the
;;*          smallest and largest eigenvalues to be returned.
;;*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
;;*          Not referenced if RANGE = 'A' or 'V'.
;;*
;;*  ABSTOL  (input) DOUBLE PRECISION
;;*          The absolute error tolerance for the
;;*          eigenvalues/eigenvectors. IF JOBZ = 'V', the eigenvalues and
;;*          eigenvectors output have residual norms bounded by ABSTOL,
;;*          and the dot products between different eigenvectors are
;;*          bounded by ABSTOL. If ABSTOL is less than N*EPS*|T|, then
;;*          N*EPS*|T| will be used in its place, where EPS is the
;;*          machine precision and |T| is the 1-norm of the tridiagonal
;;*          matrix. The eigenvalues are computed to an accuracy of
;;*          EPS*|T| irrespective of ABSTOL. If high relative accuracy
;;*          is important, set ABSTOL to DLAMCH( 'Safe minimum' ).
;;*          See Barlow and Demmel "Computing Accurate Eigensystems of
;;*          Scaled Diagonally Dominant Matrices", LAPACK Working Note #7
;;*          for a discussion of which matrices define their eigenvalues
;;*          to high relative accuracy.
;;*
;;*  M       (output) INTEGER
;;*          The total number of eigenvalues found.  0 <= M <= N.
;;*          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.
;;*
;;*  W       (output) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements contain the selected eigenvalues in
;;*          ascending order.
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M) )
;;*          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
;;*          contain the orthonormal eigenvectors of the matrix T
;;*          corresponding to the selected eigenvalues, with the i-th
;;*          column of Z holding the eigenvector associated with W(i).
;;*          If JOBZ = 'N', then Z is not referenced.
;;*          Note: the user must ensure that at least max(1,M) columns are
;;*          supplied in the array Z; if RANGE = 'V', the exact value of M
;;*          is not known in advance and an upper bound must be used.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          JOBZ = 'V', LDZ >= max(1,N).
;;*
;;*  ISUPPZ  (output) INTEGER ARRAY, dimension ( 2*max(1,M) )
;;*          The support of the eigenvectors in Z, i.e., the indices
;;*          indicating the nonzero elements in Z. The i-th eigenvector
;;*          is nonzero only in elements ISUPPZ( 2*i-1 ) through
;;*          ISUPPZ( 2*i ).
;;*
;;*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal
;;*          (and minimal) LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,18*N)
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER array, dimension (LIWORK)
;;*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK.  LIWORK >= max(1,10*N)
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = 1, internal error in DLARRE,
;;*                if INFO = 2, internal error in ZLARRV.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Inderjit Dhillon, IBM Almaden, USA
;;*     Osni Marques, LBNL/NERSC, USA
;;*     Ken Stanley, Computer Science Division, University of
;;*       California at Berkeley, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zstegr (jobz  range  n  d  e  vl  vu  il  iu  abstol  m  w  z  ldz  isuppz  work  lwork  iwork  liwork  info  )
	((-str-) jobz )
	((-str-) range )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-double-)) vl )
	((-idx0- (-double-)) vu )
	((-idx0- (-int-)) il )
	((-idx0- (-int-)) iu )
	((-idx0- (-double-)) abstol )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-int-)) isuppz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ zstegr_($jobz->data, $range->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($vl,double), IDX_PTR($vu,double), IDX_PTR($il,int), IDX_PTR($iu,int), IDX_PTR($abstol,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($isuppz,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zstein <n>  <d>  <e>  <m>  <w>  <iblock>  <isplit>  <z>  <ldz>  <work>  <iwork>  <ifail>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSTEIN computes the eigenvectors of a real symmetric tridiagonal
;;*  matrix T corresponding to specified eigenvalues, using inverse
;;*  iteration.
;;*
;;*  The maximum number of iterations allowed for each eigenvector is
;;*  specified by an internal parameter MAXITS (currently set to 5).
;;*
;;*  Although the eigenvectors are real, they are stored in a complex
;;*  array, which may be passed to ZUNMTR or ZUPMTR for back
;;*  transformation to the eigenvectors of a complex Hermitian matrix
;;*  which was reduced to tridiagonal form.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input) DOUBLE PRECISION array, dimension (N)
;;*          The n diagonal elements of the tridiagonal matrix T.
;;*
;;*  E       (input) DOUBLE PRECISION array, dimension (N)
;;*          The (n-1) subdiagonal elements of the tridiagonal matrix
;;*          T, stored in elements 1 to N-1; E(N) need not be set.
;;*
;;*  M       (input) INTEGER
;;*          The number of eigenvectors to be found.  0 <= M <= N.
;;*
;;*  W       (input) DOUBLE PRECISION array, dimension (N)
;;*          The first M elements of W contain the eigenvalues for
;;*          which eigenvectors are to be computed.  The eigenvalues
;;*          should be grouped by split-off block and ordered from
;;*          smallest to largest within the block.  ( The output array
;;*          W from DSTEBZ with ORDER = 'B' is expected here. )
;;*
;;*  IBLOCK  (input) INTEGER array, dimension (N)
;;*          The submatrix indices associated with the corresponding
;;*          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
;;*          the first submatrix from the top, =2 if W(i) belongs to
;;*          the second submatrix, etc.  ( The output array IBLOCK
;;*          from DSTEBZ is expected here. )
;;*
;;*  ISPLIT  (input) INTEGER array, dimension (N)
;;*          The splitting points, at which T breaks up into submatrices.
;;*          The first submatrix consists of rows/columns 1 to
;;*          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
;;*          through ISPLIT( 2 ), etc.
;;*          ( The output array ISPLIT from DSTEBZ is expected here. )
;;*
;;*  Z       (output) COMPLEX*16 array, dimension (LDZ, M)
;;*          The computed eigenvectors.  The eigenvector associated
;;*          with the eigenvalue W(i) is stored in the i-th column of
;;*          Z.  Any vector which fails to converge is set to its current
;;*          iterate after MAXITS iterations.
;;*          The imaginary parts of the eigenvectors are set to zero.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (5*N)
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N)
;;*
;;*  IFAIL   (output) INTEGER array, dimension (M)
;;*          On normal exit, all elements of IFAIL are zero.
;;*          If one or more eigenvectors fail to converge after
;;*          MAXITS iterations, then their indices are stored in
;;*          array IFAIL.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, then i eigenvectors failed to converge
;;*               in MAXITS iterations.  Their indices are stored in
;;*               array IFAIL.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXITS  INTEGER, default = 5
;;*          The maximum number of iterations performed.
;;*
;;*  EXTRA   INTEGER, default = 2
;;*          The number of iterations performed after norm growth
;;*          criterion is satisfied, should be at least 1.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zstein (n  d  e  m  w  iblock  isplit  z  ldz  work  iwork  ifail  info  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx0- (-int-)) m )
	((-idx1- (-double-)) w )
	((-idx1- (-int-)) iblock )
	((-idx1- (-int-)) isplit )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx1- (-int-)) iwork )
	((-idx1- (-int-)) ifail )
	((-idx0- (-int-)) info )
	#{ zstein_(IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($m,int), IDX_PTR($w,double), IDX_PTR($iblock,int), IDX_PTR($isplit,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($iwork,int), IDX_PTR($ifail,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsteqr <compz>  <n>  <d>  <e>  <z>  <ldz>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
;;*  symmetric tridiagonal matrix using the implicit QL or QR method.
;;*  The eigenvectors of a full or band complex Hermitian matrix can also
;;*  be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
;;*  matrix to tridiagonal form.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPZ   (input) CHARACTER*1
;;*          = 'N':  Compute eigenvalues only.
;;*          = 'V':  Compute eigenvalues and eigenvectors of the original
;;*                  Hermitian matrix.  On entry, Z must contain the
;;*                  unitary matrix used to reduce the original matrix
;;*                  to tridiagonal form.
;;*          = 'I':  Compute eigenvalues and eigenvectors of the
;;*                  tridiagonal matrix.  Z is initialized to the identity
;;*                  matrix.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix.  N >= 0.
;;*
;;*  D       (input/output) DOUBLE PRECISION array, dimension (N)
;;*          On entry, the diagonal elements of the tridiagonal matrix.
;;*          On exit, if INFO = 0, the eigenvalues in ascending order.
;;*
;;*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
;;*          On entry, the (n-1) subdiagonal elements of the tridiagonal
;;*          matrix.
;;*          On exit, E has been destroyed.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ, N)
;;*          On entry, if  COMPZ = 'V', then Z contains the unitary
;;*          matrix used in the reduction to tridiagonal form.
;;*          On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
;;*          orthonormal eigenvectors of the original Hermitian matrix,
;;*          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
;;*          of the symmetric tridiagonal matrix.
;;*          If COMPZ = 'N', then Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z.  LDZ >= 1, and if
;;*          eigenvectors are desired, then  LDZ >= max(1,N).
;;*
;;*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))
;;*          If COMPZ = 'N', then WORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  the algorithm has failed to find all the eigenvalues in
;;*                a total of 30*N iterations; if INFO = i, then i
;;*                elements of E have not converged to zero; on exit, D
;;*                and E contain the elements of a symmetric tridiagonal
;;*                matrix which is unitarily similar to the original
;;*                matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsteqr (compz  n  d  e  z  ldz  work  info  )
	((-str-) compz )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) d )
	((-idx1- (-double-)) e )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx1- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zsteqr_($compz->data, IDX_PTR($n,int), IDX_PTR($d,double), IDX_PTR($e,double), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsycon <uplo>  <n>  <a>  <lda>  <ipiv>  <anorm>  <rcond>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYCON estimates the reciprocal of the condition number (in the
;;*  1-norm) of a complex symmetric matrix A using the factorization
;;*  A = U*D*U**T or A = L*D*L**T computed by ZSYTRF.
;;*
;;*  An estimate is obtained for norm(inv(A)), and the reciprocal of the
;;*  condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSYTRF.
;;*
;;*  ANORM   (input) DOUBLE PRECISION
;;*          The 1-norm of the original matrix A.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
;;*          estimate of the 1-norm of inv(A) computed in this routine.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsycon (uplo  n  a  lda  ipiv  anorm  rcond  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-double-)) anorm )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zsycon_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($anorm,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsymv <uplo>  <n>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYMV  performs the matrix-vector  operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric matrix.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX*16
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX*16 array, dimension ( LDA, N )
;;*           Before entry, with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced.
;;*           Before entry, with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, N ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX*16 array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX*16
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX*16 array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsymv (uplo  n  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) alpha )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) beta )
	((-idx2- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ zsymv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsyrfs <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYRFS improves the computed solution to a system of linear
;;*  equations when the coefficient matrix is symmetric indefinite, and
;;*  provides error bounds and backward error estimates for the solution.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input) COMPLEX*16 array, dimension (LDAF,N)
;;*          The factored form of the matrix A.  AF contains the block
;;*          diagonal matrix D and the multipliers used to obtain the
;;*          factor U or L from the factorization A = U*D*U**T or
;;*          A = L*D*L**T as computed by ZSYTRF.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSYTRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input/output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          On entry, the solution matrix X, as computed by ZSYTRS.
;;*          On exit, the improved solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  ITMAX is the maximum number of steps of iterative refinement.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsyrfs (uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zsyrfs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsyr <uplo>  <n>  <alpha>  <x>  <incx>  <a>  <lda>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYR   performs the symmetric rank 1 operation
;;*
;;*     A := alpha*x*( x' ) + A,
;;*
;;*  where alpha is a complex scalar, x is an n element vector and A is an
;;*  n by n symmetric matrix.
;;*
;;*  Arguments
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX*16
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX*16 array, dimension at least
;;*           ( 1 + ( N - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the N-
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX*16 array, dimension ( LDA, N )
;;*           Before entry, with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced. On exit, the
;;*           upper triangular part of the array A is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry, with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced. On exit, the
;;*           lower triangular part of the array A is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDA    - INTEGER
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, N ).
;;*           Unchanged on exit.
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsyr (uplo  n  alpha  x  incx  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) alpha )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ zsyr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsysv <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYSV computes the solution to a complex system of linear equations
;;*     A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  The diagonal pivoting method is used to factor A as
;;*     A = U * D * U**T,  if UPLO = 'U', or
;;*     A = L * D * L**T,  if UPLO = 'L',
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
;;*  used to solve the system of equations A * X = B.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, if INFO = 0, the block diagonal matrix D and the
;;*          multipliers used to obtain the factor U or L from the
;;*          factorization A = U*D*U**T or A = L*D*L**T as computed by
;;*          ZSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D, as
;;*          determined by ZSYTRF.  If IPIV(k) > 0, then rows and columns
;;*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
;;*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
;;*          then rows and columns k-1 and -IPIV(k) were interchanged and
;;*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
;;*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
;;*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
;;*          diagonal block.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the N-by-NRHS right hand side matrix B.
;;*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 1, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          ZSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, so the solution could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zsysv (uplo  n  nrhs  a  lda  ipiv  b  ldb  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zsysv_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsysvx <fact>  <uplo>  <n>  <nrhs>  <a>  <lda>  <af>  <ldaf>  <ipiv>  <b>  <ldb>  <x>  <ldx>  <rcond>  <ferr>  <berr>  <work>  <lwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYSVX uses the diagonal pivoting factorization to compute the
;;*  solution to a complex system of linear equations A * X = B,
;;*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
;;*  matrices.
;;*
;;*  Error bounds on the solution and a condition estimate are also
;;*  provided.
;;*
;;*  Description
;;*  ===========
;;*
;;*  The following steps are performed:
;;*
;;*  1. If FACT = 'N', the diagonal pivoting method is used to factor A.
;;*     The form of the factorization is
;;*        A = U * D * U**T,  if UPLO = 'U', or
;;*        A = L * D * L**T,  if UPLO = 'L',
;;*     where U (or L) is a product of permutation and unit upper (lower)
;;*     triangular matrices, and D is symmetric and block diagonal with
;;*     1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  2. If some D(i,i)=0, so that D is exactly singular, then the routine
;;*     returns with INFO = i. Otherwise, the factored form of A is used
;;*     to estimate the condition number of the matrix A.  If the
;;*     reciprocal of the condition number is less than machine precision,
;;*     INFO = N+1 is returned as a warning, but the routine still goes on
;;*     to solve for X and compute error bounds as described below.
;;*
;;*  3. The system of equations is solved for X using the factored form
;;*     of A.
;;*
;;*  4. Iterative refinement is applied to improve the computed solution
;;*     matrix and calculate error bounds and backward error estimates
;;*     for it.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  FACT    (input) CHARACTER*1
;;*          Specifies whether or not the factored form of A has been
;;*          supplied on entry.
;;*          = 'F':  On entry, AF and IPIV contain the factored form
;;*                  of A.  A, AF and IPIV will not be modified.
;;*          = 'N':  The matrix A will be copied to AF and factored.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The number of linear equations, i.e., the order of the
;;*          matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The symmetric matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of A contains the upper triangular part
;;*          of the matrix A, and the strictly lower triangular part of A
;;*          is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of A contains the lower triangular part of
;;*          the matrix A, and the strictly upper triangular part of A is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)
;;*          If FACT = 'F', then AF is an input argument and on entry
;;*          contains the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T as computed by ZSYTRF.
;;*
;;*          If FACT = 'N', then AF is an output argument and on exit
;;*          returns the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L from the factorization
;;*          A = U*D*U**T or A = L*D*L**T.
;;*
;;*  LDAF    (input) INTEGER
;;*          The leading dimension of the array AF.  LDAF >= max(1,N).
;;*
;;*  IPIV    (input or output) INTEGER array, dimension (N)
;;*          If FACT = 'F', then IPIV is an input argument and on entry
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZSYTRF.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*          If FACT = 'N', then IPIV is an output argument and on exit
;;*          contains details of the interchanges and the block structure
;;*          of D, as determined by ZSYTRF.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The N-by-NRHS right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The estimate of the reciprocal condition number of the matrix
;;*          A.  If RCOND is less than the machine precision (in
;;*          particular, if RCOND = 0), the matrix is singular to working
;;*          precision.  This condition is indicated by a return code of
;;*          INFO > 0.
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >= 2*N, and for best performance
;;*          LWORK >= N*NB, where NB is the optimal blocksize for
;;*          ZSYTRF.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, and i is
;;*                <= N:  D(i,i) is exactly zero.  The factorization
;;*                       has been completed but the factor D is exactly
;;*                       singular, so the solution and error bounds could
;;*                       not be computed. RCOND = 0 is returned.
;;*                = N+1: D is nonsingular, but RCOND is less than machine
;;*                       precision, meaning that the matrix is singular
;;*                       to working precision.  Nevertheless, the
;;*                       solution and error bounds are computed because
;;*                       there are a number of situations where the
;;*                       computed solution can be more accurate than the
;;*                       value of RCOND would suggest.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsysvx (fact  uplo  n  nrhs  a  lda  af  ldaf  ipiv  b  ldb  x  ldx  rcond  ferr  berr  work  lwork  rwork  info  )
	((-str-) fact )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) af )
	((-idx0- (-int-)) ldaf )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx0- (-double-)) rcond )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ zsysvx_($fact->data, $uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($af,double), IDX_PTR($ldaf,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($rcond,double), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsytf2 <uplo>  <n>  <a>  <lda>  <ipiv>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYTF2 computes the factorization of a complex symmetric matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method:
;;*
;;*     A = U*D*U'  or  A = L*D*L'
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, U' is the transpose of U, and D is symmetric and
;;*  block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the upper or lower triangular part of the
;;*          symmetric matrix A is stored:
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          n-by-n upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n-by-n lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
;;*               has been completed, but the block diagonal matrix D is
;;*               exactly singular, and division by zero will occur if it
;;*               is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  1-96 - Based on modifications by J. Lewis, Boeing Computer Services
;;*         Company
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsytf2 (uplo  n  a  lda  ipiv  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx0- (-int-)) info )
	#{ zsytf2_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsytrf <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYTRF computes the factorization of a complex symmetric matrix A
;;*  using the Bunch-Kaufman diagonal pivoting method.  The form of the
;;*  factorization is
;;*
;;*     A = U*D*U**T  or  A = L*D*L**T
;;*
;;*  where U (or L) is a product of permutation and unit upper (lower)
;;*  triangular matrices, and D is symmetric and block diagonal with
;;*  with 1-by-1 and 2-by-2 diagonal blocks.
;;*
;;*  This is the blocked version of the algorithm, calling Level 3 BLAS.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  Upper triangle of A is stored;
;;*          = 'L':  Lower triangle of A is stored.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
;;*          N-by-N upper triangular part of A contains the upper
;;*          triangular part of the matrix A, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of A contains the lower
;;*          triangular part of the matrix A, and the strictly upper
;;*          triangular part of A is not referenced.
;;*
;;*          On exit, the block diagonal matrix D and the multipliers used
;;*          to obtain the factor U or L (see below for further details).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (output) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D.
;;*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
;;*          interchanged and D(k,k) is a 1-by-1 diagonal block.
;;*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
;;*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
;;*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
;;*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
;;*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The length of WORK.  LWORK >=1.  For best performance
;;*          LWORK >= N*NB, where NB is the block size returned by ILAENV.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
;;*                has been completed, but the block diagonal matrix D is
;;*                exactly singular, and division by zero will occur if it
;;*                is used to solve a system of equations.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  If UPLO = 'U', then A = U*D*U', where
;;*     U = P(n)*U(n)* ... *P(k)U(k)* ...,
;;*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to
;;*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    v    0   )   k-s
;;*     U(k) =  (   0    I    0   )   s
;;*             (   0    0    I   )   n-k
;;*                k-s   s   n-k
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
;;*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
;;*  and A(k,k), and v overwrites A(1:k-2,k-1:k).
;;*
;;*  If UPLO = 'L', then A = L*D*L', where
;;*     L = P(1)*L(1)* ... *P(k)*L(k)* ...,
;;*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
;;*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
;;*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
;;*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
;;*  that if the diagonal block D(k) is of order s (s = 1 or 2), then
;;*
;;*             (   I    0     0   )  k-1
;;*     L(k) =  (   0    I     0   )  s
;;*             (   0    v     I   )  n-k-s+1
;;*                k-1   s  n-k-s+1
;;*
;;*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
;;*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
;;*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zsytrf (uplo  n  a  lda  ipiv  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zsytrf_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsytri <uplo>  <n>  <a>  <lda>  <ipiv>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYTRI computes the inverse of a complex symmetric indefinite matrix
;;*  A using the factorization A = U*D*U**T or A = L*D*L**T computed by
;;*  ZSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the block diagonal matrix D and the multipliers
;;*          used to obtain the factor U or L as computed by ZSYTRF.
;;*
;;*          On exit, if INFO = 0, the (symmetric) inverse of the original
;;*          matrix.  If UPLO = 'U', the upper triangular part of the
;;*          inverse is formed and the part of A below the diagonal is not
;;*          referenced; if UPLO = 'L' the lower triangular part of the
;;*          inverse is formed and the part of A above the diagonal is
;;*          not referenced.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSYTRF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
;;*               inverse could not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsytri (uplo  n  a  lda  ipiv  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zsytri_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zsytrs <uplo>  <n>  <nrhs>  <a>  <lda>  <ipiv>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZSYTRS solves a system of linear equations A*X = B with a complex
;;*  symmetric matrix A using the factorization A = U*D*U**T or
;;*  A = L*D*L**T computed by ZSYTRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the details of the factorization are stored
;;*          as an upper or lower triangular matrix.
;;*          = 'U':  Upper triangular, form is A = U*D*U**T;
;;*          = 'L':  Lower triangular, form is A = L*D*L**T.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The block diagonal matrix D and the multipliers used to
;;*          obtain the factor U or L as computed by ZSYTRF.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  IPIV    (input) INTEGER array, dimension (N)
;;*          Details of the interchanges and the block structure of D
;;*          as determined by ZSYTRF.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zsytrs (uplo  n  nrhs  a  lda  ipiv  b  ldb  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-int-)) ipiv )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ zsytrs_($uplo->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($ipiv,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztbcon <norm>  <uplo>  <diag>  <n>  <kd>  <ab>  <ldab>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTBCON estimates the reciprocal of the condition number of a
;;*  triangular band matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztbcon (norm  uplo  diag  n  kd  ab  ldab  rcond  work  rwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztbcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztbrfs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTBRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular band
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by ZTBTRS or some other
;;*  means before entering this routine.  ZTBRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of the array. The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztbrfs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztbrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztbtrs <uplo>  <trans>  <diag>  <n>  <kd>  <nrhs>  <ab>  <ldab>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTBTRS solves a triangular system of the form
;;*
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*
;;*  where A is a triangular band matrix of order N, and B is an
;;*  N-by-NRHS matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  KD      (input) INTEGER
;;*          The number of superdiagonals or subdiagonals of the
;;*          triangular band matrix A.  KD >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AB      (input) COMPLEX*16 array, dimension (LDAB,N)
;;*          The upper or lower triangular band matrix A, stored in the
;;*          first kd+1 rows of AB.  The j-th column of A is stored
;;*          in the j-th column of the array AB as follows:
;;*          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
;;*          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  LDAB    (input) INTEGER
;;*          The leading dimension of the array AB.  LDAB >= KD+1.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztbtrs (uplo  trans  diag  n  kd  nrhs  ab  ldab  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kd )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) ab )
	((-idx0- (-int-)) ldab )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ztbtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($kd,int), IDX_PTR($nrhs,int), IDX_PTR($ab,double), IDX_PTR($ldab,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgevc <side>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGEVC computes some or all of the right and/or left generalized
;;*  eigenvectors of a pair of complex upper triangular matrices (A,B).
;;*
;;*  The right generalized eigenvector x and the left generalized
;;*  eigenvector y of (A,B) corresponding to a generalized eigenvalue
;;*  w are defined by:
;;*
;;*          (A - wB) * x = 0  and  y**H * (A - wB) = 0
;;*
;;*  where y**H denotes the conjugate tranpose of y.
;;*
;;*  If an eigenvalue w is determined by zero diagonal elements of both A
;;*  and B, a unit vector is returned as the corresponding eigenvector.
;;*
;;*  If all eigenvectors are requested, the routine may either return
;;*  the matrices X and/or Y of right or left eigenvectors of (A,B), or
;;*  the products Z*X and/or Q*Y, where Z and Q are input unitary
;;*  matrices.  If (A,B) was obtained from the generalized Schur
;;*  factorization of an original pair of matrices
;;*     (A0,B0) = (Q*A*Z**H,Q*B*Z**H),
;;*  then Z*X and Q*Y are the matrices of right or left eigenvectors of
;;*  A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R': compute right eigenvectors only;
;;*          = 'L': compute left eigenvectors only;
;;*          = 'B': compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute all right and/or left eigenvectors;
;;*          = 'B': compute all right and/or left eigenvectors, and
;;*                 backtransform them using the input matrices supplied
;;*                 in VR and/or VL;
;;*          = 'S': compute selected right and/or left eigenvectors,
;;*                 specified by the logical array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY='S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY='A' or 'B', SELECT is not referenced.
;;*          To select the eigenvector corresponding to the j-th
;;*          eigenvalue, SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The upper triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,N)
;;*          The upper triangular matrix B.  B must have real diagonal
;;*          elements.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of array B.  LDB >= max(1,N).
;;*
;;*  VL      (input/output) COMPLEX*16 array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Q
;;*          of left Schur vectors returned by ZHGEQZ).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VL, in the same order as their eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of array VL.
;;*          LDVL >= max(1,N) if SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) COMPLEX*16 array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Z
;;*          of right Schur vectors returned by ZHGEQZ).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of (A,B);
;;*          if HOWMNY = 'B', the matrix Z*X;
;;*          if HOWMNY = 'S', the right eigenvectors of (A,B) specified by
;;*                      SELECT, stored consecutively in the columns of
;;*                      VR, in the same order as their eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= max(1,N) if SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
;;*          is set to N.  Each selected eigenvector occupies one column.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit.
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgevc (side  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  mm  m  work  rwork  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztgevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgex2 <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <j1>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
;;*  in an upper triangular matrix pair (A, B) by an unitary equivalence
;;*  transformation.
;;*
;;*  (A, B) must be in generalized Schur canonical form, that is, A and
;;*  B are both upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 arrays, dimensions (LDA,N)
;;*          On entry, the matrix A in the pair (A, B).
;;*          On exit, the updated matrix A.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 arrays, dimensions (LDB,N)
;;*          On entry, the matrix B in the pair (A, B).
;;*          On exit, the updated matrix B.
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          If WANTQ = .TRUE, on entry, the unitary matrix Q. On exit,
;;*          the updated matrix Q.
;;*          Not referenced if WANTQ = .FALSE..
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1;
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          If WANTZ = .TRUE, on entry, the unitary matrix Z. On exit,
;;*          the updated matrix Z.
;;*          Not referenced if WANTZ = .FALSE..
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1;
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  J1      (input) INTEGER
;;*          The index to the first block (A11, B11).
;;*
;;*  INFO    (output) INTEGER
;;*           =0:  Successful exit.
;;*           =1:  The transformed matrix pair (A, B) would be too far
;;*                from generalized Schur form; the problem is ill-
;;*                conditioned. (A, B) may have been partially reordered,
;;*                and ILST points to the first row of the current
;;*                position of the block being moved.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  In the current code both weak and strong stability tests are
;;*  performed. The user can omit the strong stability test by changing
;;*  the internal logical parameter WANDS to .FALSE.. See ref. [2] for
;;*  details.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report UMINF-94.04,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, 1994. Also as LAPACK Working Note 87. To appear in
;;*      Numerical Algorithms, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgex2 (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  j1  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) j1 )
	((-idx0- (-int-)) info )
	#{ ztgex2_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($j1,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgexc <wantq>  <wantz>  <n>  <a>  <lda>  <b>  <ldb>  <q>  <ldq>  <z>  <ldz>  <ifst>  <ilst>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGEXC reorders the generalized Schur decomposition of a complex
;;*  matrix pair (A,B), using an unitary equivalence transformation
;;*  (A, B) := Q * (A, B) * Z', so that the diagonal block of (A, B) with
;;*  row index IFST is moved to row ILST.
;;*
;;*  (A, B) must be in generalized Schur canonical form, that is, A and
;;*  B are both upper triangular.
;;*
;;*  Optionally, the matrices Q and Z of generalized Schur vectors are
;;*  updated.
;;*
;;*         Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'
;;*         Q(in) * B(in) * Z(in)' = Q(out) * B(out) * Z(out)'
;;*
;;*  Arguments
;;*  =========
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the upper triangular matrix A in the pair (A, B).
;;*          On exit, the updated matrix A.
;;*
;;*  LDA     (input)  INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the upper triangular matrix B in the pair (A, B).
;;*          On exit, the updated matrix B.
;;*
;;*  LDB     (input)  INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          On entry, if WANTQ = .TRUE., the unitary matrix Q.
;;*          On exit, the updated matrix Q.
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1;
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., the unitary matrix Z.
;;*          On exit, the updated matrix Z.
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1;
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  IFST    (input/output) INTEGER
;;*  ILST    (input/output) INTEGER
;;*          Specify the reordering of the diagonal blocks of (A, B).
;;*          The block with row index IFST is moved to row ILST, by a
;;*          sequence of swapping between adjacent blocks.
;;*
;;*  INFO    (output) INTEGER
;;*           =0:  Successful exit.
;;*           <0:  if INFO = -i, the i-th argument had an illegal value.
;;*           =1:  The transformed matrix pair (A, B) would be too far
;;*                from generalized Schur form; the problem is ill-
;;*                conditioned. (A, B) may have been partially reordered,
;;*                and ILST points to the first row of the current
;;*                position of the block being moved.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report
;;*      UMINF - 94.04, Department of Computing Science, Umea University,
;;*      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
;;*      To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK working
;;*      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
;;*      1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ztgexc (wantq  wantz  n  a  lda  b  ldb  q  ldq  z  ldz  ifst  ilst  info  )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx0- (-int-)) info )
	#{ ztgexc_(IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgsen <ijob>  <wantq>  <wantz>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <alpha>  <beta>  <q>  <ldq>  <z>  <ldz>  <m>  <pl>  <pr>  <dif>  <work>  <lwork>  <iwork>  <liwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGSEN reorders the generalized Schur decomposition of a complex
;;*  matrix pair (A, B) (in terms of an unitary equivalence trans-
;;*  formation Q' * (A, B) * Z), so that a selected cluster of eigenvalues
;;*  appears in the leading diagonal blocks of the pair (A,B). The leading
;;*  columns of Q and Z form unitary bases of the corresponding left and
;;*  right eigenspaces (deflating subspaces). (A, B) must be in
;;*  generalized Schur canonical form, that is, A and B are both upper
;;*  triangular.
;;*
;;*  ZTGSEN also computes the generalized eigenvalues
;;*
;;*           w(j)= ALPHA(j) / BETA(j)
;;*
;;*  of the reordered matrix pair (A, B).
;;*
;;*  Optionally, the routine computes estimates of reciprocal condition
;;*  numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
;;*  (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
;;*  between the matrix pairs (A11, B11) and (A22,B22) that correspond to
;;*  the selected cluster and the eigenvalues outside the cluster, resp.,
;;*  and norms of "projections" onto left and right eigenspaces w.r.t.
;;*  the selected cluster in the (1,1)-block.
;;*
;;*
;;*  Arguments
;;*  =========
;;*
;;*  IJOB    (input) integer
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (PL and PR) or the deflating subspaces
;;*          (Difu and Difl):
;;*           =0: Only reorder w.r.t. SELECT. No extras.
;;*           =1: Reciprocal of norms of "projections" onto left and right
;;*               eigenspaces w.r.t. the selected cluster (PL and PR).
;;*           =2: Upper bounds on Difu and Difl. F-norm-based estimate
;;*               (DIF(1:2)).
;;*           =3: Estimate of Difu and Difl. 1-norm-based estimate
;;*               (DIF(1:2)).
;;*               About 5 times as expensive as IJOB = 2.
;;*           =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
;;*               version to get it all.
;;*           =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)
;;*
;;*  WANTQ   (input) LOGICAL
;;*          .TRUE. : update the left transformation matrix Q;
;;*          .FALSE.: do not update Q.
;;*
;;*  WANTZ   (input) LOGICAL
;;*          .TRUE. : update the right transformation matrix Z;
;;*          .FALSE.: do not update Z.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster. To
;;*          select an eigenvalue w(j), SELECT(j) must be set to
;;*          .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices A and B. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension(LDA,N)
;;*          On entry, the upper triangular matrix A, in generalized
;;*          Schur canonical form.
;;*          On exit, A is overwritten by the reordered matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension(LDB,N)
;;*          On entry, the upper triangular matrix B, in generalized
;;*          Schur canonical form.
;;*          On exit, B is overwritten by the reordered matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  ALPHA   (output) COMPLEX*16 array, dimension (N)
;;*  BETA    (output) COMPLEX*16 array, dimension (N)
;;*          The diagonal elements of A and B, respectively,
;;*          when the pair (A,B) has been reduced to generalized Schur
;;*          form.  ALPHA(i)/BETA(i) i=1,...,N are the generalized
;;*          eigenvalues.
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*          On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
;;*          On exit, Q has been postmultiplied by the left unitary
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Q form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTQ = .FALSE., Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= 1.
;;*          If WANTQ = .TRUE., LDQ >= N.
;;*
;;*  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
;;*          On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
;;*          On exit, Z has been postmultiplied by the left unitary
;;*          transformation matrix which reorder (A, B); The leading M
;;*          columns of Z form orthonormal bases for the specified pair of
;;*          left eigenspaces (deflating subspaces).
;;*          If WANTZ = .FALSE., Z is not referenced.
;;*
;;*  LDZ     (input) INTEGER
;;*          The leading dimension of the array Z. LDZ >= 1.
;;*          If WANTZ = .TRUE., LDZ >= N.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified pair of left and right
;;*          eigenspaces, (deflating subspaces) 0 <= M <= N.
;;*
;;*  PL, PR  (output) DOUBLE PRECISION
;;*          If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
;;*          reciprocal  of the norm of "projections" onto left and right
;;*          eigenspace with respect to the selected cluster.
;;*          0 < PL, PR <= 1.
;;*          If M = 0 or M = N, PL = PR  = 1.
;;*          If IJOB = 0, 2 or 3 PL, PR are not referenced.
;;*
;;*  DIF     (output) DOUBLE PRECISION array, dimension (2).
;;*          If IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.
;;*          If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
;;*          Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
;;*          estimates of Difu and Difl, computed using reversed
;;*          communication with ZLACON.
;;*          If M = 0 or N, DIF(1:2) = F-norm([A, B]).
;;*          If IJOB = 0 or 1, DIF is not referenced.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          IF IJOB = 0, WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >=  1
;;*          If IJOB = 1, 2 or 4, LWORK >=  2*M*(N-M)
;;*          If IJOB = 3 or 5, LWORK >=  4*M*(N-M)
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace/output) INTEGER, dimension (LIWORK)
;;*          IF IJOB = 0, IWORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
;;*
;;*  LIWORK  (input) INTEGER
;;*          The dimension of the array IWORK. LIWORK >= 1.
;;*          If IJOB = 1, 2 or 4, LIWORK >=  N+2;
;;*          If IJOB = 3 or 5, LIWORK >= MAX(N+2, 2*M*(N-M));
;;*
;;*          If LIWORK = -1, then a workspace query is assumed; the
;;*          routine only calculates the optimal size of the IWORK array,
;;*          returns this value as the first entry of the IWORK array, and
;;*          no error message related to LIWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*            =0: Successful exit.
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            =1: Reordering of (A, B) failed because the transformed
;;*                matrix pair (A, B) would be too far from generalized
;;*                Schur form; the problem is very ill-conditioned.
;;*                (A, B) may have been partially reordered.
;;*                If requested, 0 is returned in DIF(*), PL and PR.
;;*
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  ZTGSEN first collects the selected eigenvalues by computing unitary
;;*  U and W that move them to the top left corner of (A, B). In other
;;*  words, the selected eigenvalues are the eigenvalues of (A11, B11) in
;;*
;;*                U'*(A, B)*W = (A11 A12) (B11 B12) n1
;;*                              ( 0  A22),( 0  B22) n2
;;*                                n1  n2    n1  n2
;;*
;;*  where N = n1+n2 and U' means the conjugate transpose of U. The first
;;*  n1 columns of U and W span the specified pair of left and right
;;*  eigenspaces (deflating subspaces) of (A, B).
;;*
;;*  If (A, B) has been obtained from the generalized real Schur
;;*  decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the
;;*  reordered generalized Schur form of (C, D) is given by
;;*
;;*           (C, D) = (Q*U)*(U'*(A, B)*W)*(Z*W)',
;;*
;;*  and the first n1 columns of Q*U and Z*W span the corresponding
;;*  deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).
;;*
;;*  Note that if the selected eigenvalue is sufficiently ill-conditioned,
;;*  then its value may differ significantly from its value before
;;*  reordering.
;;*
;;*  The reciprocal condition numbers of the left and right eigenspaces
;;*  spanned by the first n1 columns of U and W (or Q*U and Z*W) may
;;*  be returned in DIF(1:2), corresponding to Difu and Difl, resp.
;;*
;;*  The Difu and Difl are defined as:
;;*
;;*       Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
;;*  and
;;*       Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],
;;*
;;*  where sigma-min(Zu) is the smallest singular value of the
;;*  (2*n1*n2)-by-(2*n1*n2) matrix
;;*
;;*       Zu = [ kron(In2, A11)  -kron(A22', In1) ]
;;*            [ kron(In2, B11)  -kron(B22', In1) ].
;;*
;;*  Here, Inx is the identity matrix of size nx and A22' is the
;;*  transpose of A22. kron(X, Y) is the Kronecker product between
;;*  the matrices X and Y.
;;*
;;*  When DIF(2) is small, small changes in (A, B) can cause large changes
;;*  in the deflating subspace. An approximate (asymptotic) bound on the
;;*  maximum angular error in the computed deflating subspaces is
;;*
;;*       EPS * norm((A, B)) / DIF(2),
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal norm of the projectors on the left and right
;;*  eigenspaces associated with (A11, B11) may be returned in PL and PR.
;;*  They are computed as follows. First we compute L and R so that
;;*  P*(A, B)*Q is block diagonal, where
;;*
;;*       P = ( I -L ) n1           Q = ( I R ) n1
;;*           ( 0  I ) n2    and        ( 0 I ) n2
;;*             n1 n2                    n1 n2
;;*
;;*  and (L, R) is the solution to the generalized Sylvester equation
;;*
;;*       A11*R - L*A22 = -A12
;;*       B11*R - L*B22 = -B12
;;*
;;*  Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2).
;;*  An approximate (asymptotic) bound on the average absolute error of
;;*  the selected eigenvalues is
;;*
;;*       EPS * norm((A, B)) / PL.
;;*
;;*  There are also global error bounds which valid for perturbations up
;;*  to a certain restriction:  A lower bound (x) on the smallest
;;*  F-norm(E,F) for which an eigenvalue of (A11, B11) may move and
;;*  coalesce with an eigenvalue of (A22, B22) under perturbation (E,F),
;;*  (i.e. (A + E, B + F), is
;;*
;;*   x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).
;;*
;;*  An approximate bound on x can be computed from DIF(1:2), PL and PR.
;;*
;;*  If y = ( F-norm(E,F) / x) <= 1, the angles between the perturbed
;;*  (L', R') and unperturbed (L, R) left and right deflating subspaces
;;*  associated with the selected cluster in the (1,1)-blocks can be
;;*  bounded as
;;*
;;*   max-angle(L, L') <= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2))
;;*   max-angle(R, R') <= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))
;;*
;;*  See LAPACK User's Guide section 4.11 or the following references
;;*  for more information.
;;*
;;*  Note that if the default method for computing the Frobenius-norm-
;;*  based estimate DIF is not wanted (see ZLATDF), then the parameter
;;*  IDIFJB (see below) should be changed from 3 to 4 (routine ZLATDF
;;*  (IJOB = 2 will be used)). See ZTGSYL for more details.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report
;;*      UMINF - 94.04, Department of Computing Science, Umea University,
;;*      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
;;*      To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK working
;;*      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
;;*      1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgsen (ijob  wantq  wantz  select  n  a  lda  b  ldb  alpha  beta  q  ldq  z  ldz  m  pl  pr  dif  work  lwork  iwork  liwork  info  )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) wantq )
	((-idx0- (-int-)) wantz )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx2- (-double-)) alpha )
	((-idx2- (-double-)) beta )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx3- (-double-)) z )
	((-idx0- (-int-)) ldz )
	((-idx0- (-int-)) m )
	((-idx0- (-double-)) pl )
	((-idx0- (-double-)) pr )
	((-idx1- (-double-)) dif )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) liwork )
	((-idx0- (-int-)) info )
	#{ ztgsen_(IDX_PTR($ijob,int), IDX_PTR($wantq,int), IDX_PTR($wantz,int), IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($z,double), IDX_PTR($ldz,int), IDX_PTR($m,int), IDX_PTR($pl,double), IDX_PTR($pr,double), IDX_PTR($dif,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($liwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgsja <jobu>  <jobv>  <jobq>  <m>  <p>  <n>  <k>  <l>  <a>  <lda>  <b>  <ldb>  <tola>  <tolb>  <alpha>  <beta>  <u>  <ldu>  <v>  <ldv>  <q>  <ldq>  <work>  <ncycle>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGSJA computes the generalized singular value decomposition (GSVD)
;;*  of two complex upper triangular (or trapezoidal) matrices A and B.
;;*
;;*  On entry, it is assumed that matrices A and B have the following
;;*  forms, which may be obtained by the preprocessing subroutine ZGGSVP
;;*  from a general M-by-N matrix A and P-by-N matrix B:
;;*
;;*               N-K-L  K    L
;;*     A =    K ( 0    A12  A13 ) if M-K-L >= 0;
;;*            L ( 0     0   A23 )
;;*        M-K-L ( 0     0    0  )
;;*
;;*             N-K-L  K    L
;;*     A =  K ( 0    A12  A13 ) if M-K-L < 0;
;;*        M-K ( 0     0   A23 )
;;*
;;*             N-K-L  K    L
;;*     B =  L ( 0     0   B13 )
;;*        P-L ( 0     0    0  )
;;*
;;*  where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
;;*  upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
;;*  otherwise A23 is (M-K)-by-L upper trapezoidal.
;;*
;;*  On exit,
;;*
;;*         U'*A*Q = D1*( 0 R ),    V'*B*Q = D2*( 0 R ),
;;*
;;*  where U, V and Q are unitary matrices, Z' denotes the conjugate
;;*  transpose of Z, R is a nonsingular upper triangular matrix, and D1
;;*  and D2 are ``diagonal'' matrices, which are of the following
;;*  structures:
;;*
;;*  If M-K-L >= 0,
;;*
;;*                      K  L
;;*         D1 =     K ( I  0 )
;;*                  L ( 0  C )
;;*              M-K-L ( 0  0 )
;;*
;;*                     K  L
;;*         D2 = L   ( 0  S )
;;*              P-L ( 0  0 )
;;*
;;*                 N-K-L  K    L
;;*    ( 0 R ) = K (  0   R11  R12 ) K
;;*              L (  0    0   R22 ) L
;;*
;;*  where
;;*
;;*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
;;*    S = diag( BETA(K+1),  ... , BETA(K+L) ),
;;*    C**2 + S**2 = I.
;;*
;;*    R is stored in A(1:K+L,N-K-L+1:N) on exit.
;;*
;;*  If M-K-L < 0,
;;*
;;*                 K M-K K+L-M
;;*      D1 =   K ( I  0    0   )
;;*           M-K ( 0  C    0   )
;;*
;;*                   K M-K K+L-M
;;*      D2 =   M-K ( 0  S    0   )
;;*           K+L-M ( 0  0    I   )
;;*             P-L ( 0  0    0   )
;;*
;;*                 N-K-L  K   M-K  K+L-M
;;* ( 0 R ) =    K ( 0    R11  R12  R13  )
;;*            M-K ( 0     0   R22  R23  )
;;*          K+L-M ( 0     0    0   R33  )
;;*
;;*  where
;;*  C = diag( ALPHA(K+1), ... , ALPHA(M) ),
;;*  S = diag( BETA(K+1),  ... , BETA(M) ),
;;*  C**2 + S**2 = I.
;;*
;;*  R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
;;*      (  0  R22 R23 )
;;*  in B(M-K+1:L,N+M-K-L+1:N) on exit.
;;*
;;*  The computation of the unitary transformation matrices U, V or Q
;;*  is optional.  These matrices may either be formed explicitly, or they
;;*  may be postmultiplied into input matrices U1, V1, or Q1.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOBU    (input) CHARACTER*1
;;*          = 'U':  U must contain a unitary matrix U1 on entry, and
;;*                  the product U1*U is returned;
;;*          = 'I':  U is initialized to the unit matrix, and the
;;*                  unitary matrix U is returned;
;;*          = 'N':  U is not computed.
;;*
;;*  JOBV    (input) CHARACTER*1
;;*          = 'V':  V must contain a unitary matrix V1 on entry, and
;;*                  the product V1*V is returned;
;;*          = 'I':  V is initialized to the unit matrix, and the
;;*                  unitary matrix V is returned;
;;*          = 'N':  V is not computed.
;;*
;;*  JOBQ    (input) CHARACTER*1
;;*          = 'Q':  Q must contain a unitary matrix Q1 on entry, and
;;*                  the product Q1*Q is returned;
;;*          = 'I':  Q is initialized to the unit matrix, and the
;;*                  unitary matrix Q is returned;
;;*          = 'N':  Q is not computed.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  P       (input) INTEGER
;;*          The number of rows of the matrix B.  P >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrices A and B.  N >= 0.
;;*
;;*  K       (input) INTEGER
;;*  L       (input) INTEGER
;;*          K and L specify the subblocks in the input matrices A and B:
;;*          A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,,N-L+1:N)
;;*          of A and B, whose GSVD is going to be computed by ZTGSJA.
;;*          See Further details.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the M-by-N matrix A.
;;*          On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
;;*          matrix R or part of R.  See Purpose for details.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)
;;*          On entry, the P-by-N matrix B.
;;*          On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
;;*          a part of R.  See Purpose for details.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,P).
;;*
;;*  TOLA    (input) DOUBLE PRECISION
;;*  TOLB    (input) DOUBLE PRECISION
;;*          TOLA and TOLB are the convergence criteria for the Jacobi-
;;*          Kogbetliantz iteration procedure. Generally, they are the
;;*          same as used in the preprocessing step, say
;;*              TOLA = MAX(M,N)*norm(A)*MAZHEPS,
;;*              TOLB = MAX(P,N)*norm(B)*MAZHEPS.
;;*
;;*  ALPHA   (output) DOUBLE PRECISION array, dimension (N)
;;*  BETA    (output) DOUBLE PRECISION array, dimension (N)
;;*          On exit, ALPHA and BETA contain the generalized singular
;;*          value pairs of A and B;
;;*            ALPHA(1:K) = 1,
;;*            BETA(1:K)  = 0,
;;*          and if M-K-L >= 0,
;;*            ALPHA(K+1:K+L) = diag(C),
;;*            BETA(K+1:K+L)  = diag(S),
;;*          or if M-K-L < 0,
;;*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
;;*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
;;*          Furthermore, if K+L < N,
;;*            ALPHA(K+L+1:N) = 0
;;*            BETA(K+L+1:N)  = 0.
;;*
;;*  U       (input/output) COMPLEX*16 array, dimension (LDU,M)
;;*          On entry, if JOBU = 'U', U must contain a matrix U1 (usually
;;*          the unitary matrix returned by ZGGSVP).
;;*          On exit,
;;*          if JOBU = 'I', U contains the unitary matrix U;
;;*          if JOBU = 'U', U contains the product U1*U.
;;*          If JOBU = 'N', U is not referenced.
;;*
;;*  LDU     (input) INTEGER
;;*          The leading dimension of the array U. LDU >= max(1,M) if
;;*          JOBU = 'U'; LDU >= 1 otherwise.
;;*
;;*  V       (input/output) COMPLEX*16 array, dimension (LDV,P)
;;*          On entry, if JOBV = 'V', V must contain a matrix V1 (usually
;;*          the unitary matrix returned by ZGGSVP).
;;*          On exit,
;;*          if JOBV = 'I', V contains the unitary matrix V;
;;*          if JOBV = 'V', V contains the product V1*V.
;;*          If JOBV = 'N', V is not referenced.
;;*
;;*  LDV     (input) INTEGER
;;*          The leading dimension of the array V. LDV >= max(1,P) if
;;*          JOBV = 'V'; LDV >= 1 otherwise.
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*          On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
;;*          the unitary matrix returned by ZGGSVP).
;;*          On exit,
;;*          if JOBQ = 'I', Q contains the unitary matrix Q;
;;*          if JOBQ = 'Q', Q contains the product Q1*Q.
;;*          If JOBQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N) if
;;*          JOBQ = 'Q'; LDQ >= 1 otherwise.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  NCYCLE  (output) INTEGER
;;*          The number of cycles required for convergence.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value.
;;*          = 1:  the procedure does not converge after MAXIT cycles.
;;*
;;*  Internal Parameters
;;*  ===================
;;*
;;*  MAXIT   INTEGER
;;*          MAXIT specifies the total loops that the iterative procedure
;;*          may take. If after MAXIT cycles, the routine fails to
;;*          converge, we return INFO = 1.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  ZTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
;;*  min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
;;*  matrix B13 to the form:
;;*
;;*           U1'*A13*Q1 = C1*R1; V1'*B13*Q1 = S1*R1,
;;*
;;*  where U1, V1 and Q1 are unitary matrix, and Z' is the conjugate
;;*  transpose of Z.  C1 and S1 are diagonal matrices satisfying
;;*
;;*                C1**2 + S1**2 = I,
;;*
;;*  and R1 is an L-by-L nonsingular upper triangular matrix.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgsja (jobu  jobv  jobq  m  p  n  k  l  a  lda  b  ldb  tola  tolb  alpha  beta  u  ldu  v  ldv  q  ldq  work  ncycle  info  )
	((-str-) jobu )
	((-str-) jobv )
	((-str-) jobq )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) p )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) tola )
	((-idx0- (-double-)) tolb )
	((-idx1- (-double-)) alpha )
	((-idx1- (-double-)) beta )
	((-idx3- (-double-)) u )
	((-idx0- (-int-)) ldu )
	((-idx3- (-double-)) v )
	((-idx0- (-int-)) ldv )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) ncycle )
	((-idx0- (-int-)) info )
	#{ ztgsja_($jobu->data, $jobv->data, $jobq->data, IDX_PTR($m,int), IDX_PTR($p,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($tola,double), IDX_PTR($tolb,double), IDX_PTR($alpha,double), IDX_PTR($beta,double), IDX_PTR($u,double), IDX_PTR($ldu,int), IDX_PTR($v,double), IDX_PTR($ldv,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($ncycle,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgsna <job>  <howmny>  <select>  <n>  <a>  <lda>  <b>  <ldb>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <dif>  <mm>  <m>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or eigenvectors of a matrix pair (A, B).
;;*
;;*  (A, B) must be in generalized Schur canonical form, that is, A and
;;*  B are both upper triangular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (DIF):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (DIF);
;;*          = 'B': for both eigenvalues and eigenvectors (S and DIF).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the corresponding j-th eigenvalue and/or eigenvector,
;;*          SELECT(j) must be set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the square matrix pair (A, B). N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The upper triangular matrix A in the pair (A,B).
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,N)
;;*          The upper triangular matrix B in the pair (A, B).
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  VL      (input) COMPLEX*16 array, dimension (LDVL,M)
;;*          IF JOB = 'E' or 'B', VL must contain left eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT.  The eigenvectors must be stored in consecutive
;;*          columns of VL, as returned by ZTGEVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL. LDVL >= 1; and
;;*          If JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) COMPLEX*16 array, dimension (LDVR,M)
;;*          IF JOB = 'E' or 'B', VR must contain right eigenvectors of
;;*          (A, B), corresponding to the eigenpairs specified by HOWMNY
;;*          and SELECT.  The eigenvectors must be stored in consecutive
;;*          columns of VR, as returned by ZTGEVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR. LDVR >= 1;
;;*          If JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array.
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  DIF     (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array.
;;*          If the eigenvalues cannot be reordered to compute DIF(j),
;;*          DIF(j) is set to 0; this can only occur when the true value
;;*          would be very small anyway.
;;*          For each eigenvalue/vector specified by SELECT, DIF stores
;;*          a Frobenius norm-based estimate of Difl.
;;*          If JOB = 'E', DIF is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S and DIF. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and DIF used to store
;;*          the specified condition numbers; for each selected eigenvalue
;;*          one element is used. If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          If JOB = 'E', WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK  (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= 1.
;;*          If JOB = 'V' or 'B', LWORK >= 2*N*N.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (N+2)
;;*          If JOB = 'E', IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: Successful exit
;;*          < 0: If INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of the i-th generalized
;;*  eigenvalue w = (a, b) is defined as
;;*
;;*          S(I) = (|v'Au|**2 + |v'Bu|**2)**(1/2) / (norm(u)*norm(v))
;;*
;;*  where u and v are the right and left eigenvectors of (A, B)
;;*  corresponding to w; |z| denotes the absolute value of the complex
;;*  number, and norm(u) denotes the 2-norm of the vector u. The pair
;;*  (a, b) corresponds to an eigenvalue w = a/b (= v'Au/v'Bu) of the
;;*  matrix pair (A, B). If both a and b equal zero, then (A,B) is
;;*  singular and S(I) = -1 is returned.
;;*
;;*  An approximate error bound on the chordal distance between the i-th
;;*  computed generalized eigenvalue w and the corresponding exact
;;*  eigenvalue lambda is
;;*
;;*          chord(w, lambda) <=   EPS * norm(A, B) / S(I),
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number of the right eigenvector u
;;*  and left eigenvector v corresponding to the generalized eigenvalue w
;;*  is defined as follows. Suppose
;;*
;;*                   (A, B) = ( a   *  ) ( b  *  )  1
;;*                            ( 0  A22 ),( 0 B22 )  n-1
;;*                              1  n-1     1 n-1
;;*
;;*  Then the reciprocal condition number DIF(I) is
;;*
;;*          Difl[(a, b), (A22, B22)]  = sigma-min( Zl )
;;*
;;*  where sigma-min(Zl) denotes the smallest singular value of
;;*
;;*         Zl = [ kron(a, In-1) -kron(1, A22) ]
;;*              [ kron(b, In-1) -kron(1, B22) ].
;;*
;;*  Here In-1 is the identity matrix of size n-1 and X' is the conjugate
;;*  transpose of X. kron(X, Y) is the Kronecker product between the
;;*  matrices X and Y.
;;*
;;*  We approximate the smallest singular value of Zl with an upper
;;*  bound. This is done by ZLATDF.
;;*
;;*  An approximate error bound for a computed eigenvector VL(i) or
;;*  VR(i) is given by
;;*
;;*                      EPS * norm(A, B) / DIF(i).
;;*
;;*  See ref. [2-3] for more details and further references.
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  References
;;*  ==========
;;*
;;*  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
;;*      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
;;*      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
;;*      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
;;*
;;*  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
;;*      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
;;*      Estimation: Theory, Algorithms and Software, Report
;;*      UMINF - 94.04, Department of Computing Science, Umea University,
;;*      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
;;*      To appear in Numerical Algorithms, 1996.
;;*
;;*  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.
;;*      To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgsna (job  howmny  select  n  a  lda  b  ldb  vl  ldvl  vr  ldvr  s  dif  mm  m  work  lwork  iwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) dif )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ztgsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($s,double), IDX_PTR($dif,double), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgsy2 <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <rdsum>  <rdscal>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGSY2 solves the generalized Sylvester equation
;;*
;;*              A * R - L * B = scale *   C               (1)
;;*              D * R - L * E = scale * F
;;*
;;*  using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
;;*  (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
;;*  N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
;;*  (i.e., (A,D) and (B,E) in generalized Schur form).
;;*
;;*  The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
;;*  scaling factor chosen to avoid overflow.
;;*
;;*  In matrix notation solving equation (1) corresponds to solve
;;*  Zx = scale * b, where Z is defined as
;;*
;;*         Z = [ kron(In, A)  -kron(B', Im) ]             (2)
;;*             [ kron(In, D)  -kron(E', Im) ],
;;*
;;*  Ik is the identity matrix of size k and X' is the transpose of X.
;;*  kron(X, Y) is the Kronecker product between the matrices X and Y.
;;*
;;*  If TRANS = 'C', y in the conjugate transposed system Z'y = scale*b
;;*  is solved for, which is equivalent to solve for R and L in
;;*
;;*              A' * R  + D' * L   = scale *  C           (3)
;;*              R  * B' + L  * E'  = scale * -F
;;*
;;*  This case is used to compute an estimate of Dif[(A, D), (B, E)] =
;;*  = sigma_min(Z) using reverse communicaton with ZLACON.
;;*
;;*  ZTGSY2 also (IJOB >= 1) contributes to the computation in ZTGSYL
;;*  of an upper bound on the separation between to matrix pairs. Then
;;*  the input (A, D), (B, E) are sub-pencils of two matrix pairs in
;;*  ZTGSYL.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER
;;*          = 'N', solve the generalized Sylvester equation (1).
;;*          = 'T': solve the 'transposed' system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*          =0: solve (1) only.
;;*          =1: A contribution from this subsystem to a Frobenius
;;*              norm-based estimate of the separation between two matrix
;;*              pairs is computed. (look ahead strategy is used).
;;*          =2: A contribution from this subsystem to a Frobenius
;;*              norm-based estimate of the separation between two matrix
;;*              pairs is computed. (DGECON on sub-systems is used.)
;;*          Not referenced if TRANS = 'T'.
;;*
;;*  M       (input) INTEGER
;;*          On entry, M specifies the order of A and D, and the row
;;*          dimension of C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          On entry, N specifies the order of B and E, and the column
;;*          dimension of C, F, R and L.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA, M)
;;*          On entry, A contains an upper triangular matrix.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the matrix A. LDA >= max(1, M).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB, N)
;;*          On entry, B contains an upper triangular matrix.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the matrix B. LDB >= max(1, N).
;;*
;;*  C       (input/ output) COMPLEX*16 array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, C has been overwritten by the solution
;;*          R.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the matrix C. LDC >= max(1, M).
;;*
;;*  D       (input) COMPLEX*16 array, dimension (LDD, M)
;;*          On entry, D contains an upper triangular matrix.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the matrix D. LDD >= max(1, M).
;;*
;;*  E       (input) COMPLEX*16 array, dimension (LDE, N)
;;*          On entry, E contains an upper triangular matrix.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the matrix E. LDE >= max(1, N).
;;*
;;*  F       (input/ output) COMPLEX*16 array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1).
;;*          On exit, if IJOB = 0, F has been overwritten by the solution
;;*          L.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the matrix F. LDF >= max(1, M).
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          On exit, 0 <= SCALE <= 1. If 0 < SCALE < 1, the solutions
;;*          R and L (C and F on entry) will hold the solutions to a
;;*          slightly perturbed system but the input matrices A, B, D and
;;*          E have not been changed. If SCALE = 0, R and L will hold the
;;*          solutions to the homogeneous system with C = F = 0.
;;*          Normally, SCALE = 1.
;;*
;;*  RDSUM   (input/output) DOUBLE PRECISION
;;*          On entry, the sum of squares of computed contributions to
;;*          the Dif-estimate under computation by ZTGSYL, where the
;;*          scaling factor RDSCAL (see below) has been factored out.
;;*          On exit, the corresponding sum of squares updated with the
;;*          contributions from the current sub-system.
;;*          If TRANS = 'T' RDSUM is not touched.
;;*          NOTE: RDSUM only makes sense when ZTGSY2 is called by
;;*          ZTGSYL.
;;*
;;*  RDSCAL  (input/output) DOUBLE PRECISION
;;*          On entry, scaling factor used to prevent overflow in RDSUM.
;;*          On exit, RDSCAL is updated w.r.t. the current contributions
;;*          in RDSUM.
;;*          If TRANS = 'T', RDSCAL is not touched.
;;*          NOTE: RDSCAL only makes sense when ZTGSY2 is called by
;;*          ZTGSYL.
;;*
;;*  INFO    (output) INTEGER
;;*          On exit, if INFO is set to
;;*            =0: Successful exit
;;*            <0: If INFO = -i, input argument number i is illegal.
;;*            >0: The matrix pairs (A, D) and (B, E) have common or very
;;*                close eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgsy2 (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  rdsum  rdscal  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-double-)) d )
	((-idx0- (-int-)) ldd )
	((-idx3- (-double-)) e )
	((-idx0- (-int-)) lde )
	((-idx3- (-double-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) rdsum )
	((-idx0- (-double-)) rdscal )
	((-idx0- (-int-)) info )
	#{ ztgsy2_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($d,double), IDX_PTR($ldd,int), IDX_PTR($e,double), IDX_PTR($lde,int), IDX_PTR($f,double), IDX_PTR($ldf,int), IDX_PTR($scale,double), IDX_PTR($rdsum,double), IDX_PTR($rdscal,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztgsyl <trans>  <ijob>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <d>  <ldd>  <e>  <lde>  <f>  <ldf>  <scale>  <dif>  <work>  <lwork>  <iwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTGSYL solves the generalized Sylvester equation:
;;*
;;*              A * R - L * B = scale * C            (1)
;;*              D * R - L * E = scale * F
;;*
;;*  where R and L are unknown m-by-n matrices, (A, D), (B, E) and
;;*  (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
;;*  respectively, with complex entries. A, B, D and E are upper
;;*  triangular (i.e., (A,D) and (B,E) in generalized Schur form).
;;*
;;*  The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
;;*  is an output scaling factor chosen to avoid overflow.
;;*
;;*  In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
;;*  is defined as
;;*
;;*         Z = [ kron(In, A)  -kron(B', Im) ]        (2)
;;*             [ kron(In, D)  -kron(E', Im) ],
;;*
;;*  Here Ix is the identity matrix of size x and X' is the conjugate
;;*  transpose of X. Kron(X, Y) is the Kronecker product between the
;;*  matrices X and Y.
;;*
;;*  If TRANS = 'C', y in the conjugate transposed system Z'*y = scale*b
;;*  is solved for, which is equivalent to solve for R and L in
;;*
;;*              A' * R + D' * L = scale * C           (3)
;;*              R * B' + L * E' = scale * -F
;;*
;;*  This case (TRANS = 'C') is used to compute an one-norm-based estimate
;;*  of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
;;*  and (B,E), using ZLACON.
;;*
;;*  If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
;;*  Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
;;*  reciprocal of the smallest singular value of Z.
;;*
;;*  This is a level-3 BLAS algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': solve the generalized sylvester equation (1).
;;*          = 'C': solve the "conjugate transposed" system (3).
;;*
;;*  IJOB    (input) INTEGER
;;*          Specifies what kind of functionality to be performed.
;;*          =0: solve (1) only.
;;*          =1: The functionality of 0 and 3.
;;*          =2: The functionality of 0 and 4.
;;*          =3: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*              (look ahead strategy is used).
;;*          =4: Only an estimate of Dif[(A,D), (B,E)] is computed.
;;*              (ZGECON on sub-systems is used).
;;*          Not referenced if TRANS = 'C'.
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrices A and D, and the row dimension of
;;*          the matrices C, F, R and L.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrices B and E, and the column dimension
;;*          of the matrices C, F, R and L.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA, M)
;;*          The upper triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1, M).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB, N)
;;*          The upper triangular matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1, N).
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC, N)
;;*          On entry, C contains the right-hand-side of the first matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, C has been overwritten by
;;*          the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1, M).
;;*
;;*  D       (input) COMPLEX*16 array, dimension (LDD, M)
;;*          The upper triangular matrix D.
;;*
;;*  LDD     (input) INTEGER
;;*          The leading dimension of the array D. LDD >= max(1, M).
;;*
;;*  E       (input) COMPLEX*16 array, dimension (LDE, N)
;;*          The upper triangular matrix E.
;;*
;;*  LDE     (input) INTEGER
;;*          The leading dimension of the array E. LDE >= max(1, N).
;;*
;;*  F       (input/output) COMPLEX*16 array, dimension (LDF, N)
;;*          On entry, F contains the right-hand-side of the second matrix
;;*          equation in (1) or (3).
;;*          On exit, if IJOB = 0, 1 or 2, F has been overwritten by
;;*          the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
;;*          the solution achieved during the computation of the
;;*          Dif-estimate.
;;*
;;*  LDF     (input) INTEGER
;;*          The leading dimension of the array F. LDF >= max(1, M).
;;*
;;*  DIF     (output) DOUBLE PRECISION
;;*          On exit DIF is the reciprocal of a lower bound of the
;;*          reciprocal of the Dif-function, i.e. DIF is an upper bound of
;;*          Dif[(A,D), (B,E)] = sigma-min(Z), where Z as in (2).
;;*          IF IJOB = 0 or TRANS = 'C', DIF is not referenced.
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          On exit SCALE is the scaling factor in (1) or (3).
;;*          If 0 < SCALE < 1, C and F hold the solutions R and L, resp.,
;;*          to a slightly perturbed system but the input matrices A, B,
;;*          D and E have not been changed. If SCALE = 0, R and L will
;;*          hold the solutions to the homogenious system with C = F = 0.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          IF IJOB = 0, WORK is not referenced.  Otherwise,
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK > = 1.
;;*          If IJOB = 1 or 2 and TRANS = 'N', LWORK >= 2*M*N.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  IWORK   (workspace) INTEGER array, dimension (M+N+2)
;;*          If IJOB = 0, IWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*            =0: successful exit
;;*            <0: If INFO = -i, the i-th argument had an illegal value.
;;*            >0: (A, D) and (B, E) have common or very close
;;*                eigenvalues.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
;;*     Umea University, S-901 87 Umea, Sweden.
;;*
;;*  [1] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
;;*      for Solving the Generalized Sylvester Equation and Estimating the
;;*      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
;;*      Department of Computing Science, Umea University, S-901 87 Umea,
;;*      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
;;*      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
;;*      No 1, 1996.
;;*
;;*  [2] B. Kagstrom, A Perturbation Analysis of the Generalized Sylvester
;;*      Equation (AR - LB, DR - LE ) = (C, F), SIAM J. Matrix Anal.
;;*      Appl., 15(4):1045-1060, 1994.
;;*
;;*  [3] B. Kagstrom and L. Westin, Generalized Schur Methods with
;;*      Condition Estimators for Solving the Generalized Sylvester
;;*      Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7,
;;*      July 1989, pp 745-751.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztgsyl (trans  ijob  m  n  a  lda  b  ldb  c  ldc  d  ldd  e  lde  f  ldf  scale  dif  work  lwork  iwork  info  )
	((-str-) trans )
	((-idx0- (-int-)) ijob )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx3- (-double-)) d )
	((-idx0- (-int-)) ldd )
	((-idx3- (-double-)) e )
	((-idx0- (-int-)) lde )
	((-idx3- (-double-)) f )
	((-idx0- (-int-)) ldf )
	((-idx0- (-double-)) scale )
	((-idx0- (-double-)) dif )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx1- (-int-)) iwork )
	((-idx0- (-int-)) info )
	#{ ztgsyl_($trans->data, IDX_PTR($ijob,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($d,double), IDX_PTR($ldd,int), IDX_PTR($e,double), IDX_PTR($lde,int), IDX_PTR($f,double), IDX_PTR($ldf,int), IDX_PTR($scale,double), IDX_PTR($dif,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($iwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztpcon <norm>  <uplo>  <diag>  <n>  <ap>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTPCON estimates the reciprocal of the condition number of a packed
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztpcon (norm  uplo  diag  n  ap  rcond  work  rwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztpcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztprfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTPRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular packed
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by ZTPTRS or some other
;;*  means before entering this routine.  ZTPRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
;;*          If DIAG = 'U', the diagonal elements of A are not referenced
;;*          and are assumed to be 1.
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztprfs (uplo  trans  diag  n  nrhs  ap  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztprfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztptri <uplo>  <diag>  <n>  <ap>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTPTRI computes the inverse of a complex upper or lower triangular
;;*  matrix A stored in packed format.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          On entry, the upper or lower triangular matrix A, stored
;;*          columnwise in a linear array.  The j-th column of A is stored
;;*          in the array AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.
;;*          See below for further details.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same packed storage format.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular
;;*                matrix is singular and its inverse can not be computed.
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  A triangular matrix A can be transferred to packed storage using one
;;*  of the following program segments:
;;*
;;*  UPLO = 'U':                      UPLO = 'L':
;;*
;;*        JC = 1                           JC = 1
;;*        DO 2 J = 1, N                    DO 2 J = 1, N
;;*           DO 1 I = 1, J                    DO 1 I = J, N
;;*              AP(JC+I-1) = A(I,J)              AP(JC+I-J) = A(I,J)
;;*      1    CONTINUE                    1    CONTINUE
;;*           JC = JC + J                      JC = JC + N - J + 1
;;*      2 CONTINUE                       2 CONTINUE
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztptri (uplo  diag  n  ap  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx0- (-int-)) info )
	#{ ztptri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztptrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <ap>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTPTRS solves a triangular system of the form
;;*
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*
;;*  where A is a triangular matrix of order N stored in packed format,
;;*  and B is an N-by-NRHS matrix.  A check is made to verify that A is
;;*  nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The upper or lower triangular matrix A, packed columnwise in
;;*          a linear array.  The j-th column of A is stored in the array
;;*          AP as follows:
;;*          if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
;;*          if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*          > 0:  if INFO = i, the i-th diagonal element of A is zero,
;;*                indicating that the matrix is singular and the
;;*                solutions X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztptrs (uplo  trans  diag  n  nrhs  ap  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx2- (-double-)) ap )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ztptrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($ap,double), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrcon <norm>  <uplo>  <diag>  <n>  <a>  <lda>  <rcond>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRCON estimates the reciprocal of the condition number of a
;;*  triangular matrix A, in either the 1-norm or the infinity-norm.
;;*
;;*  The norm of A is computed and an estimate is obtained for
;;*  norm(inv(A)), then the reciprocal of the condition number is
;;*  computed as
;;*     RCOND = 1 / ( norm(A) * norm(inv(A)) ).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  NORM    (input) CHARACTER*1
;;*          Specifies whether the 1-norm condition number or the
;;*          infinity-norm condition number is required:
;;*          = '1' or 'O':  1-norm;
;;*          = 'I':         Infinity-norm.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  RCOND   (output) DOUBLE PRECISION
;;*          The reciprocal of the condition number of the matrix A,
;;*          computed as RCOND = 1/(norm(A) * norm(inv(A))).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrcon (norm  uplo  diag  n  a  lda  rcond  work  rwork  info  )
	((-str-) norm )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) rcond )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztrcon_($norm->data, $uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($rcond,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrevc <side>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <mm>  <m>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTREVC computes some or all of the right and/or left eigenvectors of
;;*  a complex upper triangular matrix T.
;;*
;;*  The right eigenvector x and the left eigenvector y of T corresponding
;;*  to an eigenvalue w are defined by:
;;*
;;*               T*x = w*x,     y'*T = w*y'
;;*
;;*  where y' denotes the conjugate transpose of the vector y.
;;*
;;*  If all eigenvectors are requested, the routine may either return the
;;*  matrices X and/or Y of right or left eigenvectors of T, or the
;;*  products Q*X and/or Q*Y, where Q is an input unitary
;;*  matrix. If T was obtained from the Schur factorization of an
;;*  original matrix A = Q*T*Q', then Q*X and Q*Y are the matrices of
;;*  right or left eigenvectors of A.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'R':  compute right eigenvectors only;
;;*          = 'L':  compute left eigenvectors only;
;;*          = 'B':  compute both right and left eigenvectors.
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A':  compute all right and/or left eigenvectors;
;;*          = 'B':  compute all right and/or left eigenvectors,
;;*                  and backtransform them using the input matrices
;;*                  supplied in VR and/or VL;
;;*          = 'S':  compute selected right and/or left eigenvectors,
;;*                  specified by the logical array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenvectors to be
;;*          computed.
;;*          If HOWMNY = 'A' or 'B', SELECT is not referenced.
;;*          To select the eigenvector corresponding to the j-th
;;*          eigenvalue, SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) COMPLEX*16 array, dimension (LDT,N)
;;*          The upper triangular matrix T.  T is modified, but restored
;;*          on exit.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input/output) COMPLEX*16 array, dimension (LDVL,MM)
;;*          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Q of
;;*          Schur vectors returned by ZHSEQR).
;;*          On exit, if SIDE = 'L' or 'B', VL contains:
;;*          if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
;;*                           VL is lower triangular. The i-th column
;;*                           VL(i) of VL is the eigenvector corresponding
;;*                           to T(i,i).
;;*          if HOWMNY = 'B', the matrix Q*Y;
;;*          if HOWMNY = 'S', the left eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VL, in the same order as their
;;*                           eigenvalues.
;;*          If SIDE = 'R', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.  LDVL >= max(1,N) if
;;*          SIDE = 'L' or 'B'; LDVL >= 1 otherwise.
;;*
;;*  VR      (input/output) COMPLEX*16 array, dimension (LDVR,MM)
;;*          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
;;*          contain an N-by-N matrix Q (usually the unitary matrix Q of
;;*          Schur vectors returned by ZHSEQR).
;;*          On exit, if SIDE = 'R' or 'B', VR contains:
;;*          if HOWMNY = 'A', the matrix X of right eigenvectors of T;
;;*                           VR is upper triangular. The i-th column
;;*                           VR(i) of VR is the eigenvector corresponding
;;*                           to T(i,i).
;;*          if HOWMNY = 'B', the matrix Q*X;
;;*          if HOWMNY = 'S', the right eigenvectors of T specified by
;;*                           SELECT, stored consecutively in the columns
;;*                           of VR, in the same order as their
;;*                           eigenvalues.
;;*          If SIDE = 'L', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.  LDVR >= max(1,N) if
;;*           SIDE = 'R' or 'B'; LDVR >= 1 otherwise.
;;*
;;*  MM      (input) INTEGER
;;*          The number of columns in the arrays VL and/or VR. MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of columns in the arrays VL and/or VR actually
;;*          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
;;*          is set to N.  Each selected eigenvector occupies one
;;*          column.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The algorithm used in this program is basically backward (forward)
;;*  substitution, with scaling to make the the code robust against
;;*  possible overflow.
;;*
;;*  Each eigenvector is normalized so that the element of largest
;;*  magnitude has magnitude 1; here the magnitude of a complex number
;;*  (x,y) is taken to be |x| + |y|.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrevc (side  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  mm  m  work  rwork  info  )
	((-str-) side )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztrevc_($side->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrexc <compq>  <n>  <t_>  <ldt>  <q>  <ldq>  <ifst>  <ilst>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTREXC reorders the Schur factorization of a complex matrix
;;*  A = Q*T*Q**H, so that the diagonal element of T with row index IFST
;;*  is moved to row ILST.
;;*
;;*  The Schur form T is reordered by a unitary similarity transformation
;;*  Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
;;*  postmultplying it with Z.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V':  update the matrix Q of Schur vectors;
;;*          = 'N':  do not update Q.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) COMPLEX*16 array, dimension (LDT,N)
;;*          On entry, the upper triangular matrix T.
;;*          On exit, the reordered upper triangular matrix.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          unitary transformation matrix Z which reorders T.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.  LDQ >= max(1,N).
;;*
;;*  IFST    (input) INTEGER
;;*  ILST    (input) INTEGER
;;*          Specify the reordering of the diagonal elements of T:
;;*          The element with row index IFST is moved to row ILST by a
;;*          sequence of transpositions between adjacent elements.
;;*          1 <= IFST <= N; 1 <= ILST <= N.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de ztrexc (compq  n  t_  ldt  q  ldq  ifst  ilst  info  )
	((-str-) compq )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx0- (-int-)) ifst )
	((-idx0- (-int-)) ilst )
	((-idx0- (-int-)) info )
	#{ ztrexc_($compq->data, IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($ifst,int), IDX_PTR($ilst,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrrfs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <x>  <ldx>  <ferr>  <berr>  <work>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRRFS provides error bounds and backward error estimates for the
;;*  solution to a system of linear equations with a triangular
;;*  coefficient matrix.
;;*
;;*  The solution matrix X must be computed by ZTRTRS or some other
;;*  means before entering this routine.  ZTRRFS does not do iterative
;;*  refinement because doing so cannot improve the backward error.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrices B and X.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          The right hand side matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  X       (input) COMPLEX*16 array, dimension (LDX,NRHS)
;;*          The solution matrix X.
;;*
;;*  LDX     (input) INTEGER
;;*          The leading dimension of the array X.  LDX >= max(1,N).
;;*
;;*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The estimated forward error bound for each solution vector
;;*          X(j) (the j-th column of the solution matrix X).
;;*          If XTRUE is the true solution corresponding to X(j), FERR(j)
;;*          is an estimated upper bound for the magnitude of the largest
;;*          element in (X(j) - XTRUE) divided by the magnitude of the
;;*          largest element in X(j).  The estimate is as reliable as
;;*          the estimate for RCOND, and is almost always a slight
;;*          overestimate of the true error.
;;*
;;*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)
;;*          The componentwise relative backward error of each solution
;;*          vector X(j) (i.e., the smallest relative change in
;;*          any element of A or B that makes X(j) an exact solution).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrrfs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  x  ldx  ferr  berr  work  rwork  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) x )
	((-idx0- (-int-)) ldx )
	((-idx1- (-double-)) ferr )
	((-idx1- (-double-)) berr )
	((-idx2- (-double-)) work )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztrrfs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($x,double), IDX_PTR($ldx,int), IDX_PTR($ferr,double), IDX_PTR($berr,double), IDX_PTR($work,double), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrsen <job>  <compq>  <select>  <n>  <t_>  <ldt>  <q>  <ldq>  <w>  <m>  <s>  <sep>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRSEN reorders the Schur factorization of a complex matrix
;;*  A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
;;*  the leading positions on the diagonal of the upper triangular matrix
;;*  T, and the leading columns of Q form an orthonormal basis of the
;;*  corresponding right invariant subspace.
;;*
;;*  Optionally the routine computes the reciprocal condition numbers of
;;*  the cluster of eigenvalues and/or the invariant subspace.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for the
;;*          cluster of eigenvalues (S) or the invariant subspace (SEP):
;;*          = 'N': none;
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for invariant subspace only (SEP);
;;*          = 'B': for both eigenvalues and invariant subspace (S and
;;*                 SEP).
;;*
;;*  COMPQ   (input) CHARACTER*1
;;*          = 'V': update the matrix Q of Schur vectors;
;;*          = 'N': do not update Q.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          SELECT specifies the eigenvalues in the selected cluster. To
;;*          select the j-th eigenvalue, SELECT(j) must be set to .TRUE..
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input/output) COMPLEX*16 array, dimension (LDT,N)
;;*          On entry, the upper triangular matrix T.
;;*          On exit, T is overwritten by the reordered matrix T, with the
;;*          selected eigenvalues as the leading diagonal elements.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
;;*          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
;;*          On exit, if COMPQ = 'V', Q has been postmultiplied by the
;;*          unitary transformation matrix which reorders T; the leading M
;;*          columns of Q form an orthonormal basis for the specified
;;*          invariant subspace.
;;*          If COMPQ = 'N', Q is not referenced.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q.
;;*          LDQ >= 1; and if COMPQ = 'V', LDQ >= N.
;;*
;;*  W       (output) COMPLEX*16 array, dimension (N)
;;*          The reordered eigenvalues of T, in the same order as they
;;*          appear on the diagonal of T.
;;*
;;*  M       (output) INTEGER
;;*          The dimension of the specified invariant subspace.
;;*          0 <= M <= N.
;;*
;;*  S       (output) DOUBLE PRECISION
;;*          If JOB = 'E' or 'B', S is a lower bound on the reciprocal
;;*          condition number for the selected cluster of eigenvalues.
;;*          S cannot underestimate the true reciprocal condition number
;;*          by more than a factor of sqrt(N). If M = 0 or N, S = 1.
;;*          If JOB = 'N' or 'V', S is not referenced.
;;*
;;*  SEP     (output) DOUBLE PRECISION
;;*          If JOB = 'V' or 'B', SEP is the estimated reciprocal
;;*          condition number of the specified invariant subspace. If
;;*          M = 0 or N, SEP = norm(T).
;;*          If JOB = 'N' or 'E', SEP is not referenced.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          If JOB = 'N', WORK is not referenced.  Otherwise,
;;*          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If JOB = 'N', LWORK >= 1;
;;*          if JOB = 'E', LWORK = M*(N-M);
;;*          if JOB = 'V' or 'B', LWORK >= 2*M*(N-M).
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  ZTRSEN first collects the selected eigenvalues by computing a unitary
;;*  transformation Z to move them to the top left corner of T. In other
;;*  words, the selected eigenvalues are the eigenvalues of T11 in:
;;*
;;*                Z'*T*Z = ( T11 T12 ) n1
;;*                         (  0  T22 ) n2
;;*                            n1  n2
;;*
;;*  where N = n1+n2 and Z' means the conjugate transpose of Z. The first
;;*  n1 columns of Z span the specified invariant subspace of T.
;;*
;;*  If T has been obtained from the Schur factorization of a matrix
;;*  A = Q*T*Q', then the reordered Schur factorization of A is given by
;;*  A = (Q*Z)*(Z'*T*Z)*(Q*Z)', and the first n1 columns of Q*Z span the
;;*  corresponding invariant subspace of A.
;;*
;;*  The reciprocal condition number of the average of the eigenvalues of
;;*  T11 may be returned in S. S lies between 0 (very badly conditioned)
;;*  and 1 (very well conditioned). It is computed as follows. First we
;;*  compute R so that
;;*
;;*                         P = ( I  R ) n1
;;*                             ( 0  0 ) n2
;;*                               n1 n2
;;*
;;*  is the projector on the invariant subspace associated with T11.
;;*  R is the solution of the Sylvester equation:
;;*
;;*                        T11*R - R*T22 = T12.
;;*
;;*  Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
;;*  the two-norm of M. Then S is computed as the lower bound
;;*
;;*                      (1 + F-norm(R)**2)**(-1/2)
;;*
;;*  on the reciprocal of 2-norm(P), the true reciprocal condition number.
;;*  S cannot underestimate 1 / 2-norm(P) by more than a factor of
;;*  sqrt(N).
;;*
;;*  An approximate error bound for the computed average of the
;;*  eigenvalues of T11 is
;;*
;;*                         EPS * norm(T) / S
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal condition number of the right invariant subspace
;;*  spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
;;*  SEP is defined as the separation of T11 and T22:
;;*
;;*                     sep( T11, T22 ) = sigma-min( C )
;;*
;;*  where sigma-min(C) is the smallest singular value of the
;;*  n1*n2-by-n1*n2 matrix
;;*
;;*     C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )
;;*
;;*  I(m) is an m by m identity matrix, and kprod denotes the Kronecker
;;*  product. We estimate sigma-min(C) by the reciprocal of an estimate of
;;*  the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
;;*  cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).
;;*
;;*  When SEP is small, small changes in T can cause large changes in
;;*  the invariant subspace. An approximate bound on the maximum angular
;;*  error in the computed right invariant subspace is
;;*
;;*                      EPS * norm(T) / SEP
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrsen (job  compq  select  n  t_  ldt  q  ldq  w  m  s  sep  work  lwork  info  )
	((-str-) job )
	((-str-) compq )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) w )
	((-idx0- (-int-)) m )
	((-idx0- (-double-)) s )
	((-idx0- (-double-)) sep )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ztrsen_($job->data, $compq->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($w,double), IDX_PTR($m,int), IDX_PTR($s,double), IDX_PTR($sep,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrsna <job>  <howmny>  <select>  <n>  <t_>  <ldt>  <vl>  <ldvl>  <vr>  <ldvr>  <s>  <sep>  <mm>  <m>  <work>  <ldwork>  <rwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRSNA estimates reciprocal condition numbers for specified
;;*  eigenvalues and/or right eigenvectors of a complex upper triangular
;;*  matrix T (or of any matrix Q*T*Q**H with Q unitary).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  JOB     (input) CHARACTER*1
;;*          Specifies whether condition numbers are required for
;;*          eigenvalues (S) or eigenvectors (SEP):
;;*          = 'E': for eigenvalues only (S);
;;*          = 'V': for eigenvectors only (SEP);
;;*          = 'B': for both eigenvalues and eigenvectors (S and SEP).
;;*
;;*  HOWMNY  (input) CHARACTER*1
;;*          = 'A': compute condition numbers for all eigenpairs;
;;*          = 'S': compute condition numbers for selected eigenpairs
;;*                 specified by the array SELECT.
;;*
;;*  SELECT  (input) LOGICAL array, dimension (N)
;;*          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
;;*          condition numbers are required. To select condition numbers
;;*          for the j-th eigenpair, SELECT(j) must be set to .TRUE..
;;*          If HOWMNY = 'A', SELECT is not referenced.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix T. N >= 0.
;;*
;;*  T       (input) COMPLEX*16 array, dimension (LDT,N)
;;*          The upper triangular matrix T.
;;*
;;*  LDT     (input) INTEGER
;;*          The leading dimension of the array T. LDT >= max(1,N).
;;*
;;*  VL      (input) COMPLEX*16 array, dimension (LDVL,M)
;;*          If JOB = 'E' or 'B', VL must contain left eigenvectors of T
;;*          (or of any Q*T*Q**H with Q unitary), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VL, as returned by
;;*          ZHSEIN or ZTREVC.
;;*          If JOB = 'V', VL is not referenced.
;;*
;;*  LDVL    (input) INTEGER
;;*          The leading dimension of the array VL.
;;*          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N.
;;*
;;*  VR      (input) COMPLEX*16 array, dimension (LDVR,M)
;;*          If JOB = 'E' or 'B', VR must contain right eigenvectors of T
;;*          (or of any Q*T*Q**H with Q unitary), corresponding to the
;;*          eigenpairs specified by HOWMNY and SELECT. The eigenvectors
;;*          must be stored in consecutive columns of VR, as returned by
;;*          ZHSEIN or ZTREVC.
;;*          If JOB = 'V', VR is not referenced.
;;*
;;*  LDVR    (input) INTEGER
;;*          The leading dimension of the array VR.
;;*          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N.
;;*
;;*  S       (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'E' or 'B', the reciprocal condition numbers of the
;;*          selected eigenvalues, stored in consecutive elements of the
;;*          array. Thus S(j), SEP(j), and the j-th columns of VL and VR
;;*          all correspond to the same eigenpair (but not in general the
;;*          j-th eigenpair, unless all eigenpairs are selected).
;;*          If JOB = 'V', S is not referenced.
;;*
;;*  SEP     (output) DOUBLE PRECISION array, dimension (MM)
;;*          If JOB = 'V' or 'B', the estimated reciprocal condition
;;*          numbers of the selected eigenvectors, stored in consecutive
;;*          elements of the array.
;;*          If JOB = 'E', SEP is not referenced.
;;*
;;*  MM      (input) INTEGER
;;*          The number of elements in the arrays S (if JOB = 'E' or 'B')
;;*           and/or SEP (if JOB = 'V' or 'B'). MM >= M.
;;*
;;*  M       (output) INTEGER
;;*          The number of elements of the arrays S and/or SEP actually
;;*          used to store the estimated condition numbers.
;;*          If HOWMNY = 'A', M is set to N.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (LDWORK,N+1)
;;*          If JOB = 'E', WORK is not referenced.
;;*
;;*  LDWORK  (input) INTEGER
;;*          The leading dimension of the array WORK.
;;*          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N.
;;*
;;*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)
;;*          If JOB = 'E', RWORK is not referenced.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The reciprocal of the condition number of an eigenvalue lambda is
;;*  defined as
;;*
;;*          S(lambda) = |v'*u| / (norm(u)*norm(v))
;;*
;;*  where u and v are the right and left eigenvectors of T corresponding
;;*  to lambda; v' denotes the conjugate transpose of v, and norm(u)
;;*  denotes the Euclidean norm. These reciprocal condition numbers always
;;*  lie between zero (very badly conditioned) and one (very well
;;*  conditioned). If n = 1, S(lambda) is defined to be 1.
;;*
;;*  An approximate error bound for a computed eigenvalue W(i) is given by
;;*
;;*                      EPS * norm(T) / S(i)
;;*
;;*  where EPS is the machine precision.
;;*
;;*  The reciprocal of the condition number of the right eigenvector u
;;*  corresponding to lambda is defined as follows. Suppose
;;*
;;*              T = ( lambda  c  )
;;*                  (   0    T22 )
;;*
;;*  Then the reciprocal condition number is
;;*
;;*          SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )
;;*
;;*  where sigma-min denotes the smallest singular value. We approximate
;;*  the smallest singular value by the reciprocal of an estimate of the
;;*  one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is
;;*  defined to be abs(T(1,1)).
;;*
;;*  An approximate error bound for a computed right eigenvector VR(i)
;;*  is given by
;;*
;;*                      EPS * norm(T) / SEP(i)
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrsna (job  howmny  select  n  t_  ldt  vl  ldvl  vr  ldvr  s  sep  mm  m  work  ldwork  rwork  info  )
	((-str-) job )
	((-str-) howmny )
	((-idx1- (-int-)) select )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) t_ )
	((-idx0- (-int-)) ldt )
	((-idx3- (-double-)) vl )
	((-idx0- (-int-)) ldvl )
	((-idx3- (-double-)) vr )
	((-idx0- (-int-)) ldvr )
	((-idx1- (-double-)) s )
	((-idx1- (-double-)) sep )
	((-idx0- (-int-)) mm )
	((-idx0- (-int-)) m )
	((-idx3- (-double-)) work )
	((-idx0- (-int-)) ldwork )
	((-idx1- (-double-)) rwork )
	((-idx0- (-int-)) info )
	#{ ztrsna_($job->data, $howmny->data, IDX_PTR($select,int), IDX_PTR($n,int), IDX_PTR($t_,double), IDX_PTR($ldt,int), IDX_PTR($vl,double), IDX_PTR($ldvl,int), IDX_PTR($vr,double), IDX_PTR($ldvr,int), IDX_PTR($s,double), IDX_PTR($sep,double), IDX_PTR($mm,int), IDX_PTR($m,int), IDX_PTR($work,double), IDX_PTR($ldwork,int), IDX_PTR($rwork,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrsyl <trana>  <tranb>  <isgn>  <m>  <n>  <a>  <lda>  <b>  <ldb>  <c>  <ldc>  <scale>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRSYL solves the complex Sylvester matrix equation:
;;*
;;*     op(A)*X + X*op(B) = scale*C or
;;*     op(A)*X - X*op(B) = scale*C,
;;*
;;*  where op(A) = A or A**H, and A and B are both upper triangular. A is
;;*  M-by-M and B is N-by-N; the right hand side C and the solution X are
;;*  M-by-N; and scale is an output scale factor, set <= 1 to avoid
;;*  overflow in X.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  TRANA   (input) CHARACTER*1
;;*          Specifies the option op(A):
;;*          = 'N': op(A) = A    (No transpose)
;;*          = 'C': op(A) = A**H (Conjugate transpose)
;;*
;;*  TRANB   (input) CHARACTER*1
;;*          Specifies the option op(B):
;;*          = 'N': op(B) = B    (No transpose)
;;*          = 'C': op(B) = B**H (Conjugate transpose)
;;*
;;*  ISGN    (input) INTEGER
;;*          Specifies the sign in the equation:
;;*          = +1: solve op(A)*X + X*op(B) = scale*C
;;*          = -1: solve op(A)*X - X*op(B) = scale*C
;;*
;;*  M       (input) INTEGER
;;*          The order of the matrix A, and the number of rows in the
;;*          matrices X and C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix B, and the number of columns in the
;;*          matrices X and C. N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,M)
;;*          The upper triangular matrix A.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,M).
;;*
;;*  B       (input) COMPLEX*16 array, dimension (LDB,N)
;;*          The upper triangular matrix B.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B. LDB >= max(1,N).
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N right hand side matrix C.
;;*          On exit, C is overwritten by the solution matrix X.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M)
;;*
;;*  SCALE   (output) DOUBLE PRECISION
;;*          The scale factor, scale, set <= 1 to avoid overflow in X.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          = 1: A and B have common or very close eigenvalues; perturbed
;;*               values were used to solve the equation (but the matrices
;;*               A and B are unchanged).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrsyl (trana  tranb  isgn  m  n  a  lda  b  ldb  c  ldc  scale  info  )
	((-str-) trana )
	((-str-) tranb )
	((-idx0- (-int-)) isgn )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx0- (-double-)) scale )
	((-idx0- (-int-)) info )
	#{ ztrsyl_($trana->data, $tranb->data, IDX_PTR($isgn,int), IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($scale,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrti2 <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRTI2 computes the inverse of a complex upper or lower triangular
;;*  matrix.
;;*
;;*  This is the Level 2 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          Specifies whether the matrix A is upper or lower triangular.
;;*          = 'U':  Upper triangular
;;*          = 'L':  Lower triangular
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          Specifies whether or not the matrix A is unit triangular.
;;*          = 'N':  Non-unit triangular
;;*          = 'U':  Unit triangular
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading n by n upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading n by n lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -k, the k-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrti2 (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ ztrti2_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrtri <uplo>  <diag>  <n>  <a>  <lda>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRTRI computes the inverse of a complex upper or lower triangular
;;*  matrix A.
;;*
;;*  This is the Level 3 BLAS version of the algorithm.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the triangular matrix A.  If UPLO = 'U', the
;;*          leading N-by-N upper triangular part of the array A contains
;;*          the upper triangular matrix, and the strictly lower
;;*          triangular part of A is not referenced.  If UPLO = 'L', the
;;*          leading N-by-N lower triangular part of the array A contains
;;*          the lower triangular matrix, and the strictly upper
;;*          triangular part of A is not referenced.  If DIAG = 'U', the
;;*          diagonal elements of A are also not referenced and are
;;*          assumed to be 1.
;;*          On exit, the (triangular) inverse of the original matrix, in
;;*          the same storage format.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
;;*               matrix is singular and its inverse can not be computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrtri (uplo  diag  n  a  lda  info  )
	((-str-) uplo )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-int-)) info )
	#{ ztrtri_($uplo->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztrtrs <uplo>  <trans>  <diag>  <n>  <nrhs>  <a>  <lda>  <b>  <ldb>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTRTRS solves a triangular system of the form
;;*
;;*     A * X = B,  A**T * X = B,  or  A**H * X = B,
;;*
;;*  where A is a triangular matrix of order N, and B is an N-by-NRHS
;;*  matrix.  A check is made to verify that A is nonsingular.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U':  A is upper triangular;
;;*          = 'L':  A is lower triangular.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          Specifies the form of the system of equations:
;;*          = 'N':  A * X = B     (No transpose)
;;*          = 'T':  A**T * X = B  (Transpose)
;;*          = 'C':  A**H * X = B  (Conjugate transpose)
;;*
;;*  DIAG    (input) CHARACTER*1
;;*          = 'N':  A is non-unit triangular;
;;*          = 'U':  A is unit triangular.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix A.  N >= 0.
;;*
;;*  NRHS    (input) INTEGER
;;*          The number of right hand sides, i.e., the number of columns
;;*          of the matrix B.  NRHS >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,N)
;;*          The triangular matrix A.  If UPLO = 'U', the leading N-by-N
;;*          upper triangular part of the array A contains the upper
;;*          triangular matrix, and the strictly lower triangular part of
;;*          A is not referenced.  If UPLO = 'L', the leading N-by-N lower
;;*          triangular part of the array A contains the lower triangular
;;*          matrix, and the strictly upper triangular part of A is not
;;*          referenced.  If DIAG = 'U', the diagonal elements of A are
;;*          also not referenced and are assumed to be 1.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,N).
;;*
;;*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)
;;*          On entry, the right hand side matrix B.
;;*          On exit, if INFO = 0, the solution matrix X.
;;*
;;*  LDB     (input) INTEGER
;;*          The leading dimension of the array B.  LDB >= max(1,N).
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*          > 0: if INFO = i, the i-th diagonal element of A is zero,
;;*               indicating that the matrix is singular and the solutions
;;*               X have not been computed.
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztrtrs (uplo  trans  diag  n  nrhs  a  lda  b  ldb  info  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) nrhs )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-int-)) info )
	#{ ztrtrs_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($nrhs,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztzrqf <m>  <n>  <a>  <lda>  <tau>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  This routine is deprecated and has been replaced by routine ZTZRZF.
;;*
;;*  ZTZRQF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
;;*  to upper triangular form by means of unitary transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N unitary matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= M.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          unitary matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  The  factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), whose conjugate transpose is used to
;;*  introduce zeros into the (m - k + 1)th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;* =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztzrqf (m  n  a  lda  tau  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx0- (-int-)) info )
	#{ ztzrqf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (ztzrzf <m>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
;;*  to upper triangular form by means of unitary transformations.
;;*
;;*  The upper trapezoidal matrix A is factored as
;;*
;;*     A = ( R  0 ) * Z,
;;*
;;*  where Z is an N-by-N unitary matrix and R is an M-by-M upper
;;*  triangular matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix A.  M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix A.  N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the leading M-by-N upper trapezoidal part of the
;;*          array A must contain the matrix to be factorized.
;;*          On exit, the leading M-by-M upper triangular part of A
;;*          contains the upper triangular matrix R, and elements M+1 to
;;*          N of the first M rows of A, with the array TAU, represent the
;;*          unitary matrix Z as a product of M elementary reflectors.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.  LDA >= max(1,M).
;;*
;;*  TAU     (output) COMPLEX*16 array, dimension (M)
;;*          The scalar factors of the elementary reflectors.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.  LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  The factorization is obtained by Householder's method.  The kth
;;*  transformation matrix, Z( k ), which is used to introduce zeros into
;;*  the ( m - k + 1 )th row of A, is given in the form
;;*
;;*     Z( k ) = ( I     0   ),
;;*              ( 0  T( k ) )
;;*
;;*  where
;;*
;;*     T( k ) = I - tau*u( k )*u( k )',   u( k ) = (   1    ),
;;*                                                 (   0    )
;;*                                                 ( z( k ) )
;;*
;;*  tau is a scalar and z( k ) is an ( n - m ) element vector.
;;*  tau and z( k ) are chosen to annihilate the elements of the kth row
;;*  of X.
;;*
;;*  The scalar tau is returned in the kth element of TAU and the vector
;;*  u( k ) in the kth row of A, such that the elements of z( k ) are
;;*  in  a( k, m + 1 ), ..., a( k, n ). The elements of R are returned in
;;*  the upper triangular part of A.
;;*
;;*  Z is given by
;;*
;;*     Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ztzrzf (m  n  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ ztzrzf_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zung2l <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNG2L generates an m by n complex matrix Q with orthonormal columns,
;;*  which is defined as the last n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by ZGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by ZGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQLF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zung2l (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zung2l_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zung2r <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNG2R generates an m by n complex matrix Q with orthonormal columns,
;;*  which is defined as the first n columns of a product of k elementary
;;*  reflectors of order m
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by ZGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by ZGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQRF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zung2r (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zung2r_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungbr <vect>  <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGBR generates one of the complex unitary matrices Q or P**H
;;*  determined by ZGEBRD when reducing a complex matrix A to bidiagonal
;;*  form: A = Q * B * P**H.  Q and P**H are defined as products of
;;*  elementary reflectors H(i) or G(i) respectively.
;;*
;;*  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
;;*  is of order M:
;;*  if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
;;*  columns of Q, where m >= n >= k;
;;*  if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
;;*  M-by-M matrix.
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
;;*  is of order N:
;;*  if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
;;*  rows of P**H, where n >= m >= k;
;;*  if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
;;*  an N-by-N matrix.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          Specifies whether the matrix Q or the matrix P**H is
;;*          required, as defined in the transformation applied by ZGEBRD:
;;*          = 'Q':  generate Q;
;;*          = 'P':  generate P**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q or P**H to be returned.
;;*          M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q or P**H to be returned.
;;*          N >= 0.
;;*          If VECT = 'Q', M >= N >= min(M,K);
;;*          if VECT = 'P', N >= M >= min(N,K).
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original M-by-K
;;*          matrix reduced by ZGEBRD.
;;*          If VECT = 'P', the number of rows in the original K-by-N
;;*          matrix reduced by ZGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by ZGEBRD.
;;*          On exit, the M-by-N matrix Q or P**H.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= M.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension
;;*                                (min(M,K)) if VECT = 'Q'
;;*                                (min(N,K)) if VECT = 'P'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i), which determines Q or P**H, as
;;*          returned by ZGEBRD in its array argument TAUQ or TAUP.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,min(M,N)).
;;*          For optimum performance LWORK >= min(M,N)*NB, where NB
;;*          is the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungbr (vect  m  n  k  a  lda  tau  work  lwork  info  )
	((-str-) vect )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zungbr_($vect->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunghr <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGHR generates a complex unitary matrix Q which is defined as the
;;*  product of IHI-ILO elementary reflectors of order N, as returned by
;;*  ZGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of ZGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by ZGEHRD.
;;*          On exit, the N-by-N unitary matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEHRD.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= IHI-ILO.
;;*          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunghr (n  ilo  ihi  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunghr_(IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungl2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
;;*  which is defined as the first m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by ZGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by ZGELQF in the first k rows of its array argument A.
;;*          On exit, the m by n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGELQF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungl2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zungl2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunglq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
;;*  which is defined as the first M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by ZGELQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the i-th row must contain the vector which defines
;;*          the elementary reflector H(i), for i = 1,2,...,k, as returned
;;*          by ZGELQF in the first k rows of its array argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGELQF.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit;
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunglq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunglq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungql <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
;;*  which is defined as the last N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(k) . . . H(2) H(1)
;;*
;;*  as returned by ZGEQLF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the (n-k+i)-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by ZGEQLF in the last k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQLF.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungql (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zungql_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungqr <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
;;*  which is defined as the first N columns of a product of K elementary
;;*  reflectors of order M
;;*
;;*        Q  =  H(1) H(2) . . . H(k)
;;*
;;*  as returned by ZGEQRF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. M >= N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. N >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the i-th column must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by ZGEQRF in the first k columns of its array
;;*          argument A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQRF.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,N).
;;*          For optimum performance LWORK >= N*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungqr (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zungqr_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungr2 <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGR2 generates an m by n complex matrix Q with orthonormal rows,
;;*  which is defined as the last m rows of a product of k elementary
;;*  reflectors of order n
;;*
;;*        Q  =  H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by ZGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by ZGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the m-by-n matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGERQF.
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (M)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungr2 (m  n  k  a  lda  tau  work  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zungr2_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungrq <m>  <n>  <k>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
;;*  which is defined as the last M rows of a product of K elementary
;;*  reflectors of order N
;;*
;;*        Q  =  H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by ZGERQF.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix Q. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix Q. N >= M.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines the
;;*          matrix Q. M >= K >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the (m-k+i)-th row must contain the vector which
;;*          defines the elementary reflector H(i), for i = 1,2,...,k, as
;;*          returned by ZGERQF in the last k rows of its array argument
;;*          A.
;;*          On exit, the M-by-N matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The first dimension of the array A. LDA >= max(1,M).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGERQF.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= max(1,M).
;;*          For optimum performance LWORK >= M*NB, where NB is the
;;*          optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument has an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungrq (m  n  k  a  lda  tau  work  lwork  info  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zungrq_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zungtr <uplo>  <n>  <a>  <lda>  <tau>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNGTR generates a complex unitary matrix Q which is defined as the
;;*  product of n-1 elementary reflectors of order N, as returned by
;;*  ZHETRD:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from ZHETRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from ZHETRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
;;*          On entry, the vectors which define the elementary reflectors,
;;*          as returned by ZHETRD.
;;*          On exit, the N-by-N unitary matrix Q.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= N.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZHETRD.
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK. LWORK >= N-1.
;;*          For optimum performance LWORK >= (N-1)*NB, where NB is
;;*          the optimal blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zungtr (uplo  n  a  lda  tau  work  lwork  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zungtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunm2l <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNM2L overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by ZGEQLF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQLF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunm2l (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zunm2l_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunm2r <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNM2R overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by ZGEQRF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQRF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunm2r (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zunm2r_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmbr <vect>  <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
;;*  with
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      P * C          C * P
;;*  TRANS = 'C':      P**H * C       C * P**H
;;*
;;*  Here Q and P**H are the unitary matrices determined by ZGEBRD when
;;*  reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
;;*  and P**H are defined as products of elementary reflectors H(i) and
;;*  G(i) respectively.
;;*
;;*  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
;;*  order of the unitary matrix Q or P**H that is applied.
;;*
;;*  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
;;*  if nq >= k, Q = H(1) H(2) . . . H(k);
;;*  if nq < k, Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
;;*  if k < nq, P = G(1) G(2) . . . G(k);
;;*  if k >= nq, P = G(1) G(2) . . . G(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  VECT    (input) CHARACTER*1
;;*          = 'Q': apply Q or Q**H;
;;*          = 'P': apply P or P**H.
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q, Q**H, P or P**H from the Left;
;;*          = 'R': apply Q, Q**H, P or P**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q or P;
;;*          = 'C':  Conjugate transpose, apply Q**H or P**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          If VECT = 'Q', the number of columns in the original
;;*          matrix reduced by ZGEBRD.
;;*          If VECT = 'P', the number of rows in the original
;;*          matrix reduced by ZGEBRD.
;;*          K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                                (LDA,min(nq,K)) if VECT = 'Q'
;;*                                (LDA,nq)        if VECT = 'P'
;;*          The vectors which define the elementary reflectors H(i) and
;;*          G(i), whose products determine the matrices Q and P, as
;;*          returned by ZGEBRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If VECT = 'Q', LDA >= max(1,nq);
;;*          if VECT = 'P', LDA >= max(1,min(nq,K)).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (min(nq,K))
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i) or G(i) which determines Q or P, as returned
;;*          by ZGEBRD in the array argument TAUQ or TAUP.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
;;*          or P*C or P**H*C or C*P or C*P**H.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zunmbr (vect  side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) vect )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmbr_($vect->data, $side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmhr <side>  <trans>  <m>  <n>  <ilo>  <ihi>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMHR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  IHI-ILO elementary reflectors, as returned by ZGEHRD:
;;*
;;*  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q**H (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  ILO     (input) INTEGER
;;*  IHI     (input) INTEGER
;;*          ILO and IHI must have the same values as in the previous call
;;*          of ZGEHRD. Q is equal to the unit matrix except in the
;;*          submatrix Q(ilo+1:ihi,ilo+1:ihi).
;;*          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
;;*          ILO = 1 and IHI = 0, if M = 0;
;;*          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
;;*          ILO = 1 and IHI = 0, if N = 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by ZGEHRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEHRD.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zunmhr (side  trans  m  n  ilo  ihi  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) ilo )
	((-idx0- (-int-)) ihi )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmhr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ilo,int), IDX_PTR($ihi,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunml2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNML2 overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by ZGELQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGELQF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunml2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zunml2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmlq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMLQ overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k)' . . . H(2)' H(1)'
;;*
;;*  as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGELQF in the first k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGELQF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunmlq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmlq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmql <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMQL overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(k) . . . H(2) H(1)
;;*
;;*  as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGEQLF in the last k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQLF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunmql (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmql_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmqr <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMQR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension (LDA,K)
;;*          The i-th column must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGEQRF in the first k columns of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          If SIDE = 'L', LDA >= max(1,M);
;;*          if SIDE = 'R', LDA >= max(1,N).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGEQRF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunmqr (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmqr_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmr2 <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMR2 overwrites the general complex m-by-n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by ZGERQF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGERQF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunmr2 (side  trans  m  n  k  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zunmr2_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmr3 <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMR3 overwrites the general complex m by n matrix C with
;;*
;;*        Q * C  if SIDE = 'L' and TRANS = 'N', or
;;*
;;*        Q'* C  if SIDE = 'L' and TRANS = 'C', or
;;*
;;*        C * Q  if SIDE = 'R' and TRANS = 'N', or
;;*
;;*        C * Q' if SIDE = 'R' and TRANS = 'C',
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by ZTZRZF. Q is of order m if SIDE = 'L' and of order n
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q' from the Left
;;*          = 'R': apply Q or Q' from the Right
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N': apply Q  (No transpose)
;;*          = 'C': apply Q' (Conjugate transpose)
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZTZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZTZRZF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the m-by-n matrix C.
;;*          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                                   (N) if SIDE = 'L',
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0: successful exit
;;*          < 0: if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zunmr3 (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zunmr3_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmrq <side>  <trans>  <m>  <n>  <k>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMRQ overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1)' H(2)' . . . H(k)'
;;*
;;*  as returned by ZGERQF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZGERQF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZGERQF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunmrq (side  trans  m  n  k  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmrq_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmrz <side>  <trans>  <m>  <n>  <k>  <l>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMRZ overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix defined as the product of k
;;*  elementary reflectors
;;*
;;*        Q = H(1) H(2) . . . H(k)
;;*
;;*  as returned by ZTZRZF. Q is of order M if SIDE = 'L' and of order N
;;*  if SIDE = 'R'.
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  K       (input) INTEGER
;;*          The number of elementary reflectors whose product defines
;;*          the matrix Q.
;;*          If SIDE = 'L', M >= K >= 0;
;;*          if SIDE = 'R', N >= K >= 0.
;;*
;;*  L       (input) INTEGER
;;*          The number of columns of the matrix A containing
;;*          the meaningful part of the Householder reflectors.
;;*          If SIDE = 'L', M >= L >= 0, if SIDE = 'R', N >= L >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L',
;;*                               (LDA,N) if SIDE = 'R'
;;*          The i-th row must contain the vector which defines the
;;*          elementary reflector H(i), for i = 1,2,...,k, as returned by
;;*          ZTZRZF in the last k rows of its array argument A.
;;*          A is modified by the routine but restored on exit.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A. LDA >= max(1,K).
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (K)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZTZRZF.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  Further Details
;;*  ===============
;;*
;;*  Based on contributions by
;;*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zunmrz (side  trans  m  n  k  l  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-int-)) l )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmrz_($side->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($l,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zunmtr <side>  <uplo>  <trans>  <m>  <n>  <a>  <lda>  <tau>  <c>  <ldc>  <work>  <lwork>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUNMTR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by ZHETRD:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangle of A contains elementary reflectors
;;*                 from ZHETRD;
;;*          = 'L': Lower triangle of A contains elementary reflectors
;;*                 from ZHETRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  A       (input) COMPLEX*16 array, dimension
;;*                               (LDA,M) if SIDE = 'L'
;;*                               (LDA,N) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by ZHETRD.
;;*
;;*  LDA     (input) INTEGER
;;*          The leading dimension of the array A.
;;*          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension
;;*                               (M-1) if SIDE = 'L'
;;*                               (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZHETRD.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK)
;;*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
;;*
;;*  LWORK   (input) INTEGER
;;*          The dimension of the array WORK.
;;*          If SIDE = 'L', LWORK >= max(1,N);
;;*          if SIDE = 'R', LWORK >= max(1,M).
;;*          For optimum performance LWORK >= N*NB if SIDE = 'L', and
;;*          LWORK >=M*NB if SIDE = 'R', where NB is the optimal
;;*          blocksize.
;;*
;;*          If LWORK = -1, then a workspace query is assumed; the routine
;;*          only calculates the optimal size of the WORK array, returns
;;*          this value as the first entry of the WORK array, and no error
;;*          message related to LWORK is issued by XERBLA.
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Local Scalars ..
;;*  =====================================================================

(de zunmtr (side  uplo  trans  m  n  a  lda  tau  c  ldc  work  lwork  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx3- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) lwork )
	((-idx0- (-int-)) info )
	#{ zunmtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($lwork,int), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zupgtr <uplo>  <n>  <ap>  <tau>  <q>  <ldq>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUPGTR generates a complex unitary matrix Q which is defined as the
;;*  product of n-1 elementary reflectors H(i) of order n, as returned by
;;*  ZHPTRD using packed storage:
;;*
;;*  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to ZHPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to ZHPTRD.
;;*
;;*  N       (input) INTEGER
;;*          The order of the matrix Q. N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)
;;*          The vectors which define the elementary reflectors, as
;;*          returned by ZHPTRD.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (N-1)
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZHPTRD.
;;*
;;*  Q       (output) COMPLEX*16 array, dimension (LDQ,N)
;;*          The N-by-N unitary matrix Q.
;;*
;;*  LDQ     (input) INTEGER
;;*          The leading dimension of the array Q. LDQ >= max(1,N).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension (N-1)
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zupgtr (uplo  n  ap  tau  q  ldq  work  info  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) q )
	((-idx0- (-int-)) ldq )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zupgtr_($uplo->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($tau,double), IDX_PTR($q,double), IDX_PTR($ldq,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())
;;interface generated from LAPACK Fortran files automatically
;;Fu Jie Huang, 2002

#? (zupmtr <side>  <uplo>  <trans>  <m>  <n>  <ap>  <tau>  <c>  <ldc>  <work>  <info>  )
;;.VP
;;*  Purpose
;;*  =======
;;*
;;*  ZUPMTR overwrites the general complex M-by-N matrix C with
;;*
;;*                  SIDE = 'L'     SIDE = 'R'
;;*  TRANS = 'N':      Q * C          C * Q
;;*  TRANS = 'C':      Q**H * C       C * Q**H
;;*
;;*  where Q is a complex unitary matrix of order nq, with nq = m if
;;*  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
;;*  nq-1 elementary reflectors, as returned by ZHPTRD using packed
;;*  storage:
;;*
;;*  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
;;*
;;*  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
;;*
;;*  Arguments
;;*  =========
;;*
;;*  SIDE    (input) CHARACTER*1
;;*          = 'L': apply Q or Q**H from the Left;
;;*          = 'R': apply Q or Q**H from the Right.
;;*
;;*  UPLO    (input) CHARACTER*1
;;*          = 'U': Upper triangular packed storage used in previous
;;*                 call to ZHPTRD;
;;*          = 'L': Lower triangular packed storage used in previous
;;*                 call to ZHPTRD.
;;*
;;*  TRANS   (input) CHARACTER*1
;;*          = 'N':  No transpose, apply Q;
;;*          = 'C':  Conjugate transpose, apply Q**H.
;;*
;;*  M       (input) INTEGER
;;*          The number of rows of the matrix C. M >= 0.
;;*
;;*  N       (input) INTEGER
;;*          The number of columns of the matrix C. N >= 0.
;;*
;;*  AP      (input) COMPLEX*16 array, dimension
;;*                               (M*(M+1)/2) if SIDE = 'L'
;;*                               (N*(N+1)/2) if SIDE = 'R'
;;*          The vectors which define the elementary reflectors, as
;;*          returned by ZHPTRD.  AP is modified by the routine but
;;*          restored on exit.
;;*
;;*  TAU     (input) COMPLEX*16 array, dimension (M-1) if SIDE = 'L'
;;*                                     or (N-1) if SIDE = 'R'
;;*          TAU(i) must contain the scalar factor of the elementary
;;*          reflector H(i), as returned by ZHPTRD.
;;*
;;*  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
;;*          On entry, the M-by-N matrix C.
;;*          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
;;*
;;*  LDC     (input) INTEGER
;;*          The leading dimension of the array C. LDC >= max(1,M).
;;*
;;*  WORK    (workspace) COMPLEX*16 array, dimension
;;*                                   (N) if SIDE = 'L'
;;*                                   (M) if SIDE = 'R'
;;*
;;*  INFO    (output) INTEGER
;;*          = 0:  successful exit
;;*          < 0:  if INFO = -i, the i-th argument had an illegal value
;;*
;;*  =====================================================================
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de zupmtr (side  uplo  trans  m  n  ap  tau  c  ldc  work  info  )
	((-str-) side )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) ap )
	((-idx2- (-double-)) tau )
	((-idx3- (-double-)) c )
	((-idx0- (-int-)) ldc )
	((-idx2- (-double-)) work )
	((-idx0- (-int-)) info )
	#{ zupmtr_($side->data, $uplo->data, $trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($tau,double), IDX_PTR($c,double), IDX_PTR($ldc,int), IDX_PTR($work,double), IDX_PTR($info,int)) #} ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar lapack-z-funclist-nonintel ())

(defvar lapack-z-funclist
  '("zbdsqr" "zdrot"
    "zdrscl" "zgbbrd" "zgbcon" "zgbequ" "zgbrfs" "zgbsv" "zgbsvx" "zgbtf2"
    "zgbtrf" "zgbtrs" "zgebak" "zgebal" "zgebd2" "zgebrd" "zgecon"
    "zgeequ" "zgees" "zgeesx" "zgeev" "zgeevx" "zgegs" "zgegv" "zgehd2"
    "zgehrd" "zgelq2" "zgelqf" "zgelsd" "zgels" "zgelss" "zgelsx" "zgelsy"
    "zgeql2" "zgeqlf" "zgeqp3" "zgeqpf" "zgeqr2" "zgeqrf" "zgerfs"
    "zgerq2" "zgerqf" "zgesc2" "zgesdd" "zgesvd" "zgesv" "zgesvx" "zgetc2"
    "zgetf2" "zgetrf" "zgetri" "zgetrs" "zggbak" "zggbal" "zgges" "zggesx"
    "zggev" "zggevx" "zggglm" "zgghrd" "zgglse" "zggqrf" "zggrqf" "zggsvd"
    "zggsvp" "zgtcon" "zgtrfs" "zgtsv" "zgtsvx" "zgttrf" "zgttrs" "zgtts2"
    "zhbevd" "zhbev" "zhbevx" "zhbgst" "zhbgvd" "zhbgv" "zhbgvx" "zhbtrd"
    "zhecon" "zheevd" "zheev" "zheevr" "zheevx" "zhegs2" "zhegst" "zhegvd"
    "zhegv" "zhegvx" "zherfs" "zhesv" "zhesvx" "zhetd2" "zhetf2" "zhetrd"
    "zhetrf" "zhetri" "zhetrs" "zhgeqz" "zhpcon" "zhpevd" "zhpev" "zhpevx"
    "zhpgst" "zhpgvd" "zhpgv" "zhpgvx" "zhprfs" "zhpsv" "zhpsvx" "zhptrd"
    "zhptrf" "zhptri" "zhptrs" "zhsein" "zhseqr" "zlabrd" "zlacgv"
    "zlacon" "zlacp2" "zlacpy" "zlacrm" "zlacrt" "zladiv" "zlaed0"
    "zlaed7" "zlaed8" "zlaein" "zlaesy" "zlaev2" "zlags2" "zlagtm"
    "zlahef" "zlahqr" "zlahrd" "zlaic1" "zlals0" "zlalsa" "zlalsd"
    "zlangb" "zlange" "zlangt" "zlanhb" "zlanhe" "zlanhp" "zlanhs"
    "zlanht" "zlansb" "zlansp" "zlansy" "zlantb" "zlantp" "zlantr"
    "zlapll" "zlapmt" "zlaqgb" "zlaqge" "zlaqhb" "zlaqhe" "zlaqhp"
    "zlaqp2" "zlaqps" "zlaqsb" "zlaqsp" "zlaqsy" "zlar1v" "zlar2v"
    "zlarcm" "zlarfb" "zlarf" "zlarfg" "zlarft" "zlarfx" "zlargv" "zlarnv"
    "zlarrv" "zlartg" "zlartv" "zlarzb" "zlarz" "zlarzt" "zlascl" "zlaset"
    "zlasr" "zlassq" "zlaswp" "zlasyf" "zlatbs" "zlatdf" "zlatps" "zlatrd"
    "zlatrs" "zlatrz" "zlatzm" "zlauu2" "zlauum" "zpbcon" "zpbequ"
    "zpbrfs" "zpbstf" "zpbsv" "zpbsvx" "zpbtf2" "zpbtrf" "zpbtrs" "zpocon"
    "zpoequ" "zporfs" "zposv" "zposvx" "zpotf2" "zpotrf" "zpotri" "zpotrs"
    "zppcon" "zppequ" "zpprfs" "zppsv" "zppsvx" "zpptrf" "zpptri" "zpptrs"
    "zptcon" "zpteqr" "zptrfs" "zptsv" "zptsvx" "zpttrf" "zpttrs" "zptts2"
    "zrot" "zspcon" "zspmv" "zspr" "zsprfs" "zspsv" "zspsvx" "zsptrf"
    "zsptri" "zsptrs" "zstedc" "zstegr" "zstein" "zsteqr" "zsycon" "zsymv"
    "zsyr" "zsyrfs" "zsysv" "zsysvx" "zsytf2" "zsytrf" "zsytri" "zsytrs"
    "ztbcon" "ztbrfs" "ztbtrs" "ztgevc" "ztgex2" "ztgexc" "ztgsen"
    "ztgsja" "ztgsna" "ztgsy2" "ztgsyl" "ztpcon" "ztprfs" "ztptri"
    "ztptrs" "ztrcon" "ztrevc" "ztrexc" "ztrrfs" "ztrsen" "ztrsna"
    "ztrsyl" "ztrti2" "ztrtri" "ztrtrs" "ztzrqf" "ztzrzf" "zung2l"
    "zung2r" "zungbr" "zunghr" "zungl2" "zunglq" "zungql" "zungqr"
    "zungr2" "zungrq" "zungtr" "zunm2l" "zunm2r" "zunmbr" "zunmhr"
    "zunml2" "zunmlq" "zunmql" "zunmqr" "zunmr2" "zunmr3" "zunmrq"
    "zunmrz" "zunmtr" "zupgtr" "zupmtr"
    ))

(with-namespace lush1-
(let ((dhc-make-lushflags (concat dhc-make-lushflags lapack-cflags)))
  (dhc-make-all 
   ()
   (all ((x (cons "lapack-z-dummy" lapack-z-funclist)))
     (named (downcase x)))
   (append lapack-liblapack lapack-libfortran)))
)
