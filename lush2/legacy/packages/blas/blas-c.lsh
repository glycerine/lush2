#? * BLAS: Single Precision Complex Functions
;;.AUTHOR Fu Jie Huang, Yann LeCun
;; This provides a complete interface to the FORTRAN BLAS
;; library of low-level linear algebra functions.

(libload "blas-config")
(libload "blas-x")

;; Check if we can short-circuit by just mod-loading the object file
(let* ((dhc-make-lushflags (concat dhc-make-lushflags blas-cflags))
       (objfile (dhc-make-test ())) )
  (when objfile
    (mod-load objfile)
    (mapcar mod-load (cons blas-libblas blas-libfortran))
    (exit) ) )


(de blas-c-dummy () (cheader "typedef int int_func();") ())

#? (caxpy <n>  <ca>  <cx>  <incx>  <cy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     constant times a vector plus a vector.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de caxpy (n  ca  cx  incx  cy  incy  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ca )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	#{ caxpy_(IDX_PTR($n,int), IDX_PTR($ca,float), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int)) #} ())



#? (ccopy <n>  <cx>  <incx>  <cy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     copies a vector, x, to a vector, y.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de ccopy (n  cx  incx  cy  incy  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	#{ ccopy_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int)) #} ())



#? (cdotc <n>  <cx>  <incx>  <cy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     forms the dot product of two vectors, conjugating the first
;;*     vector.
;;*     jack dongarra, linpack,  3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de cdotc (n  cx  incx  cy  incy  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	(let ((rval 0))
	#{ $rval=cdotc_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int)) #} rval))



#? (cdotu <n>  <cx>  <incx>  <cy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     forms the dot product of two vectors.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de cdotu (n  cx  incx  cy  incy  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	(let ((rval 0))
	#{ $rval=cdotu_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int)) #} rval))



#? (cgbmv <trans>  <m>  <n>  <kl>  <ku>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CGBMV  performs one of the matrix-vector operations
;;*
;;*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
;;*
;;*     y := alpha*conjg( A' )*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are vectors and A is an
;;*  m by n band matrix, with kl sub-diagonals and ku super-diagonals.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
;;*
;;*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
;;*
;;*              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  KL     - INTEGER.
;;*           On entry, KL specifies the number of sub-diagonals of the
;;*           matrix A. KL must satisfy  0 .le. KL.
;;*           Unchanged on exit.
;;*
;;*  KU     - INTEGER.
;;*           On entry, KU specifies the number of super-diagonals of the
;;*           matrix A. KU must satisfy  0 .le. KU.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading ( kl + ku + 1 ) by n part of the
;;*           array A must contain the matrix of coefficients, supplied
;;*           column by column, with the leading diagonal of the matrix in
;;*           row ( ku + 1 ) of the array, the first super-diagonal
;;*           starting at position 2 in row ku, the first sub-diagonal
;;*           starting at position 1 in row ( ku + 2 ), and so on.
;;*           Elements in the array A that do not correspond to elements
;;*           in the band matrix (such as the top left ku by ku triangle)
;;*           are not referenced.
;;*           The following program segment will transfer a band matrix
;;*           from conventional full matrix storage to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    K = KU + 1 - J
;;*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
;;*                       A( K + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( kl + ku + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
;;*           Before entry, the incremented array X must contain the
;;*           vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of DIMENSION at least
;;*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
;;*           Before entry, the incremented array Y must contain the
;;*           vector y. On exit, Y is overwritten by the updated vector y.
;;*
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgbmv (trans  m  n  kl  ku  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ cgbmv_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())



#? (cgemm <transa>  <transb>  <m>  <n>  <k>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CGEMM  performs one of the matrix-matrix operations
;;*
;;*     C := alpha*op( A )*op( B ) + beta*C,
;;*
;;*  where  op( X ) is one of
;;*
;;*     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),
;;*
;;*  alpha and beta are scalars, and A, B and C are matrices, with op( A )
;;*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  TRANSA - CHARACTER*1.
;;*           On entry, TRANSA specifies the form of op( A ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSA = 'N' or 'n',  op( A ) = A.
;;*
;;*              TRANSA = 'T' or 't',  op( A ) = A'.
;;*
;;*              TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANSB - CHARACTER*1.
;;*           On entry, TRANSB specifies the form of op( B ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSB = 'N' or 'n',  op( B ) = B.
;;*
;;*              TRANSB = 'T' or 't',  op( B ) = B'.
;;*
;;*              TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry,  M  specifies  the number  of rows  of the  matrix
;;*           op( A )  and of the  matrix  C.  M  must  be at least  zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N  specifies the number  of columns of the matrix
;;*           op( B ) and the number of columns of the matrix C. N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry,  K  specifies  the number of columns of the matrix
;;*           op( A ) and the number of rows of the matrix op( B ). K must
;;*           be at least  zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
;;*           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by m  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
;;*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
;;*           least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, kb ), where kb is
;;*           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
;;*           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
;;*           part of the array  B  must contain the matrix  B,  otherwise
;;*           the leading  n by k  part of the array  B  must contain  the
;;*           matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
;;*           LDB must be at least  max( 1, k ), otherwise  LDB must be at
;;*           least  max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
;;*           supplied as zero then C need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry, the leading  m by n  part of the array  C must
;;*           contain the matrix  C,  except when  beta  is zero, in which
;;*           case C need not be set on entry.
;;*           On exit, the array  C  is overwritten by the  m by n  matrix
;;*           ( alpha*op( A )*op( B ) + beta*C ).
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cgemm (transa  transb  m  n  k  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) transa )
	((-str-) transb )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ cgemm_($transa->data, $transb->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (cgemv <trans>  <m>  <n>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CGEMV  performs one of the matrix-vector operations
;;*
;;*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
;;*
;;*     y := alpha*conjg( A' )*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are vectors and A is an
;;*  m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
;;*
;;*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
;;*
;;*              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading m by n part of the array A must
;;*           contain the matrix of coefficients.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
;;*           Before entry, the incremented array X must contain the
;;*           vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of DIMENSION at least
;;*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
;;*           Before entry with BETA non-zero, the incremented array Y
;;*           must contain the vector y. On exit, Y is overwritten by the
;;*           updated vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgemv (trans  m  n  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ cgemv_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())



#? (cgerc <m>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CGERC  performs the rank 1 operation
;;*
;;*     A := alpha*x*conjg( y' ) + A,
;;*
;;*  where alpha is a scalar, x is an m element vector, y is an n element
;;*  vector and A is an m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the m
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading m by n part of the array A must
;;*           contain the matrix of coefficients. On exit, A is
;;*           overwritten by the updated matrix.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgerc (m  n  alpha  x  incx  y  incy  a  lda  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ cgerc_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())



#? (cgeru <m>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CGERU  performs the rank 1 operation
;;*
;;*     A := alpha*x*y' + A,
;;*
;;*  where alpha is a scalar, x is an m element vector, y is an n element
;;*  vector and A is an m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the m
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading m by n part of the array A must
;;*           contain the matrix of coefficients. On exit, A is
;;*           overwritten by the updated matrix.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cgeru (m  n  alpha  x  incx  y  incy  a  lda  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ cgeru_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())



#? (chbmv <uplo>  <n>  <k>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHBMV  performs the matrix-vector  operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n hermitian band matrix, with k super-diagonals.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the band matrix A is being supplied as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  being supplied.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  being supplied.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry, K specifies the number of super-diagonals of the
;;*           matrix A. K must satisfy  0 .le. K.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
;;*           by n part of the array A must contain the upper triangular
;;*           band part of the hermitian matrix, supplied column by
;;*           column, with the leading diagonal of the matrix in row
;;*           ( k + 1 ) of the array, the first super-diagonal starting at
;;*           position 2 in row k, and so on. The top left k by k triangle
;;*           of the array A is not referenced.
;;*           The following program segment will transfer the upper
;;*           triangular part of a hermitian band matrix from conventional
;;*           full matrix storage to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = K + 1 - J
;;*                    DO 10, I = MAX( 1, J - K ), J
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
;;*           by n part of the array A must contain the lower triangular
;;*           band part of the hermitian matrix, supplied column by
;;*           column, with the leading diagonal of the matrix in row 1 of
;;*           the array, the first sub-diagonal starting at position 1 in
;;*           row 2, and so on. The bottom right k by k triangle of the
;;*           array A is not referenced.
;;*           The following program segment will transfer the lower
;;*           triangular part of a hermitian band matrix from conventional
;;*           full matrix storage to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = 1 - J
;;*                    DO 10, I = J, MIN( N, J + K )
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set and are assumed to be zero.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( k + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the
;;*           vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the
;;*           vector y. On exit, Y is overwritten by the updated vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chbmv (uplo  n  k  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ chbmv_($uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())



#? (chemm <side>  <uplo>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHEMM  performs one of the matrix-matrix operations
;;*
;;*     C := alpha*A*B + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*B*A + beta*C,
;;*
;;*  where alpha and beta are scalars, A is an hermitian matrix and  B and
;;*  C are m by n matrices.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry,  SIDE  specifies whether  the  hermitian matrix  A
;;*           appears on the  left or right  in the  operation as follows:
;;*
;;*              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
;;*
;;*              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of  the  hermitian  matrix   A  is  to  be
;;*           referenced as follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of the
;;*                                  hermitian matrix is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of the
;;*                                  hermitian matrix is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry,  M  specifies the number of rows of the matrix  C.
;;*           M  must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix C.
;;*           N  must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           m  when  SIDE = 'L' or 'l'  and is n  otherwise.
;;*           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
;;*           the array  A  must contain the  hermitian matrix,  such that
;;*           when  UPLO = 'U' or 'u', the leading m by m upper triangular
;;*           part of the array  A  must contain the upper triangular part
;;*           of the  hermitian matrix and the  strictly  lower triangular
;;*           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
;;*           the leading  m by m  lower triangular part  of the  array  A
;;*           must  contain  the  lower triangular part  of the  hermitian
;;*           matrix and the  strictly upper triangular part of  A  is not
;;*           referenced.
;;*           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
;;*           the array  A  must contain the  hermitian matrix,  such that
;;*           when  UPLO = 'U' or 'u', the leading n by n upper triangular
;;*           part of the array  A  must contain the upper triangular part
;;*           of the  hermitian matrix and the  strictly  lower triangular
;;*           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
;;*           the leading  n by n  lower triangular part  of the  array  A
;;*           must  contain  the  lower triangular part  of the  hermitian
;;*           matrix and the  strictly upper triangular part of  A  is not
;;*           referenced.
;;*           Note that the imaginary parts  of the diagonal elements need
;;*           not be set, they are assumed to be zero.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
;;*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
;;*           least max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, n ).
;;*           Before entry, the leading  m by n part of the array  B  must
;;*           contain the matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
;;*           supplied as zero then C need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry, the leading  m by n  part of the array  C must
;;*           contain the matrix  C,  except when  beta  is zero, in which
;;*           case C need not be set on entry.
;;*           On exit, the array  C  is overwritten by the  m by n updated
;;*           matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de chemm (side  uplo  m  n  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) side )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ chemm_($side->data, $uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (chemv <uplo>  <n>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHEMV  performs the matrix-vector  operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n hermitian matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the hermitian matrix and the strictly
;;*           lower triangular part of A is not referenced.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the hermitian matrix and the strictly
;;*           upper triangular part of A is not referenced.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set and are assumed to be zero.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chemv (uplo  n  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ chemv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())



#? (cher2k <uplo>  <trans>  <n>  <k>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHER2K  performs one of the hermitian rank 2k operations
;;*
;;*     C := alpha*A*conjg( B' ) + conjg( alpha )*B*conjg( A' ) + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*conjg( A' )*B + conjg( alpha )*conjg( B' )*A + beta*C,
;;*
;;*  where  alpha and beta  are scalars with  beta  real,  C is an  n by n
;;*  hermitian matrix and  A and B  are  n by k matrices in the first case
;;*  and  k by n  matrices in the second case.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of the  array  C  is to be  referenced  as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry,  TRANS  specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'    C := alpha*A*conjg( B' )          +
;;*                                         conjg( alpha )*B*conjg( A' ) +
;;*                                         beta*C.
;;*
;;*              TRANS = 'C' or 'c'    C := alpha*conjg( A' )*B          +
;;*                                         conjg( alpha )*conjg( B' )*A +
;;*                                         beta*C.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N specifies the order of the matrix C.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
;;*           of  columns  of the  matrices  A and B,  and on  entry  with
;;*           TRANS = 'C' or 'c',  K  specifies  the number of rows of the
;;*           matrices  A and B.  K must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by n  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDA must be at least  max( 1, n ), otherwise  LDA must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, kb ), where kb is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  B  must contain the matrix  B,  otherwise
;;*           the leading  k by n  part of the array  B  must contain  the
;;*           matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDB must be at least  max( 1, n ), otherwise  LDB must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - REAL            .
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
;;*           upper triangular part of the array C must contain the upper
;;*           triangular part  of the  hermitian matrix  and the strictly
;;*           lower triangular part of C is not referenced.  On exit, the
;;*           upper triangular part of the array  C is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
;;*           lower triangular part of the array C must contain the lower
;;*           triangular part  of the  hermitian matrix  and the strictly
;;*           upper triangular part of C is not referenced.  On exit, the
;;*           lower triangular part of the array  C is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set,  they are assumed to be zero,  and on exit they
;;*           are set to zero.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*  -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.
;;*     Ed Anderson, Cray Research Inc.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cher2k (uplo  trans  n  k  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ cher2k_($uplo->data, $trans->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (cher2 <uplo>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHER2  performs the hermitian rank 2 operation
;;*
;;*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
;;*
;;*  where alpha is a scalar, x and y are n element vectors and A is an n
;;*  by n hermitian matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the hermitian matrix and the strictly
;;*           lower triangular part of A is not referenced. On exit, the
;;*           upper triangular part of the array A is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the hermitian matrix and the strictly
;;*           upper triangular part of A is not referenced. On exit, the
;;*           lower triangular part of the array A is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set, they are assumed to be zero, and on exit they
;;*           are set to zero.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cher2 (uplo  n  alpha  x  incx  y  incy  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ cher2_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())



#? (cherk <uplo>  <trans>  <n>  <k>  <alpha>  <a>  <lda>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHERK  performs one of the hermitian rank k operations
;;*
;;*     C := alpha*A*conjg( A' ) + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*conjg( A' )*A + beta*C,
;;*
;;*  where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
;;*  matrix and  A  is an  n by k  matrix in the  first case and a  k by n
;;*  matrix in the second case.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of the  array  C  is to be  referenced  as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry,  TRANS  specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   C := alpha*A*conjg( A' ) + beta*C.
;;*
;;*              TRANS = 'C' or 'c'   C := alpha*conjg( A' )*A + beta*C.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N specifies the order of the matrix C.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
;;*           of  columns   of  the   matrix   A,   and  on   entry   with
;;*           TRANS = 'C' or 'c',  K  specifies  the number of rows of the
;;*           matrix A.  K must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - REAL            .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by n  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDA must be at least  max( 1, n ), otherwise  LDA must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - REAL            .
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
;;*           upper triangular part of the array C must contain the upper
;;*           triangular part  of the  hermitian matrix  and the strictly
;;*           lower triangular part of C is not referenced.  On exit, the
;;*           upper triangular part of the array  C is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
;;*           lower triangular part of the array C must contain the lower
;;*           triangular part  of the  hermitian matrix  and the strictly
;;*           upper triangular part of C is not referenced.  On exit, the
;;*           lower triangular part of the array  C is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set,  they are assumed to be zero,  and on exit they
;;*           are set to zero.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*  -- Modified 8-Nov-93 to set C(J,J) to REAL( C(J,J) ) when BETA = 1.
;;*     Ed Anderson, Cray Research Inc.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de cherk (uplo  trans  n  k  alpha  a  lda  beta  c  ldc  )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ cherk_($uplo->data, $trans->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (cher <uplo>  <n>  <alpha>  <x>  <incx>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHER   performs the hermitian rank 1 operation
;;*
;;*     A := alpha*x*conjg( x' ) + A,
;;*
;;*  where alpha is a real scalar, x is an n element vector and A is an
;;*  n by n hermitian matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - REAL            .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the hermitian matrix and the strictly
;;*           lower triangular part of A is not referenced. On exit, the
;;*           upper triangular part of the array A is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the hermitian matrix and the strictly
;;*           upper triangular part of A is not referenced. On exit, the
;;*           lower triangular part of the array A is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set, they are assumed to be zero, and on exit they
;;*           are set to zero.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de cher (uplo  n  alpha  x  incx  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	#{ cher_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($a,float), IDX_PTR($lda,int)) #} ())



#? (chpmv <uplo>  <n>  <alpha>  <ap>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHPMV  performs the matrix-vector operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n hermitian matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX          array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the hermitian matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the hermitian matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set and are assumed to be zero.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpmv (uplo  n  alpha  ap  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-float-)) beta )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	#{ chpmv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($ap,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($beta,float), IDX_PTR($y,float), IDX_PTR($incy,int)) #} ())



#? (chpr2 <uplo>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <ap>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHPR2  performs the hermitian rank 2 operation
;;*
;;*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
;;*
;;*  where alpha is a scalar, x and y are n element vectors and A is an
;;*  n by n hermitian matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX          array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the hermitian matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the upper triangular part of the
;;*           updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the hermitian matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the lower triangular part of the
;;*           updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set, they are assumed to be zero, and on exit they
;;*           are set to zero.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpr2 (uplo  n  alpha  x  incx  y  incy  ap  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) y )
	((-idx0- (-int-)) incy )
	((-idx2- (-float-)) ap )
	#{ chpr2_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($y,float), IDX_PTR($incy,int), IDX_PTR($ap,float)) #} ())



#? (chpr <uplo>  <n>  <alpha>  <x>  <incx>  <ap>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CHPR    performs the hermitian rank 1 operation
;;*
;;*     A := alpha*x*conjg( x' ) + A,
;;*
;;*  where alpha is a real scalar, x is an n element vector and A is an
;;*  n by n hermitian matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - REAL            .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX          array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the hermitian matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the upper triangular part of the
;;*           updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the hermitian matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the lower triangular part of the
;;*           updated matrix.
;;*           Note that the imaginary parts of the diagonal elements need
;;*           not be set, they are assumed to be zero, and on exit they
;;*           are set to zero.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de chpr (uplo  n  alpha  x  incx  ap  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) alpha )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) ap )
	#{ chpr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($x,float), IDX_PTR($incx,int), IDX_PTR($ap,float)) #} ())



#? (crotg <ca>  <cb>  <c>  <s>  )
;;.VP
;;*  =====================================================================
;;*  =====================================================================

(de crotg (ca  cb  c  s  )
	((-idx1- (-float-)) ca )
	((-idx1- (-float-)) cb )
	((-idx0- (-float-)) c )
	((-idx1- (-float-)) s )
	#{ crotg_(IDX_PTR($ca,float), IDX_PTR($cb,float), IDX_PTR($c,float), IDX_PTR($s,float)) #} ())



#? (cscal <n>  <ca>  <cx>  <incx>  )
;;.VP
;;*  =====================================================================
;;*
;;*     scales a vector by a constant.
;;*     jack dongarra, linpack,  3/11/78.
;;*     modified 3/93 to return if incx .le. 0.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de cscal (n  ca  cx  incx  )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) ca )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	#{ cscal_(IDX_PTR($n,int), IDX_PTR($ca,float), IDX_PTR($cx,float), IDX_PTR($incx,int)) #} ())



#? (csscal <n>  <sa>  <cx>  <incx>  )
;;.VP
;;*  =====================================================================
;;*
;;*     scales a complex vector by a real constant.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 3/93 to return if incx .le. 0.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de csscal (n  sa  cx  incx  )
	((-idx0- (-int-)) n )
	((-idx0- (-float-)) sa  )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	#{ csscal_(IDX_PTR($n,int), IDX_PTR($sa,float), IDX_PTR($cx,float), IDX_PTR($incx,int)) #} ())



#? (cswap <n>  <cx>  <incx>  <cy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     interchanges two vectors.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de cswap (n  cx  incx  cy  incy  )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) cx )
	((-idx0- (-int-)) incx )
	((-idx2- (-float-)) cy )
	((-idx0- (-int-)) incy )
	#{ cswap_(IDX_PTR($n,int), IDX_PTR($cx,float), IDX_PTR($incx,int), IDX_PTR($cy,float), IDX_PTR($incy,int)) #} ())



#? (csymm <side>  <uplo>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CSYMM  performs one of the matrix-matrix operations
;;*
;;*     C := alpha*A*B + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*B*A + beta*C,
;;*
;;*  where  alpha and beta are scalars, A is a symmetric matrix and  B and
;;*  C are m by n matrices.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry,  SIDE  specifies whether  the  symmetric matrix  A
;;*           appears on the  left or right  in the  operation as follows:
;;*
;;*              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
;;*
;;*              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of  the  symmetric  matrix   A  is  to  be
;;*           referenced as follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of the
;;*                                  symmetric matrix is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of the
;;*                                  symmetric matrix is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry,  M  specifies the number of rows of the matrix  C.
;;*           M  must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix C.
;;*           N  must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           m  when  SIDE = 'L' or 'l'  and is n  otherwise.
;;*           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
;;*           the array  A  must contain the  symmetric matrix,  such that
;;*           when  UPLO = 'U' or 'u', the leading m by m upper triangular
;;*           part of the array  A  must contain the upper triangular part
;;*           of the  symmetric matrix and the  strictly  lower triangular
;;*           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
;;*           the leading  m by m  lower triangular part  of the  array  A
;;*           must  contain  the  lower triangular part  of the  symmetric
;;*           matrix and the  strictly upper triangular part of  A  is not
;;*           referenced.
;;*           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
;;*           the array  A  must contain the  symmetric matrix,  such that
;;*           when  UPLO = 'U' or 'u', the leading n by n upper triangular
;;*           part of the array  A  must contain the upper triangular part
;;*           of the  symmetric matrix and the  strictly  lower triangular
;;*           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
;;*           the leading  n by n  lower triangular part  of the  array  A
;;*           must  contain  the  lower triangular part  of the  symmetric
;;*           matrix and the  strictly upper triangular part of  A  is not
;;*           referenced.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
;;*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
;;*           least max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, n ).
;;*           Before entry, the leading  m by n part of the array  B  must
;;*           contain the matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
;;*           supplied as zero then C need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry, the leading  m by n  part of the array  C must
;;*           contain the matrix  C,  except when  beta  is zero, in which
;;*           case C need not be set on entry.
;;*           On exit, the array  C  is overwritten by the  m by n updated
;;*           matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de csymm (side  uplo  m  n  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) side )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ csymm_($side->data, $uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (csyr2k <uplo>  <trans>  <n>  <k>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CSYR2K  performs one of the symmetric rank 2k operations
;;*
;;*     C := alpha*A*B' + alpha*B*A' + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*A'*B + alpha*B'*A + beta*C,
;;*
;;*  where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
;;*  and  A and B  are  n by k  matrices  in the  first  case  and  k by n
;;*  matrices in the second case.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of the  array  C  is to be  referenced  as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry,  TRANS  specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'    C := alpha*A*B' + alpha*B*A' +
;;*                                         beta*C.
;;*
;;*              TRANS = 'T' or 't'    C := alpha*A'*B + alpha*B'*A +
;;*                                         beta*C.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N specifies the order of the matrix C.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
;;*           of  columns  of the  matrices  A and B,  and on  entry  with
;;*           TRANS = 'T' or 't',  K  specifies  the number of rows of the
;;*           matrices  A and B.  K must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by n  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDA must be at least  max( 1, n ), otherwise  LDA must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, kb ), where kb is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  B  must contain the matrix  B,  otherwise
;;*           the leading  k by n  part of the array  B  must contain  the
;;*           matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDB must be at least  max( 1, n ), otherwise  LDB must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
;;*           upper triangular part of the array C must contain the upper
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           lower triangular part of C is not referenced.  On exit, the
;;*           upper triangular part of the array  C is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
;;*           lower triangular part of the array C must contain the lower
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           upper triangular part of C is not referenced.  On exit, the
;;*           lower triangular part of the array  C is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de csyr2k (uplo  trans  n  k  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ csyr2k_($uplo->data, $trans->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (csyrk <uplo>  <trans>  <n>  <k>  <alpha>  <a>  <lda>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CSYRK  performs one of the symmetric rank k operations
;;*
;;*     C := alpha*A*A' + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*A'*A + beta*C,
;;*
;;*  where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
;;*  and  A  is an  n by k  matrix in the first case and a  k by n  matrix
;;*  in the second case.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of the  array  C  is to be  referenced  as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry,  TRANS  specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   C := alpha*A*A' + beta*C.
;;*
;;*              TRANS = 'T' or 't'   C := alpha*A'*A + beta*C.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N specifies the order of the matrix C.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
;;*           of  columns   of  the   matrix   A,   and  on   entry   with
;;*           TRANS = 'T' or 't',  K  specifies  the number of rows of the
;;*           matrix A.  K must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by n  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDA must be at least  max( 1, n ), otherwise  LDA must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - COMPLEX         .
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  C      - COMPLEX          array of DIMENSION ( LDC, n ).
;;*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
;;*           upper triangular part of the array C must contain the upper
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           lower triangular part of C is not referenced.  On exit, the
;;*           upper triangular part of the array  C is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
;;*           lower triangular part of the array C must contain the lower
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           upper triangular part of C is not referenced.  On exit, the
;;*           lower triangular part of the array  C is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de csyrk (uplo  trans  n  k  alpha  a  lda  beta  c  ldc  )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-float-)) beta )
	((-idx3- (-float-)) c )
	((-idx0- (-int-)) ldc )
	#{ csyrk_($uplo->data, $trans->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($beta,float), IDX_PTR($c,float), IDX_PTR($ldc,int)) #} ())



#? (ctbmv <uplo>  <trans>  <diag>  <n>  <k>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTBMV  performs one of the matrix-vector operations
;;*
;;*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
;;*
;;*  where x is an n element vector and  A is an n by n unit, or non-unit,
;;*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   x := A*x.
;;*
;;*              TRANS = 'T' or 't'   x := A'*x.
;;*
;;*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with UPLO = 'U' or 'u', K specifies the number of
;;*           super-diagonals of the matrix A.
;;*           On entry with UPLO = 'L' or 'l', K specifies the number of
;;*           sub-diagonals of the matrix A.
;;*           K must satisfy  0 .le. K.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
;;*           by n part of the array A must contain the upper triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row
;;*           ( k + 1 ) of the array, the first super-diagonal starting at
;;*           position 2 in row k, and so on. The top left k by k triangle
;;*           of the array A is not referenced.
;;*           The following program segment will transfer an upper
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = K + 1 - J
;;*                    DO 10, I = MAX( 1, J - K ), J
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
;;*           by n part of the array A must contain the lower triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row 1 of
;;*           the array, the first sub-diagonal starting at position 1 in
;;*           row 2, and so on. The bottom right k by k triangle of the
;;*           array A is not referenced.
;;*           The following program segment will transfer a lower
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = 1 - J
;;*                    DO 10, I = J, MIN( N, J + K )
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Note that when DIAG = 'U' or 'u' the elements of the array A
;;*           corresponding to the diagonal elements of the matrix are not
;;*           referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( k + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x. On exit, X is overwritten with the
;;*           tranformed vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctbmv (uplo  trans  diag  n  k  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ ctbmv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())



#? (ctbsv <uplo>  <trans>  <diag>  <n>  <k>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTBSV  solves one of the systems of equations
;;*
;;*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
;;*
;;*  where b and x are n element vectors and A is an n by n unit, or
;;*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
;;*  diagonals.
;;*
;;*  No test for singularity or near-singularity is included in this
;;*  routine. Such tests must be performed before calling this routine.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the equations to be solved as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   A*x = b.
;;*
;;*              TRANS = 'T' or 't'   A'*x = b.
;;*
;;*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with UPLO = 'U' or 'u', K specifies the number of
;;*           super-diagonals of the matrix A.
;;*           On entry with UPLO = 'L' or 'l', K specifies the number of
;;*           sub-diagonals of the matrix A.
;;*           K must satisfy  0 .le. K.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
;;*           by n part of the array A must contain the upper triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row
;;*           ( k + 1 ) of the array, the first super-diagonal starting at
;;*           position 2 in row k, and so on. The top left k by k triangle
;;*           of the array A is not referenced.
;;*           The following program segment will transfer an upper
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = K + 1 - J
;;*                    DO 10, I = MAX( 1, J - K ), J
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
;;*           by n part of the array A must contain the lower triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row 1 of
;;*           the array, the first sub-diagonal starting at position 1 in
;;*           row 2, and so on. The bottom right k by k triangle of the
;;*           array A is not referenced.
;;*           The following program segment will transfer a lower
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = 1 - J
;;*                    DO 10, I = J, MIN( N, J + K )
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Note that when DIAG = 'U' or 'u' the elements of the array A
;;*           corresponding to the diagonal elements of the matrix are not
;;*           referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( k + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element right-hand side vector b. On exit, X is overwritten
;;*           with the solution vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctbsv (uplo  trans  diag  n  k  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ ctbsv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())



#? (ctpmv <uplo>  <trans>  <diag>  <n>  <ap>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTPMV  performs one of the matrix-vector operations
;;*
;;*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
;;*
;;*  where x is an n element vector and  A is an n by n unit, or non-unit,
;;*  upper or lower triangular matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   x := A*x.
;;*
;;*              TRANS = 'T' or 't'   x := A'*x.
;;*
;;*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX          array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
;;*           respectively, and so on.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
;;*           respectively, and so on.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x. On exit, X is overwritten with the
;;*           tranformed vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctpmv (uplo  trans  diag  n  ap  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ ctpmv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())



#? (ctpsv <uplo>  <trans>  <diag>  <n>  <ap>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTPSV  solves one of the systems of equations
;;*
;;*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
;;*
;;*  where b and x are n element vectors and A is an n by n unit, or
;;*  non-unit, upper or lower triangular matrix, supplied in packed form.
;;*
;;*  No test for singularity or near-singularity is included in this
;;*  routine. Such tests must be performed before calling this routine.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the equations to be solved as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   A*x = b.
;;*
;;*              TRANS = 'T' or 't'   A'*x = b.
;;*
;;*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - COMPLEX          array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
;;*           respectively, and so on.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
;;*           respectively, and so on.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element right-hand side vector b. On exit, X is overwritten
;;*           with the solution vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctpsv (uplo  trans  diag  n  ap  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-float-)) ap )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ ctpsv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,float), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())



#? (ctrmm <side>  <uplo>  <transa>  <diag>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTRMM  performs one of the matrix-matrix operations
;;*
;;*     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
;;*
;;*  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
;;*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
;;*
;;*     op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry,  SIDE specifies whether  op( A ) multiplies B from
;;*           the left or right as follows:
;;*
;;*              SIDE = 'L' or 'l'   B := alpha*op( A )*B.
;;*
;;*              SIDE = 'R' or 'r'   B := alpha*B*op( A ).
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix A is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANSA - CHARACTER*1.
;;*           On entry, TRANSA specifies the form of op( A ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSA = 'N' or 'n'   op( A ) = A.
;;*
;;*              TRANSA = 'T' or 't'   op( A ) = A'.
;;*
;;*              TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit triangular
;;*           as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of B. M must be at
;;*           least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of B.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
;;*           zero then  A is not referenced and  B need not be set before
;;*           entry.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, k ), where k is m
;;*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
;;*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
;;*           upper triangular part of the array  A must contain the upper
;;*           triangular matrix  and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
;;*           lower triangular part of the array  A must contain the lower
;;*           triangular matrix  and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
;;*           A  are not referenced either,  but are assumed to be  unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
;;*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
;;*           then LDA must be at least max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, n ).
;;*           Before entry,  the leading  m by n part of the array  B must
;;*           contain the matrix  B,  and  on exit  is overwritten  by the
;;*           transformed matrix.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de ctrmm (side  uplo  transa  diag  m  n  alpha  a  lda  b  ldb  )
	((-str-) side )
	((-str-) uplo )
	((-str-) transa )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ ctrmm_($side->data, $uplo->data, $transa->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())



#? (ctrmv <uplo>  <trans>  <diag>  <n>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTRMV  performs one of the matrix-vector operations
;;*
;;*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
;;*
;;*  where x is an n element vector and  A is an n by n unit, or non-unit,
;;*  upper or lower triangular matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   x := A*x.
;;*
;;*              TRANS = 'T' or 't'   x := A'*x.
;;*
;;*              TRANS = 'C' or 'c'   x := conjg( A' )*x.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular matrix and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular matrix and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced either, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x. On exit, X is overwritten with the
;;*           tranformed vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrmv (uplo  trans  diag  n  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ ctrmv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())



#? (ctrsm <side>  <uplo>  <transa>  <diag>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTRSM  solves one of the matrix equations
;;*
;;*     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
;;*
;;*  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
;;*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
;;*
;;*     op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
;;*
;;*  The matrix X is overwritten on B.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry, SIDE specifies whether op( A ) appears on the left
;;*           or right of X as follows:
;;*
;;*              SIDE = 'L' or 'l'   op( A )*X = alpha*B.
;;*
;;*              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix A is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANSA - CHARACTER*1.
;;*           On entry, TRANSA specifies the form of op( A ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSA = 'N' or 'n'   op( A ) = A.
;;*
;;*              TRANSA = 'T' or 't'   op( A ) = A'.
;;*
;;*              TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit triangular
;;*           as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of B. M must be at
;;*           least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of B.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - COMPLEX         .
;;*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
;;*           zero then  A is not referenced and  B need not be set before
;;*           entry.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, k ), where k is m
;;*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
;;*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
;;*           upper triangular part of the array  A must contain the upper
;;*           triangular matrix  and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
;;*           lower triangular part of the array  A must contain the lower
;;*           triangular matrix  and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
;;*           A  are not referenced either,  but are assumed to be  unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
;;*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
;;*           then LDA must be at least max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - COMPLEX          array of DIMENSION ( LDB, n ).
;;*           Before entry,  the leading  m by n part of the array  B must
;;*           contain  the  right-hand  side  matrix  B,  and  on exit  is
;;*           overwritten by the solution matrix  X.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de ctrsm (side  uplo  transa  diag  m  n  alpha  a  lda  b  ldb  )
	((-str-) side )
	((-str-) uplo )
	((-str-) transa )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx1- (-float-)) alpha )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx3- (-float-)) b )
	((-idx0- (-int-)) ldb )
	#{ ctrsm_($side->data, $uplo->data, $transa->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,float), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($b,float), IDX_PTR($ldb,int)) #} ())



#? (ctrsv <uplo>  <trans>  <diag>  <n>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  CTRSV  solves one of the systems of equations
;;*
;;*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
;;*
;;*  where b and x are n element vectors and A is an n by n unit, or
;;*  non-unit, upper or lower triangular matrix.
;;*
;;*  No test for singularity or near-singularity is included in this
;;*  routine. Such tests must be performed before calling this routine.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the equations to be solved as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   A*x = b.
;;*
;;*              TRANS = 'T' or 't'   A'*x = b.
;;*
;;*              TRANS = 'C' or 'c'   conjg( A' )*x = b.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  A      - COMPLEX          array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular matrix and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular matrix and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced either, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  X      - COMPLEX          array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element right-hand side vector b. On exit, X is overwritten
;;*           with the solution vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de ctrsv (uplo  trans  diag  n  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx3- (-float-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-float-)) x )
	((-idx0- (-int-)) incx )
	#{ ctrsv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,float), IDX_PTR($lda,int), IDX_PTR($x,float), IDX_PTR($incx,int)) #} ())


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(with-namespace sf-lush-
(let ((dhc-make-lushflags (concat dhc-make-lushflags blas-cflags)))
  (dhc-make-with-libs  
   () 
   (cons blas-libblas blas-libfortran)
   blas-c-dummy 
   caxpy ccopy cdotc cdotu cgbmv cgemm cgemv cgerc cgeru chbmv chemm
   chemv cher2k cher2 cherk cher chpmv chpr2 chpr crotg cscal csscal
   cswap csymm csyr2k csyrk ctbmv ctbsv ctpmv ctpsv ctrmm ctrmv ctrsm
   ctrsv))
)
