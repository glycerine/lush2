#? * BLAS: Double Precision Functions
;;.AUTHOR Fu Jie Huang, Yann LeCun
;; This provides a complete interface to the FORTRAN BLAS
;; library of low-level linear algebra functions.

(libload "blas-config")
(libload "blas-x")


;; Check if we can short-circuit by just mod-loading the object file
(let* ((dhc-make-lushflags (concat dhc-make-lushflags blas-cflags))
       (objfile (dhc-make-test ())) )
  (when objfile
    (mod-load objfile)
    (mapcar mod-load (cons blas-libblas blas-libfortran))
    (skip-char "~\e") ;; skip until EOF
    t ) )


(de blas-d-dummy () (cheader "typedef int int_func();") ())


#? (dasum <n>  <dx>  <incx>  )
;;.VP
;;*  =====================================================================
;;*
;;*     takes the sum of the absolute values.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 3/93 to return if incx .le. 0.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de dasum (n  dx  incx  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dx )
	((-idx0- (-int-)) incx )
	(let ((rval 0))
	  ((-double-) rval)
	#{ $rval=dasum_(IDX_PTR($n,int), IDX_PTR($dx,double), IDX_PTR($incx,int)) #} rval))



#? (daxpy <n>  <da>  <dx>  <incx>  <dy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     constant times a vector plus a vector.
;;*     uses unrolled loops for increments equal to one.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de daxpy (n  da  dx  incx  dy  incy  )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) da )
	((-idx1- (-double-)) dx )
	((-idx0- (-int-))  incx )
	((-idx1- (-double-))  dy )
	((-idx0- (-int-))  incy )
	#{ daxpy_(IDX_PTR($n,int), IDX_PTR($da,double), IDX_PTR($dx,double), IDX_PTR($incx,int), IDX_PTR($dy,double), IDX_PTR($incy,int)) #} ())



#? (dcabs1 <z>  )
;;.VP
;;*  =====================================================================
;;*  =====================================================================

(de dcabs1 (z  )
    ((-idx1- (-double-)) z)
    (let ((rval 0))
      ((-double-) rval)
      #{ $rval=dcabs1_(IDX_PTR($z,double)) #} rval))



#? (dcopy <n>  <dx>  <incx>  <dy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     copies a vector, x, to a vector, y.
;;*     uses unrolled loops for increments equal to one.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de dcopy (n  dx  incx  dy  incy  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dx)
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) dy)
	((-idx0- (-int-)) incy )
	#{ dcopy_(IDX_PTR($n,int), IDX_PTR($dx,double), IDX_PTR($incx,int), IDX_PTR($dy,double), IDX_PTR($incy,int)) #} ())



#? (ddot <n>  <dx>  <incx>  <dy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     forms the dot product of two vectors.
;;*     uses unrolled loops for increments equal to one.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de ddot (n  dx  incx  dy  incy  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dx)
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) dy)
	((-idx0- (-int-)) incy )
	(let ((rval 0))
	#{ $rval=ddot_(IDX_PTR($n,int), IDX_PTR($dx,double), IDX_PTR($incx,int), IDX_PTR($dy,double), IDX_PTR($incy,int)) #} rval))



#? (dgbmv <trans>  <m>  <n>  <kl>  <ku>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DGBMV  performs one of the matrix-vector operations
;;*
;;*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are vectors and A is an
;;*  m by n band matrix, with kl sub-diagonals and ku super-diagonals.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
;;*
;;*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
;;*
;;*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  KL     - INTEGER.
;;*           On entry, KL specifies the number of sub-diagonals of the
;;*           matrix A. KL must satisfy  0 .le. KL.
;;*           Unchanged on exit.
;;*
;;*  KU     - INTEGER.
;;*           On entry, KU specifies the number of super-diagonals of the
;;*           matrix A. KU must satisfy  0 .le. KU.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading ( kl + ku + 1 ) by n part of the
;;*           array A must contain the matrix of coefficients, supplied
;;*           column by column, with the leading diagonal of the matrix in
;;*           row ( ku + 1 ) of the array, the first super-diagonal
;;*           starting at position 2 in row ku, the first sub-diagonal
;;*           starting at position 1 in row ( ku + 2 ), and so on.
;;*           Elements in the array A that do not correspond to elements
;;*           in the band matrix (such as the top left ku by ku triangle)
;;*           are not referenced.
;;*           The following program segment will transfer a band matrix
;;*           from conventional full matrix storage to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    K = KU + 1 - J
;;*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
;;*                       A( K + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( kl + ku + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
;;*           Before entry, the incremented array X must contain the
;;*           vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of DIMENSION at least
;;*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
;;*           Before entry, the incremented array Y must contain the
;;*           vector y. On exit, Y is overwritten by the updated vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgbmv (trans  m  n  kl  ku  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) kl )
	((-idx0- (-int-)) ku )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) beta )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ dgbmv_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($kl,int), IDX_PTR($ku,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())



#? (dgemm <transa>  <transb>  <m>  <n>  <k>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DGEMM  performs one of the matrix-matrix operations
;;*
;;*     C := alpha*op( A )*op( B ) + beta*C,
;;*
;;*  where  op( X ) is one of
;;*
;;*     op( X ) = X   or   op( X ) = X',
;;*
;;*  alpha and beta are scalars, and A, B and C are matrices, with op( A )
;;*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  TRANSA - CHARACTER*1.
;;*           On entry, TRANSA specifies the form of op( A ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSA = 'N' or 'n',  op( A ) = A.
;;*
;;*              TRANSA = 'T' or 't',  op( A ) = A'.
;;*
;;*              TRANSA = 'C' or 'c',  op( A ) = A'.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANSB - CHARACTER*1.
;;*           On entry, TRANSB specifies the form of op( B ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSB = 'N' or 'n',  op( B ) = B.
;;*
;;*              TRANSB = 'T' or 't',  op( B ) = B'.
;;*
;;*              TRANSB = 'C' or 'c',  op( B ) = B'.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry,  M  specifies  the number  of rows  of the  matrix
;;*           op( A )  and of the  matrix  C.  M  must  be at least  zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N  specifies the number  of columns of the matrix
;;*           op( B ) and the number of columns of the matrix C. N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry,  K  specifies  the number of columns of the matrix
;;*           op( A ) and the number of rows of the matrix op( B ). K must
;;*           be at least  zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
;;*           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by m  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
;;*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
;;*           least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
;;*           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
;;*           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
;;*           part of the array  B  must contain the matrix  B,  otherwise
;;*           the leading  n by k  part of the array  B  must contain  the
;;*           matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
;;*           LDB must be at least  max( 1, k ), otherwise  LDB must be at
;;*           least  max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
;;*           supplied as zero then C need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
;;*           Before entry, the leading  m by n  part of the array  C must
;;*           contain the matrix  C,  except when  beta  is zero, in which
;;*           case C need not be set on entry.
;;*           On exit, the array  C  is overwritten by the  m by n  matrix
;;*           ( alpha*op( A )*op( B ) + beta*C ).
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dgemm (transa  transb  m  n  k  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) transa )
	((-str-) transb )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	#{ dgemm_($transa->data, $transb->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($beta,double), IDX_PTR($c,double), IDX_PTR($ldc,int)) #} ())



#? (dgemv <trans>  <m>  <n>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DGEMV  performs one of the matrix-vector operations
;;*
;;*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are vectors and A is an
;;*  m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
;;*
;;*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
;;*
;;*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading m by n part of the array A must
;;*           contain the matrix of coefficients.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
;;*           Before entry, the incremented array X must contain the
;;*           vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of DIMENSION at least
;;*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
;;*           and at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
;;*           Before entry with BETA non-zero, the incremented array Y
;;*           must contain the vector y. On exit, Y is overwritten by the
;;*           updated vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dgemv (trans  m  n  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) trans )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) beta )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ dgemv_($trans->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())



#? (dger <m>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DGER   performs the rank 1 operation
;;*
;;*     A := alpha*x*y' + A,
;;*
;;*  where alpha is a scalar, x is an m element vector, y is an n element
;;*  vector and A is an m by n matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of the matrix A.
;;*           M must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( m - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the m
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry, the leading m by n part of the array A must
;;*           contain the matrix of coefficients. On exit, A is
;;*           overwritten by the updated matrix.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dger (m  n  alpha  x  incx  y  incy  a  lda  )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ dger_(IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())



#? (dnrm2 <n>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DNRM2 returns the euclidean norm of a vector via the function
;;*  name, so that
;;*
;;*     DNRM2 := sqrt( x'*x )
;;*
;;*
;;*
;;*  -- This version written on 25-October-1982.
;;*     Modified on 14-October-1993 to inline the call to DLASSQ.
;;*     Sven Hammarling, Nag Ltd.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dnrm2 (n  x  incx  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dnrm2_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} rval))



#? (drotg <da>  <db>  <c>  <s>  )
;;.VP
;;*  =====================================================================
;;*
;;*     construct givens plane rotation.
;;*     jack dongarra, linpack, 3/11/78.
;;*
;;*  =====================================================================

(de drotg (da  db  c  s  )
    ((-idx0- (-double-)) da)
    ((-idx0- (-double-)) db)
    ((-idx0- (-double-)) c)
    ((-idx0- (-double-)) s)
	#{ drotg_(IDX_PTR($da,double), IDX_PTR($db,double), IDX_PTR($c,double), IDX_PTR($s,double)) #} ())



#? (drot <n>  <dx>  <incx>  <dy>  <incy>  <c>  <s>  )
;;.VP
;;*  =====================================================================
;;*
;;*     applies a plane rotation.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de drot (n  dx  incx  dy  incy  c  s  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dx)
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) dy)
	((-idx0- (-int-)) incy )
	((-idx0- (-double-))  c)
	((-idx0- (-double-))  s)
	#{ drot_(IDX_PTR($n,int), IDX_PTR($dx,double), IDX_PTR($incx,int), IDX_PTR($dy,double), IDX_PTR($incy,int), IDX_PTR($c,double), IDX_PTR($s,double)) #} ())



#? (dsbmv <uplo>  <n>  <k>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSBMV  performs the matrix-vector  operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric band matrix, with k super-diagonals.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the band matrix A is being supplied as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  being supplied.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  being supplied.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry, K specifies the number of super-diagonals of the
;;*           matrix A. K must satisfy  0 .le. K.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
;;*           by n part of the array A must contain the upper triangular
;;*           band part of the symmetric matrix, supplied column by
;;*           column, with the leading diagonal of the matrix in row
;;*           ( k + 1 ) of the array, the first super-diagonal starting at
;;*           position 2 in row k, and so on. The top left k by k triangle
;;*           of the array A is not referenced.
;;*           The following program segment will transfer the upper
;;*           triangular part of a symmetric band matrix from conventional
;;*           full matrix storage to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = K + 1 - J
;;*                    DO 10, I = MAX( 1, J - K ), J
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
;;*           by n part of the array A must contain the lower triangular
;;*           band part of the symmetric matrix, supplied column by
;;*           column, with the leading diagonal of the matrix in row 1 of
;;*           the array, the first sub-diagonal starting at position 1 in
;;*           row 2, and so on. The bottom right k by k triangle of the
;;*           array A is not referenced.
;;*           The following program segment will transfer the lower
;;*           triangular part of a symmetric band matrix from conventional
;;*           full matrix storage to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = 1 - J
;;*                    DO 10, I = J, MIN( N, J + K )
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( k + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the
;;*           vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of DIMENSION at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the
;;*           vector y. On exit, Y is overwritten by the updated vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsbmv (uplo  n  k  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) beta )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ dsbmv_($uplo->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())



#? (dscal <n>  <da>  <dx>  <incx>  )
;;.VP
;;*  =====================================================================
;;*
;;*     scales a vector by a constant.
;;*     uses unrolled loops for increment equal to one.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 3/93 to return if incx .le. 0.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de dscal (n  da  dx  incx  )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) da)
	((-idx1- (-double-)) dx)
	((-idx0- (-int-)) incx )
	#{ dscal_(IDX_PTR($n,int), IDX_PTR($da,double), IDX_PTR($dx,double), IDX_PTR($incx,int)) #} ())



#? (dspmv <uplo>  <n>  <alpha>  <ap>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSPMV  performs the matrix-vector operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  AP     - DOUBLE PRECISION array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspmv (uplo  n  alpha  ap  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) beta )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ dspmv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($ap,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())



#? (dspr2 <uplo>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <ap>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSPR2  performs the symmetric rank 2 operation
;;*
;;*     A := alpha*x*y' + alpha*y*x' + A,
;;*
;;*  where alpha is a scalar, x and y are n element vectors and A is an
;;*  n by n symmetric matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - DOUBLE PRECISION array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the upper triangular part of the
;;*           updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the lower triangular part of the
;;*           updated matrix.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspr2 (uplo  n  alpha  x  incx  y  incy  ap  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx1- (-double-)) ap )
	#{ dspr2_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($ap,double)) #} ())



#? (dspr <uplo>  <n>  <alpha>  <x>  <incx>  <ap>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSPR    performs the symmetric rank 1 operation
;;*
;;*     A := alpha*x*x' + A,
;;*
;;*  where alpha is a real scalar, x is an n element vector and A is an
;;*  n by n symmetric matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the matrix A is supplied in the packed
;;*           array AP as follows:
;;*
;;*              UPLO = 'U' or 'u'   The upper triangular part of A is
;;*                                  supplied in AP.
;;*
;;*              UPLO = 'L' or 'l'   The lower triangular part of A is
;;*                                  supplied in AP.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - DOUBLE PRECISION array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
;;*           and a( 2, 2 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the upper triangular part of the
;;*           updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular part of the symmetric matrix
;;*           packed sequentially, column by column, so that AP( 1 )
;;*           contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
;;*           and a( 3, 1 ) respectively, and so on. On exit, the array
;;*           AP is overwritten by the lower triangular part of the
;;*           updated matrix.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dspr (uplo  n  alpha  x  incx  ap  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) ap )
	#{ dspr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($ap,double)) #} ())



#? (dswap <n>  <dx>  <incx>  <dy>  <incy>  )
;;.VP
;;*  =====================================================================
;;*
;;*     interchanges two vectors.
;;*     uses unrolled loops for increments equal one.
;;*     jack dongarra, linpack, 3/11/78.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de dswap (n  dx  incx  dy  incy  )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) dx)
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) dy)
	((-idx0- (-int-)) incy )
	#{ dswap_(IDX_PTR($n,int), IDX_PTR($dx,double), IDX_PTR($incx,int), IDX_PTR($dy,double), IDX_PTR($incy,int)) #} ())



#? (dsymm <side>  <uplo>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSYMM  performs one of the matrix-matrix operations
;;*
;;*     C := alpha*A*B + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*B*A + beta*C,
;;*
;;*  where alpha and beta are scalars,  A is a symmetric matrix and  B and
;;*  C are  m by n matrices.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry,  SIDE  specifies whether  the  symmetric matrix  A
;;*           appears on the  left or right  in the  operation as follows:
;;*
;;*              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
;;*
;;*              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of  the  symmetric  matrix   A  is  to  be
;;*           referenced as follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of the
;;*                                  symmetric matrix is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of the
;;*                                  symmetric matrix is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry,  M  specifies the number of rows of the matrix  C.
;;*           M  must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of the matrix C.
;;*           N  must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
;;*           m  when  SIDE = 'L' or 'l'  and is  n otherwise.
;;*           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
;;*           the array  A  must contain the  symmetric matrix,  such that
;;*           when  UPLO = 'U' or 'u', the leading m by m upper triangular
;;*           part of the array  A  must contain the upper triangular part
;;*           of the  symmetric matrix and the  strictly  lower triangular
;;*           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
;;*           the leading  m by m  lower triangular part  of the  array  A
;;*           must  contain  the  lower triangular part  of the  symmetric
;;*           matrix and the  strictly upper triangular part of  A  is not
;;*           referenced.
;;*           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
;;*           the array  A  must contain the  symmetric matrix,  such that
;;*           when  UPLO = 'U' or 'u', the leading n by n upper triangular
;;*           part of the array  A  must contain the upper triangular part
;;*           of the  symmetric matrix and the  strictly  lower triangular
;;*           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
;;*           the leading  n by n  lower triangular part  of the  array  A
;;*           must  contain  the  lower triangular part  of the  symmetric
;;*           matrix and the  strictly upper triangular part of  A  is not
;;*           referenced.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
;;*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
;;*           least  max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
;;*           Before entry, the leading  m by n part of the array  B  must
;;*           contain the matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
;;*           supplied as zero then C need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
;;*           Before entry, the leading  m by n  part of the array  C must
;;*           contain the matrix  C,  except when  beta  is zero, in which
;;*           case C need not be set on entry.
;;*           On exit, the array  C  is overwritten by the  m by n updated
;;*           matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dsymm (side  uplo  m  n  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) side )
	((-str-) uplo )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	#{ dsymm_($side->data, $uplo->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($beta,double), IDX_PTR($c,double), IDX_PTR($ldc,int)) #} ())



#? (dsymv <uplo>  <n>  <alpha>  <a>  <lda>  <x>  <incx>  <beta>  <y>  <incy>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSYMV  performs the matrix-vector  operation
;;*
;;*     y := alpha*A*x + beta*y,
;;*
;;*  where alpha and beta are scalars, x and y are n element vectors and
;;*  A is an n by n symmetric matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta. When BETA is
;;*           supplied as zero then Y need not be set on input.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y. On exit, Y is overwritten by the updated
;;*           vector y.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsymv (uplo  n  alpha  a  lda  x  incx  beta  y  incy  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx0- (-double-)) beta )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	#{ dsymv_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($beta,double), IDX_PTR($y,double), IDX_PTR($incy,int)) #} ())



#? (dsyr2k <uplo>  <trans>  <n>  <k>  <alpha>  <a>  <lda>  <b>  <ldb>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSYR2K  performs one of the symmetric rank 2k operations
;;*
;;*     C := alpha*A*B' + alpha*B*A' + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*A'*B + alpha*B'*A + beta*C,
;;*
;;*  where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
;;*  and  A and B  are  n by k  matrices  in the  first  case  and  k by n
;;*  matrices in the second case.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of the  array  C  is to be  referenced  as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry,  TRANS  specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   C := alpha*A*B' + alpha*B*A' +
;;*                                        beta*C.
;;*
;;*              TRANS = 'T' or 't'   C := alpha*A'*B + alpha*B'*A +
;;*                                        beta*C.
;;*
;;*              TRANS = 'C' or 'c'   C := alpha*A'*B + alpha*B'*A +
;;*                                        beta*C.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N specifies the order of the matrix C.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
;;*           of  columns  of the  matrices  A and B,  and on  entry  with
;;*           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
;;*           of rows of the matrices  A and B.  K must be at least  zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by n  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDA must be at least  max( 1, n ), otherwise  LDA must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  B  must contain the matrix  B,  otherwise
;;*           the leading  k by n  part of the array  B  must contain  the
;;*           matrix B.
;;*           Unchanged on exit.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDB must be at least  max( 1, n ), otherwise  LDB must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
;;*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
;;*           upper triangular part of the array C must contain the upper
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           lower triangular part of C is not referenced.  On exit, the
;;*           upper triangular part of the array  C is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
;;*           lower triangular part of the array C must contain the lower
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           upper triangular part of C is not referenced.  On exit, the
;;*           lower triangular part of the array  C is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dsyr2k (uplo  trans  n  k  alpha  a  lda  b  ldb  beta  c  ldc  )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	#{ dsyr2k_($uplo->data, $trans->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int), IDX_PTR($beta,double), IDX_PTR($c,double), IDX_PTR($ldc,int)) #} ())



#? (dsyr2 <uplo>  <n>  <alpha>  <x>  <incx>  <y>  <incy>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSYR2  performs the symmetric rank 2 operation
;;*
;;*     A := alpha*x*y' + alpha*y*x' + A,
;;*
;;*  where alpha is a scalar, x and y are n element vectors and A is an n
;;*  by n symmetric matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  Y      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCY ) ).
;;*           Before entry, the incremented array Y must contain the n
;;*           element vector y.
;;*           Unchanged on exit.
;;*
;;*  INCY   - INTEGER.
;;*           On entry, INCY specifies the increment for the elements of
;;*           Y. INCY must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced. On exit, the
;;*           upper triangular part of the array A is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced. On exit, the
;;*           lower triangular part of the array A is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyr2 (uplo  n  alpha  x  incx  y  incy  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx1- (-double-)) y )
	((-idx0- (-int-)) incy )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ dsyr2_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($y,double), IDX_PTR($incy,int), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())



#? (dsyrk <uplo>  <trans>  <n>  <k>  <alpha>  <a>  <lda>  <beta>  <c>  <ldc>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSYRK  performs one of the symmetric rank k operations
;;*
;;*     C := alpha*A*A' + beta*C,
;;*
;;*  or
;;*
;;*     C := alpha*A'*A + beta*C,
;;*
;;*  where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
;;*  and  A  is an  n by k  matrix in the first case and a  k by n  matrix
;;*  in the second case.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
;;*           triangular  part  of the  array  C  is to be  referenced  as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry,  TRANS  specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   C := alpha*A*A' + beta*C.
;;*
;;*              TRANS = 'T' or 't'   C := alpha*A'*A + beta*C.
;;*
;;*              TRANS = 'C' or 'c'   C := alpha*A'*A + beta*C.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry,  N specifies the order of the matrix C.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
;;*           of  columns   of  the   matrix   A,   and  on   entry   with
;;*           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
;;*           of rows of the matrix  A.  K must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
;;*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
;;*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
;;*           part of the array  A  must contain the matrix  A,  otherwise
;;*           the leading  k by n  part of the array  A  must contain  the
;;*           matrix A.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
;;*           then  LDA must be at least  max( 1, n ), otherwise  LDA must
;;*           be at least  max( 1, k ).
;;*           Unchanged on exit.
;;*
;;*  BETA   - DOUBLE PRECISION.
;;*           On entry, BETA specifies the scalar beta.
;;*           Unchanged on exit.
;;*
;;*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
;;*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
;;*           upper triangular part of the array C must contain the upper
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           lower triangular part of C is not referenced.  On exit, the
;;*           upper triangular part of the array  C is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
;;*           lower triangular part of the array C must contain the lower
;;*           triangular part  of the  symmetric matrix  and the strictly
;;*           upper triangular part of C is not referenced.  On exit, the
;;*           lower triangular part of the array  C is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDC    - INTEGER.
;;*           On entry, LDC specifies the first dimension of C as declared
;;*           in  the  calling  (sub)  program.   LDC  must  be  at  least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dsyrk (uplo  trans  n  k  alpha  a  lda  beta  c  ldc  )
	((-str-) uplo )
	((-str-) trans )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx0- (-double-)) beta )
	((-idx2- (-double-)) c )
	((-idx0- (-int-)) ldc )
	#{ dsyrk_($uplo->data, $trans->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($beta,double), IDX_PTR($c,double), IDX_PTR($ldc,int)) #} ())



#? (dsyr <uplo>  <n>  <alpha>  <x>  <incx>  <a>  <lda>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DSYR   performs the symmetric rank 1 operation
;;*
;;*     A := alpha*x*x' + A,
;;*
;;*  where alpha is a real scalar, x is an n element vector and A is an
;;*  n by n symmetric matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the upper or lower
;;*           triangular part of the array A is to be referenced as
;;*           follows:
;;*
;;*              UPLO = 'U' or 'u'   Only the upper triangular part of A
;;*                                  is to be referenced.
;;*
;;*              UPLO = 'L' or 'l'   Only the lower triangular part of A
;;*                                  is to be referenced.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry, ALPHA specifies the scalar alpha.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x.
;;*           Unchanged on exit.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular part of the symmetric matrix and the strictly
;;*           lower triangular part of A is not referenced. On exit, the
;;*           upper triangular part of the array A is overwritten by the
;;*           upper triangular part of the updated matrix.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular part of the symmetric matrix and the strictly
;;*           upper triangular part of A is not referenced. On exit, the
;;*           lower triangular part of the array A is overwritten by the
;;*           lower triangular part of the updated matrix.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dsyr (uplo  n  alpha  x  incx  a  lda  )
	((-str-) uplo )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	#{ dsyr_($uplo->data, IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($x,double), IDX_PTR($incx,int), IDX_PTR($a,double), IDX_PTR($lda,int)) #} ())



#? (dtbmv <uplo>  <trans>  <diag>  <n>  <k>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTBMV  performs one of the matrix-vector operations
;;*
;;*     x := A*x,   or   x := A'*x,
;;*
;;*  where x is an n element vector and  A is an n by n unit, or non-unit,
;;*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   x := A*x.
;;*
;;*              TRANS = 'T' or 't'   x := A'*x.
;;*
;;*              TRANS = 'C' or 'c'   x := A'*x.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with UPLO = 'U' or 'u', K specifies the number of
;;*           super-diagonals of the matrix A.
;;*           On entry with UPLO = 'L' or 'l', K specifies the number of
;;*           sub-diagonals of the matrix A.
;;*           K must satisfy  0 .le. K.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
;;*           by n part of the array A must contain the upper triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row
;;*           ( k + 1 ) of the array, the first super-diagonal starting at
;;*           position 2 in row k, and so on. The top left k by k triangle
;;*           of the array A is not referenced.
;;*           The following program segment will transfer an upper
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = K + 1 - J
;;*                    DO 10, I = MAX( 1, J - K ), J
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
;;*           by n part of the array A must contain the lower triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row 1 of
;;*           the array, the first sub-diagonal starting at position 1 in
;;*           row 2, and so on. The bottom right k by k triangle of the
;;*           array A is not referenced.
;;*           The following program segment will transfer a lower
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = 1 - J
;;*                    DO 10, I = J, MIN( N, J + K )
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Note that when DIAG = 'U' or 'u' the elements of the array A
;;*           corresponding to the diagonal elements of the matrix are not
;;*           referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( k + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x. On exit, X is overwritten with the
;;*           tranformed vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtbmv (uplo  trans  diag  n  k  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ dtbmv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())



#? (dtbsv <uplo>  <trans>  <diag>  <n>  <k>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTBSV  solves one of the systems of equations
;;*
;;*     A*x = b,   or   A'*x = b,
;;*
;;*  where b and x are n element vectors and A is an n by n unit, or
;;*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
;;*  diagonals.
;;*
;;*  No test for singularity or near-singularity is included in this
;;*  routine. Such tests must be performed before calling this routine.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the equations to be solved as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   A*x = b.
;;*
;;*              TRANS = 'T' or 't'   A'*x = b.
;;*
;;*              TRANS = 'C' or 'c'   A'*x = b.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  K      - INTEGER.
;;*           On entry with UPLO = 'U' or 'u', K specifies the number of
;;*           super-diagonals of the matrix A.
;;*           On entry with UPLO = 'L' or 'l', K specifies the number of
;;*           sub-diagonals of the matrix A.
;;*           K must satisfy  0 .le. K.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
;;*           by n part of the array A must contain the upper triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row
;;*           ( k + 1 ) of the array, the first super-diagonal starting at
;;*           position 2 in row k, and so on. The top left k by k triangle
;;*           of the array A is not referenced.
;;*           The following program segment will transfer an upper
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = K + 1 - J
;;*                    DO 10, I = MAX( 1, J - K ), J
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
;;*           by n part of the array A must contain the lower triangular
;;*           band part of the matrix of coefficients, supplied column by
;;*           column, with the leading diagonal of the matrix in row 1 of
;;*           the array, the first sub-diagonal starting at position 1 in
;;*           row 2, and so on. The bottom right k by k triangle of the
;;*           array A is not referenced.
;;*           The following program segment will transfer a lower
;;*           triangular band matrix from conventional full matrix storage
;;*           to band storage:
;;*
;;*                 DO 20, J = 1, N
;;*                    M = 1 - J
;;*                    DO 10, I = J, MIN( N, J + K )
;;*                       A( M + I, J ) = matrix( I, J )
;;*              10    CONTINUE
;;*              20 CONTINUE
;;*
;;*           Note that when DIAG = 'U' or 'u' the elements of the array A
;;*           corresponding to the diagonal elements of the matrix are not
;;*           referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           ( k + 1 ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element right-hand side vector b. On exit, X is overwritten
;;*           with the solution vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtbsv (uplo  trans  diag  n  k  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx0- (-int-)) k )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ dtbsv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($k,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())



#? (dtpmv <uplo>  <trans>  <diag>  <n>  <ap>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTPMV  performs one of the matrix-vector operations
;;*
;;*     x := A*x,   or   x := A'*x,
;;*
;;*  where x is an n element vector and  A is an n by n unit, or non-unit,
;;*  upper or lower triangular matrix, supplied in packed form.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   x := A*x.
;;*
;;*              TRANS = 'T' or 't'   x := A'*x.
;;*
;;*              TRANS = 'C' or 'c'   x := A'*x.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - DOUBLE PRECISION array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
;;*           respectively, and so on.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
;;*           respectively, and so on.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x. On exit, X is overwritten with the
;;*           tranformed vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtpmv (uplo  trans  diag  n  ap  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ dtpmv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())



#? (dtpsv <uplo>  <trans>  <diag>  <n>  <ap>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTPSV  solves one of the systems of equations
;;*
;;*     A*x = b,   or   A'*x = b,
;;*
;;*  where b and x are n element vectors and A is an n by n unit, or
;;*  non-unit, upper or lower triangular matrix, supplied in packed form.
;;*
;;*  No test for singularity or near-singularity is included in this
;;*  routine. Such tests must be performed before calling this routine.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the equations to be solved as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   A*x = b.
;;*
;;*              TRANS = 'T' or 't'   A'*x = b.
;;*
;;*              TRANS = 'C' or 'c'   A'*x = b.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  AP     - DOUBLE PRECISION array of DIMENSION at least
;;*           ( ( n*( n + 1 ) )/2 ).
;;*           Before entry with  UPLO = 'U' or 'u', the array AP must
;;*           contain the upper triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
;;*           respectively, and so on.
;;*           Before entry with UPLO = 'L' or 'l', the array AP must
;;*           contain the lower triangular matrix packed sequentially,
;;*           column by column, so that AP( 1 ) contains a( 1, 1 ),
;;*           AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
;;*           respectively, and so on.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element right-hand side vector b. On exit, X is overwritten
;;*           with the solution vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtpsv (uplo  trans  diag  n  ap  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx1- (-double-)) ap )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ dtpsv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($ap,double), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())



#? (dtrmm <side>  <uplo>  <transa>  <diag>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTRMM  performs one of the matrix-matrix operations
;;*
;;*     B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
;;*
;;*  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
;;*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
;;*
;;*     op( A ) = A   or   op( A ) = A'.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry,  SIDE specifies whether  op( A ) multiplies B from
;;*           the left or right as follows:
;;*
;;*              SIDE = 'L' or 'l'   B := alpha*op( A )*B.
;;*
;;*              SIDE = 'R' or 'r'   B := alpha*B*op( A ).
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix A is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANSA - CHARACTER*1.
;;*           On entry, TRANSA specifies the form of op( A ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSA = 'N' or 'n'   op( A ) = A.
;;*
;;*              TRANSA = 'T' or 't'   op( A ) = A'.
;;*
;;*              TRANSA = 'C' or 'c'   op( A ) = A'.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit triangular
;;*           as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of B. M must be at
;;*           least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of B.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
;;*           zero then  A is not referenced and  B need not be set before
;;*           entry.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
;;*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
;;*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
;;*           upper triangular part of the array  A must contain the upper
;;*           triangular matrix  and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
;;*           lower triangular part of the array  A must contain the lower
;;*           triangular matrix  and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
;;*           A  are not referenced either,  but are assumed to be  unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
;;*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
;;*           then LDA must be at least max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
;;*           Before entry,  the leading  m by n part of the array  B must
;;*           contain the matrix  B,  and  on exit  is overwritten  by the
;;*           transformed matrix.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dtrmm (side  uplo  transa  diag  m  n  alpha  a  lda  b  ldb  )
	((-str-) side )
	((-str-) uplo )
	((-str-) transa )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ dtrmm_($side->data, $uplo->data, $transa->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())



#? (dtrmv <uplo>  <trans>  <diag>  <n>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTRMV  performs one of the matrix-vector operations
;;*
;;*     x := A*x,   or   x := A'*x,
;;*
;;*  where x is an n element vector and  A is an n by n unit, or non-unit,
;;*  upper or lower triangular matrix.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the operation to be performed as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   x := A*x.
;;*
;;*              TRANS = 'T' or 't'   x := A'*x.
;;*
;;*              TRANS = 'C' or 'c'   x := A'*x.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular matrix and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular matrix and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced either, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element vector x. On exit, X is overwritten with the
;;*           tranformed vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrmv (uplo  trans  diag  n  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ dtrmv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())



#? (dtrsm <side>  <uplo>  <transa>  <diag>  <m>  <n>  <alpha>  <a>  <lda>  <b>  <ldb>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTRSM  solves one of the matrix equations
;;*
;;*     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
;;*
;;*  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
;;*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
;;*
;;*     op( A ) = A   or   op( A ) = A'.
;;*
;;*  The matrix X is overwritten on B.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  SIDE   - CHARACTER*1.
;;*           On entry, SIDE specifies whether op( A ) appears on the left
;;*           or right of X as follows:
;;*
;;*              SIDE = 'L' or 'l'   op( A )*X = alpha*B.
;;*
;;*              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
;;*
;;*           Unchanged on exit.
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix A is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANSA - CHARACTER*1.
;;*           On entry, TRANSA specifies the form of op( A ) to be used in
;;*           the matrix multiplication as follows:
;;*
;;*              TRANSA = 'N' or 'n'   op( A ) = A.
;;*
;;*              TRANSA = 'T' or 't'   op( A ) = A'.
;;*
;;*              TRANSA = 'C' or 'c'   op( A ) = A'.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit triangular
;;*           as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  M      - INTEGER.
;;*           On entry, M specifies the number of rows of B. M must be at
;;*           least zero.
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the number of columns of B.  N must be
;;*           at least zero.
;;*           Unchanged on exit.
;;*
;;*  ALPHA  - DOUBLE PRECISION.
;;*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
;;*           zero then  A is not referenced and  B need not be set before
;;*           entry.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
;;*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
;;*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
;;*           upper triangular part of the array  A must contain the upper
;;*           triangular matrix  and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
;;*           lower triangular part of the array  A must contain the lower
;;*           triangular matrix  and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
;;*           A  are not referenced either,  but are assumed to be  unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
;;*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
;;*           then LDA must be at least max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
;;*           Before entry,  the leading  m by n part of the array  B must
;;*           contain  the  right-hand  side  matrix  B,  and  on exit  is
;;*           overwritten by the solution matrix  X.
;;*
;;*  LDB    - INTEGER.
;;*           On entry, LDB specifies the first dimension of B as declared
;;*           in  the  calling  (sub)  program.   LDB  must  be  at  least
;;*           max( 1, m ).
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 3 Blas routine.
;;*
;;*
;;*  -- Written on 8-February-1989.
;;*     Jack Dongarra, Argonne National Laboratory.
;;*     Iain Duff, AERE Harwell.
;;*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
;;*     Sven Hammarling, Numerical Algorithms Group Ltd.
;;*
;;*
;;*     .. External Functions ..
;;*  =====================================================================

(de dtrsm (side  uplo  transa  diag  m  n  alpha  a  lda  b  ldb  )
	((-str-) side )
	((-str-) uplo )
	((-str-) transa )
	((-str-) diag )
	((-idx0- (-int-)) m )
	((-idx0- (-int-)) n )
	((-idx0- (-double-)) alpha )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx2- (-double-)) b )
	((-idx0- (-int-)) ldb )
	#{ dtrsm_($side->data, $uplo->data, $transa->data, $diag->data, IDX_PTR($m,int), IDX_PTR($n,int), IDX_PTR($alpha,double), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($b,double), IDX_PTR($ldb,int)) #} ())



#? (dtrsv <uplo>  <trans>  <diag>  <n>  <a>  <lda>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DTRSV  solves one of the systems of equations
;;*
;;*     A*x = b,   or   A'*x = b,
;;*
;;*  where b and x are n element vectors and A is an n by n unit, or
;;*  non-unit, upper or lower triangular matrix.
;;*
;;*  No test for singularity or near-singularity is included in this
;;*  routine. Such tests must be performed before calling this routine.
;;*
;;*  Parameters
;;*  ==========
;;*
;;*  UPLO   - CHARACTER*1.
;;*           On entry, UPLO specifies whether the matrix is an upper or
;;*           lower triangular matrix as follows:
;;*
;;*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
;;*
;;*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
;;*
;;*           Unchanged on exit.
;;*
;;*  TRANS  - CHARACTER*1.
;;*           On entry, TRANS specifies the equations to be solved as
;;*           follows:
;;*
;;*              TRANS = 'N' or 'n'   A*x = b.
;;*
;;*              TRANS = 'T' or 't'   A'*x = b.
;;*
;;*              TRANS = 'C' or 'c'   A'*x = b.
;;*
;;*           Unchanged on exit.
;;*
;;*  DIAG   - CHARACTER*1.
;;*           On entry, DIAG specifies whether or not A is unit
;;*           triangular as follows:
;;*
;;*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
;;*
;;*              DIAG = 'N' or 'n'   A is not assumed to be unit
;;*                                  triangular.
;;*
;;*           Unchanged on exit.
;;*
;;*  N      - INTEGER.
;;*           On entry, N specifies the order of the matrix A.
;;*           N must be at least zero.
;;*           Unchanged on exit.
;;*
;;*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
;;*           Before entry with  UPLO = 'U' or 'u', the leading n by n
;;*           upper triangular part of the array A must contain the upper
;;*           triangular matrix and the strictly lower triangular part of
;;*           A is not referenced.
;;*           Before entry with UPLO = 'L' or 'l', the leading n by n
;;*           lower triangular part of the array A must contain the lower
;;*           triangular matrix and the strictly upper triangular part of
;;*           A is not referenced.
;;*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
;;*           A are not referenced either, but are assumed to be unity.
;;*           Unchanged on exit.
;;*
;;*  LDA    - INTEGER.
;;*           On entry, LDA specifies the first dimension of A as declared
;;*           in the calling (sub) program. LDA must be at least
;;*           max( 1, n ).
;;*           Unchanged on exit.
;;*
;;*  X      - DOUBLE PRECISION array of dimension at least
;;*           ( 1 + ( n - 1 )*abs( INCX ) ).
;;*           Before entry, the incremented array X must contain the n
;;*           element right-hand side vector b. On exit, X is overwritten
;;*           with the solution vector x.
;;*
;;*  INCX   - INTEGER.
;;*           On entry, INCX specifies the increment for the elements of
;;*           X. INCX must not be zero.
;;*           Unchanged on exit.
;;*
;;*
;;*  Level 2 Blas routine.
;;*
;;*  -- Written on 22-October-1986.
;;*     Jack Dongarra, Argonne National Lab.
;;*     Jeremy Du Croz, Nag Central Office.
;;*     Sven Hammarling, Nag Central Office.
;;*     Richard Hanson, Sandia National Labs.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dtrsv (uplo  trans  diag  n  a  lda  x  incx  )
	((-str-) uplo )
	((-str-) trans )
	((-str-) diag )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) a )
	((-idx0- (-int-)) lda )
	((-idx1- (-double-)) x )
	((-idx0- (-int-)) incx )
	#{ dtrsv_($uplo->data, $trans->data, $diag->data, IDX_PTR($n,int), IDX_PTR($a,double), IDX_PTR($lda,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} ())



#? (dzasum <n>  <zx>  <incx>  )
;;.VP
;;*  =====================================================================
;;*
;;*     takes the sum of the absolute values.
;;*     jack dongarra, 3/11/78.
;;*     modified 3/93 to return if incx .le. 0.
;;*     modified 12/3/93, array(1) declarations changed to array(*)
;;*
;;*  =====================================================================

(de dzasum (n  zx  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) zx )
	((-idx0- (-int-)) incx )
	(let ((rval 0))
	  ((-double-) rval)
	#{ $rval=dzasum_(IDX_PTR($n,int), IDX_PTR($zx,double), IDX_PTR($incx,int)) #} rval))



#? (dznrm2 <n>  <x>  <incx>  )
;;.VP
;;*  =====================================================================
;;*  Purpose
;;*  =======
;;*
;;*  DZNRM2 returns the euclidean norm of a vector via the function
;;*  name, so that
;;*
;;*     DZNRM2 := sqrt( conjg( x' )*x )
;;*
;;*
;;*
;;*  -- This version written on 25-October-1982.
;;*     Modified on 14-October-1993 to inline the call to ZLASSQ.
;;*     Sven Hammarling, Nag Ltd.
;;*
;;*
;;*     .. Parameters ..
;;*  =====================================================================

(de dznrm2 (n  x  incx  )
	((-idx0- (-int-)) n )
	((-idx2- (-double-)) x )
	((-idx0- (-int-)) incx )
	(let ((rval 0))
	((-double-) rval)
	#{ $rval=dznrm2_(IDX_PTR($n,int), IDX_PTR($x,double), IDX_PTR($incx,int)) #} rval))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(with-namespace sf-lush-
(let ((dhc-make-lushflags (concat dhc-make-lushflags blas-cflags)))
  (dhc-make-with-libs  
   () 
   (cons blas-libblas blas-libfortran)
   blas-d-dummy 
   dasum daxpy dcabs1 dcopy ddot dgbmv dgemm dgemv dger dnrm2 drotg drot
   dsbmv dscal dspmv dspr2 dspr dswap dsymm dsymv dsyr2k dsyr2 dsyrk dsyr
   dtbmv dtbsv dtpmv dtpsv dtrmm dtrmv dtrsm dtrsv dzasum dznrm2))
)

