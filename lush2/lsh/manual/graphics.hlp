$Id: graphics.hlp,v 1.20 2007/10/31 20:23:12 leonb Exp $
#? *** Graphics

Lush features a collection of graphics functions for creating
windows, drawing figures, plotting curves, and handling graphical
events. 

A window descriptor is a lisp object of class <Window>.  Most graphical
commands implicitely operate on the current window defined by the window
descriptor stored in the symbol <window>.

Each window descriptor forwards all drawing requests to a ``Graphic Driver''
which performs the system dependent calls required to display the drawings on
the corresponding device.  The most common type of window (and driver) is the
<x11-window>, which displays on your screen under Xwindows.

Three drivers are very useful to produce printable graphs.  Driver <ps-window>
sends all graphic command to an Encapsulated PostScript file.  Driver
<svg-window> procudes a SVG file that can be edited with programs such as
<"inkscape"> or <"sodipodi">. 

#? ** Creating a Window

The standard function for creating a window on your screen is
<new-window>. This function determines which system your are running
and calls the appropriate low level function.

Function <print-window> performs the same task for creating a window
descriptor that accesses your printer.


#? (new-window [[<x> <y>] <w> <h>] [<name>])
Create new window object and return it.

.TYPE DX
.SEE (new-window! [[[<x> <y>] <w> <h>] <name>])
.SEE (x11-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (svg-window [[<w> <h>] <name> [<units-per-mm>]])
.SEE (ps-window [[<w> <h>] <name>])
.SEE (wbm-window  [[[<x> <y>] <w> <h>] <name>])
.SEE window

This is the device independent function for creating a window. It
figures out which drivers are available, and call the appropriate
function for creating a window.

Function <new-window> function creates a window named <name>.
Arguments <w> and <h> specify the size of the window.
Arguments <x> and <y> specify the location of the window.

Windows are closed when they are no longer referenced by the
lisp interpreter, when they are deleted with the <delete> 
function, or when the windowing system sends a deletion request.


#? (new-window! [[<x> <y>] <w> <h>] [<name>])
Same as <new-window> but in addition store the new
window object in global variable <window>.


#? (print-window <w> <h> [<destination>])
.TYPE DX
.SEE (ps-window [[<w> <h>] <name>])
.SEE (wpr-window [[<w> <h>] <name>])
.SEE (wpr-printers)
.SEE Print Requester.
.SEE Producing Encapsulated PostScript Files.
.SEE window

This is the device independent function for printing
graphics on the system printer. This function figures
out the best way to send graphics on the printer
or the file specified by string <destination>.
Arguments <w> and <h> specify the size of the printing area.
The drawings will be scaled to fit a standard size page.

Function <print-window> actually calls a system
dependent function (e.g. <wpr-window> under Windows 95 and NT,
<ps-window> under Unix operating systems). Argument <destination>
is passed verbatim to these functions.
There are therefore two ways to write a portable program.
The simplest way consists in omitting argument <destination>. 
The best way consists in using the <PrintRequester> class
provided with the Ogre library.

The window descriptors returned by <print-window> are very
similar to the window descriptors returned by <new-window>.
They print pages instead of rendering graphics on your screen.
A page is output when you call function <cls> or when the
window descriptor is closed (because it is no longer
referenced by the interpretor or because you called function
<delete>).  

Note: Calling function <cls> while a clip rectangle is active
(see function <clip>) will not output a page. It will simply
clears the clipping zone. Before using <cls>, you can use 
function <clip> to make sure that no clipping rectangle is active.


#? ** Drawing

The coordinate system of a window has its origin in the upper left
hand corner.  Positive x and y coordinates go to the right and
downwards.


#? (cls)  

Clears the current graphics window.

#? (draw-line  <x1> <y1> <x2> <y2>)

Draws a line from point (<x1>, <y1>) to the point (<x2>, <y2>) in the
current window, with the current color.


#? (draw-rect <x> <y> <w> <h>)

Draws a hollow rectangle in the current window, with the current
color.  Its top-left corner is located at coordinates (<x>, <y>); its
width is <w>, and its height is <h>.

#? (draw-round-rect <x> <y> <w> <h> [<r>])

Draws a hollow rectangle whith rounded corners of radius <r>.


#? (draw-circle  <x> <y> <r>)

Draws a hollow circle in the current window, with the current color.
The center of the circle is located at position (<x>, <y>).  The radius
of the circle is radius is <r>.


#? (draw-arc  <x> <y> <r> <fromangle> <toangle>)

Draws a segment of a circle in the current window, with the current
color.  The center of the circle is located at position (<x>, <y>).
The radius of the circle is radius is <r>.  The segment is delimited
by angle <fromangle> and <toangle> which are values between -360 and
360 inclusive. Argument <toangle> must be larger than <fromangle>.


#? (fill-rect <x> <y> <w> <h>)

Fills a rectangle in the current window, with the current color.  Its
top-left corner is located at coordinates (<x>, <y>); its width is <w>,
and its height is <h>.


#? (fill-round-rect  <x> <y> <w> <h> [<r>])

Fills a rectangle whith rounded corners of radius <r>.


#? (fill-circle  <x> <y> <r>)

Fills a circle in the current window, with the current color.  The
center of the circle is located at position (<x>, <y>).  The radius of
the circle is radius is <r>.


#? (fill-arc  <x> <y> <r> <fromangle> <toangle>)

Fills a segment of a circle in the current window, with the current
color.  The center of the circle is located at position (<x>, <y>).
The radius of the circle is radius is <r>.  The segment is delimited
by angle <fromangle> and <toangle> which are values between -360 and
360 inclusive. Argument <toangle> must be larger than <fromangle>.


#? (fill-polygon <x1> <y1> ... <xn> <yn>)

Fills the polygon defined by the points (<x1>, <y1>) to (<xn>, <yn>),
in the current window, with the current color.


#? (rgb-draw-matrix <x> <y> <mat> [<sx> <sy>])

This is the main function to draw an RGB or greyscale image.

This function displays the pixels contained in idx <mat> at
location (<x>,<y>) in the current window. The optional arguments <sx> 
and <sy> specify the horizontal and vertical zoom factors.

The matrix <mat> can be an idx2 or idx3. If it is an idx2,
each value is interpreted as a greyscale value where 0 is
black and 255 is white. If it is an idx3, the last dimension
must be 1, 3, or more. If the last dimension is 1, the values
are interpreted as greayscale values. If the last dimension
is 3 or more, the first 3 values in the last dimension are
interpreted as RGB intensities (between 0 and 255).

#? (draw-value  <x> <y> <val> <maxv> <maxs>)

This function displays a real value as a white or black square.

Arguments <x> and <y> are the coordinates of the center of the square.
Argument <val> is the value to be displayed.  Argument <maxv> is the
maximum absolute value for <val>.  Argument <maxs> is the maximum size
of the square. When <val> is larger than <maxv>, a square of size
<maxs> is drawn.

Note: The square will not be visible if it is drawn in the same color
as the background.



#? (draw-list  <x> <y> <l> <ncol> <maxv> <apart> <maxs>)

High level drawing function to graphically represent a list of real
numbers. A list of real numbers <l> will be represented as a series of
black or white squares on a grey background (actual colors depend on
the implementation).

Arguments <x> and <y> are the coordinates of the top left edge of the
background area.  The squares are arranged in an array with <ncol>
columns, the number of lines is then defined by the length of the list
<l>.  The grey background is always rectangular, even if <ncol> is not
a divisor of the length of <l>.

As with <draw-value>, argument <maxv> is the maximum absolute value
for the list elements. The size of the square is however bounded by
<maxs>.

Argument <apart> defines the size of the space occupied by a single
square, i.e, the centers of two neighboring squares will be apart
pixels apart. It is generally suitable to choose a value for <apart>
slightly greater than maxs so that no squares will overlap. For best
results, the difference between <apart> and <maxs> should be an even
number.

Example:
.CODE
 ; draw 6 values on 3 columns and 2 lines, in 50 pixel squares
 (draw-list 50 50 '( 4 5 -10 
                     0 4  16 ) 3 16 52 50)

 ; draw the values in l on a single line
 (draw-list 100 100 l (length l) 10 20 18)
.PP


#? (gray-draw-list  <x> <y> <l> <ncol> <minv> <maxv> <apart>)

High level drawing function to graphically represent a list of real
numbers. A list of real numbers <l> will be represented as a series of
gray squares whose gray level is related to the represented value.
This function uses a clever dithering algorithm on black&white
displays.

Arguments <x> and <y> are the coordinates of the topleft edge of the
first square (representing the first element in the list).  The
squares are arranged in an array with <ncol> columns, the number of
lines is defined by the length of the list <l>.  

Values between <minv> and <maxv> will be displayed as gray levels.  A
value of <minv> will be rendered as a black square. A value of <maxv>
will be rendered as a white square.  Argument <minv> can be defined to
be greater than <maxv> in order to produce a reverse video effect.
The sizes of the squares are defined by the <apart> parameter.



#? (gray-draw-matrix  <x> <y> <mat> <minv> <maxv> <apartx> <aparty>)

High level drawing function to graphically represent a 2D matrix <mat>
as a series of gray rectangles whose gray level is related to the
represented value. This function uses a clever dithering algorithm on
black and white displays.

Arguments <x> and <y> are the coordinates of the topleft edge of the
first square (representing the first element in the list).  The values
between <minv> and <maxv> will be displayed as gray levels.  A value
<minv> will be rendered as a black rectangle. A value <maxv> will be
rendered as a white rectangle.  Value <minv> can be defined to be
greater than <maxv> in order to produce a reverse video effect.  The
sizes of the rectangles are defined by the <apartx> and <aparty>
parameter.


#? (mat-disp <m> [<x> <y>])
.SEE gray-draw-matrix, new-window!
Display matrix contents in current window and return the window
object. 

This is an easy to use wrapper for <gray-draw-matrix>. It
automatically re-scales the matrix values to use the full dynamic
range of the display. When there is no current window, <mat-disp>
creates one.


#? (color-draw-list  <x> <y> <l> <ncol> <minv> <maxv> <apart> <cmap>)
.SEE (alloccolor <r> <g> <b>)

This function is essentially similar to <gray-draw-list>.  Argument
<cmap> however must be a one-dimensional matrix of 64 color numbers
returned by <alloccolor>.  Values between <minv> and <maxv> are
rendered using the ramp of colors specified by this matrix.



#? (color-draw-matrix  <x> <y> <mat> <minv> <maxv> <apartx> <aparty> <cmap>)
.SEE (alloccolor <r> <g> <b>)

This function is essentially similar to <gray-draw-matrix>.  Argument
<cmap> however must be a one-dimensional integer matrix of 64 color numbers
returned by <alloccolor>.  Values between <minv> and <maxv> are
rendered using the ramp of colors specified by this matrix.


#? ** Grabbing Images

#? (rgb-grab-matrix <x> <y> <mat>)
.SEE (rgb-draw-matrix <x> <y> <mat> [<sx> <sy>])

This function grabs a rectangular image from the current window.  
The top left corner of the image is located at coordinates (<x>,<y>).  
The size of the image is determined by the first two dimensions of matrix <mat>.  

The matrix <mat> can be an idx2 or idx3 as with <rgb-draw-matrix>.

This function only works on true color displays.


#? (save-window-as-ppm <filename>)
.SEE (rgb-grab-matrix <x> <y> <mat>)
This function uses <rgb-grab-matrix> to save
a snapshot of the current window into 
the PPM file <filename>.


#? ** Drawing with Colors

Color selection is highly dependent on the capabilities
of your graphics hardware and drivers.
.IP
There are still computers equipped with black and white screens.
You can check that your hardware can display enough colors
using function <colorp>. 
.IP
Many graphic devices use color palettes. The color palette defines
a small set of colors that can be displayed simultaneously on the 
screen. Lush will allocate palette entries as soon as you 
start using a new color. Since palette entries are rare resources,
you should use colors cautiously.
.PP
Lush provides two elementary functions for dealing with colors.
Function <alloccolor> takes a set of three numbers (ranging from 0 to 1)
representing the red, green and blue component of the color. 
This function allocates a palette entry if necessary and 
returns a hardware dependent color number. These color numbers
can be used with function <color> to set the current drawing color.

It happens sometimes that it is not possible to allocate a color
because the color palette is full. Lush will first try to create
its own color palette and install it whenever you activate a Lush window.
Windows created by other programs can display funny colors until
you activate one of these windows. If the private color palette is full,
function <alloccolor> simply returns a default color.

The use of a limited number of colors is therefore highly encouraged.
The function <color-stdmap> provides several convenient
sets of standard colors for this purpose.

.SEE Ogre Color Palette.

#? (colorp)
The function <colorp> is a predicate which returns <t> when the display
is known to support color. This function returns <()> 
when the display does not support color.

#? (color [<c>])
.SEE (alloccolor <r> <g> <b>)
If <c> is specified, sets the current color to color number <c>.
Function <color> always returns the current color.  
Color numbers are obtained with function <alloccolor>. A few
predefined color numbers however are defined by the file
<"graphenv.lsh">:
.IP
<color-fg> or -1  for the system foreground color.
.IP
<color-bg> or -2  for the system background color.
.IP
<color-gray> or -3 for a 50 percent dithered gray level.


#? (alloccolor <r> <g> <b>)
.SEE (color [<c>])
.SEE distinct-colors
Ask the driver for a color number defined by its three primitive
values. Arguments <r>, <g>, <b> are reals between 0 and 1 that define
the red, green and blue components of the desired color.

Returns a color number suitable for using with the <color> function.
This function returns the constant <color-gray> if the 
system is not able to display the requested color.

#? (distinct-colors)
Yield a sequence of color numbers of distinctly looking colors.
.P
Example:
.CODE
? (do ((cn (distinct-colors)))
    (color cn)
    ;; draw something
    )

#? color-fg
.TYPE VAR
.FILE graphenv.lsh
.SEE (color [<c>])
System foreground color.

#? color-bg
.TYPE VAR
.FILE graphenv.lsh
.SEE (color [<c>])
System background color.

#? color-gray
.TYPE VAR
.FILE graphenv.lsh
.SEE (color [<c>])
A 50 percent dithered gray level.

#? (color-shade <x>)
.TYPE DE
.FILE graphenv.lsh

This function calls <alloccolor> then <color> for setting a grayscale
color. Argument <x> is a real between 0 and 1. Function <color-shade>
provides support for grayscale monitors. In addition, drivers often
use dithering for filling circles or rectangles on black and white
monitors .

#? (color-rgb  <r> <g> <b>)
.TYPE DE
.FILE graphenv.lsh

This function calls <alloccolor> then <color> for setting the current
color according to its three primitive values. Arguments <r>, <g>, <b>
are reals between 0 and 1. Of course, this function has a poor effect
without a color screen.


#? (color-stdmap [<map>])
.SEE (show-stdmap [<map>])
Create a set of predefined colors. <Color-stdmap> returns an integer
vector containing color identifiers that can be passed to function 
<color>. In addition, <(color-stdmap 'rainbow)> establishes a global
<htable> <*color-to-colornumber*>, that map color names (symbols) to
color numbers.
.PP
Using this function maximizes the chances that several parts of your 
Lush programs will use the same palette entries and therefore avoid
palette saturation.
.PP
The argument <map> is a symbol which specifies ont of the predefined
color sets:
.IP
Symbol <rainbow> defines 64 colors located on a circle linking the
pure red, green and blue hues. The first 48 colors actually represent 
a rainbow. The last 16 colors directly interpolate purple to red.
.IP
Symbol <spread> defines 7 colors that are easy to discriminate.
.IP
Symbol <shade> defines a set of 64 gray levels going from black to 
white. 
.PP
Example:
.CODE
? (let ((win (new-window)))
    (color-stdmap 'rainbow)
    (*color-to-colornumber* 'yellow))
= 16772352

#? (show-stdmap [<map>])
Open a new graphics window and display all colors as defined by
<(color-stdmap map)>.
.SEE (color-stdmap [<map>])


#? (color-std (<x> [<map>])
The function <color-std> provides access to the convenient sets
of colors allocated by <color-stdmap>.
.IP
Argument <x> is number whose decimal part selects a color
in the set returned by function <color-stdmap>.
Value <0> selects the first color of the set. 
Value <0.9999> selects the last color of the set.
.IP
Optional argument <map> is a symbol which specifies a color set
for function <color-stdmap>.
.SEE (color-stdmap [<map>])


#? (linestyle [<ls>])
This function allows for drawing dashed lines.  
Argument <ls> can take the following values:
.IP 
<0> for solid lines.
.IP 
<1> for dotted lines.
.IP 
<2> for dashed lines.
.IP 
<3> for dotdashed lines.
.PP
Calling this function without arguments returns
the last selected line style.


#? ** Drawing Text

Text may be printed in graphic window by using the functions
<draw-text> and <gprintf>. The current font may be changed by
the function <font>. The size and/or rectangle of a graphic text
may be scaned by the functions <text-width>, <text-height> and
<rect-text>.


#? (draw-text <x> <y> <s>)

Draws the text of the string <s> in the current window at position
(<x>, <y>), using the current font and the current color.

#? (gprintf <x> <y> <fmt> ... <args> ...)
.TYPE DE
.FILE graphenv.lsh
.SEE (draw-text <x> <y> <s>)

Function <gprintf> behaves like function <printf>, but prints out the
text on the current graphic window, with the current font and color,
starting at location (<x>, <y>).


#? (font  [<fontname>])
.SEE (draw-text <x> <y> <s>)

When used without argument, 
function <font> returns the current font name.

Otherwise function <font> sets the font used for rendering 
characters in subsequent calls of function <draw-text>. 
If a matching font is found, <font> returns the name of the selected font.
Otherwise it returns <()> and sets a default font.

The default font name "default" is recognized by all drivers
and selects a reasonably small default font. Always using 
font <"default"> is the best guarantee to write fully 
portable programs.

All drivers however recognize PostScript(tm) style font names.
These font names have the following form:
.CODE
    "<family>[-<style>][-<size>]"
.IP
The recognized font family <family> usually depends heavily
on the operating system configuration. It is reasonable to
assume that the basic families <"Times">, <"Helvetica"> and <"Courier">
are available (or translated) everywhere. 
.IP
The optional style is preceded by a dash. Style <"Roman"> lets you
print plain text. More complex style are composed by concatenating 
an optional weight specification (e.g. <Light>, <DemiBold>, <Bold>, 
<Black>, etc...)  and an optional slant specification (i.e. <Italic>
or <Oblique>). 
.IP
The optional size is a number between 1 and 128.
.PP
Not all combination of families, styles and size are supported on all
systems. A good compromise between fancy display and portable graphics 
consists in using PostScript font names, but to limit yourself to the 
following fonts:
.CODE
    Courier-X, Courier-Bold-X, Courier-Italic-X, Courier-BoldItalic-X
    Times-Roman-X, Times-Bold-X, Times-Italic-X, Times-BoldItalic-X,
    Helvetica-X, Helvetica-Bold-X, Helvetica-Oblique-X, 
    Helvetica-BoldOblique-X, Symbol-X
.PP
where size <X> is one of <8>, <10>, <11>, <12>, <14>, <18>, <24>.
.PP
Most drivers also understand window system dependent font names (when such
font names are defined by the window system). For instance, 
the X11 driver recognizes XFLD font names 
(such as <"-*-times-*medium-*r-*--18-*">)
and, on some systems, also recognizes fontconfig patterns
(such as <":family=Bitstream Vera Sans:pixelsize=11">.
Function <x11-fontname> can be used to translate a Postscript 
font name into a system specific font name.

#? (rect-text <x> <y> <s>)

Returns a list <(x y w h)> describing the rectangle that would be
affected by a call to <(draw-text x y s)>. 

A few driver, including the PS driver, do not implement this function.
In that case, <rect-text> returns the empty list.

#? (text-width <s>)
.TYPE DE
.FILE graphenv.lsh
.SEE (rect-text <x> <y> <s>)

Returns the width of the text in string <s>, if it is printed with the
current font. This function uses <rect-text> if it is available, or
uses some crude heuristics.

#? (text-height <s>)
.TYPE DE
.FILE graphenv.lsh

Returns the height of the text in string <s>, if it is printed with
the current font. This function uses <rect-text> if it is available,
or uses some crude heuristics.


#? ** The Drawing Context

Several features define the drawing context.
The most usefull ones are the current driver,
the current font, the current color and the clipping rectangle.

#? (gsave <l1> ...<ln>)
Function <gsave> saves the graphics state of the current window,
evaluates lists <l1> to <ln> with a call to <progn>, and restores the
saved graphics state. Function <gsave> returns the result of the last
evaluation.

#? (gdriver)
Returns the name of the graphic driver of the current window.

#? (xsize)
Returns the width of the current window.

#? (ysize)
Returns the height of the current window.

#? window
.TYPE VAR
This variable <window> defines the current window. Most graphics
functions refers implicitly to the window descriptor stored in this
variable.

#? (clip [<x> <y> <w> <h>])

When a clip rectangle has been set, graphics output is restricted to
the inner part of the clip rectangle. the <clip> function allows for
manipulating the clip rectangle.

.IP
<(clip x y w h)> sets a new clip rectangle whose top left corner is
located at position (<x>, <y>), whose width is <w>, and whose height
is <h>.
.IP
<(clip ())> cancels clipping and unset the clipping rectangle.
.IP
<(clip)> just returns the current clipping rectangle.
.PP

Function <(clip)> always returns the previous clip rectangle, as a
list <(x y w h)>, or the empty list if no previous clipping rectangle
was set.

#? (addclip <rect>)

Argument <rect> must be a list of the form <(x y w h)>, where <x>,
<y>, <w>, and <h> are numbers.

Function <addclip> sets the current clip rectangle to the
intersection of the current clipping rectangle with a rectangle whose
top left corner is located at position (<x>, <y>), whose width is <w>,
and whose height is <h>.

If this intersection is empty, the empty list is returned.  Otherwise,
<addclip> returns the new clip rectangle.


#? ** Double Buffering and Synchronization

#? (graphics-batch  <l1> ... <ln>)

Most graphics drivers can work with an off-screen bitmap to update the
screen after several graphics commands. The <graphics-batch> function
provides a support for this double buffering abilities.  

This function evaluates the lists <l1> to <ln>, but if a graphic
instruction is executed, the screen update is delayed until the end of
these evaluations, and is performed only once.

#? (graphics-sync)

Inside a <graphics-batch> construct, this function immediatly
updates the screen without waiting for the completion of
the <graphics-batch> instruction.



#? ** Plotting Functions
.SEE Plotting Library.

Lush offers three ways to plot curves.
.IP
The old SN plotting functions are still 
available by loading file <"oldplotenv.lsh">.
We do not recomment using these functions,
but we keep them around for compatibility.
.IP
The new SN plotting functions provide a more
modern plotting experience while preserving
a fair level of backward compatibility
with the old SN plotting functions.
These function are defined in file <"plotenv.lsh">
and are loaded on demand using <autoload>.
.IP
A completely redesigned library <"libplot/plotter.lsh"> 
provides a third set of plotting function.
This library is documented in the Standard Libraries section.

#? * Plotting Basics

#? (graph-xy <lx> <ly> <...options...>) 
.TYPE DE 
.FILE plotenv.lsh 
.SEE (graph-options <...options...>)

Plots a curve composed of points whose X coordinates
are specified by list <lx> and Y coordinates by list <ly>.
The arguments <...options...> can be any of the
options described under function <graph-options>.

This function returns an object of class <PlotContext>
representing the axis system used for the plot.
This object can then be passed among the <...options...>
argument of a subsequent call to <graph-xy> in order
to plot several curves inside the same axis.

Example: 
Plot sine and cosine waves in the same axes.
.VP
(setq x (range 0 10 .2))
(setq v (graph-xy x (mapcar sin x)  
           `(color-rgb 1 0 0) ))
(setq v (graph-xy x (mapcar cos x) v  
            `(color-rgb 0 0 1) 
            `(linestyle 2) ))
.PP

The graphs themselves are displayed inside an
interactive window of class <PlotWindow>.
Menus provide ways to print, export,
and change the plot attributes.


#? (graph-xyv  <lx> <ly> <lsd> <...options...>)
.TYPE DE
.FILE plotenv.lsh
.SEE (graph-xy <lx> <ly> <...options...>) 
.SEE (graph-options <...options...>)

This function is similar to <graph-xy> but
accepts a third list containing the sizes
of standard deviation bars.

Example:
.VP
(setq lx (range 0 10 .2))
(graph-xyv lx 
          (all ((x lx)) (sin x)) 
          (all ((x lx)) (abs (* .3 (cos x)))) )




#? (graph-options <...options...>)

This function provides for creating an empty plot or
changing the appearance of a plot.
The optional arguments <...options...> are used to specify
which curve or plot context should be modified and 
which attributes should be modified.

The following arguments can be used to specify
which curve or plot context should be modified.
Absent such an argument, a new plot is created.
.IP
Pass a <PlotContext> object to select the plot context of interest.
Such objects are returned by function <graph-xy> for instance.
If no curve is specified, curve attributes will modify
the last curve plotted in the specified context.
.IP
Pass a <PlotCurve> object to select the curve of interest.
Curves can be obtained in the slot <curves> of the plot context object.
.IP
Pass a port (see next section) to select both the 
plot context and the curve.
.PP
Function <graph-options> always returns the selected plot context.
A new plot context is created if none is selected.
Therefore, calling this function without arguments simply
creates and returns a new plotting context.

The remaining options specify attributes for 
the selected plot context or plot curve.
A warning is displayed for each unrecognized attribute.

The following plot context attributes are recognized:
.IP
<(title <string>)> 
to select the plot title.
.IP
<(xtitle <string>)> and <(ytitle <string>)> 
to select the legend of the axes.
.IP 
<(margintop <x>)>,
<(marginleft <x>)>,
<(marginbottom <x>)>, and
<(marginright <x>)>
to specify the size of the specified margin.
.IP
<(xlog <boolean>)> and <(ylog <boolean>)>
to select a logarithmic scale for an axis.
.IP
<(xgrid <boolean>)> and <(ygrid <boolean>)>
to display a grid for an axis.
.IP
<(xbounds <b>)> or <(ybounds <b>)>
to specify the bounds of an axis.
Argument <b> can be the empty list (for the automatic mode) 
or a list <(min max)> containing the axis minimum and maximum values.
.IP
<(xlabels <b>)>,
<(ylabels <b>)>,
<(xticks <b>)>, and
<(yticks <b>)>
to specify the position of the axis labels and ticks.
Argument <b> can be the empty list (for the automatic mode),
a single number (for a specified interval), or a list of values.
.IP
<(xlabel2str <f>)> and <(ylabel2str <f>)>
to specify how labels should be displayed.
Argument <f> can be the empty list or a 
function taking a value and returning a string.
.PP
The following curve attributes are recognized:
.IP
<(color-rgb <r> <g> <b>)> and <(color <c>)>
to specify the curve color.
Arguments <r>, <g>, and <b> are numbers in range 0 to 1
representing the color components.
Argument <c> is a color returned by function <alloccolor>.
.IP
<(linestyle <n>)>
to specify the line style of the curve.
Argument <n> is a small integer suitable for
function <linestyle>.
.IP
<(sd-bar-size <x>)>
to specify the size of standard deviation bars.
This is used with function <graph-xyv>.
.IP
<(object <f>)> and <(object-size <n>)>
to specify the kind and size of the small symbols 
used for representing the curve points.
Argument <f> is a function described below.
Argument <n> is a small positive integer.
.PP
Each curve point is marked with a small symbol defined by a symbol function. 
A few symbol functions are predefined:
.IP
<object-nil> does not draw anything.
.IP     
<open-square>, <closed-square>, <open-circle>, and <closed-circle>
respectively draw a small hollow square, a small filled square, a
small hollow circle or a small filled circle.
.IP
<open-up-triangle>, <closed-up-triangle>, <open-down-triangle>, and
<closed-down-triangle> draw various kind of small triangles.
.IP
<straight-cross> and <oblique-cross> draw small crosses.
.PP



#? * Plotting using Ports

Functions <graph-xy> and <graph-xyv> do not provide for plotting 
curves in the midst of a computation, or for changing curve 
attributes from one point to the next.  
Such capabilities are available when one uses "ports".

A plotting port is a data structure which references 
a plotting context, a curve inside this context,
and the last plotted point.  This data structure
is implemented as a list for maintaining backward
compatibility with the old plotting functions.

#? plot-port
.TYPE VAR
.FILE plotenv.lsh
The current plot port is stored in this global variable.  
Most of the following plotting functions implicitly refer
to the plot port stored in variable <plot-port>.

#? (new-plot-port) 
.TYPE DE 
.FILE plotenv.lsh 
Function <(new-plot-port)> creates a new plotting 
window and returns a fresh plot port for this window.
It does not change the contents of variable <plot-port>.

#? (copy-plot-port  <p> [<object>])
.TYPE DE
.FILE plotenv.lsh
Returns a new plot port that plots inside the same
axis system as plot port <p>. This function allows 
the user to simultaneously plot several curves 
in the same axes by swapping the current plot port.

The optional argument <object> changes the initial 
object plotting function for this plot port.  
Function <graph-options> provides much more control.

#? (setup-axes)
.TYPE DE 
.FILE plotenv.lsh 
This function creates a new plot port and makes it current.
It is conceptually similar to 
.VP
  (setq plot-port (new-plot-port))

#? (plt-color-rgb <r> <g> <b>)
.SEE (graph-options <...options...>)
Sets the color for subsequent 
drawing operations in the current plot port.

#? (plt-color <c>)
.SEE (graph-options <...options...>)
Sets the color for subsequent 
drawing operations in the current plot port.

#? (plt-linestyle <n>)
.SEE (graph-options <...options...>)
Sets the linestyle for subsequent 
drawing operations in the current plot port.

#? (plt-object <f>)
.SEE (graph-options <...options...>)
Sets the symbol drawing function for subsequent 
drawing operations in the current plot port.

#? (plt-object-size <f>)
.SEE (graph-options <...options...>)
Sets the symbol size for subsequent 
drawing operations in the current plot port.

#? (plt-sd-bar-size <f>)
.SEE (graph-options <...options...>)
Sets the standard deviation width for subsequent 
drawing operations in the current plot port.

#? (plt-clear)
.TYPE DE
.FILE plotenv.lsh
This function clears the current point in the current plot port. 
Calling <plt-draw> after this function does not draw a line 
but simply sets the current point.

#? (plt-move <x> <y>)
.TYPE DE
.FILE plotenv.lsh
This function sets the current point in the current plot port.
Calling <plt-draw> after this function draws a line 
starting from the point of real coordinates <x>, <y>.

#? (plt-draw  <x y)
.TYPE DE
.FILE plotenv.lsh
Draws a line in the current plot port starting from the 
current point to the point of real coordinates <x> and <y>.
The current point is then moved to <x>, <y>.
When this function is called, the plot context
might recompute its axis system and redraw all the
curves to account for the new axis mapping.

#? (plt-plot <x> <y>)
.TYPE DE
.FILE plotenv.lsh
.SEE current-object
.SEE object-size
Moves the current point to the real coordinates <x> and <y>, 
and draws a small symbol like those used for showing 
the data points on a curve.

#? (plt-sd <x> <y> <v>)
.TYPE DE
.FILE plotenv.lsh
.SEE sd-bar-size.
Draws a standard deviation bar of size <v> around point (<x>,<y>).

#? (plot-lists <lx> <ly>)
.TYPE DE
.FILE plotenv.lsh
Plots a curve taking using in list <lx> as abscissas and values in <ly> as
ordinates in the current plot port. This function uses uses <plt-draw> and
<plt-plot> to draw a symbol at each data point.

#? (plot-lists-sd  <lx> <ly> <lsd>)
.TYPE DE
.FILE plotenv.lsh
Plots a curve taking values in list <lx> as abscissas and values in <ly> as
ordinates. Argument <lsd> is a list of values that will be displayed as
uncertainty bars around each data point.  This function uses uses <plt-draw>,
<plt-sd> and <plt-plot> to draw a symbol and an uncertainity bar at each data
point.



#? * Miscellaneous

The functions described in this section
exist mostly for backward compatibility
with the old plotting package.


#? (new-plot-port <brect> <rect> <object>) 
.TYPE DE 
.FILE plotenv.lsh 

DEPRECATED USAGE

Function <new-plot-port> may be called with additional 
arguments in order to create a plot port that draws 
inside a specified area of the current window
instead of creating an interactive plotting window.

Argument <brect> is a list <(bxmin bymin bxmax bymax)> 
whose elements are the pixel coordinates of the target 
rectangle in the current window. Argument
<rect> is a list <(xmin ymin xmax ymax)> whose 
elements define the axis bounds.
Argument <object> is the initial 
symbol drawing function.


#? (draw-axes  <brect> <xl> <yl> <name> [<x2l>] [<y2l>])
.TYPE DE
.FILE plotenv.lsh

DEPRECATED

Creating a plot port with the old plotting library 
did not automatically draw the axes. Calling
function <draw-axes> was mandatory.

The compatible implementation of this function simply 
changes the plotting port attributes to match
the desired axes.  
Argument <brect> is a list <(bxmin bymin bxmax bymax)>
whose elements are the pixel coordinates of the target 
rectangle in the current window.  
Arguments <xl> and <yl> are lists of label values 
for the <x> and <y> axis.  These labels are numbers 
expressed with the same scale than the axes. 
The optional functions <x2l> and <y2l> are used to 
convert these numbers into strings to display at 
the proper positions along the axes. 
Finally, argument <name> is the title of the plot.


#? (setup-axes <x1> <y1> <x2> <y2> [<xst> <yst> [<s> [<object>]]])
.TYPE DE
.FILE plotenv.lsh

DEPRECATED USAGE

Function <setup-axes> may be called with additional arguments 
in order to create a plot port that draws inside the 
current window instead of creating an interactive 
plotting window. The returned plot port is also 
stored in  variable <plot-port> to make it current.

Arguments <x1> and <y1> are the lower bounds of the axis coordinates;
arguments <x2> and <y2> are the upper bounds of the axis coordinates. 
The axes will be labeled every <xst> units horizontally and 
every <yst> units vertically. Argument <s> is the title string.
Argument <object> is the default plot object used by <plt-plot>.



#? current-object
.TYPE VAR
.FILE plotenv.lsh

DEPRECATED, DANGEROUS

The <plt-XXX> functions always check whether this
variable contains a suitable symbol drawing function.
If it does so, that symbol drawing function is made
current in the current plot port as if <plt-object> had been called.

#? object-size
.TYPE VAR
.FILE plotenv.lsh

DEPRECATED, DANGEROUS

The <plt-XXX> functions always check whether this
variable contains a suitable size for drawing symbols.
If it does so, that size is made current in the current plot port 
as if <plt-object-size> had been called.


#? sd-bar-size
.TYPE VAR
.FILE plotenv.lsh

DEPRECATED, DANGEROUS

The <plt-XXX> functions always check whether this
variable contains a suitable size for drawing standard deviation bars.
If it does so, that size is made current in the current plot port 
as if <plt-sd-bar-size> had been called.


#? (in-plot-port <l1> ... <ln>)
.TYPE DMD
.FILE plotenv.lsh

DEPRECATED, NOT IMPLEMENTED.

This function was part of the old plotting package and 
is no longer meaningful. If you need this function,
please load the old plotting packate <"oldplotenv.lsh">.


#? * Plotting Internals

#? << libstd/plotenv.lsh



#? ** Events
.SEE Ogre.

Several functions are provided for handling mouse and keyboard events
occurring on graphic windows. Lush has a centralized event queue
(see a full description in the Events and Timers section).
It is possible to obtain the events occuring on a window by creating an
<EventLock> object. Messages <read-event> and <check-event> allow for
testing and waiting for events.

This mechanism is used by a few handy functions <get-click>,
<get-vector> and <get-rect>, as demonstrated by the
incredibly shrinking paint program <lushpaint> below:
.CODE
(de lushpaint()
    (let ((window ()))
      (new-window)
      (draw-line 2 5 18 5)
      (draw-rect 22 2 18 8)
      (fill-rect 42 2 18 9)
      (gprintf 102 10 "Quit")
      (clip 0 12 1000 1000)
      (let ((ok t)
	    (mode draw-line)
	    (echo get-vector))
	(while ok
	   (let (((x y) (get-click)))
	     (cond
	      ((> y 10)
	       (apply mode (echo)) )
	      ((point-in-rect x y '(0 0 20 10))
	       (setq mode draw-line echo get-vector) )
	      ((point-in-rect x y '(20 0 20 10))
	       (setq mode draw-rect echo get-rect) )
	      ((point-in-rect x y '(40 0 20 10))
	       (setq mode fill-rect echo get-rect) )
	      ((point-in-rect x y '(100 0 20 10))
	       (setq ok ()) )) ) ) )
      (delete window) ) )		
.PP
(NOTE: more serious paint programs should probably be
 written with Ogre).


#? * Graphic Event Functions

#? (new EventLock <window>)
.FILE graphenv.lsh

Creating an <EventLock> object sets up window <window> to record
graphic events in the event-queue. Events can be retrieved with
messages <read-event> and <check-event>.

The initial state of the window is restored when the <EventLock>
object is destroyed.

#? (==> <EventLock> read-event)
.FILE graphenv.lsh
.SEE Event Lists.
.SEE (eventinfo)

This function returns the first available event on the window
associated to the <EventLock> object. Each event is represented
by a list whose first element broadly describes the event type.
Additional information can be obtained using function <eventinfo>. 

If the event queue is empty,
this function blocks until an event occurs.


#? (==> <EventLock> check-event)
.FILE graphenv.lsh
.SEE Event Lists.
.SEE (eventinfo)

This function returns the first available event on the window
associated to the <EventLock> object. Each event is represented
by a list whose first element broadly describes the event type.
Additional information can be obtained using function <eventinfo>. 

This function returns the empty list when no events are available.


#? (hilite <mode> <x1> <y1> <x2> <y2>)

The <hilite> function is used for displaying transient drawings when
the mouse button is depressed. As soon as the mouse button is
released, these transient drawings are cleared, and the window is
refreshed.

Four kinds of drawings are supported, whose names are defined by
<"graphenv.lsh">:

.IP
When <mode> is <hilite-invert>, the rectangle defined by the points
(<x1>,<y1>) and (<x2>,<y2>) is inverted. The result however is
poor on color displays.
.IP
When <mode> is <hilite-rect>, the rectangle defined by the points 
(<x1>,<y1>) and (<x2>,<y2>) is outlined with a dashed line.
.IP
When <mode> is <hilite-line>, a dashed line is drawn from point 
(<x1>,<y1>) to point (<x2>,<y2>).
.IP
When <mode> is <hilite-none>, any transient graphics are cleared, and
the window is refreshed.
.PP

Transient drawings created with <hilite> are very efficient, and
totally disappear when the mouse button is released. This function is
useful for providing an echo to the user during a mouse drag
operation. For example, function <hilite> can display a rectangular
outline while the user is dragging the mouse for selecting a part of
an image.


#? (get-click [<rect>])
.TYPE DE
.FILE graphenv.lsh

Waits for a mouse click on the current window.  Returns a list <(x y)>
giving the coordinates of the mouse during the mouse click.  Mouse
clisks will be ignored outside the rectangle specified by the optional
argument <rect>.

#? (get-vector [<rect>])
.TYPE DE
.FILE graphenv.lsh

Waits for a mouse down on the current window.  Tracks the mouse moves
with a dashed line, until the mouse button is released.  Returns a
list <(x1 y1 x2 y2)> telling where the mouse button has been depressed
and where it has been released.

The optional argument <rect> indicates a bouding rectangle which must
entirely contain the resulting vector. The echoed dashed line reflects
then this limitation.

#? (get-rect [<rect>])
.TYPE DE
.FILE graphenv.lsh

Waits for a mouse down on the current window.  Tracks the mouse moves
with a dashed rectangle, until the mouse button is released.  Returns
a list <(x y w h)> telling the location of the top left corner of the
rectangle, its width and its height.

The optional argument <rect> indicates a bouding rectangle which must
entirely contain the resulting rectangle. The echoed dashed rectangle
reflects then this limitation.


#? * Event Lists
.SEE (eventinfo)

Events returned by methods <read-event> and <check-event> are encoded
as lists, according to the following templates:

.IP
<(mouse-down x y)>:
The mouse button has been depressed at position (<x>,<y>).
You may use function <eventinfo> to query the identity of the
button and the status of the shift and control keys.
.IP
<(mouse-drag x_1 y_1 x_2 y_2)>:
The mouse button has been depressed at position (<x1>,<y1>).The
mouse has then been moved to position (<x2>,<y2>). The mouse button
still is depressed. 
You may use function <eventinfo> to query the identity of the
button and the status of the shift and control keys.

.IP
<(mouse-up x_1 y_1 x_2 y_2)>:
The mouse button has been depressed at position (x_1,y-1). The mouse
has then been moved to position (x_2,y_2), where the button has been
released.
You may use function <eventinfo> to query the identity of the
button and the status of the shift and control keys.
.IP
<("c" x y)>:
The key associated to the single character string <"c"> has been hit,
while the mouse pointer was located at position (<x>,<y>). These
events often are referred as keypress events.
.IP
<(arrow-left x y)>, <(arrow-right x y)>,
<(arrow-up x y)> or <(arrow-down x y)>:
The left (respectively right, up and down) arrow has been hit, while
the mouse pointer was located at position (<x>,<y>).
You may use function <eventinfo> to query the exact identity of the
depressed key and the status of the shift and control keys.
.IP
<(help x y)>:
The keyboard dependent help key has been hit, while the mouse pointer
was located at position (<x>,<y>).
You may use function <eventinfo> to query the exact name of the
depressed key and the status of the shift and control keys.
.IP
<(fkey x y)>:
A function key has been depressed. You must use function <eventinfo>
to get more information about the identity of the function key
and of the status of the shift and control keys.
.IP
<(resize w h)>
The window has been resized by the user, and is now <w>x<h> pixels large.
.IP
<(delete)>:
Windowing systems often provides a mean to delete a window. For
example, X11 ICCM compliant window managers are able to send a
WM_DELETE message to a client. If an event handler is attached to the
window, a delete event is added to the event queue, and the window is
not destroyed. A program thus gets a chance to display a confirmation
dialog before deleting the window.
.IP
<(sendevent x y)>:
These event is generated by function <sendevent>. Integer values <x>
and <y> are arbitrary.
.PP
These few events give enough information for building graphics
interfaces. The class library <"libogre/ogre.lsh"> is designed for that
purpose.


#? (eventinfo)

Returns a list <(name shiftp controlp)> that further describes 
the latest event returned by function <checkevent>.  
List elements <shiftp> and <controlp> are flags
indicating whether the shift or controlp are depressed.

After a mouse event, string <name> is the mouse button name.  
Possible names are <"Button1">, <"Button2">, etc.
for single clicks, and <"Button1-Dbl">, <"Button2-Dbl">, etc.
for double clicks.  After a <keypress> event, string <name> is
the name of the key.  


#? ** System Specific Graphic Functions

Lush provides also system specific functions.
The name of these functions always begin with the name
of the supported graphic system.  For example, "x11" is the
prefix for X-Windows specific functions and "win" is 
the prefix for Windows (95 and NT) specific functions.



#? * Specific Graphic Functions for X11

The following functions are only implemented on 
Unix systems implementing the X Windows standard.
This includes ``Motif'' and ``OpenWindows'' based systems.


#? (x11-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (new-window [[<x> <y>] <w> <h>] [<name>])

This is the low level function called by <new-window>
on X Windows systems.

This function creates a window of size <w> and <h> at position <x> and
<y> named <name> on the default X Windows screen. During the first
call of function <x11-window>, Lush searches the variable <display>
and the environment variable DISPLAY for the name of the X Windows
server and display to use.

Unlike <new-window>, this function does not store the newly created
window in the variable <window>, and thus does not make this window
current.


#? (x11-fontname <s>)
.SEE (font [<fontname>])

This function comes with the X11 driver. It converts a legal
PostScript(TM) font name, into a X11 font name.

String <s> must be a legal PostScript font name, composed of a font
family, an optional font style, and a font size, possibly separated by
dashes, like <"Helvetica-18">, <"Times-Roman24">, <"Courier-Bold-12">.
This function returns the corresponding font name under the X11.
conventions.

Example:
.EX (when x11-fontname (x11-fontname "Times-Roman18"))

#? (x11-depth)

Returns the depth of the current screen.

#? (x11-lookup-color <name>)

Lookup the (R,G,B) components of a color named <name>.


#? (x11-configure [<raise> <x> <y> <w> <h>])

Changes the window location (<x>,<y>) and size (<w>,<h>).  Giving the
empty list as argument leaves the corresponding characteristic
unchanged. When argument <raise> is true, the window is deiconified
and raised.

This function works only with X11R4 or greater. When effective, it
returns a list <(visible w h)> whose elements indicate the window
visibility and size.

#? (x11-iconify [<w>])
Iconify window <w> (default is current window).


#? (x11-text-to-clip <text>)

This function stores string <text> into the X11 copy/paste mechanism.
This function will some day recognize the copy/paste protocol used and
behave accordingly.

It implements today a cut buffer based mechanism suitable for
exchanging text with emacs and xterm. We plan to support selection as
soon as possible.


#? (x11-clip-to-text)

This function retrieves a string from the X11 copy/paste mechanism. It
returns the empty list <()> if no string is available. This function
will some day recognize the copy/paste protocol used and behave
accordingly.

It implements today a cut buffer based mechanism suitable for
exchanging text with emacs and xterm. We plan to support selection as
soon as possible.


#? * Specific Graphic Functions for Windows

[note: this function is not available in the current
 version of Lush]

The following functions are only implemented on Windows 

#? (wbm-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (new-window [[<x> <y>] <w> <h>] [<name>])
.SEE (wbm-toplevel-window  [[[<x> <y>] <w> <h>] <name>])

This is the low level function called by <new-window>
on Windows 95 and NT systems. This function is available
under WinLush only.

Function <wbm-window> creates a window of size <w> and <h> 
at position <x> and <y> named <name> in the WinLush environment.  
The command line version of Lush cannot create graphic windows yet.

Unlike <new-window>, this function does not store the newly created
window in the variable <window>, and thus does not make this window
current.


#? (wbm-toplevel-window  [[[<x> <y>] <w> <h>] <name>])
.SEE (new-window [[<x> <y>] <w> <h>] [<name>])
.SEE (wbm-window  [[[<x> <y>] <w> <h>] <name>])

This function is very similar to function <wbm-window>
described above. Instead of creating a child window
of the main WinLush window (according to the Windows MDI scheme),
function <wbm-toplevel-window> creates a toplevel window
that is not attached to the main WinLush window.


#? (wpr-window [[<w> <h>] <name>])
.SEE (print-window <w> <h> [<destination>])
.SEE (wpr-printers)

This is the low level function called by <print-window>
on Windows 95 and NT systems.

Function <wpr-window> creates a window descriptor which actually
accesses the printer named <name>. The default printer
is used if argument <name> is not specified. Function
<wpr-printers> should be used to obtain the list
of valid printer names.

Unlike <new-window> or <print-window>, 
this function does not store the newly created
window in the variable <window>, and thus does not make this window
current.

Arguments <w> and <h> specify the width and height 
of the coordinate system. The drawings will be scaled to fit
the size of the page returned by your printer.


#? (wpr-printers)
.SEE (wpr-window [[ <w> <h>] <name>])

This function returns a list of printers names suitable
for function <wpr-window>. The default printer name comes first.


#? (win-depth)

Returns the depth of the default display of your computer.
This is the number of bits specified in the Display Properties
dialog box.


#? (win-configure [<raise> <x> <y> <w> <h>])

Changes the window location (<x>,<y>) and size (<w>,<h>).  Giving the
empty list as argument leaves the corresponding characteristic
unchanged. When argument <raise> is true, the window is deiconified
and raised.

This function returns a list <(visible w h)> whose elements
indicate the window visibility and size.

#? (win-text-to-clip <text>)

This function stores string <text> into the clipboard.

#? (win-clip-to-text)

This function retrieves a string from the clipboard.
It returns () if the clipboard does not currently contain a string.




#? * Determining System Dependent Feature Support

The function <gdriver-feature> implements a small database
about the features supported by the common graphic drivers.
We suggest you use this function to implement portable
programs.

#? (gdriver-feature <feat> <opt>)

This function provides a portable mean to scan the current
graphic system for a feature. It returns the function
implementing the feature specified by symbol <feat> on the
given window. The result depends on the parameter <opt>.
.IP
When <opt> is symbol <loose>, this function always
returns a function. It returns the feature function
as soon as a partial implementation exists.
It returns function <progn> if the feature is
not implemented.

This option is usefull for calling minor services
(e.g. puting text into the clipboard)
for which failure has little consequence.
.IP
When <opt> is symbol <strict>, this function returns
a function if and only if the feature is fully implemented.
It returns the empty list otherwise.
.PP

Features are the following.
.IP 
<depth>:
This feature is a generalization of <x11-depth>.
.IP 
<text-to-clip>:
This feature is a generalization of <x11-text-to-clip>.
.IP
<clip-to-text>:
This feature is a generalization of <x11-clip-to-text>.
.IP
<configure>:
This feature is a generalization of <x11-configure>.
.IP
<hide>
This feature is a generalizetion of <x11-iconify>.
.IP
<fontname>:
This feature is a generalization of <x11-fontname>.
.IP
<lookup-color>:
This feature is a generalization of <x11-lookup-color>.
.PP

Here is an example of the use which can be made of
<gdriver-feature>.
.CODE
? (new-window 400 400 400 400 "test")
= ::Window:X11:8c440
? ((gdriver-feature configure loose) () 300 300 400 400)
= (t 400 400)
.PP





#? ** Producing Encapsulated PostScript Files

Lush can output graphics commands into an Encapsulated PostScript
File (EPS). You can then send these files to a PostScript printer
or use adequate software packages to modify these files and integrate
them into your documents.  There is even a Lush command that 
tranlates these files into a sequence of Lush drawing commands.

Note: Many computers use incompatible conventions for
marking the end of lines (Unix machines use the character NL, Macs use
the character CR and PC use a sequence CR NL.)
Several popular software exhibit a strange behavior when they attempt
to read a sequence of characters which appears to them as a very long
line.  You must probably use a text filter like <dos2unix> to convert
your EPS files.



#? (ps-window [[<w> <h>] <name>])
.SEE (print-window <w> <h> [<destination>])

Function <ps-window> is the low level function called by
<print-window> on systems that provide no other alternative.
All versions of Lush however support Encapsulated PostScript
files.

Function <ps-window> returns a window descriptor which actually 
writes PostScript commands into a file named <name>. 
When argument <name> is omitted, the
PostScript commands are written to file <"tloutput.ps">.

Unlike <new-window> or <print-window>, this function does not store 
the newly created window in the variable <window>, and thus does not 
make this window current.

Arguments <w> and <h> specify the width and height 
of the coordinate system. The target rectangle will be scaled 
to fit a standard A4 or Letter format page.


#? (gspecial <string>)

This function sends a system specific command represented
by string <string>. This function is ignored if
the graphics driver does not recognize the string <string>.
In the case of a window descriptor created with <ps-window>,
the string <string> is inserted verbatim into the 
Encapsulated PostScript file. 


#? (ps-play <filename> [<function>])
.SEE (ps-window [[[<x> <y>] <w> <h>] <name>])

This function interprets PostScript files created with <ps-window>.  
Function <ps-play> parses the PostScript file <filename>, converts
it into a sequence of SN calls, and applies function <function> to
these calls.  The default value for the optional argument
<function> is <eval>. Function <ps-play> thus plays the contents of
the PostScript file in the current window.

Exemples: 

To play a EPS file into a window, type:
.CODE
? (let ((window (new-window)))
   (ps-play "your_file.ps") )
.PP

To see the contents of a EPS file, type:
.CODE
? (ps-play "your_file.ps" pprint)
.PP
Note: This function only interprets PostScript files created by the
Lush PostScript driver. It is by no means a complete PostScript 
interpreter.  


#? (ps-plot <filename> <x> <y> <w> <h> [<bb-overrule>])
.SEE (ps-play <filename> [<function>]) 

This function plots EPS-files created with SN or Lush in the window
referred to by the symbol <window> in the region determined by <x> <y>
<w> and <h>. <x> <y> correspond to the coordinates of the region's
upper-left corner, <w> to its width and <h> to its height. The plot is
scaled to fill exactly this region using the EPS <"%%BoundingBox">
directive which can be overruled by the optional <bb-overrule>
parameter. If <w> or <h> are 0 or nil, scaling in their
respective directions are choosen as to preserve proportions. 
If both <w> and <h> are 0 or nil, no scaling is performed.


#? ** << libstd/svgwindow.lsh



#? ** Graphical Utilities

A family of Lush functions are provided to perform elementary computations 
on rectangles. A rectangle is stored as a list <(x y w h)>. The first two
elements <x> and <y> are the coordinates of its top left corner; <w>
is its width, <h> its height.


#? (rect-2-ppbrect <r>)
.TYPE DE
.FILE graphenv.lsh

Returns rectangle <r> under a format suitable for using with
<new-plot-port>.


#? (window-rect)
.TYPE DE
.FILE graphenv.lsh

Returns the boundaries of the current window as a rectangle.

#? (point-in-rect <x> <y> <r>)

The point-in-rect function returns <t> if point (<x>,<y>) is located
inside rectangle <r>.

#? (rect-in-rect <r1> <r2>)

The <rect-in-rect> function returns <t> if rectangle <r2> encloses
rectangle <r1>.

#? (collide-rect <r1> <r2>)

Returns the intersection of <r1> and <r2>. If rectangle <r1> and <r2>
do not intersect, <collide-rect> returns the empty list.

#? (bounding-rect <r1> <r2>)

Returns the smallest rectangle that encloses both 
rectangles <r1> and <r2>.
